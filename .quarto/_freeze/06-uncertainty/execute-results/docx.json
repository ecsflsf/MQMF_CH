{
  "hash": "1a51f81b6cf6067438f424aa94e60f32",
  "result": {
    "engine": "knitr",
    "markdown": "# 不确定性  {#sec-uncertainty}\n\n## 简介\n\n根据一组数据拟合模型，需要寻找参数估计值，以优化观测数据与模型预测之间的关系。模型参数估计值代表了我们感兴趣的群体的属性。虽然在每种情况下都有可能找到最佳参数值，但无论使用什么数据，都只是从总体中抽取的一组样本。假设可以从同总体中抽取不同的、独立的同类数据样本，如果对它们进行独立分析，很可能会得出至少略有不同的参数估计值。因此，在根据数据拟合模型时，估计参数的确切值其实并不是最重要的问题，相反，我们想知道的是，如果我们能够获得多个独立样本，这些估计值的可重复性有多大。也就是说，参数只是估计值，我们想知道对这些估计值有多大把握。例如，通常情况下，高度多变的数据通常会导致每个模型参数都可能具有广泛的可信估计值分布，通常情况下，这些估计值的置信区间也会很宽。\n\n在本章中，我们将探讨其他可用的方法，以描述任何建模情况中至少一部分固有的不确定性。虽然可能有许多潜在的不确定性来源会阻碍我们管理自然资源的能力，但这里只能对其中的一部分进行有用的研究。一些不确定性来源会影响所收集数据的可变性，其他来源则会影响可用数据的类型。\n\n### 不确定性类型\n\n### 示例模型\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n #Fit a surplus production model to abdat fisheries data  \n\nlibrary(MQMF)\n\ndata(abdat); logce <- log(abdat$cpue)    \nparam <- log(c(0.42,9400,3400,0.05))   \nlabel=c(\"r\",\"K\",\"Binit\",\"sigma\") # simpspm returns   \nbestmod <- nlm(f=negLL,p=param,funk=simpspm,indat=abdat,logobs=logce)  \noutfit(bestmod,title=\"SP-Model\",parnames=label) #backtransforms  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nnlm solution:  SP-Model \nminimum     :  -41.37511 \niterations  :  20 \ncode        :  2 >1 iterates in tolerance, probably solution \n             par      gradient   transpar\nr     -0.9429555  6.743051e-06    0.38948\nK      9.1191569 -9.223729e-05 9128.50173\nBinit  8.1271026  1.059182e-04 3384.97779\nsigma -3.1429030 -8.116218e-07    0.04316\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n #plot the abdat data and the optimum sp-model fit  Fig 6.1  \npredce <- exp(simpspm(bestmod$estimate,abdat))   \noptresid <- abdat[,\"cpue\"]/predce #multiply by predce for obsce  \nymax <- getmax(c(predce,abdat$cpue))  \nplot1(abdat$year,(predce*optresid),type=\"l\",maxy=ymax,cex=0.9,  \n      ylab=\"CPUE\",xlab=\"Year\",lwd=3,col=\"grey\",lty=1)  \npoints(abdat$year,abdat$cpue,pch=1,col=1,cex=1.1)  \nlines(abdat$year,predce,lwd=2,col=1)  # best fit line  \n```\n\n::: {.cell-output-display}\n![在线性空间中绘制的 Schaefer 过剩生产模型与 abdat 数据集的最佳拟合（红色实线）。灰线穿过数据点，以说明与预测线的差异。The optimum fit of the Schaefer surplus production model to the abdat data set plotted in linear-space (solid red-line). The grey line passes through the data points to clarify the difference with the predicted line.](06-uncertainty_files/figure-docx/fig-6_1-1.png){#fig-6_1}\n:::\n:::\n\n\n\n## 自举法\n\n### 经验概率密度分布\n\n## 简单自举法示例\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n #regression between catches of NPF prawn species Fig 6.2  \ndata(npf)  \nmodel <- lm(endeavour ~ tiger,data=npf)  \nplot1(npf$tiger,npf$endeavour,type=\"p\",xlab=\"Tiger Prawn (t)\",  \n      ylab=\"Endeavour Prawn (t)\",cex=0.9)  \nabline(model,col=1,lwd=2)  \ncorrel <- sqrt(summary(model)$r.squared)  \npval <- summary(model)$coefficients[2,4]  \nlabel <- paste0(\"Correlation \",round(correl,5),\" P = \",round(pval,8))  \ntext(2700,180,label,cex=1.0,font=7,pos=4)  \n```\n\n::: {.cell-output-display}\n![1970 - 1992 年间澳大利亚北部对虾渔业中努力虾和老虎虾产量之间的正相关关系（数据来自 Robins 和 Somers，1994）。The positive correlation between the catches of endeavour and tiger prawns in the Australian Northern Prawn Fishery between 1970 - 1992 (data from Robins and Somers, 1994).](06-uncertainty_files/figure-docx/fig-6_2-1.png){#fig-6_2}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n # 5000 bootstrap estimates of correlation coefficient Fig 6.3  \nset.seed(12321)     # better to use a less obvious seed, if at all  \nN <- 5000                            # number of bootstrap samples  \nresult <- numeric(N)          #a vector to store 5000 correlations  \nfor (i in 1:N) {          #sample index from 1:23 with replacement  \n   pick <- sample(1:23,23,replace=TRUE)   #sample is an R function  \n   result[i] <- cor(npf$tiger[pick],npf$endeavour[pick])   \n}  \nrge <- range(result)                  # store the range of results  \nCI <- quants(result)     # calculate quantiles; 90%CI = 5% and 95%  \nrestrim <- result[result > 0] #remove possible -ve values for plot  \nparset(cex=1.0)        # set up a plot window and draw a histogram  \nbins <- seq(trunc(range(restrim)[1]*10)/10,1.0,0.01)   \nouth <- hist(restrim,breaks=bins,main=\"\",col=0,xlab=\"Correlation\")  \nabline(v=c(correl,mean(result)),col=c(4,3),lwd=c(3,2),lty=c(1,2))  \nabline(v=CI[c(2,4)],col=4,lwd=2) # and 90% confidence intervals  \ntext(0.48,400,makelabel(\"Range \",rge,sep=\"  \",sigdig=4),font=7,pos=4)  \nlabel <- makelabel(\"90%CI \",CI[c(2,4)],sep=\"  \",sigdig=4)  \ntext(0.48,300,label,cex=1.0,font=7,pos=4)  \n```\n\n::: {.cell-output-display}\n![奋进号和老虎虾渔获量之间相关性的 5000 次自举估计值，绿色虚线表示原始平均值，蓝色实线表示自举平均值和 90% CI。为便于绘制，删除了可能的负相关（尽管没有出现）。5000 bootstrap estimates of the correlation between Endeavour and Tiger prawn catches with the original mean in dashed green and bootstrap mean and 90% CI in solid blue. Possible negative correlations have been removed for plotting purposes (though none occurred).](06-uncertainty_files/figure-docx/fig-6_3-1.png){#fig-6_3}\n:::\n:::\n\n\n\n## 自举法时间序列数据\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n # fitting Schaefer model with log-normal residuals with 24 years   \ndata(abdat); logce <- log(abdat$cpue) # of abalone fisheries data  \nparam <- log(c(r= 0.42,K=9400,Binit=3400,sigma=0.05)) #log values  \nbestmod <- nlm(f=negLL,p=param,funk=simpspm,indat=abdat,logobs=logce)  \noptpar <- bestmod$estimate      # these are still log-transformed  \npredce <- exp(simpspm(optpar,abdat))      #linear-scale pred cpue  \noptres <- abdat[,\"cpue\"]/predce     # optimum log-normal residual  \noptmsy <- exp(optpar[1])*exp(optpar[2])/4  \nsampn <- length(optres)        # number of residuals and of years  \n```\n:::\n\n::: {#tbl-6_1 .cell tbl-cap='abdat 数据集及相关的最佳预测 cpue（predce）和最佳残差（optres）。The abdat data-set with the associated optimum predicted cpue (predce), and the optimum residuals (optres).'}\n\n```{.r .cell-code}\nresult <- cbind(abdat, predce, optres)\n\nknitr::kable(result, digits = 3)\n```\n\n::: {.cell-output-display}\n\n\n year   catch    cpue   predce   optres\n-----  ------  ------  -------  -------\n 1985    1020   1.000    1.135    0.881\n 1986     743   1.096    1.071    1.023\n 1987     867   1.130    1.093    1.034\n 1988     724   1.147    1.076    1.066\n 1989     586   1.187    1.105    1.075\n 1990     532   1.202    1.183    1.016\n 1991     567   1.265    1.288    0.983\n 1992     609   1.320    1.388    0.951\n 1993     548   1.428    1.479    0.966\n 1994     498   1.477    1.593    0.927\n 1995     480   1.685    1.724    0.978\n 1996     424   1.920    1.856    1.034\n 1997     655   2.051    1.998    1.027\n 1998     494   2.124    2.049    1.037\n 1999     644   2.215    2.147    1.032\n 2000     960   2.253    2.180    1.033\n 2001     938   2.105    2.103    1.001\n 2002     911   2.082    2.044    1.018\n 2003     955   2.009    2.003    1.003\n 2004     936   1.923    1.952    0.985\n 2005     941   1.870    1.914    0.977\n 2006     954   1.878    1.878    1.000\n 2007    1027   1.850    1.840    1.005\n 2008     980   1.727    1.782    0.969\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n # 1000 bootstrap Schaefer model fits; takes a few seconds  \nstart <- Sys.time() # use of as.matrix faster than using data.frame  \nbootfish <- as.matrix(abdat)  # and avoid altering original data  \nN <- 1000;   years <- abdat[,\"year\"] # need N x years matrices  \ncolumns <- c(\"r\",\"K\",\"Binit\",\"sigma\")   \nresults <- matrix(0,nrow=N,ncol=sampn,dimnames=list(1:N,years))  \nbootcpue <- matrix(0,nrow=N,ncol=sampn,dimnames=list(1:N,years))  \nparboot <- matrix(0,nrow=N,ncol=4,dimnames=list(1:N,columns))  \nfor (i in 1:N) {  # fit the models and save solutions  \n  bootcpue[i,] <- predce * sample(optres, sampn, replace=TRUE)  \n  bootfish[,\"cpue\"] <- bootcpue[i,] #calc and save bootcpue  \n  bootmod <- nlm(f=negLL,p=optpar,funk=simpspm,indat=bootfish,  \n        logobs=log(bootfish[,\"cpue\"])) \n  parboot[i,] <- exp(bootmod$estimate)  #now save parameters \n  results[i,] <- exp(simpspm(bootmod$estimate,abdat))  #and predce   \n}  \ncat(\"total time = \",Sys.time()-start, \"seconds   \\n\")  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntotal time =  5.098597 seconds   \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n # bootstrap replicates in grey behind main plot Fig 6.4  \nplot1(abdat[,\"year\"],abdat[,\"cpue\"],type=\"n\",xlab=\"Year\",  \n      ylab=\"CPUE\") # type=\"n\" just lays out an empty plot  \nfor (i in 1:N)      # ready to add the separate components  \n  lines(abdat[,\"year\"],results[i,],lwd=1,col=\"grey\")  \npoints(abdat[,\"year\"],abdat[,\"cpue\"],pch=16,cex=1.0,col=1)  \nlines(abdat[,\"year\"],predce,lwd=2,col=1)  \n```\n\n::: {.cell-output-display}\n![鲍鱼渔业 abdat 数据集最佳预测 cpue 的 1000 个自举估计值。黑点为原始数据，黑线为原始模型拟合的最佳预测 cpue，灰色轨迹为预测 cpue 的 1000 个自举估计值。1000 bootstrap estimates of the optimum predicted cpue from the abdat data set for an abalone fishery. Black points are the original data, the black line is the optimum predicted cpue from the original model fit, and the grey trajectories are the 1000 bootstrap estimates of the predicted cpue.](06-uncertainty_files/figure-docx/fig-6_4-1.png){#fig-6_4}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n #histograms of bootstrap parameters and model outputs Fig 6.5  \ndohist <- function(invect,nmvar,bins=30,bootres,avpar) { #adhoc  \n  hist(invect[,nmvar],breaks=bins,main=\"\",xlab=nmvar,col=0)  \n  abline(v=c(exp(avpar),bootres[pick,nmvar]),lwd=c(3,2,3,2),  \n         col=c(3,4,4,4))  \n}  \nmsy <- parboot[,\"r\"]*parboot[,\"K\"]/4 #calculate bootstrap MSY   \nmsyB <- quants(msy)        #from optimum bootstrap parameters  \nparset(plots=c(2,2),cex=0.9)  \nbootres <- apply(parboot,2,quants); pick <- c(2,3,4) #quantiles  \ndohist(parboot,nmvar=\"r\",bootres=bootres,avpar=optpar[1])  \ndohist(parboot,nmvar=\"K\",bootres=bootres,avpar=optpar[2])  \ndohist(parboot,nmvar=\"Binit\",bootres=bootres,avpar=optpar[3])  \nhist(msy,breaks=30,main=\"\",xlab=\"MSY\",col=0)  \nabline(v=c(optmsy,msyB[pick]),lwd=c(3,2,3,2),col=c(3,4,4,4))  \n```\n\n::: {.cell-output-display}\n![前三个模型参数的 1000 个自举估计值和 MSY 的柱状图。在每幅图中，两条细外线定义了中位数周围的 90%置信区间，中间的垂直线表示最佳估计值，但这些估计值通常紧靠中位数下方，Binit 模型除外。The 1000 bootstrap estimates of each of the first three model parameters and MSY as histograms. In each plot the two fine outer lines define the inner 90% confidence bounds around the median, the central vertical line denotes the optimum estimates, but these are generally immediately below the medians, except for the Binit.](06-uncertainty_files/figure-docx/fig-6_5-1.png){#fig-6_5}\n:::\n:::\n\n\n\n### 参数相关关系\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n #relationships between parameters and MSY  Fig 6.6  \nparboot1 <- cbind(parboot,msy)  \n # note rgb use, alpha allows for shading, try 1/15 or 1/10  \npairs(parboot1,pch=16,col=rgb(red=1,green=0,blue=0,alpha = 1/20))  \n```\n\n::: {.cell-output-display}\n![用 Schaefer 模型拟合 abdat 数据集时，1000 个自举法估算的最佳参数估算值与得出的 MSY 值之间的关系。全色强度由至少 20 个点得出。更多的自举重复将使这些强度图更加完整。The relationships between the 1000 bootstrap estimates of the optimum parameter estimates and the derived MSY values for the Schaefer model fitted to the abdat data-set. Full colour intensity derived from a minimum of 20 points. More bootstrap replicates would fill out these intensity plots.](06-uncertainty_files/figure-docx/fig-6_6-1.png){#fig-6_6}\n:::\n:::\n\n\n\n## 渐近误差\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n #Fit Schaefer model and generate the Hessian  \ndata(abdat)  \nparam <- log(c(r= 0.42,K=9400,Binit=3400,sigma=0.05))   \n # Note inclusion of the option hessian=TRUE in nlm function  \nbestmod <- nlm(f=negLL,p=param,funk=simpspm,indat=abdat,  \n               logobs=log(abdat[,\"cpue\"]),hessian=TRUE)   \noutfit(bestmod,backtran = TRUE) #try typing bestmod in console  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nnlm solution:   \nminimum     :  -41.37511 \niterations  :  20 \ncode        :  2 >1 iterates in tolerance, probably solution \n         par      gradient   transpar\n1 -0.9429555  6.743051e-06    0.38948\n2  9.1191569 -9.223729e-05 9128.50173\n3  8.1271026  1.059182e-04 3384.97779\n4 -3.1429030 -8.116218e-07    0.04316\nhessian     : \n             [,1]         [,2]        [,3]       [,4]\n[1,] 3542.8630966  2300.305473   447.63247 -0.3509662\n[2,] 2300.3054728  4654.008776 -2786.59928 -4.2155105\n[3,]  447.6324673 -2786.599276  3183.93947 -2.5662897\n[4,]   -0.3509662    -4.215511    -2.56629 47.9905538\n```\n\n\n:::\n\n```{.r .cell-code}\n # Now generate the confidence intervals  \nvcov <- solve(bestmod$hessian)      # solve inverts matrices  \nsterr <- sqrt(diag(vcov)) #diag extracts diagonal from a matrix  \noptpar <- bestmod$estimate      #use qt for t-distrib quantiles  \nU95 <- optpar + qt(0.975,20)*sterr # 4 parameters hence  \nL95 <- optpar - qt(0.975,20)*sterr # (24 - 4) df  \ncat(\"\\n               r      K     Binit    sigma \\n\")   \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n               r      K     Binit    sigma \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Upper 95% \",round(exp(U95),5),\"\\n\") # backtransform  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUpper 95%  0.45025 10948.12 4063.59 0.05838 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Optimum   \",round(exp(optpar),5),\"\\n\")#\\n =linefeed in cat  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nOptimum    0.38948 9128.502 3384.978 0.04316 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Lower 95% \",round(exp(L95),5),\"\\n\")  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLower 95%  0.33691 7611.311 2819.693 0.0319 \n```\n\n\n:::\n:::\n\n\n\n### 模型输出的不确定性\n\n### 从多元正态分布中取样\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n # Use multi-variate normal to generate percentile CI    Fig 6.7  \nlibrary(mvtnorm) # use RStudio, or install.packages(\"mvtnorm\")  \nN <- 1000 # number of multi-variate normal parameter vectors  \nyears <- abdat[,\"year\"];  sampn <- length(years)  # 24 years  \nmvncpue <- matrix(0,nrow=N,ncol=sampn,dimnames=list(1:N,years))  \ncolumns <- c(\"r\",\"K\",\"Binit\",\"sigma\")  \n # Fill parameter vectors with N vectors from rmvnorm  \nmvnpar <- matrix(exp(rmvnorm(N,mean=optpar,sigma=vcov)),  \n                 nrow=N,ncol=4,dimnames=list(1:N,columns))  \n # Calculate N cpue trajectories using simpspm  \nfor (i in 1:N) mvncpue[i,] <- exp(simpspm(log(mvnpar[i,]),abdat))  \nmsy <- mvnpar[,\"r\"]*mvnpar[,\"K\"]/4 #N MSY estimates   \n # plot data and trajectories from the N parameter vectors  \nplot1(abdat[,\"year\"],abdat[,\"cpue\"],type=\"p\",xlab=\"Year\",  \n      ylab=\"CPUE\",cex=0.9)  \nfor (i in 1:N) lines(abdat[,\"year\"],mvncpue[i,],col=\"grey\",lwd=1)  \npoints(abdat[,\"year\"],abdat[,\"cpue\"],pch=16,cex=1.0)#orig data  \nlines(abdat[,\"year\"],exp(simpspm(optpar,abdat)),lwd=2,col=1)  \n```\n\n::: {.cell-output-display}\n![从最优参数及其相关方差-协方差矩阵定义的多变量正态分布中采样的随机参数向量得出的 1000 条 cpue 预测轨迹。The 1000 predicted cpue trajectories derived from random parameter vectors sampled from the multi-variate Normal distribution defined by the optimum parameters and their related variance-covariance matrix.](06-uncertainty_files/figure-docx/fig-6_7-1.png){#fig-6_7}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n #correlations between parameters when using mvtnorm Fig 6.8  \n\npairs(cbind(mvnpar,msy),pch=16,col=rgb(red=1,0,0,alpha = 1/10)) \n```\n\n::: {.cell-output-display}\n![从估计的多变量正态分布中取样的 1000 个参数估计值（假定围绕最佳参数估计值）与 Schaefer 模型拟合的丰年鱼量值之间的关系。The relationships between the 1000 parameter estimates sampled from the estimated multi-variate Normal distribution assumed to surround the optimum parameter estimates and the derived MSY values for the Schaefer model fitted to the abdat data set.](06-uncertainty_files/figure-docx/fig-6_8-1.png){#fig-6_8}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n #N parameter vectors from the multivariate normal Fig 6.9  \nmvnres <- apply(mvnpar,2,quants)  # table of quantiles  \npick <- c(2,3,4)   # select rows for 5%, 50%, and 95%   \nmeanmsy <- mean(msy)     # optimum bootstrap parameters  \nmsymvn <- quants(msy)   # msy from mult-variate normal estimates  \n  \nplothist <- function(x,optp,label,resmvn) {  \n  hist(x,breaks=30,main=\"\",xlab=label,col=0)  \n  abline(v=c(exp(optp),resmvn),lwd=c(3,2,3,2),col=c(3,4,4,4))   \n} # repeated 4 times, so worthwhile writing a short function  \npar(mfrow=c(2,2),mai=c(0.45,0.45,0.05,0.05),oma=c(0.0,0,0.0,0.0))   \npar(cex=0.85, mgp=c(1.35,0.35,0), font.axis=7,font=7,font.lab=7)  \nplothist(mvnpar[,\"r\"],optpar[1],\"r\",mvnres[pick,\"r\"])  \nplothist(mvnpar[,\"K\"],optpar[2],\"K\",mvnres[pick,\"K\"])  \nplothist(mvnpar[,\"Binit\"],optpar[3],\"Binit\",mvnres[pick,\"Binit\"])  \nplothist(msy,meanmsy,\"MSY\",msymvn[pick])  \n```\n\n::: {.cell-output-display}\n![从最优解估算的多变量正态中得出的 r、K、Binit 和推导的 MSY 的 1000 个参数估计直方图。在每幅图中，绿线表示算术平均数，蓝色粗线表示中位数，两条蓝色细线表示中位数周围 90%的置信区间。Histograms of the 1000 parameter estimates for r, K, Binit, and the derived MSY, from the multi-variate normal estimated at the optimum solution. In each plot, the green line denotes the arithmetic mean, the thick blue line the median, and the two fine blue lines the inner 90% confidence bounds around the median.](06-uncertainty_files/figure-docx/fig-6_9-1.png){#fig-6_9}\n:::\n:::\n\n::: {#tbl-6_2 .cell tbl-cap='自举百分位数参数置信区间与方差-协方差矩阵渐近估计值参数置信区间的比较。上表是自举法结果，下表是多元正态分布结果。A comparison of the bootstrap percentile confidence bounds on parameters with those derived from the Asymptotic estimate of the variance-covariance matrix. The top table relates to the bootstrapping and the bottom to the values from the multi-variate normal.'}\n\n```{.r .cell-code}\nknitr::kable(bootres, digits = 3)\n```\n\n::: {.cell-output-display}\n\n             r           K      Binit   sigma\n------  ------  ----------  ---------  ------\n2.5%     0.335    7740.636   2893.714   0.025\n5%       0.345    8010.341   2970.524   0.026\n50%      0.390    9116.193   3387.077   0.039\n95%      0.435   10507.708   3889.824   0.050\n97.5%    0.445   11003.649   4055.071   0.052\n\n\n:::\n\n```{.r .cell-code}\nknitr::kable(mvnres, digits = 3)\n```\n\n::: {.cell-output-display}\n\n             r           K      Binit   sigma\n------  ------  ----------  ---------  ------\n2.5%     0.339    7717.875   2882.706   0.033\n5%       0.347    7943.439   2945.264   0.034\n50%      0.389    9145.146   3389.279   0.043\n95%      0.437   10521.651   3900.034   0.055\n97.5%    0.444   10879.571   4031.540   0.058\n\n\n:::\n:::\n\n\n\n## 似然剖面\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n #Fit the Schaefer surplus production model to abdat  \ndata(abdat); logce <- log(abdat$cpue)    # using negLL  \nparam <- log(c(r= 0.42,K=9400,Binit=3400,sigma=0.05))   \noptmod <- nlm(f=negLL,p=param,funk=simpspm,indat=abdat,logobs=logce)  \noutfit(optmod,parnames=c(\"r\",\"K\",\"Binit\",\"sigma\"))  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nnlm solution:   \nminimum     :  -41.37511 \niterations  :  20 \ncode        :  2 >1 iterates in tolerance, probably solution \n             par      gradient   transpar\nr     -0.9429555  6.743051e-06    0.38948\nK      9.1191569 -9.223729e-05 9128.50173\nBinit  8.1271026  1.059182e-04 3384.97779\nsigma -3.1429030 -8.116218e-07    0.04316\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n #the code for MQMF's negLLP function  \nnegLLP <- function(pars, funk, indat, logobs, initpar=pars,  \n                   notfixed=c(1:length(pars)),...) {  \n  usepar <- initpar  #copy the original parameters into usepar  \n  usepar[notfixed] <- pars[notfixed] #change 'notfixed' values  \n  npar <- length(usepar)   \n  logpred <- funk(usepar,indat,...) #funk uses the usepar values  \n  pick <- which(is.na(logobs))  # proceed as in negLL  \n  if (length(pick) > 0) {  \n    LL <- -sum(dnorm(logobs[-pick],logpred[-pick],exp(pars[npar]),  \n                     log=T))  \n  } else {  \n    LL <- -sum(dnorm(logobs,logpred,exp(pars[npar]),log=T))  \n  }  \n  return(LL)  \n} # end of negLLP  \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n #does negLLP give same answers as negLL when no parameters fixed?  \nparam <- log(c(r= 0.42,K=9400,Binit=3400,sigma=0.05))   \nbestmod <- nlm(f=negLLP,p=param,funk=simpspm,indat=abdat,logobs=logce)  \noutfit(bestmod,parnames=c(\"r\",\"K\",\"Binit\",\"sigma\"))  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nnlm solution:   \nminimum     :  -41.37511 \niterations  :  20 \ncode        :  2 >1 iterates in tolerance, probably solution \n             par      gradient   transpar\nr     -0.9429555  6.743051e-06    0.38948\nK      9.1191569 -9.223729e-05 9128.50173\nBinit  8.1271026  1.059182e-04 3384.97779\nsigma -3.1429030 -8.116218e-07    0.04316\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n #Likelihood profile for r values 0.325 to 0.45  \nrval <- seq(0.325,0.45,0.001)  # set up the test sequence  \nntrial <- length(rval)        # create storage for the results  \ncolumns <- c(\"r\",\"K\",\"Binit\",\"sigma\",\"-veLL\")  \nresult <- matrix(0,nrow=ntrial,ncol=length(columns),  \n                 dimnames=list(rval,columns))# close to optimum  \nbestest <- c(r= 0.32,K=11000,Binit=4000,sigma=0.05)   \nfor (i in 1:ntrial) {  #i <- 1  \n  param <- log(c(rval[i],bestest[2:4])) #recycle bestest values  \n  parinit <- param  #to improve the stability of nlm as r changes         \n  bestmodP <- nlm(f=negLLP,p=param,funk=simpspm,initpar=parinit,   \n                  indat=abdat,logobs=log(abdat$cpue),notfixed=c(2:4),  \n                  typsize=magnitude(param),iterlim=1000)\n  bestest <- exp(bestmodP$estimate)       \n  result[i,] <- c(bestest,bestmodP$minimum)  # store each result  \n}  \nminLL <- min(result[,\"-veLL\"]) #minimum across r values used.  \n```\n:::\n\n::: {#tbl-6_3 .cell tbl-cap='nlm 解决方案 126 行中的前 12 条记录用于绘制 r 的似然曲线。The first 12 records from the 126 rows of the nlm solutions that are used to make the likelihood profile on r. The strong correlation between r, K, and Binit is, once again, apparent.'}\n\n```{.r .cell-code}\nknitr::kable(result[1:12,], digits = 3)\n```\n\n::: {.cell-output-display}\n\n             r          K      Binit   sigma     -veLL\n------  ------  ---------  ---------  ------  --------\n0.325    0.325   11449.17   4240.797   0.048   -38.618\n0.326    0.326   11403.51   4223.866   0.048   -38.696\n0.327    0.327   11358.24   4207.082   0.048   -38.772\n0.328    0.328   11313.35   4190.442   0.048   -38.848\n0.329    0.329   11268.83   4173.945   0.048   -38.922\n0.33     0.330   11224.69   4157.589   0.048   -38.996\n0.331    0.331   11180.91   4141.373   0.048   -39.070\n0.332    0.332   11137.49   4125.293   0.047   -39.142\n0.333    0.333   11094.43   4109.350   0.047   -39.213\n0.334    0.334   11051.72   4093.540   0.047   -39.284\n0.335    0.335   11009.11   4077.752   0.047   -39.354\n0.336    0.336   10967.34   4062.316   0.047   -39.422\n\n\n:::\n:::\n\n\n\n### 基于置信区间的似然比率\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n #likelihood profile on r from the Schaefer model Fig 6.10  \nplotprofile(result,var=\"r\",lwd=2)  # review the code   \n```\n\n::: {.cell-output-display}\n![A likelihood profile for the r parameter from the Schaefer surplus production model fitted to the abdat data set. The horizontal solid lines are the minimum and the minimum minus 1.92 (95% level for  χ2   with 1 degree of freedom, see text). The outer vertical lines are the approximate 95% confidence bounds around the central mean of 0.389.](06-uncertainty_files/figure-docx/fig-6_10-1.png){#fig-6_10}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n #Likelihood profile for K values 7200 to 12000  \nKval <- seq(7200,12000,10)  \nntrial <- length(Kval)  \ncolumns <- c(\"r\",\"K\",\"Binit\",\"sigma\",\"-veLL\")  \nresultK <- matrix(0,nrow=ntrial,ncol=length(columns),  \n                 dimnames=list(Kval,columns))  \nbestest <- c(r= 0.45,K=7500,Binit=2800,sigma=0.05)   \nfor (i in 1:ntrial) { \n  param <- log(c(bestest[1],Kval[i],bestest[c(3,4)]))   \n  parinit <- param  \n  bestmodP <- nlm(f=negLLP,p=param,funk=simpspm,initpar=parinit,  \n                indat=abdat,logobs=log(abdat$cpue),  \n                notfixed=c(1,3,4),iterlim=1000)  \n  bestest <- exp(bestmodP$estimate)  \n  resultK[i,] <- c(bestest,bestmodP$minimum)  \n}  \nminLLK <- min(resultK[,\"-veLL\"])  \n #kable(head(result,12),digits=c(4,3,3,4,5))  # if wanted.  \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n #likelihood profile on K from the Schaefer model Fig 6.11  \nplotprofile(resultK,var=\"K\",lwd=2)  \n```\n\n::: {.cell-output-display}\n![A likelihood profile for the K parameter from the Schaefer surplus production model fitted to the abdat data-set, conducted in the same manner as the r parameter. The red lines are the minimum and the minimum plus 1.92 (95% level for Chi2 with 1 degree of freedom, see text). The vertical thick lines are the approximate 95% confidence bounds around the mean of 9128.5.](06-uncertainty_files/figure-docx/fig-6_11-1.png){#fig-6_11}\n:::\n:::\n\n\n\n### -ve  对数似然或似然\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n #translate -velog-likelihoods into likelihoods  \nlikes <- exp(-resultK[,\"-veLL\"])/sum(exp(-resultK[,\"-veLL\"]),  \n                                     na.rm=TRUE)  \nresK <- cbind(resultK,likes,cumlike=cumsum(likes))  \n```\n:::\n\n::: {#tbl-6_4 .cell tbl-cap='The first 8 records from the 481 rows of the nlm solutions that are used to make the likelihood profile on K. Included is the back-transformed -ve log-likelihoods, scaled to sum to 1.0, and their running cumulative sum.'}\n\n```{.r .cell-code}\nknitr::kable(resK[1:8,], digits = 5)\n```\n\n::: {.cell-output-display}\n\n              r      K      Binit     sigma       -veLL   likes   cumlike\n-----  --------  -----  ---------  --------  ----------  ------  --------\n7200    0.47314   7200   2689.875   0.05158   -37.09799   7e-05   0.00007\n7210    0.47257   7210   2693.444   0.05147   -37.14518   7e-05   0.00014\n7220    0.47201   7220   2697.023   0.05137   -37.19213   8e-05   0.00022\n7230    0.47145   7230   2700.602   0.05127   -37.23881   8e-05   0.00030\n7240    0.47089   7240   2704.182   0.05118   -37.28524   8e-05   0.00038\n7250    0.47033   7250   2707.762   0.05108   -37.33141   9e-05   0.00047\n7260    0.46977   7260   2711.341   0.05098   -37.37732   9e-05   0.00056\n7270    0.46922   7270   2714.933   0.05088   -37.42298   1e-04   0.00065\n\n\n:::\n:::\n\n\n\n### 模型输出中的分位数似然剖面\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n #examine effect on -veLL of MSY values from 740 - 1050t  \n #need a different negLLP() function, negLLO(): O for output.  \n #now optvar=888.831 (rK/4), the optimum MSY, varval ranges 740-1050   \n #and wght is the weighting to give to the penalty  \nnegLLO <- function(pars,funk,indat,logobs,wght,optvar,varval) {  \n  logpred <- funk(pars,indat)  \n  LL <- -sum(dnorm(logobs,logpred,exp(tail(pars,1)),log=T)) +  \n             wght*((varval - optvar)/optvar)^2  #compare with negLL  \n  return(LL)  \n} # end of negLLO  \nmsyP <- seq(740,1020,2.5);   \noptmsy <- exp(optmod$estimate[1])*exp(optmod$estimate[2])/4  \nntrial <- length(msyP)  \nwait <- 400  \ncolumns <- c(\"r\",\"K\",\"Binit\",\"sigma\",\"-veLL\",\"MSY\",\"pen\",  \n             \"TrialMSY\")  \nresultO <- matrix(0,nrow=ntrial,ncol=length(columns),  \n                  dimnames=list(msyP,columns))  \nbestest <- c(r= 0.47,K=7300,Binit=2700,sigma=0.05)   \nfor (i in 1:ntrial) {  # i <- 1  \n  param <- log(bestest)   \n  bestmodO <- nlm(f=negLLO,p=param,funk=simpspm,indat=abdat,  \n                  logobs=log(abdat$cpue),wght=wait,  \n                  optvar=optmsy,varval=msyP[i],iterlim=1000)  \n  bestest <- exp(bestmodO$estimate)  \n  ans <- c(bestest,bestmodO$minimum,bestest[1]*bestest[2]/4,  \n           wait *((msyP[i] - optmsy)/optmsy)^2,msyP[i])  \n  resultO[i,] <- ans  \n}  \nminLLO <- min(resultO[,\"-veLL\"])  \n```\n:::\n\n\n\n## 贝叶斯后验分布\n\n### 生成马尔可夫链\n\n### 起始点\n\n### 预烧期\n\n### 收敛至稳定分布\n\n### 跳跃分布\n\n### MCMC的应用示例\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n #activate and plot the fisheries data in abdat  Fig 6.14  \ndata(abdat)   # type abdat in the console to see contents  \nplotspmdat(abdat) #use helper function to plot fishery stats vs year\n```\n\n::: {.cell-output-display}\n![The time-series of cpue and catch from the abdat data set.](06-uncertainty_files/figure-docx/fig-6_14-1.png){#fig-6_14}\n:::\n:::\n\n\n\n### 马尔可夫链蒙特卡罗（MCMC）\n\n### MCMC的第一个示例\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n # Conduct MCMC analysis to illustrate burn-in. Fig 6.15  \ndata(abdat);  logce <- log(abdat$cpue)  \nfish <- as.matrix(abdat) # faster to use a matrix than a data.frame!  \nbegin <- Sys.time()       # enable time taken to be calculated  \nchains <- 1                # 1 chain per run; normally do more   \nburnin <- 0                # no burn-in for first three chains  \nN <- 100                        # Number of MCMC steps to keep  \nstep <- 4       # equals one step per parameter so no thinning  \npriorcalc <- calcprior # define the prior probability function  \nscales <- c(0.065,0.055,0.065,0.425) #found by trial and error  \nset.seed(128900) #gives repeatable results in book; usually omitted  \ninpar <- log(c(r= 0.4,K=11000,Binit=3600,sigma=0.05))  \nresult1 <- do_MCMC(chains,burnin,N,step,inpar,negLL,calcpred=simpspm,  \n                   calcdat=fish,obsdat=logce,priorcalc,scales)  \ninpar <- log(c(r= 0.35,K=8500,Binit=3400,sigma=0.05))  \nresult2 <- do_MCMC(chains,burnin,N,step,inpar,negLL,calcpred=simpspm,  \n                   calcdat=fish,obsdat=logce,priorcalc,scales)  \ninpar <- log(c(r= 0.45,K=9500,Binit=3200,sigma=0.05))  \nresult3 <- do_MCMC(chains,burnin,N,step,inpar,negLL,calcpred=simpspm,  \n                   calcdat=fish,obsdat=logce,priorcalc,scales)  \nburnin <- 50 # strictly a low thinning rate of 4; not enough\nstep <- 16   # 16 thinstep rate = 4 parameters x 4 = 16  \nN <- 10000   # 16 x 10000 = 160,000 steps + 50 burnin\ninpar <- log(c(r= 0.4,K=9400,Binit=3400,sigma=0.05))  \nresult4 <- do_MCMC(chains,burnin,N,step,inpar,negLL,calcpred=simpspm,  \n                   calcdat=fish,obsdat=logce,priorcalc,scales)  \npost1 <- result1[[1]][[1]]  \npost2 <- result2[[1]][[1]]  \npost3 <- result3[[1]][[1]]  \npostY <- result4[[1]][[1]]  \ncat(\"time   = \",Sys.time() - begin,\"\\n\")  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntime   =  11.60582 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Accept = \",result4[[2]],\"\\n\")  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAccept =  0.3471241 0.3437158 0.354289 0.3826251 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n #first example and start of 3 initial chains for MCMC Fig6.15  \nparset(cex=0.85)     \nP <- 75  # the first 75 steps only start to explore parameter space\nplot(postY[,\"K\"],postY[,\"r\"],type=\"p\",cex=0.2,xlim=c(7000,13000),  \n   ylim=c(0.28,0.47),col=8,xlab=\"K\",ylab=\"r\",panel.first=grid())  \nlines(post2[1:P,\"K\"],post2[1:P,\"r\"],lwd=1,col=1)  \npoints(post2[1:P,\"K\"],post2[1:P,\"r\"],pch=15,cex=1.0)  \nlines(post1[1:P,\"K\"],post1[1:P,\"r\"],lwd=1,col=1)  \npoints(post1[1:P,\"K\"],post1[1:P,\"r\"],pch=1,cex=1.2,col=1)  \nlines(post3[1:P,\"K\"],post3[1:P,\"r\"],lwd=1,col=1)  \npoints(post3[1:P,\"K\"],post3[1:P,\"r\"],pch=2,cex=1.2,col=1)  \n```\n\n::: {.cell-output-display}\n![从不同的起点（三角形、正方形、圆形）出发的三个独立 MCMC 链中的前 75 个点。这些短链没有设置预烧，因此记录从起点开始。灰色圆点是第四条链中的 10000 个点，其中有 50 个点的 “预烧 ”和 4 个点的 “稀疏率”，这给出了所有链都应趋近的静态分布的大致概念。The first 75 points in three separate MCMC chains starting from different origins (triangles, squares, circles). No burn-in was set for these short chains so records begin from the starting points. The grey dots are 10000 points from a single fourth chain, with a 50 point burn-in and a thinning rate of four, giving an approximate idea of the stationary distribution towards which all chains should converge.](06-uncertainty_files/figure-docx/fig-6_15-1.png){#fig-6_15}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n #pairs plot of parameters from the first MCMC Fig 6.16  \nposterior <- result4[[1]][[1]]  \nmsy <-posterior[,1]*posterior[,2]/4     \npairs(cbind(posterior[,1:4],msy),pch=16,col=rgb(1,0,0,1/50),font=7)  \n```\n\n::: {.cell-output-display}\n![Schaefer 模型参数后验分布的 10000 个样本与 MSY 之间的关系。通常情况下，我们会使用比 4 更长的稀疏化步长来描述后验结果。图中的全部颜色至少来自 50 个点。The relationship between the 10000 samples from the posterior distributions of the Schaefer model parameters and MSY. Normally one would use a much longer thinning step than 4 to characterize the posterior. Full colour in the plot comes from at least 50 points.](06-uncertainty_files/figure-docx/fig-6_16-1.png){#fig-6_16}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n #plot the traces from the first MCMC example Fig 6.17  \nposterior <- result4[[1]][[1]]  \npar(mfrow=c(4,2),mai=c(0.4,0.4,0.05,0.05),oma=c(0.0,0,0.0,0.0))  \npar(cex=0.8, mgp=c(1.35,0.35,0), font.axis=7,font=7,font.lab=7)  \nlabel <- colnames(posterior)  \nN <- dim(posterior)[1]  \nfor (i in 1:4) {  \n  ymax <- getmax(posterior[,i]); ymin <- getmin(posterior[,i])  \n  plot(1:N,posterior[,i],type=\"l\",lwd=1,ylim=c(ymin,ymax),  \n       panel.first=grid(),ylab=label[i],xlab=\"Step\")  \n  plot(density(posterior[,i]),lwd=2,col=2,panel.first=grid(),main=\"\")  \n}  \n```\n\n::: {.cell-output-display}\n![四个 Schaefer 模型参数的轨迹以及每个参数的隐含边际分布。如果稀疏化步长增加到 128、256 或更长，迹线内明显的自相关性就会得到改善。The traces for the four Schaefer model parameters along with the implied marginal distribution of each parameter. The obvious auto-correlation within traces should be improved if the thinning step were increased to 128, 256, or, as we shall see, much longer.](06-uncertainty_files/figure-docx/fig-6_17-1.png){#fig-6_17}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n #Use acf to examine auto-correlation with thinstep = 16   Fig 6.18  \nposterior <- result4[[1]][[1]]  \nlabel <- colnames(posterior)[1:4]  \nparset(plots=c(2,2),cex=0.85)  \nfor (i in 1:4) auto <- acf(posterior[,i],type=\"correlation\",lwd=2,  \n                           plot=TRUE,ylab=label[i],lag.max=20)  \n```\n\n::: {.cell-output-display}\n![四个 Schaefer 模型参数的轨迹显示的自相关性。这是在对四个参数中的每个参数进行 16 = 4 的稀疏化处理后得到的结果。显然，要消除出现的强相关性，需要大幅提高步长。The auto-correlation exhibited in the traces for the four Schaefer model parameters. This is with a thinning step of 16 = 4 for each of four parameters. Clearly a large increase in needed to remove the strong correlations that occur.](06-uncertainty_files/figure-docx/fig-6_18-1.png){#fig-6_18}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n #setup MCMC with thinstep of 128 per parameter  Fig 6.19  \nbegin=gettime()  \nscales <- c(0.06,0.05,0.06,0.4)  \ninpar <- log(c(r= 0.4,K=9400,Binit=3400,sigma=0.05))  \nresult <- do_MCMC(chains=1,burnin=100,N=1000,thinstep=512,inpar,  \n                  negLL,calcpred=simpspm,calcdat=fish,  \n                  obsdat=logce,calcprior,scales,schaefer=TRUE)  \nposterior <- result[[1]][[1]]  \nlabel <- colnames(posterior)[1:4]  \nparset(plots=c(2,2),cex=0.85)  \nfor (i in 1:4) auto <- acf(posterior[,i],type=\"correlation\",lwd=2,  \n                           plot=TRUE,ylab=label[i],lag.max=20)  \n```\n\n::: {.cell-output-display}\n![The auto-correlation exhibited in the traces for the four Schaefer model parameters when the thinning step is 512 = 4 x 128, which is 128 times that used in the first auto-correlation diagram.](06-uncertainty_files/figure-docx/fig-6_19-1.png){#fig-6_19}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncat(gettime() - begin)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n34.86295\n```\n\n\n:::\n:::\n\n\n\n### 边际分布\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n # plot marginal distributions from the MCMC  Fig 6.20  \ndohist <- function(x,xlab) { # to save a little space  \n  return(hist(x,main=\"\",breaks=50,col=0,xlab=xlab,ylab=\"\",  \n               panel.first=grid()))   \n}  \n # ensure we have the optimum solution available  \nparam <- log(c(r= 0.42,K=9400,Binit=3400,sigma=0.05))   \nbestmod <- nlm(f=negLL,p=param,funk=simpspm,indat=abdat,  \n               logobs=log(abdat$cpue))  \noptval <- exp(bestmod$estimate)  \nposterior <- result[[1]][[1]] #example above N=1000, thin=512  \npar(mfrow=c(5,1),mai=c(0.4,0.3,0.025,0.05),oma=c(0,1,0,0))   \npar(cex=0.85, mgp=c(1.35,0.35,0), font.axis=7,font=7,font.lab=7)   \nnp <- length(param)  \nfor (i in 1:np) { #store invisible output from hist for later use  \n  outH <- dohist(posterior[,i],xlab=colnames(posterior)[i])  \n  abline(v=optval[i],lwd=3,col=4)  \n  tmp <- density(posterior[,i])  \n  scaler <- sum(outH$counts)*(outH$mids[2]-outH$mids[1])  \n  tmp$y <- tmp$y * scaler  \n  lines(tmp,lwd=2,col=2)  \n}  \nmsy <- posterior[,\"r\"]*posterior[,\"K\"]/4  \nmout <- dohist(msy,xlab=\"MSY\")  \ntmp <- density(msy)  \ntmp$y <- tmp$y * (sum(mout$counts)*(mout$mids[2]-mout$mids[1]))  \nlines(tmp,lwd=2,col=2)  \nabline(v=(optval[1]*optval[2]/4),lwd=3,col=4)  \nmtext(\"Frequency\",side=2,outer=T,line=0.0,font=7,cex=1.0)  \n```\n\n::: {.cell-output-display}\n![稀疏率为 128 时 1000 个点的边际后验分布。在每种情况下，垂直蓝线都是最大似然最优估计值。可能需要更多的重复来平滑分布。后验模式不一定与最大似然估计值相同。The marginal posterior distributions for the 1000 points at a thinning rate of 128. The vertical blue line, in each case, is the maximum likelihood optimum estimate. More replicates may be needed to smooth the distributions. The posterior mode is not necessarily the same as the maximum likelihood estimate.](06-uncertainty_files/figure-docx/fig-6_20-1.png){#fig-6_20}\n:::\n:::\n\n\n\n## Rcpp的应用\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n #profile the running of do_MCMC  using the now well known abdat   \ndata(abdat); logce <- log(abdat$cpue); fish <- as.matrix(abdat)    \nparam <- log(c(r=0.39,K=9200,Binit=3400,sigma=0.05))  \nRprof(append=TRUE)  # note the use of negLL1()  \nresult <- do_MCMC(chains=1,burnin=100,N=20000,thinstep=16,inpar=param,  \n                 infunk=negLL1,calcpred=simpspm,calcdat=fish,  \n                 obsdat=logce,priorcalc=calcprior,  \n                 scales=c(0.07,0.06,0.07,0.45))  \nRprof(NULL)  \noutprof <- summaryRprof()  \n```\n:::\n\n\n\n### 处理向量和矩阵\n\n### 替换`simpspm()` \n\n如果要使用 `simpspmC()` 函数代替 `simpspm()`，则需要在运行任何代码之前运行以下代码块中的代码。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(Rcpp)  \n #Send a text string containing the C++ code to cppFunction this will   \n #take a few seconds to compile, then the function simpspmC will   \n #continue to be available during the rest of your R session. The   \n #code in this chunk could be included into its own R file, and then  \n #the R source() function can be used to include the C++ into a   \n #session. indat must have catch in col2 (col1 in C++), and cpue in  \n #col3 (col2 in C++). Note the use of ; at the end of each line.   \n #Like simpspm(), this returns only the log(predicted cpue).  \ncppFunction('NumericVector simpspmC(NumericVector pars,  \n             NumericMatrix indat, LogicalVector schaefer) {  \n    int nyrs = indat.nrow();  \n    NumericVector predce(nyrs);  \n    NumericVector biom(nyrs+1);  \n    double Bt, qval;  \n    double sumq = 0.0;  \n    double p = 0.00000001;  \n    if (schaefer(0) == TRUE) {  \n      p = 1.0;  \n    }  \n    NumericVector ep = exp(pars);  \n    biom[0] = ep[2];  \n    for (int i = 0; i < nyrs; i++) {  \n      Bt = biom[i];  \n      biom[(i+1)]=Bt+(ep[0]/p)*Bt*(1-pow((Bt/ep[1]),p))-  \n                      indat(i,1);  \n      if (biom[(i+1)] < 40.0) biom[(i+1)] = 40.0;  \n      sumq += log(indat(i,2)/biom[i]);  \n    }  \n    qval = exp(sumq/nyrs);  \n    for (int i = 0; i < nyrs; i++) {  \n      predce[i] = log(biom[i] * qval);  \n    }  \n    return predce;  \n}')  \n```\n:::\n\n\n\n一旦运行了 `cppFunction()` 代码，我们就可以在任何使用过 `simpspm()` 函数的地方使用 `simpspmC()` 函数。一个小麻烦是，`simpspmC()` 希望输入数据 *abdat* 是矩阵，而 *abdat* 以 data.frame 开始（实际上是列表，试试 `class(abdat)`）。输入 data.frame 而不是矩阵会导致 C++ 函数失效，因此，为了解决这个问题，在下面的代码中，你会看到我们使用了 `as.matrix()` 函数，以确保向 `simpspmC()` 发送正确的对象类别，幸运的是，使用矩阵比使用 `data.frame` 更快，因此我们也将其发送给了 `simpspm()`。我们还加入了 **microbenchmark** 软件包，以便准确比较两个不同函数的运行速度。显然，要使用该软件包，必须安装该软件包（如果不想安装，也可以省略）。在我的 Windows 10 2018 XPS 13 上进行的比较中，根据时间中位数，`simpspmC()` 所花的时间通常只有 `simpspm()` 的 20%，如表（6.8）所示。第一次使用 `simpspmC()` 函数时，有时启动速度非常慢，这会影响平均值，但中位数受到的干扰较小。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n #Ensure results obtained from simpspm and simpspmC are same  \nlibrary(microbenchmark)  \ndata(abdat)  \nfishC <- as.matrix(abdat) # Use a matrix rather than a data.frame  \ninpar <- log(c(r= 0.389,K=9200,Binit=3300,sigma=0.05))  \nspmR <- exp(simpspm(inpar,fishC)) # demonstrate equivalence  \n #need to declare all arguments in simpspmC, no default values  \nspmC <- exp(simpspmC(inpar,fishC,schaefer=TRUE))  \nout <- microbenchmark( # verything identical calling function  \n  simpspm(inpar,fishC,schaefer=TRUE),   \n  simpspmC(inpar,fishC,schaefer=TRUE),  \n  times=1000  \n)  \nout2 <- summary(out)[,2:8]  \nout2 <- rbind(out2,out2[2,]/out2[1,])  \nrownames(out2) <- c(\"simpspm\",\"simpspmC\",\"TimeRatio\")  \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n #How much does using simpspmC in do_MCMC speed the run time?  \n #Assumes Rcpp code has run, eg source(\"Rcpp_functions.R\")  \nset.seed(167423) #Can use getseed() to generate a suitable seed  \nbeginR <- gettime()  #to enable estimate of time taken  \nsetscale <- c(0.07,0.06,0.07,0.45)  \nreps <- 2000  #Not enough but sufficient for demonstration  \nparam <- log(c(r=0.39,K=9200,Binit=3400,sigma=0.05))  \nresultR <- do_MCMC(chains=1,burnin=100,N=reps,thinstep=128,  \n                  inpar=param,infunk=negLL1,calcpred=simpspm,  \n                  calcdat=fishC,obsdat=log(abdat$cpue),schaefer=TRUE,  \n                  priorcalc=calcprior,scales=setscale)  \ntimeR <- gettime() - beginR   \ncat(\"time = \",timeR,\"\\n\")  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntime =  16.99757 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"acceptance rate = \",resultR$arate,\" \\n\")  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nacceptance rate =  0.319021 0.3187083 0.3282664 0.368747  \n```\n\n\n:::\n\n```{.r .cell-code}\npostR <- resultR[[1]][[1]]  \nset.seed(167423)     # Use the same pseudo-random numbers and the   \nbeginC <- gettime()  # same starting point to make the comparsion  \nparam <- log(c(r=0.39,K=9200,Binit=3400,sigma=0.05))  \nresultC <- do_MCMC(chains=1,burnin=100,N=reps,thinstep=128,  \n                 inpar=param,infunk=negLL1,calcpred=simpspmC,  \n                 calcdat=fishC,obsdat=log(abdat$cpue),schaefer=TRUE,  \n                 priorcalc=calcprior,scales=setscale)  \ntimeC <- gettime() - beginC  \ncat(\"time = \",timeC,\"\\n\")  # note the same acceptance rates  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntime =  3.269548 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"acceptance rate = \",resultC$arate,\" \\n\")  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nacceptance rate =  0.319021 0.3187083 0.3282664 0.368747  \n```\n\n\n:::\n\n```{.r .cell-code}\npostC <- resultC[[1]][[1]]  \ncat(\"Time Ratio = \",timeC/timeR)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTime Ratio =  0.1923538\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n #compare marginal distributions of the 2 chains  Fig 6.21  \npar(mfrow=c(1,1),mai=c(0.45,0.45,0.05,0.05),oma=c(0.0,0,0.0,0.0))   \npar(cex=0.85, mgp=c(1.35,0.35,0), font.axis=7,font=7,font.lab=7)   \nmaxy <- getmax(c(density(postR[,\"K\"])$y,density(postC[,\"K\"])$y))  \nplot(density(postR[,\"K\"]),lwd=2,col=1,xlab=\"K\",ylab=\"Density\",  \n     main=\"\",ylim=c(0,maxy),panel.first=grid())  \nlines(density(postC[,\"K\"]),lwd=3,col=5,lty=2)  \n```\n\n::: {.cell-output-display}\n![ A comparison of the K parameter density distribution for the chains produced by the simpspm function (solid black line) and the simpspmC function (dashed blue line), with each chain having identical starting positions and the same random seed they lie on top of each other. Repeat these examples with different seeds, and or different starting positions to see the effect.](06-uncertainty_files/figure-docx/fig-6_21-1.png){#fig-6_21}\n:::\n:::\n\n\n\n### 多个独立链\n\n在进行 MCMC 分析时，最佳做法是运行多个链，但在实际操作中，生成链的总数往往需要在可用时间与至少三个或更多链之间进行权衡。重要的是提供足够的证据来支持分析师关于分析已达到收敛的说法。这里我们将只使用三个链，尽管实际上，对于这样一个简单的模型，运行更多的链会更有说服力。为了提高速度，我们现在只使用 `simpspmC()`，因为每条细化前的链长为 $10100 \\times 256 = 2585600（2585600 \\times 3 = 7756800，770$ 万次迭代）。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n #run multiple = 3 chains  \nsetscale <- c(0.07,0.06,0.07,0.45)  # I only use a seed for   \nset.seed(9393074) # reproducibility within this book  \nreps <- 10000   # reset the timer  \nbeginC <- gettime()  # remember a thinstep=256 is insufficient  \nresultC <- do_MCMC(chains=3,burnin=100,N=reps,thinstep=256,  \n                   inpar=param,infunk=negLL1,calcpred=simpspmC,  \n                   calcdat=fishC,obsdat=log(fishC[,\"cpue\"]),  \n                   priorcalc=calcprior,scales=setscale,schaefer=TRUE)  \ncat(\"time = \",gettime() - beginC,\" secs  \\n\")  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntime =  99.29722  secs  \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n #3 chain run using simpspmC, 10000 reps, thinstep=256 Fig 6.22  \npar(mfrow=c(2,2),mai=c(0.4,0.45,0.05,0.05),oma=c(0.0,0,0.0,0.0))   \npar(cex=0.85, mgp=c(1.35,0.35,0), font.axis=7,font=7,font.lab=7)   \nlabel <- c(\"r\",\"K\",\"Binit\",\"sigma\")  \nfor (i in 1:4) {  \n   plot(density(resultC$result[[2]][,i]),lwd=2,col=1,  \n        xlab=label[i],ylab=\"Density\",main=\"\",panel.first=grid())    \n   lines(density(resultC$result[[1]][,i]),lwd=2,col=2)  \n   lines(density(resultC$result[[3]][,i]),lwd=2,col=3)  \n}  \n```\n\n::: {.cell-output-display}\n![在 64（4x64=256）的稀疏率下使用 10000 次重复和 simpspmC 函数计算的四种 Schaefer 参数的边际密度分布在三个链之间的差异。在线宽大于平均值的地方，会出现明显的细微差别。The variation between three chains in the marginal density distributions for the four Schaefer parameters using 10000 replicates at a thinning rate of 64 (4x64=256), and the simpspmC function. Slight differences are apparent where the line is wider than average.](06-uncertainty_files/figure-docx/fig-6_22-1.png){#fig-6_22}\n:::\n:::\n\n\n\n我们还可以生成不同链的汇总统计数据。事实上，有许多不同的诊断统计和图表可以使用。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n #generate summary stats from the 3 MCMC chains  \nav <- matrix(0,nrow=3,ncol=4,dimnames=list(1:3,label))  \nsig2 <- av  # do the variance  \nrelsig <- av # relative to mean of all chains  \nfor (i in 1:3) {   \n  tmp <- resultC$result[[i]]  \n  av[i,] <- apply(tmp[,1:4],2,mean)  \n  sig2[i,] <- apply(tmp[,1:4],2,var)  \n}  \ncat(\"Average \\n\")  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAverage \n```\n\n\n:::\n\n```{.r .cell-code}\nav  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          r        K    Binit      sigma\n1 0.3821707 9495.580 3522.163 0.04805695\n2 0.3809524 9530.307 3537.186 0.04811021\n3 0.3822318 9487.911 3522.021 0.04810015\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"\\nVariance per chain \\n\")  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nVariance per chain \n```\n\n\n:::\n\n```{.r .cell-code}\nsig2  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n             r         K    Binit        sigma\n1 0.0009018616 1060498.2 151208.8 6.264484e-05\n2 0.0008855405  998083.0 142153.1 6.177037e-05\n3 0.0009080043  978855.6 138585.3 6.288734e-05\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"\\n\")  \n```\n\n```{.r .cell-code}\nfor (i in 1:4) relsig[,i] <- sig2[,i]/mean(sig2[,i])  \ncat(\"Variance Relative to Mean Variance of Chains \\n\")  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nVariance Relative to Mean Variance of Chains \n```\n\n\n:::\n\n```{.r .cell-code}\nrelsig                                          \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          r         K     Binit     sigma\n1 1.0037762 1.0474275 1.0501896 1.0033741\n2 0.9856108 0.9857815 0.9872949 0.9893677\n3 1.0106130 0.9667911 0.9625155 1.0072582\n```\n\n\n:::\n:::\n\n\n\n如果我们对不同分布的量值进行比较，就能更清楚地了解差异的程度。百分比差异是指我们直接比较 2.5%和 97.5% 分位数（分布的中心 95%）的值以及第二和第三边际分布的中值，只有一个比较点（Binit 的 97.5% 上限点）大于 1%。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n #compare quantile from the 2 most widely separate MCMC chains  \ntmp <- resultC$result[[2]] # the 10000 values of each parameter  \ncat(\"Chain 2 \\n\")  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nChain 2 \n```\n\n\n:::\n\n```{.r .cell-code}\nmsy1 <- tmp[,\"r\"]*tmp[,\"K\"]/4  \nch1 <- apply(cbind(tmp[,1:4],msy1),2,quants)  \nround(ch1,4)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           r         K    Binit  sigma     msy1\n2.5%  0.3206  7926.328 2942.254 0.0356 853.1769\n5%    0.3317  8140.361 3016.340 0.0371 859.6908\n50%   0.3812  9401.467 3489.550 0.0472 896.5765\n95%   0.4287 11338.736 4214.664 0.0624 955.1773\n97.5% 0.4386 11864.430 4425.248 0.0662 970.7137\n```\n\n\n:::\n\n```{.r .cell-code}\ntmp <- resultC$result[[3]]  \ncat(\"Chain 3 \\n\")  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nChain 3 \n```\n\n\n:::\n\n```{.r .cell-code}\nmsy2 <- tmp[,\"r\"]*tmp[,\"K\"]/4  \nch2 <-  apply(cbind(tmp[,1:4],msy2),2,quants)  \nround(ch2,4)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           r         K    Binit  sigma     msy2\n2.5%  0.3225  7855.611 2920.531 0.0355 853.0855\n5%    0.3324  8090.493 3001.489 0.0371 859.3665\n50%   0.3826  9370.715 3475.401 0.0471 895.8488\n95%   0.4316 11248.955 4188.052 0.0626 952.1486\n97.5% 0.4416 11750.426 4376.639 0.0665 966.2832\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Percent difference \")  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nPercent difference \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"\\n2.5%  \",round(100*(ch1[1,] - ch2[1,])/ch1[1,],4),\"\\n\")  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n2.5%   -0.6006 0.8922 0.7383 0.4636 0.0107 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"50%   \",round(100*(ch1[3,] - ch2[3,])/ch1[3,],4),\"\\n\")  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n50%    -0.3871 0.3271 0.4055 0.2278 0.0812 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"97.5% \",round(100*(ch1[5,] - ch2[5,])/ch1[5,],4),\"\\n\")  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n97.5%  -0.6817 0.9609 1.0985 -0.5278 0.4564 \n```\n\n\n:::\n:::\n\n\n\n### 避免序列相关性所需的副本\n\n我们在前面已经看到，如果稀疏率过低，每个参数的迹线或序列内的自相关性就会很高。显然，增加稀疏化步数会降低自相关性。但不太清楚的是，需要多大的稀疏率才能使这种相关性变得不明显。\n\n现在我们有了一种更快的方法来探讨这个问题，我们可以寻找所需的稀疏率规模。我们从之前的试验中得知，每个参数的稀疏率为 128 时，滞后 2 到 4 步之间仍然存在显著的相关性，因此，我们应该研究稀疏率为 1024（$4 \\times 256$）和 2048（$4 \\times 512$）时的效果。为了更严格地进行比较，我们平衡了稀疏率和迭代次数，因此我们使用 $2000 \\times 1024$ 和 $1000 \\times 2048$，两者都 $= 2048000$。问题在于消除自相关是否能更好地掌握不同参数的全部变化。但是，为了使试验具有可比性，未稀疏链的长度必须相同，这样才能对似然曲面进行相同程度的探索。因此，在较小的稀疏率下，我们需要更多的迭代次数，同时还需要考虑烧入期（一个烧入 100 次，另一个烧入 50 次）。@fig-6_23 中，稀疏率为 1024 时，滞后期为 1 时仍有显著相关性，而稀疏率为 2028 时，相关性消失。即使使用 `simpspmC()`，该例程也需要 60 秒左右。\n\n消除序列内相关性的重要性在于，如果序列内相关性很高，就会干扰向静态分布的收敛（因为序列点是相关的，而不是跟踪似然曲面的全部范围），结果可能无法捕捉到模型和所研究的可用数据固有的全部变化范围。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n #compare two higher thinning rates per parameter in MCMC  \nparam <- log(c(r=0.39,K=9200,Binit=3400,sigma=0.05))  \nsetscale <- c(0.07,0.06,0.07,0.45)  \nresult1 <- do_MCMC(chains=1,burnin=100,N=2000,thinstep=1024,  \n                   inpar=param,infunk=negLL1,calcpred=simpspmC,  \n                   calcdat=fishC,obsdat=log(abdat$cpue),  \n                   priorcalc=calcprior,scales=setscale,schaefer=TRUE)  \nresult2 <- do_MCMC(chains=1,burnin=50,N=1000,thinstep=2048,  \n                   inpar=param,infunk=negLL1,calcpred=simpspmC,  \n                   calcdat=fishC,obsdat=log(abdat$cpue),  \n                   priorcalc=calcprior,scales=setscale,schaefer=TRUE)  \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n #autocorrelation of 2 different thinning rate chains Fig6.23  \nposterior1 <- result1$result[[1]]  \nposterior2 <- result2$result[[1]]  \nlabel <- colnames(posterior1)[1:4]  \npar(mfrow=c(4,2),mai=c(0.25,0.45,0.05,0.05),oma=c(1.0,0,1.0,0.0))   \npar(cex=0.85, mgp=c(1.35,0.35,0), font.axis=7,font=7,font.lab=7)    \nfor (i in 1:4) {  \n  auto <- acf(posterior1[,i],type=\"correlation\",plot=TRUE,  \n              ylab=label[i],lag.max=20,xlab=\"\",ylim=c(0,0.3),lwd=2)  \n  if (i == 1) mtext(1024,side=3,line=-0.1,outer=FALSE,cex=1.2)  \n  auto <- acf(posterior2[,i],type=\"correlation\",plot=TRUE,  \n              ylab=label[i],lag.max=20,xlab=\"\",ylim=c(0,0.3),lwd=2)  \n  if (i == 1) mtext(2048,side=3,line=-0.1,outer=FALSE,cex=1.2)  \n}  \nmtext(\"Lag\",side=1,line=-0.1,outer=TRUE,cex=1.2)  \n```\n\n::: {.cell-output-display}\n![两条链在 Schaefer 模型四个参数上的自相关性，综合稀疏率分别为 1024 和 2048。请注意，Y 轴上的最大值缩小了，使两者之间的差异更加明显。The auto-correlation of two chains across the four parameters of the Schaefer model with combined thinning rates of 1024 and 2048. Note the reduced maximum on the y-axis to make the differences between the two more apparent.](06-uncertainty_files/figure-docx/fig-6_23-1.png){#fig-6_23}\n:::\n:::\n\n\n\n我们可以用比较上述三个复制链的相同方法来比较具有不同稀疏率的两个链。也就是说，我们可以绘制它们的边际分布图，并比较它们的量值分布。由于稀疏化后的最终复制数量有限，它们的边际分布惊人地相似（@fig-6_23）。然而，在比较它们的量值分布时，观察到的分布中心 95% 之间的差异往往比上文 “多重独立链 ”一节中比较的三条链要大。这些差异似乎并没有遵循任何特定的方向，不过，随着下限和上限向同一方向移动，似乎存在一些偏差，但需要更多的重复才能澄清这一点。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n #visual comparison of 2 chains marginal densities  Fig 6.24  \nparset(plots=c(2,2),cex=0.85)   \nlabel <- c(\"r\",\"K\",\"Binit\",\"sigma\")  \nfor (i in 1:4) {  \n   plot(density(result1$result[[1]][,i]),lwd=4,col=1,xlab=label[i],  \n        ylab=\"Density\",main=\"\",panel.first=grid())    \n   lines(density(result2$result[[1]][,i]),lwd=2,col=5,lty=2)  \n}  \n```\n\n::: {.cell-output-display}\n![在 2048（虚线）和 1024（黑色实线）的稀疏率下，使用 1000 和 2000 个重复序列计算的 K 参数边际密度分布在两个链之间的变化。The variation between two chains in the marginal density distributions for the K parameter using 1000 and 2000 replicates at thinning rates of 2048 (dashed line) and 1024 (solid black line).](06-uncertainty_files/figure-docx/fig-6_24-1.png){#fig-6_24}\n:::\n:::\n\n\n\n独立的 MCMC 链总会存在一定程度的差异，这就是相似性标准概念变得重要的原因。在这两条链中，虽然存在明显的差异，但中位数的实际差异都小于 1%，而在 10 个外部量级中，有 8 个的实际差异都小于 1%。我们理应相信薄化率更高的链。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n #tablulate a summary of the two different thinning rates.  \ncat(\"1024 thinning rate \\n\")  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1024 thinning rate \n```\n\n\n:::\n\n```{.r .cell-code}\nposterior <- result1$result[[1]]  \nmsy <-posterior[,1]*posterior[,2]/4   \ntmp1 <- apply(cbind(posterior[,1:4],msy),2,quants)  \nrge <- apply(cbind(posterior[,1:4],msy),2,range)  \ntmp1 <- rbind(tmp1,rge[2,] - rge[1,])  \nrownames(tmp1)[6] <- \"Range\"  \nprint(round(tmp1,4))  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           r         K    Binit  sigma      msy\n2.5%  0.3221  7918.242 2943.076 0.0352 853.5243\n5%    0.3329  8139.645 3016.189 0.0367 858.8872\n50%   0.3801  9429.118 3499.826 0.0470 895.7376\n95%   0.4289 11235.643 4172.932 0.0627 953.9948\n97.5% 0.4392 11807.732 4380.758 0.0663 973.2185\nRange 0.2213  7621.901 2859.858 0.0612 238.5436\n```\n\n\n:::\n\n```{.r .cell-code}\nposterior2 <- result2$result[[1]]  \nmsy2 <-posterior2[,1]*posterior2[,2]/4    \ncat(\"2048 thinning rate \\n\")  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n2048 thinning rate \n```\n\n\n:::\n\n```{.r .cell-code}\ntmp2 <- apply(cbind(posterior2[,1:4],msy2),2,quants)  \nrge2 <- apply(cbind(posterior2[,1:4],msy2),2,range)  \ntmp2 <- rbind(tmp2,rge2[2,] - rge2[1,])  \nrownames(tmp2)[6] <- \"Range\"  \nprint(round(tmp2,4))  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           r         K    Binit  sigma     msy2\n2.5%  0.3216  7852.002 2920.198 0.0351 855.8295\n5%    0.3329  8063.878 3000.767 0.0368 859.8039\n50%   0.3820  9400.708 3482.155 0.0468 896.6774\n95%   0.4313 11235.368 4184.577 0.0628 959.2919\n97.5% 0.4434 11638.489 4456.164 0.0676 975.4358\nRange 0.2189  8156.444 3161.232 0.0546 257.1803\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Inner 95% ranges and Differences between total ranges \\n\")   \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nInner 95% ranges and Differences between total ranges \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"95% 1 \",round((tmp1[5,] - tmp1[1,]),4),\"\\n\")  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n95% 1  0.1172 3889.49 1437.682 0.0311 119.6942 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"95% 2 \",round((tmp2[5,] - tmp2[1,]),4),\"\\n\")  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n95% 2  0.1218 3786.487 1535.966 0.0325 119.6064 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Diff  \",round((tmp2[6,] - tmp1[6,]),4),\"\\n\")  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDiff   -0.0024 534.5429 301.3746 -0.0066 18.6367 \n```\n\n\n:::\n:::\n\n\n\n## 结束语\n\n本章的目的不是鼓励人们编写自己的自举、渐近误差、似然分布或 MCMC 函数，而是让他们探索这些方法，获得直觉，以便在使用这些方法时能够清楚地认识到它们的优势，同样重要的是，认识到它们的局限性。在实施 MCMC 分析时尤其如此，人们最好使用 Stan 或 Template Model Builder（Kristensen 等，2016）或 AD Model Builder（Fournier 等，1998；Fournier 等，2012）等工具。尽管如此，我们还是通过使用 MCMC 详细介绍了贝叶斯统计的应用，因为这确实是捕捉任何特定建模分析中固有的所有不确定性的最佳方法。尽管如此，在许多渔业模型中，许多参数，如自然死亡率、繁殖陡度和一些选择性参数，都被设定为常数，在贝叶斯背景下，这意味着信息量极大的先验。这种说法有点矫揉造作，因为如果不对这些参数进行估计，我们就不需要考虑任何先验概率，但原则上这就是它的含义。解决此类问题的通常方法是研究此类参数的似然曲线，或进行敏感性分析，研究使用不同常数的影响。甚至可以使用标准化的似然曲线作为先验概率。\n\n诚然，使用 MCMC 可以更全面地描述建模情景中的变化，但这种分析无法捕捉模型的不确定性，在这种情 况下，结构不同的模型可能会对所评估的种群动态提供不同的看法。这就是通常讨论的模型平均概念。不过，这也提出了一个问题，即哪个模型被认为是最现实的，以及在它们可能完全不相称的情况下，每个模型的权重是多少。不过，在研究任何建模结果时，都需要考虑模型的不确定性。正如 Punt 和 Hilborn（1997）所说：\"最常见的方法是选择一个单一的结构模型，并只考虑其参数的不确定性。另一种更站得住脚的方法是考虑一系列真正不同的结构模型。然而，除了计算量更大之外，还很难'约束'所考虑的模型范围。与此相关的一个问题是，如何确定有多少模型参数应被视为不确定参数\"。\n\n不确定性的特征描述非常重要，因为它提供了在提供管理建议时可以有多大信心的一些概念。人们可能会迷失在计算细节中，而忘记了主要目标是为某种自然资源提供站得住脚的管理建议。要做到这一点，并没有单一的方法，因此，如果情况导致 MCMC 始终无法收敛，仍有可能采用其他方法，并对评估结果和种群的状况进行长期描述。如果了解这些方法，并知道如何使用和解释这些方法所能发现的模型及其数据，显然会有所帮助。但最终，了解渔业历史以及除渔获量外的其他影响因素也会有所帮助。\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}