<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-Hans" xml:lang="zh-Hans"><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>使用 R 语言进行渔业建模和定量方法研究 - 4&nbsp; 模型参数估算</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>

<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./05-staticModel.html" rel="next">
<link href="./03-simpopmodel.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark"><script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "没有结果",
    "search-matching-documents-text": "匹配的文档",
    "search-copy-link-title": "复制搜索链接",
    "search-hide-matches-text": "隐藏其它匹配结果",
    "search-more-match-text": "更多匹配结果",
    "search-more-matches-text": "更多匹配结果",
    "search-clear-button-title": "清除",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "取消",
    "search-submit-button-title": "提交",
    "search-label": "搜索"
  }
}</script><script>
    MathJax ={
  tex: {
    macros: {
      bm: ["{\\boldsymbol #1}",1],
    }
  }
};
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>
</head>
<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top"><nav class="quarto-secondary-nav"><div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="切换侧边栏导航" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./04-application.html"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">模型参数估算</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="切换侧边栏导航" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav></header><!-- content --><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto"><div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">使用 R 语言进行渔业建模和定量方法研究</a> 
        <div class="sidebar-tools-main">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="切换深色模式"><i class="bi"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="搜索"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01-intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">关于建模</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-NonIntroductiontoR.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">R 语言的不完全介绍</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03-simpopmodel.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">简单种群模型</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04-application.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">模型参数估算</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05-staticModel.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">静态模型</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06-uncertainty.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">不确定性</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07-spm.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">剩余生产模型</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08-references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">参考文献</span></a>
  </div>
</li>
    </ul>
</div>
</nav><div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="2"><h2 id="toc-title">目录</h2>
   
  <ul>
<li>
<a href="#%E5%BC%95%E8%A8%80" id="toc-引言" class="nav-link active" data-scroll-target="#%E5%BC%95%E8%A8%80"><span class="header-section-number">4.1</span> 引言</a>
  <ul class="collapse">
<li><a href="#%E6%9C%80%E4%BC%98%E5%8C%96" id="toc-最优化" class="nav-link" data-scroll-target="#%E6%9C%80%E4%BC%98%E5%8C%96"><span class="header-section-number">4.1.1</span> 最优化</a></li>
  </ul>
</li>
  <li><a href="#%E6%9C%80%E4%BD%B3%E6%8B%9F%E5%90%88%E6%A0%87%E5%87%86" id="toc-最佳拟合标准" class="nav-link" data-scroll-target="#%E6%9C%80%E4%BD%B3%E6%8B%9F%E5%90%88%E6%A0%87%E5%87%86"><span class="header-section-number">4.2</span> 最佳拟合标准</a></li>
  <li>
<a href="#r%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9E%8B%E6%8B%9F%E5%90%88" id="toc-r语言中的模型拟合" class="nav-link" data-scroll-target="#r%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9E%8B%E6%8B%9F%E5%90%88"><span class="header-section-number">4.3</span> R语言中的模型拟合</a>
  <ul class="collapse">
<li><a href="#%E6%A8%A1%E5%9E%8B%E9%9C%80%E6%B1%82" id="toc-模型需求" class="nav-link" data-scroll-target="#%E6%A8%A1%E5%9E%8B%E9%9C%80%E6%B1%82"><span class="header-section-number">4.3.1</span> 模型需求</a></li>
  <li><a href="#%E5%B9%B4%E9%BE%84-%E4%BD%93%E9%95%BF%E7%A4%BA%E4%BE%8B" id="toc-年龄-体长示例" class="nav-link" data-scroll-target="#%E5%B9%B4%E9%BE%84-%E4%BD%93%E9%95%BF%E7%A4%BA%E4%BE%8B"><span class="header-section-number">4.3.2</span> 年龄-体长示例</a></li>
  <li><a href="#%E5%85%B6%E5%AE%83%E7%9A%84%E7%94%9F%E9%95%BF%E6%A8%A1%E5%9E%8B" id="toc-其它的生长模型" class="nav-link" data-scroll-target="#%E5%85%B6%E5%AE%83%E7%9A%84%E7%94%9F%E9%95%BF%E6%A8%A1%E5%9E%8B"><span class="header-section-number">4.3.3</span> 其它的生长模型</a></li>
  </ul>
</li>
  <li>
<a href="#%E6%AE%8B%E5%B7%AE%E5%B9%B3%E6%96%B9%E5%92%8C" id="toc-残差平方和" class="nav-link" data-scroll-target="#%E6%AE%8B%E5%B7%AE%E5%B9%B3%E6%96%B9%E5%92%8C"><span class="header-section-number">4.4</span> 残差平方和</a>
  <ul class="collapse">
<li><a href="#%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95%E7%9A%84%E5%81%87%E8%AE%BE" id="toc-最小二乘法的假设" class="nav-link" data-scroll-target="#%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95%E7%9A%84%E5%81%87%E8%AE%BE"><span class="header-section-number">4.4.1</span> 最小二乘法的假设</a></li>
  <li><a href="#%E6%95%B0%E5%80%BC%E6%B1%82%E8%A7%A3" id="toc-数值求解" class="nav-link" data-scroll-target="#%E6%95%B0%E5%80%BC%E6%B1%82%E8%A7%A3"><span class="header-section-number">4.4.2</span> 数值求解</a></li>
  <li><a href="#%E5%B0%86%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%BB%99%E5%85%B6%E5%AE%83%E5%87%BD%E6%95%B0" id="toc-将函数作为参数传递给其它函数" class="nav-link" data-scroll-target="#%E5%B0%86%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%BB%99%E5%85%B6%E5%AE%83%E5%87%BD%E6%95%B0"><span class="header-section-number">4.4.3</span> 将函数作为参数传递给其它函数</a></li>
  <li><a href="#%E6%A8%A1%E5%9E%8B%E6%8B%9F%E5%90%88" id="toc-模型拟合" class="nav-link" data-scroll-target="#%E6%A8%A1%E5%9E%8B%E6%8B%9F%E5%90%88"><span class="header-section-number">4.4.4</span> 模型拟合</a></li>
  <li><a href="#%E7%9B%AE%E6%A0%87%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9" id="toc-目标模型选择" class="nav-link" data-scroll-target="#%E7%9B%AE%E6%A0%87%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9"><span class="header-section-number">4.4.5</span> 目标模型选择</a></li>
  <li><a href="#%E6%AE%8B%E5%B7%AE%E9%80%89%E6%8B%A9%E5%AF%B9%E6%A8%A1%E5%9E%8B%E6%8B%9F%E5%90%88%E7%9A%84%E5%BD%B1%E5%93%8D" id="toc-残差选择对模型拟合的影响" class="nav-link" data-scroll-target="#%E6%AE%8B%E5%B7%AE%E9%80%89%E6%8B%A9%E5%AF%B9%E6%A8%A1%E5%9E%8B%E6%8B%9F%E5%90%88%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="header-section-number">4.4.6</span> 残差选择对模型拟合的影响</a></li>
  <li><a href="#%E5%85%B3%E4%BA%8E%E5%88%9D%E5%A7%8B%E6%A8%A1%E5%9E%8B%E6%8B%9F%E5%90%88%E7%9A%84%E8%AF%B4%E6%98%8E" id="toc-关于初始模型拟合的说明" class="nav-link" data-scroll-target="#%E5%85%B3%E4%BA%8E%E5%88%9D%E5%A7%8B%E6%A8%A1%E5%9E%8B%E6%8B%9F%E5%90%88%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="header-section-number">4.4.7</span> 关于初始模型拟合的说明</a></li>
  </ul>
</li>
  <li>
<a href="#%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6" id="toc-最大似然" class="nav-link" data-scroll-target="#%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6"><span class="header-section-number">4.5</span> 最大似然</a>
  <ul class="collapse">
<li><a href="#%E7%AE%80%E8%A6%81%E7%A4%BA%E4%BE%8B" id="toc-简要示例" class="nav-link" data-scroll-target="#%E7%AE%80%E8%A6%81%E7%A4%BA%E4%BE%8B"><span class="header-section-number">4.5.1</span> 简要示例</a></li>
  </ul>
</li>
  <li>
<a href="#%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E7%9A%84%E4%BC%BC%E7%84%B6" id="toc-正态分布的似然" class="nav-link" data-scroll-target="#%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E7%9A%84%E4%BC%BC%E7%84%B6"><span class="header-section-number">4.6</span> 正态分布的似然</a>
  <ul class="collapse">
<li><a href="#%E4%B8%8E%E5%B9%B3%E6%96%B9%E5%92%8C%E7%AD%89%E4%BB%B7%E6%80%A7" id="toc-与平方和等价性" class="nav-link" data-scroll-target="#%E4%B8%8E%E5%B9%B3%E6%96%B9%E5%92%8C%E7%AD%89%E4%BB%B7%E6%80%A7"><span class="header-section-number">4.6.1</span> 与平方和等价性</a></li>
  <li><a href="#%E5%BA%94%E7%94%A8%E6%AD%A3%E6%80%81%E4%BC%BC%E7%84%B6%E6%8B%9F%E5%90%88%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B" id="toc-应用正态似然拟合数据模型" class="nav-link" data-scroll-target="#%E5%BA%94%E7%94%A8%E6%AD%A3%E6%80%81%E4%BC%BC%E7%84%B6%E6%8B%9F%E5%90%88%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="header-section-number">4.6.2</span> 应用正态似然拟合数据模型</a></li>
  </ul>
</li>
  <li>
<a href="#%E5%AF%B9%E6%95%B0%E6%AD%A3%E6%80%81%E4%BC%BC%E7%84%B6" id="toc-对数正态似然" class="nav-link" data-scroll-target="#%E5%AF%B9%E6%95%B0%E6%AD%A3%E6%80%81%E4%BC%BC%E7%84%B6"><span class="header-section-number">4.7</span> 对数正态似然</a>
  <ul class="collapse">
<li><a href="#%E5%AF%B9%E6%95%B0%E6%AD%A3%E6%80%81%E4%BC%BC%E7%84%B6%E7%9A%84%E7%AE%80%E5%8C%96" id="toc-对数正态似然的简化" class="nav-link" data-scroll-target="#%E5%AF%B9%E6%95%B0%E6%AD%A3%E6%80%81%E4%BC%BC%E7%84%B6%E7%9A%84%E7%AE%80%E5%8C%96"><span class="header-section-number">4.7.1</span> 对数正态似然的简化</a></li>
  <li><a href="#%E5%AF%B9%E6%95%B0%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E7%9A%84%E6%80%A7%E8%B4%A8" id="toc-对数正态分布的性质" class="nav-link" data-scroll-target="#%E5%AF%B9%E6%95%B0%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="header-section-number">4.7.2</span> 对数正态分布的性质</a></li>
  <li><a href="#%E5%BA%94%E7%94%A8%E5%AF%B9%E6%95%B0%E4%BC%BC%E7%84%B6%E6%8B%9F%E5%90%88%E6%9B%B2%E7%BA%BF" id="toc-应用对数似然拟合曲线" class="nav-link" data-scroll-target="#%E5%BA%94%E7%94%A8%E5%AF%B9%E6%95%B0%E4%BC%BC%E7%84%B6%E6%8B%9F%E5%90%88%E6%9B%B2%E7%BA%BF"><span class="header-section-number">4.7.3</span> 应用对数似然拟合曲线</a></li>
  <li><a href="#%E5%BA%94%E7%94%A8%E5%AF%B9%E6%95%B0%E6%AD%A3%E6%80%81%E8%AF%AF%E5%B7%AE%E6%8B%9F%E5%90%88%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9E%8B" id="toc-应用对数正态误差拟合动态模型" class="nav-link" data-scroll-target="#%E5%BA%94%E7%94%A8%E5%AF%B9%E6%95%B0%E6%AD%A3%E6%80%81%E8%AF%AF%E5%B7%AE%E6%8B%9F%E5%90%88%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="header-section-number">4.7.4</span> 应用对数正态误差拟合动态模型</a></li>
  </ul>
</li>
  <li>
<a href="#%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%88%86%E5%B8%83%E7%9A%84%E4%BC%BC%E7%84%B6" id="toc-二项式分布的似然" class="nav-link" data-scroll-target="#%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%88%86%E5%B8%83%E7%9A%84%E4%BC%BC%E7%84%B6"><span class="header-section-number">4.8</span> 二项式分布的似然</a>
  <ul class="collapse">
<li><a href="#%E4%BA%8C%E9%A1%B9%E5%BC%8F%E4%BC%BC%E7%84%B6%E7%9A%84%E7%A4%BA%E4%BE%8B" id="toc-二项式似然的示例" class="nav-link" data-scroll-target="#%E4%BA%8C%E9%A1%B9%E5%BC%8F%E4%BC%BC%E7%84%B6%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="header-section-number">4.8.1</span> 二项式似然的示例</a></li>
  <li><a href="#%E5%BC%80%E6%94%BE%E6%B5%B7%E6%B9%BE%E5%B9%BC%E5%B9%B4%E6%B5%B7%E7%8B%97%E7%A7%8D%E7%BE%A4%E6%95%B0%E9%87%8F" id="toc-开放海湾幼年海狗种群数量" class="nav-link" data-scroll-target="#%E5%BC%80%E6%94%BE%E6%B5%B7%E6%B9%BE%E5%B9%BC%E5%B9%B4%E6%B5%B7%E7%8B%97%E7%A7%8D%E7%BE%A4%E6%95%B0%E9%87%8F"><span class="header-section-number">4.8.2</span> 开放海湾幼年海狗种群数量</a></li>
  <li><a href="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E7%8B%AC%E7%AB%8B%E6%A0%B7%E6%9C%AC" id="toc-使用多个独立样本" class="nav-link" data-scroll-target="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E7%8B%AC%E7%AB%8B%E6%A0%B7%E6%9C%AC"><span class="header-section-number">4.8.3</span> 使用多个独立样本</a></li>
  <li><a href="#%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95" id="toc-分析方法" class="nav-link" data-scroll-target="#%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95"><span class="header-section-number">4.8.4</span> 分析方法</a></li>
  </ul>
</li>
  <li><a href="#%E5%85%B6%E5%AE%83%E5%88%86%E5%B8%83" id="toc-其它分布" class="nav-link" data-scroll-target="#%E5%85%B6%E5%AE%83%E5%88%86%E5%B8%83"><span class="header-section-number">4.9</span> 其它分布</a></li>
  <li>
<a href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%88%86%E5%B8%83%E7%9A%84%E4%BC%BC%E7%84%B6" id="toc-多项式分布的似然" class="nav-link" data-scroll-target="#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%88%86%E5%B8%83%E7%9A%84%E4%BC%BC%E7%84%B6"><span class="header-section-number">4.10</span> 多项式分布的似然</a>
  <ul class="collapse">
<li><a href="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%88%86%E5%B8%83" id="toc-使用多项式分布" class="nav-link" data-scroll-target="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%88%86%E5%B8%83"><span class="header-section-number">4.10.1</span> 使用多项式分布</a></li>
  </ul>
</li>
  <li><a href="#gamma-%E5%88%86%E5%B8%83%E7%9A%84%E4%BC%BC%E7%84%B6" id="toc-gamma-分布的似然" class="nav-link" data-scroll-target="#gamma-%E5%88%86%E5%B8%83%E7%9A%84%E4%BC%BC%E7%84%B6"><span class="header-section-number">4.11</span> Gamma 分布的似然</a></li>
  <li><a href="#beta-%E5%88%86%E5%B8%83%E7%9A%84%E4%BC%BC%E7%84%B6" id="toc-beta-分布的似然" class="nav-link" data-scroll-target="#beta-%E5%88%86%E5%B8%83%E7%9A%84%E4%BC%BC%E7%84%B6"><span class="header-section-number">4.12</span> Beta 分布的似然</a></li>
  <li>
<a href="#%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86" id="toc-贝叶斯定理" class="nav-link" data-scroll-target="#%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86"><span class="header-section-number">4.13</span> 贝叶斯定理</a>
  <ul class="collapse">
<li><a href="#%E7%AE%80%E4%BB%8B" id="toc-简介" class="nav-link" data-scroll-target="#%E7%AE%80%E4%BB%8B"><span class="header-section-number">4.13.1</span> 简介</a></li>
  <li><a href="#%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%96%B9%E6%B3%95" id="toc-贝叶斯方法" class="nav-link" data-scroll-target="#%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%96%B9%E6%B3%95"><span class="header-section-number">4.13.2</span> 贝叶斯方法</a></li>
  <li><a href="#%E5%85%88%E9%AA%8C%E6%A6%82%E7%8E%87" id="toc-先验概率" class="nav-link" data-scroll-target="#%E5%85%88%E9%AA%8C%E6%A6%82%E7%8E%87"><span class="header-section-number">4.13.3</span> 先验概率</a></li>
  </ul>
</li>
  <li><a href="#%E7%BB%93%E8%AF%AD" id="toc-结语" class="nav-link" data-scroll-target="#%E7%BB%93%E8%AF%AD"><span class="header-section-number">4.14</span> 结语</a></li>
  </ul></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block default"><div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title"><span id="sec-paraestimat" class="quarto-section-identifier"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">模型参数估算</span></span></h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> 代码</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">显示所有代码</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">隐藏所有代码</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">查看源代码</a></li></ul></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header><section id="引言" class="level2" data-number="4.1"><h2 data-number="4.1" class="anchored" data-anchor-id="引言">
<span class="header-section-number">4.1</span> 引言</h2>
<p>生态学和渔业学学建模的一个更重要的方面涉及到模型与数据的拟合。这种模型拟合需要:</p>
<ul>
<li><p>从对自然感兴趣的过程中获得的数据（样本、观测），</p></li>
<li><p>明确地选择一个适合手头任务的模型结构（模型设计，然后选择——大的主题本身），</p></li>
<li><p>明确地选择概率密度函数来表示当比较时，模拟过程的预测将如何不同于自然观测的预期分布(选择残差结构) ，最后,</p></li>
<li><p>寻找模型参数，优化之间的预测模型和任何观测数据(模型拟合的准则)匹配。</p></li>
</ul>
<p>在上面的最后一个需求中，将模型与数据相匹配时所涉及的许多技巧/诡计/魔术都集中在那个看起来无害的单词或概念上进行<strong>优化</strong>。这是一个几乎是恶作剧的想法，有时会导致一个人陷入麻烦，虽然它也是一个挑战，往往是有趣的。生成所谓<em>最佳拟合</em>模型的不同方法是本章的重点。它围绕着在描述模型的质量拟合可用数据时使用什么标准的想法，以及如何实现明确选择的标准。</p>
<p>我一直使用”显式”这个词，并且有很好的理由，但是需要一些解释。很多人都有过对数据进行线性回归拟合的经验，但是，根据我的经验，很少有人意识到，当他们拟合这样一个模型时，他们假设使用了加性正态随机残差(正态误差) ，并且他们正在最小化这些残差的平方和。根据上述四个要求，当将一个线性回归应用到一个数据集时，线性关系的假设回答了第二个要求，正态误差的使用(附加常数方差的假设)回答了第三个要求，平方和的最小化是满足第四个要求的选择。通常情况下，最好是明确地了解自己在做什么，而不是仅仅出于习惯或模仿他人。为了对这些模型拟合需求做出最合适的选择(即做出可以辩护的选择) ，分析师还需要了解被建模的自然过程。一个人可以假设和断言几乎任何事情，但只有这样的选择可以得到有效的辩护。作为一个更一般的陈述，如果一个人不能为一组选择辩护，那么他就不应该做出这些选择。</p>
<section id="最优化" class="level3" data-number="4.1.1"><h3 data-number="4.1.1" class="anchored" data-anchor-id="最优化">
<span class="header-section-number">4.1.1</span> 最优化</h3>
<p>在 Microsoft Excel 中，当对数据进行模型拟合时，使用内置的Excel解算器找到最佳模型参数。这包括设置电子表格，使最佳拟合标准（平方和、最大似然等，见下文）由一个单元格的内容表示，而模型参数和使用的数据则包含在其他相互关联的单元格中。改变一个模型的参数会改变产生的预测值，这反过来又会改变最佳拟合的标准值。一个 “最佳”参数集可以通过寻找能优化观察值和预测值之间的匹配的参数来找到。这听起来很简单，但实际上是一门艺术，其中要做许多假设和决定。在 Excel 求解器中，人们确定了包含模型参数的单元格，然后求解器的内部代码将修改这些值，同时监测 “最佳拟合标准”单元格，直到找到一个最小（或最大）值（或遇到一个例外）。实际上，这样的电子表格设置构成了在Excel中使用求解器的语法。我们将在 R 中使用求解器或优化函数，它们也有一个必要的语法，但它并不比设置电子表格更复杂，只是更抽象而已。</p>
<p>当对单一数据集（如年龄-长度）用2至6个参数进行非动态过程建模时，模型拟合通常是相对简单的。然而，当处理一个种群的动态过程时，可能会变得更加复杂，涉及到补充、个体生长、自然死亡和多个捕鱼船队的捕捞死亡。可能有许多类型的数据，可能有多于几十个甚至几百个参数。在这种情况下，为了调整预测值与观测值的拟合质量，必须使用某种形式的自动优化或非线性求解器。</p>
<p>优化是一个非常大的研究课题，在CRAN任务视图中详细讨论了许多可用的选项。在 CRAN 任务视图：优化和数学编程中可以找到详细的讨论，网址是<a href="https://cran.r-project.org/" class="uri">https://cran.r-project.org/</a>。在本章的学习中，我们将主要使用内置的函数 <code><a href="https://rdrr.io/r/stats/nlm.html">nlm()</a></code>(尝试 <code><a href="https://rdrr.io/r/stats/nlm.html">?nlm</a></code>)，但也有许多替代方法（包括 <code><a href="https://rdrr.io/r/stats/nlminb.html">nlminb()</a></code>、<code><a href="https://rdrr.io/r/stats/optim.html">optim()</a></code>等）。如果你要参与模型拟合，那么真的值得阅读 R-CRAN 上关于优化的任务视图，并且作为第一步，探索 <code><a href="https://rdrr.io/r/stats/nlm.html">nlm()</a></code> 和 <code><a href="https://rdrr.io/r/stats/optim.html">optim()</a></code> 函数的帮助和例子。</p>
<p>有时有可能猜测出一组参数，产生看似合理的可视拟合，至少对简单的静态模型来说是如此。然而，虽然这种通过<em>目测拟合</em>（fitting-by-eye）可以为估计模型的参数提供可用的起点，但它并不构成将模型与数据拟合的可辩护的标准。这是因为我的 “目测拟合”（或称 “黑暗中的狂刺”）很可能与你的 “目测拟合”（或称 “有根据的猜测”）不同。与其使用这样的观点，不如使用一些更正式定义的模型与数据拟合质量的标准。</p>
<p>这里的重点是如何设置 R 代码，以便使用最小二乘法或最大似然法进行模型参数估计，特别是后者。我们以后对贝叶斯方法的考虑将主要集中在对不确定性的描述上。我们将通过重复的例子和相关的解释来说明模型的拟合过程。目的是阅读本节应该使读者能够建立自己的模型来解决参数值。我们将尝试以一种一般的方式来做这件事，它应该适合于许多问题的调整。</p>
</section></section><section id="最佳拟合标准" class="level2" data-number="4.2"><h2 data-number="4.2" class="anchored" data-anchor-id="最佳拟合标准">
<span class="header-section-number">4.2</span> 最佳拟合标准</h2>
<p>确定什么是数据的最佳模型拟合通常有三种方法。</p>
<p>一般来讲，模型拟合包括观测变量 <span class="math inline">\(x\)</span> 与为描述建模过程而提出候选模型所预测值 <span class="math inline">\(\hat x\)</span> 之间残差平方的最小化（<code><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq()</a></code>）：</p>
<p><span id="eq-4_1"><span class="math display">\[
ssq = \sum_{i=1}^n (x_i- \hat x_i)^2
\qquad(4.1)\]</span></span></p>
<p>其中 <span class="math inline">\(x_i\)</span> 是 <span class="math inline">\(n\)</span> 个观测中的第 <span class="math inline">\(i\)</span> 个观测值，<span class="math inline">\(\hat x_i\)</span> 是给定观测值 <span class="math inline">\(i\)</span> 的模型预测值（例如，如果 <span class="math inline">\(x_i\)</span> 为鱼 <span class="math inline">\(i\)</span> 的年龄-体长，则 <span class="math inline">\(\hat x_i\)</span> 为一些候选生长模型中得到的鱼 <span class="math inline">\(i\)</span> 的年龄-体长预测值）。<span class="math inline">\(\hat x\)</span> 中的 <span class="math inline">\(\hat{}\)</span> 表示 <span class="math inline">\(x\)</span> 的预测值。</p>
<p>或者，模型拟合可以涉及最小化负对数似然（在本书中为<code>-veLL</code> 或 <code>negLL</code>），这需要确定1）定义的模型结构，2）一组模型参数和 3）残差的期望概率分布的情况下，每个观测数据点的似然有多大。最小化负对数似然相当于最大化所有似然的乘积或所有数据点的对数似然总和。给定一个观测值 <span class="math inline">\(x\)</span> 的集合，一个可以预测 <span class="math inline">\(\hat x\)</span> 的模型结构，以及一组模型参数 <span class="math inline">\(\theta\)</span> ，那么这些观测值的总似然定义为：</p>
<p><span id="eq-4_2"><span class="math display">\[
\begin{aligned}  
{L} &amp;= \prod\limits_{i=1}^{n}{{L}\left( {x_i|\theta}\right )}  \\  
{-veLL} &amp;= -\sum\limits_{i=1}^{n}{ \log{({L}\left( {x_i|\theta}\right )})}  
\end{aligned}  
\qquad(4.2)\]</span></span></p>
<p>其中 <span class="math inline">\(L\)</span> 为总似然，等于<span class="math inline">\(\prod L(x|\theta)\)</span> 或给定参数值 <span class="math inline">\(\theta\)</span> 每个观测值 <span class="math inline">\(x\)</span> 的概率密度（似然）积（在每种情况下，离期望值 <span class="math inline">\(\hat x\)</span> 越远，似然越低）。<em>-veLL</em> 是给定候选模型参数 <span class="math inline">\(\theta\)</span> 时观测值 <span class="math inline">\(x\)</span> 的总负对数似然，每个观测点 <span class="math inline">\(x\)</span> 的 <span class="math inline">\(n\)</span> 对数似然的负数和。 我们使用对数似然，因为大多数似然是非常小的数值，当与许多其他非常小的数字相乘时，会变得非常小，以至于有可能导致浮点溢出的计算机错误。对数变换将乘法变为加法，避免了这种风险( <span class="math inline">\(\prod\)</span> 转变为 <span class="math inline">\(\Sigma\)</span> ）。</p>
<p>第三种方法是使用贝叶斯方法，该方法使用先验概率，即在模型拟合中给予每个备选参数向量的初始相对权重。贝叶斯方法结合并更新任何关于最可能的模型参数的先验知识（先验概率），以及在不同的候选参数向量 <span class="math inline">\(\theta\)</span> 下任何新数据的似然。就我们的目的而言，贝叶斯方法和最大似然法之间的两个关键区别是包含先验似然和重新缩放数值，以便使后验概率的总和达到1.0。重要的一点是，将给定一组参数的数据似然转换为给定数据参数的真实概率。给定数据 <span class="math inline">\(x\)</span> 的特定参数集 <span class="math inline">\(\theta\)</span> 的后验概率定义为：</p>
<p><span id="eq-4_3"><span class="math display">\[
P(\theta|x)=\frac{L(x|\theta)P(\theta)}{\sum\limits_{i=1}^{n}{\left[ L(x_i|\theta)P(\theta)\right]}}
\qquad(4.3)\]</span></span></p>
<p>其中 <span class="math inline">\(P(\theta)\)</span> 为参数集 <span class="math inline">\(\theta\)</span> 的先验概率，通过给定参数 <span class="math inline">\(\theta\)</span> 的数据 <span class="math inline">\(x\)</span> 似然、<span class="math inline">\(L(x|\theta)p(\theta)\)</span> 进行更新，除数 <span class="math inline">\(\sum_{i=1}^n[L(x_i|\theta)P(\theta)]\)</span> 对结果重新缩放或归一化，因此在给定数据的情况下，所有参数向量 <span class="math inline">\(\sum P(\theta|x)\)</span> 的后验概率之和为 1.0。最终 <a href="#eq-4_3" class="quarto-xref">公式&nbsp;<span>4.3</span></a> 是一个近似值，因为除数中的总和实际上应该是一个连续分布的积分，但在实践中，近似值就足够了，而且是处理复杂渔业模型参数时的唯一实际选择，其后验分布没有简单的分析解。</p>
<p>这里我们将主要关注负对数似然的最小化（相当于最大似然）。尽管其他方法也会得到一些关注。当我们探讨不确定性的特征时，贝叶斯方法将得到更多的关注。</p>
<p>微软的Excel在很多方面都是很好的软件，但是实现最大似然法，特别是贝叶斯法往往是缓慢和笨拙的，它们更适合于在R中实现。</p>
<p>识别平方残差之和、最大似然法和贝叶斯法并不是一个详尽的清单，它是在对数据进行模型拟合时可能使用的标准。例如，可以使用 “绝对残差之和”（sum of absolute residuals, SAR），它通过使用残差的绝对值而不是将其平方化来避免合并正负残差的问题 <span class="citation" data-cites="birkes1993">(<a href="08-references.html#ref-birkes1993" role="doc-biblioref">Birkes 和 Dodge 1993</a>)</span>。尽管存在这种最佳模型拟合的替代标准，我们将只关注上述三种。其他更常用的替代方法包括所谓的稳健方法，这些方法致力于减少现有数据中的离群值，或极端的、被认为是不典型的值的影响。如前所述，优化是一个庞大而详细的研究领域，我向你推荐它的研究，并祝你好运。</p>
</section><section id="r语言中的模型拟合" class="level2" data-number="4.3"><h2 data-number="4.3" class="anchored" data-anchor-id="r语言中的模型拟合">
<span class="header-section-number">4.3</span> R语言中的模型拟合</h2>
<p>虽然覆盖参数空间的网格搜索可能是寻找最佳参数集的一种可能的方法，但随着参数数量增加到两个以上，它将变得越来越难操作，直到最后变得不可行。我们将不再考虑这种可能性。相反，为了便于寻找最佳参数集，我们需要一个用软件实现的非线性优化器。</p>
<p>R系统有一系列不同的优化函数，每个函数都使用不同的算法（请参见CRAN任务中关于优化的内容）。解算函数（<code><a href="https://rdrr.io/r/stats/nlm.html">nlm()</a></code>）和其他函数一样，需要给出一个参数值的初始猜测，然后这些初始参数值由优化函数改变，在每次改变时，预测值会像<code><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq()</a></code> 或<code><a href="https://rdrr.io/pkg/MQMF/man/negLL.html">negLL()</a></code> 一样重新计算。优化函数，如<code><a href="https://rdrr.io/r/stats/nlm.html">nlm()</a></code>，继续改变参数值（它们如何做到这一点是算法不同的地方），直到找到一个组合，根据所选择的任何标准被定义为 “最适合”（或无法找到进一步的改进）。渔业种群评估模型通常有许多参数，数量在10或100个左右（一些有更多的参数，需要更多的专业软件，例如 <span class="citation" data-cites="fournier1998">Daid A. Fournier, Hampton, 和 Sibert (<a href="08-references.html#ref-fournier1998" role="doc-biblioref">1998</a>)</span>; <span class="citation" data-cites="fournier2012">David A. Fournier 等 (<a href="08-references.html#ref-fournier2012" role="doc-biblioref">2012</a>)</span>; <span class="citation" data-cites="kristensen2016">Kristensen 等 (<a href="08-references.html#ref-kristensen2016" role="doc-biblioref">2016</a>)</span> ）。在本书中，我们不会估计大量的参数，但无论数量多少，其原理都是相似的。</p>
<section id="模型需求" class="level3" data-number="4.3.1"><h3 data-number="4.3.1" class="anchored" data-anchor-id="模型需求">
<span class="header-section-number">4.3.1</span> 模型需求</h3>
<p>讨论模型拟合的理论是有帮助的，但并没有阐明如何在 R 中实现在实践中拟合模型。优化软件用于改变参数向量内的值，但我们需要为其提供重复计算预测值的方法，该预测值将用于与观测值进行多次比较以找到最佳解决方案（如果成功的）。我们需要开发可以重复调用的代码块，这正是设计 R 语言函数的目的。为了在 R语言 中实现对现实世界问题的模型拟合，我们需要考虑四个形式要求：</p>
<ul>
<li><p>来自所研究系统的观测（数据）。这可能是渔业中一个具有观测到的渔获量、cpue、渔获量的年龄和长度组成等，或者它可能是更简单的东西，例如鱼样本的观测到的长度和相关的年龄（但是如何将其放入 R ?),</p></li>
<li><p>第一个 R语言函数，表示系统的候选模型，当提供参数向量时，该函数用于计算预测值，以便与任何可用的观测值进行比较，</p></li>
<li><p>第二个 R语言 函数，计算选定的最佳拟合标准、最小化最小二乘或最小化负对数似然，以便将观测值与预测值进行比较。这需要能够返回单个值，反映输入参数和数据，然后可以通过最终所需的函数最小化，即</p></li>
<li><p>第三个R 语言函数（我们将倾向于使用 <code><a href="https://rdrr.io/r/stats/nlm.html">nlm()</a></code>）来自动优化所选最佳拟合标准的值。</p></li>
</ul>
<p>因此，需要输入数据和三个函数（ <a href="#fig-4-1" class="quarto-xref">图&nbsp;<span>4.1</span></a> ）但是，因为我们可以使用内置函数来进行优化，模型拟合通常需要编写最多两个函数，一个用于从使用的任何模型计算预测值另一个用于计算拟合标准（有时，在更简单的练习中，这两个可以组合成一个函数）。</p>
<p>我们在本书中假设读者至少熟悉模型拟合背后的概念，如拟合线性回归，因此我们将直接转向非线性模型拟合。这些相对简单的示例的主要目的是介绍 R 中可用求解器的使用和语法。</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div id="fig-4-1" class="quarto-figure quarto-figure-center quarto-float anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-4-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="f401-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:50.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-4-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;4.1: 将模型拟合到数据时的输入、功能需求和输出。优化函数（此处为 <code><a href="https://rdrr.io/r/stats/nlm.html">nlm()</a></code> ）最小化负对数似然（或平方和）并需要一个初始参数向量开始。此外，优化器需要一个函数（可能是 <code><a href="https://rdrr.io/pkg/MQMF/man/negLL.html">negLL()</a></code> ）来计算它在搜索最小值时产生的每个参数向量的对应负对数似然。 要计算负对数似然需要一个函数（可能是 <code><a href="https://rdrr.io/pkg/MQMF/man/vB.html">vB()</a></code> ）来生成预测值，以便与输入的观测值进行比较。
</figcaption></figure>
</div>
</div>
</div>
</section><section id="年龄-体长示例" class="level3" data-number="4.3.2"><h3 data-number="4.3.2" class="anchored" data-anchor-id="年龄-体长示例">
<span class="header-section-number">4.3.2</span> 年龄-体长示例</h3>
<p>将模型拟合到数据仅仅意味着估计模型的参数，以便其预测与观测结果相匹配，以及根据选择的最佳拟合标准。作为在 R 中将模型拟合到数据的第一个说明，我们将使用一个简单的示例用著名的 von Bertalanffy 生长曲线 (von Bertalanffy, 1938) 拟合一组年龄-长度数据。这样的数据集包含在 R 包 <strong>MQMF</strong>（尝试 <code><a href="https://rdrr.io/pkg/MQMF/man/LatA.html">?LatA</a></code>）中。要使用您自己的数据，一种选择是生成一个逗号分隔的变量 (csv) 文件，其中包含最少的年龄和长度列，每个列都有一个列名（LatA 仅有年龄和长度列；请参阅其帮助页面）。可以使用 <code>laa &lt;- read.csv(file="filename.csv", header=TRUE)</code> 将此 csv 文件读入 R中。</p>
<p>von Bertalanffy 长度-年龄生长曲线表示为：</p>
<p><span id="eq-4_4"><span class="math display">\[
\begin{aligned}    
&amp; {{\hat{L}}_t}={L_{\infty}}\left( 1-{e^{\left( -K\left( t-{t_0} \right) \right)}} \right) \\    
&amp; {L_t}={L_{\infty}}\left( 1-{e^{\left( -K\left( t-{t_0} \right) \right)}} \right)+\varepsilon  \\    
&amp; {L_t}= {\hat{L}}_t + \varepsilon    
\end{aligned}
\qquad(4.4)\]</span></span></p>
<p>其中 <span class="math inline">\(\hat L_t\)</span> 为年龄 <span class="math inline">\(t\)</span> 的期望或预测长度，<span class="math inline">\(L_{\infty}\)</span> 为渐近平均最大长度，<span class="math inline">\(K\)</span> 为是决定达到最大值的增长率系数，<span class="math inline">\(t_0\)</span> 为物种长度0时的假设年龄（von Bertalanffy, 1938），一旦我们有了<span class="math inline">\(L_{\infty}\)</span>，<span class="math inline">\(K\)</span> ，<span class="math inline">\(t_0\)</span> 的估算值（或假设值），该非线性方程就提供了一种预测不同年龄的年龄-长度的方法。在拟合数据模型时，使用 <a href="#eq-4_4" class="quarto-xref">公式&nbsp;<span>4.4</span></a> 中的下面两个方程，其中<span class="math inline">\(L_t\)</span> 为观测值，等于预测值加上正态随机离差<span class="math inline">\(\varepsilon = N(0, \sigma^2)\)</span> ，其中的每个值可能是正的或负的（某一年龄的观测值可能大于或小于期望长度）。最下面的方程实际上是关于决定使用什么剩余误差结构。在本章中，我们将描述生态学和渔业中使用的一系列可供选择的误差结构。它们并非都是可加的，有些是用函数关系而不是常数定义的（如<span class="math inline">\(\sigma\)</span>）。</p>
<p>关于 <a href="#eq-4_4" class="quarto-xref">公式&nbsp;<span>4.4</span></a> 是非线性的表述是明确的，因为早期估计 von Bertalanffy （ <code><a href="https://rdrr.io/pkg/MQMF/man/vB.html">vB()</a></code> ）生长曲线参数值的方法涉及各种旨在近似线性化曲线的变换（例如 Beverton和Holt, 1957）。在20世纪50年代末和60年代，拟合 von Bertalanffy 曲线不是一件小事。令人高兴的是，不再需要这样的转换，这样的曲线拟合也变得很简单。</p>
</section><section id="其它的生长模型" class="level3" data-number="4.3.3"><h3 data-number="4.3.3" class="anchored" data-anchor-id="其它的生长模型">
<span class="header-section-number">4.3.3</span> 其它的生长模型</h3>
<p>个体生长的研究文献很多，描述生物体生长的模型多种多样（Schnute and Richards, 1990）。自Beverton和Holt (1957)引入以来，von Bertalanffy （<code><a href="https://rdrr.io/pkg/MQMF/man/vB.html">vB()</a></code> ）曲线一直是主要的渔业模型，已被渔业科学家广泛应用。然而，只是因为该模型非常普遍命令使用，对于所有物种来说，并不一定意味着该模型总是提供生长的最佳描述。模型选择是渔业建模中一个至关重要但经常被忽视的方面 <span class="citation" data-cites="modelse2004 helidoniotis2013">(<a href="08-references.html#ref-modelse2004" role="doc-biblioref">Burnham 和 Anderson 2004</a>; <a href="08-references.html#ref-helidoniotis2013" role="doc-biblioref">Helidoniotis 和 Haddon 2013</a>)</span>。这里两种替代 <code><a href="https://rdrr.io/pkg/MQMF/man/vB.html">vB()</a></code>的两种模型可能是 Gompertz 生长曲线 （Gompertz, 1925）:</p>
<p><span id="eq-4_5"><span class="math display">\[
\hat{L_t} =ae^{-be^{ct}} \text{ or } \hat{L_t}=a \exp(-b \exp(ct))
\qquad(4.5)\]</span></span></p>
<p>以及广义Michaelis-Menten 方程（Maynard Smith and Slatkin, 1973; Legendre and Legendre, 1998):</p>
<p><span id="eq-4_6"><span class="math display">\[
{{\hat{L}}_{t}}=\frac{at}{b+{{t}^{c}}}  
\qquad(4.6)\]</span></span></p>
<p>每个模型也有 a、b 和 c 三个参数，每个模型都能对生长过程的经验数据作出令人信服的描述。可以对某些参数进行生物学解释（如最大平均长度），但这些模型最终只提供了对生长过程的经验描述。如果把模型解释为反映了现实，就会导致完全不可信的预测，如不存在一米长的鱼（Knight，1968 ）。在文献中，参数可以有不同的符号（例如，Maynard Smith 和 Slatkin（1973）用 <span class="math inline">\(R_0\)</span> 代替 <span class="math inline">\(a\)</span> 表示 Michaelis-Menton），但基本结构形式是相同的。在对 <strong>MQM</strong>F 的年龄-长度数据集 <span class="math inline">\(LatA\)</span> 中的鱼类进行 von Bertalanffy 生长曲线拟合后，我们可以利用不同模型来说明尝试这些替代模型的价值，并对应该使用哪种模型保持开放的心态。这个问题在我们讨论不确定性时会再次出现，因为我们可以从不同的模型中得到不同的结果。在对任何自然过程建模时，模型选择都是需要做出的重大决定之一。重要的是，通过这种方式尝试不同的模型，还能强化模型与数据拟合的过程。</p>
</section></section><section id="残差平方和" class="level2" data-number="4.4"><h2 data-number="4.4" class="anchored" data-anchor-id="残差平方和">
<span class="header-section-number">4.4</span> 残差平方和</h2>
<p>数据拟合模型的经典方法称为 “最小残差平方和”（见 <a href="#eq-4_1" class="quarto-xref">公式&nbsp;<span>4.1</span></a> 和 <a href="#eq-4_7" class="quarto-xref">公式&nbsp;<span>4.7</span></a> ），或更常称为 “最小二乘法”。这种方法被认为是高斯提出的（Nievergelt, 2000, 引用了高斯 1823 年用拉丁文撰写的一本书的译文：<em>Theoria combinationis observationum erroribus minimis obnoxiae</em>）。无论如何，最小二乘法符合两个多世纪以来用于确定一组预测值与观测值最佳拟合的策略。这种策略就是确定一个所谓的目标函数（最佳拟合标准），根据函数结构，可以将其最小化或最大化。就残差平方和而言，我们需要从相关的观测值中减去每个预测值，将不同的结果平方（以避免出现负值），然后将所有值相加，并使用数学（解析解）或其他方法将该相加值最小化：</p>
<p><span id="eq-4_7"><span class="math display">\[
ssq=\sum\limits_{i=1}^{n}{{{\left( {{O}_{i}}-{\hat{E}_{i}} \right)}^{2}}}  
\qquad(4.7)\]</span></span></p>
<p>其中，<span class="math inline">\(sqq\)</span> 为 <em>n</em> 个观测值的残差平方和，<span class="math inline">\(O_i\)</span> 为第<span class="math inline">\(i\)</span> 个观测值，<span class="math inline">\(E_i\)</span>为第第<span class="math inline">\(i\)</span> 个观测值的期望值或预测值。<strong>MQMF</strong> 包中的<code>ssq</code> 函数仅仅是一个封装器，它调用了用于生成预测值的任何函数，然后计算并返回平方差和。根据不同问题的复杂程度和数据输入，我们通常需要创建新的函数作为封装。<code><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq()</a></code> 很好地说明了这样一个事实，即在一个传递给函数的参数中，也可以传递其他函数（在本例中，在 <code><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq()</a></code>内我们调用了传递给 <code>funk</code> 的函数，当然在使用<code><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq()</a></code>时，我们输入的是与当前问题相关的实际函数，也许是<code>vB</code>，注意在用作函数参数时没有括号）。</p>
<section id="最小二乘法的假设" class="level3" data-number="4.4.1"><h3 data-number="4.4.1" class="anchored" data-anchor-id="最小二乘法的假设">
<span class="header-section-number">4.4.1</span> 最小二乘法的假设</h3>
<p>最小二乘方法的一个主要假设是，残差项呈正态分布，所有观测变量值具有相等的方差；即在<span class="math inline">\(\varepsilon = N(0, \sigma^2)\)</span> 中，<span class="math inline">\(\sigma^2\)</span> 是常数。如果以任何方式对数据进行变换，则变换对残差的影响可能违反这一假设。相反，如果残差以系统的方式变化，则转换可以标准化残差方差。因此，如果数据是对数正态分布，那么对数变换将使数据标准化，然后可以有效地使用最小二乘。与往常一样，考虑或可视化数据和残差的形式(由拟合模型产生)是一种很好的做法。</p>
</section><section id="数值求解" class="level3" data-number="4.4.2"><h3 data-number="4.4.2" class="anchored" data-anchor-id="数值求解">
<span class="header-section-number">4.4.2</span> 数值求解</h3>
<p>渔业科学中大多数有趣的问题都没有解析解（如线性回归），有必要使用数值方法通过定义的”最佳拟合”标准（如最小残差平方和(最小二乘)）来寻找最佳拟合模型。这显然会涉及到一点R编程，但是R的一个很大的优势是，一旦你开发了一套分析方法，就可以直接地将其应用到新的数据集。</p>
<p>在下面的示例中，我们用 <strong>MQMF</strong> 中的一些实用函数来辅助描述。我们需要 5 个函数拟合和比较上文定义的3种不同的生长模型，其中4个需要编写。前3个函数用于估计与观测数据进行比较的各年龄长度预测值。本例有3个候选模型函数分别对应3种不同的生长曲线：<code><a href="https://rdrr.io/pkg/MQMF/man/vB.html">vB()</a></code>、 <code><a href="https://rdrr.io/pkg/MQMF/man/Gz.html">Gz()</a></code>和 <code><a href="https://rdrr.io/pkg/MQMF/man/mm.html">mm()</a></code>。第4个函数用作计算预测值及其相关观测值的平方和残差。这里将使用 <strong>MQMF</strong> 中的函数 <code><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq()</a></code>（你应该检查并理解其代码）。该函数返回单一数值，该值将由最后一个函数 <code><a href="https://rdrr.io/r/stats/nlm.html">nlm()</a></code>最小化，该函数需要自动最小化求解。R 函数 <code><a href="https://rdrr.io/r/stats/nlm.html">nlm()</a></code>使用用户定义的广义函数，用 <span class="math inline">\(f\)</span> 表示 (尝试 <code>args(nlm)</code>，或<code>formals(nlm)</code>以查看完整的参数列表），用于计算最小值（在本例中为 <code><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq()</a></code>），而<code><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq()</a></code>又使用预测生长曲线中各年龄长度的函数（例如<code><a href="https://rdrr.io/pkg/MQMF/man/vB.html">vB()</a></code>）。如果我们使用不同的生长曲线函数（例如<code><a href="https://rdrr.io/pkg/MQMF/man/Gz.html">Gz()</a></code>），只需将<code><a href="https://rdrr.io/r/stats/nlm.html">nlm()</a></code>调用代码中指向<code><a href="https://rdrr.io/pkg/MQMF/man/vB.html">vB()</a></code> 的地方改为 <code><a href="https://rdrr.io/pkg/MQMF/man/Gz.html">Gz()</a></code> ，并修改参数值以适应 <code><a href="https://rdrr.io/pkg/MQMF/man/Gz.html">Gz()</a></code>函数，以便代码产生可用的结果。从根本上说，<code><a href="https://rdrr.io/r/stats/nlm.html">nlm()</a></code>通过改变输入参数(称作 <em>p</em> )来最小化<code><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq()</a></code>，无论选择哪个参数，都会改变生长函数<code><a href="https://rdrr.io/pkg/MQMF/man/vB.html">vB()</a></code>、<code><a href="https://rdrr.io/pkg/MQMF/man/Gz.html">Gz()</a></code>或<code><a href="https://rdrr.io/pkg/MQMF/man/mm.html">mm()</a></code>的结果，。</p>
<p><code><a href="https://rdrr.io/r/stats/nlm.html">nlm()</a></code>只是 <strong>R</strong> 中用于非线性优化的函数之一，候选函数包括 <code><a href="https://rdrr.io/r/stats/optim.html">optim()</a></code>和 <code><a href="https://rdrr.io/r/stats/nlminb.html">nlminb()</a></code>（请阅读 <code>nlm</code>中的文档，CRAN 上关于优化的任务视图列出了旨在解决优化问题的包）。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb1"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/haddonm/MQMF/">MQMF</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://ggplot2.tidyverse.org">ggplot2</a></span><span class="op">)</span></span>
<span> <span class="co">#setup optimization using growth and ssq  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="va">LatA</span><span class="op">)</span>      <span class="co"># try ?LatA   assumes library(MQMF) already run  </span></span>
<span> <span class="co">#convert equations 4.4 to 4.6 into vectorized R functions  </span></span>
<span> <span class="co">#These will over-write the same functions in the MQMF package  </span></span>
<span></span>
<span><span class="va">vB</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">p</span>, <span class="va">ages</span><span class="op">)</span> <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="va">p</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">*</span><span class="op">(</span><span class="fl">1</span><span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="op">-</span><span class="va">p</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span><span class="op">*</span><span class="op">(</span><span class="va">ages</span><span class="op">-</span><span class="va">p</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="va">Gz</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">p</span>, <span class="va">ages</span><span class="op">)</span> <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="va">p</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="op">-</span><span class="va">p</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">p</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span><span class="op">*</span><span class="va">ages</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="va">mm</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">p</span>, <span class="va">ages</span><span class="op">)</span> <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="op">(</span><span class="va">p</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">*</span><span class="va">ages</span><span class="op">)</span><span class="op">/</span><span class="op">(</span><span class="va">p</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span> <span class="op">+</span> <span class="va">ages</span><span class="op">^</span><span class="va">p</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span><span class="op">)</span><span class="op">)</span>  </span>
<span></span>
<span> <span class="co">#specific function to calc ssq. The ssq within MQMF is more  </span></span>
<span><span class="va">ssq</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">p</span>,<span class="va">funk</span>,<span class="va">agedata</span>,<span class="va">observed</span><span class="op">)</span> <span class="op">{</span>        <span class="co">#general and is  </span></span>
<span>  <span class="va">predval</span> <span class="op">&lt;-</span> <span class="fu">funk</span><span class="op">(</span><span class="va">p</span>,<span class="va">agedata</span><span class="op">)</span>        <span class="co">#not limited to p and agedata  </span></span>
<span>  <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="op">(</span><span class="va">observed</span> <span class="op">-</span> <span class="va">predval</span><span class="op">)</span><span class="op">^</span><span class="fl">2</span>,na.rm<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="op">}</span> <span class="co">#end of ssq   </span></span>
<span> <span class="co"># guess starting values for Linf, K, and t0, names not needed  </span></span>
<span><span class="va">pars</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Linf"</span><span class="op">=</span><span class="fl">27.0</span>,<span class="st">"K"</span><span class="op">=</span><span class="fl">0.15</span>,<span class="st">"t0"</span><span class="op">=</span><span class="op">-</span><span class="fl">2.0</span><span class="op">)</span> <span class="co">#ssq should=1478.449  </span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq</a></span><span class="op">(</span>p<span class="op">=</span><span class="va">pars</span>, funk<span class="op">=</span><span class="va">vB</span>, agedata<span class="op">=</span><span class="va">LatA</span><span class="op">$</span><span class="va">age</span>, observed<span class="op">=</span><span class="va">LatA</span><span class="op">$</span><span class="va">length</span><span class="op">)</span>   </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>[1] 1478.449</code></pre>
</div>
</div>
<p><code><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq()</a></code>函数取代了全局环境中的 <code><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">MQMF::ssq()</a></code>函数，但也返回一个数值，例如上面的 1478.449，它是 <code><a href="https://rdrr.io/r/stats/nlm.html">nlm()</a></code>函数的第一个输入，也是需要最小化的值。</p>
</section><section id="将函数作为参数传递给其它函数" class="level3" data-number="4.4.3"><h3 data-number="4.4.3" class="anchored" data-anchor-id="将函数作为参数传递给其它函数">
<span class="header-section-number">4.4.3</span> 将函数作为参数传递给其它函数</h3>
<p>在上例中，我们定义了一些用于模型拟合数据所需的函数，确定了要比较的生长模型，也定义了计算平方和的函数。刚刚做的一个非常重要的方面是，为了计算平方和，我们将 <code><a href="https://rdrr.io/pkg/MQMF/man/vB.html">vB()</a></code>函数作为参数传递给 <code><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq()</a></code>函数。这意味着我们传递了一个函数，它有参数，作为另一个函数的参数之一。你可以在这里看到潜在的混乱，所以有必要集中精力，保持清晰。目前，我们定义 <code><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq()</a></code>的方式似乎并没有那么引人注目，因为我们已经在对<code><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq()</a></code>的调用中显式地定义了两个函数的参数。但是 R 有一些妙招，我们可以用它来泛化包含其他函数作为参数的函数，主要的一个使用了神奇的省略号<code>…</code>，对于任何R函数，除非实参在其定义中设置了默认值，否则每个实参都必须给定一个值。在上面的<code><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq()</a></code>函数中，我们包含了仅由 <code><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq()</a></code> 使用的参数（ <em>funk</em> 和 <em>observed</em> ），以及仅由函数 <code>funk</code>使用的参数（ <em>p</em> 和 <em>agedata</em>）。这在本例子中很有效，因为我们故意将生长函数定义为具有相同的输入参数，但如果我们想使用的 <code>funk</code> 有不同的输入，可能是因为我们拟合的是选择性曲线而不是生长曲线，该怎么办？显然，我们需要编写一个不同的 <code><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq()</a></code> 函数。为了允许在更多情况下重用更通用的函数，R 的作者（R Core Team, 2019）包含了这个概念 <code>…</code>，它将匹配其他方式不匹配的任何参数，因此可用于输入<code>funk</code> 函数的参数。因此，我们可以这样重新定义 <code><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq()</a></code>:</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb3"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co"># Illustrates use of names within function arguments  </span></span>
<span><span class="va">vB</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">p</span>,<span class="va">ages</span><span class="op">)</span> <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="va">p</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">*</span><span class="op">(</span><span class="fl">1</span><span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="op">-</span><span class="va">p</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span> <span class="op">*</span><span class="op">(</span><span class="va">ages</span><span class="op">-</span><span class="va">p</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="va">ssq</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">funk</span>,<span class="va">observed</span>,<span class="va">...</span><span class="op">)</span> <span class="op">{</span> <span class="co"># only define ssq arguments  </span></span>
<span>  <span class="va">predval</span> <span class="op">&lt;-</span> <span class="fu">funk</span><span class="op">(</span><span class="va">...</span><span class="op">)</span> <span class="co"># funks arguments are implicit  </span></span>
<span>  <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="op">(</span><span class="va">observed</span> <span class="op">-</span> <span class="va">predval</span><span class="op">)</span><span class="op">^</span><span class="fl">2</span>,na.rm<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="op">}</span> <span class="co"># end of ssq   </span></span>
<span><span class="va">pars</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Linf"</span><span class="op">=</span><span class="fl">27.0</span>,<span class="st">"K"</span><span class="op">=</span><span class="fl">0.15</span>,<span class="st">"t0"</span><span class="op">=</span><span class="op">-</span><span class="fl">2.0</span><span class="op">)</span> <span class="co"># ssq should = 1478.449  </span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq</a></span><span class="op">(</span>p<span class="op">=</span><span class="va">pars</span>, funk<span class="op">=</span><span class="va">vB</span>, ages<span class="op">=</span><span class="va">LatA</span><span class="op">$</span><span class="va">age</span>, observed<span class="op">=</span><span class="va">LatA</span><span class="op">$</span><span class="va">length</span><span class="op">)</span> <span class="co">#if no  </span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>[1] 1478.449</code></pre>
</div>
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb5"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq</a></span><span class="op">(</span><span class="va">vB</span>,<span class="va">LatA</span><span class="op">$</span><span class="va">length</span>,<span class="va">pars</span>,<span class="va">LatA</span><span class="op">$</span><span class="va">age</span><span class="op">)</span> <span class="co"># name order is now vital!  </span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>[1] 1478.449</code></pre>
</div>
</div>
<p>这意味着 <code><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq()</a></code> 函数现在更加通用，可以与任何输入函数一起使用，这些输入函数可用于生成一组预测值，以便与一组观测值进行比较。<strong>MQMF</strong> 中的 <code><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq()</a></code> 函数就是这样实现的；查阅帮助 <code><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">?ssq</a></code>。一般的想法是，您必须定义主函数中使用的所有参数，但任何仅在被调用函数（此处称为 <em>funk</em> ）中使用的参数都可以在 <code>…</code>中传递。最好是显式地命名参数，这样它们的顺序就无关紧要了，并且您需要非常小心地键入，如果您拼错了通过<code>…</code>传递的参数的名称，并不一定会出错！例如，使用大写的 <em>LatA$Age</em> 而不是 <em>LatA$age</em> 不会出错，但会导致结果为 0 而不是 1478.440。这是因为 <em>LatA$Age = NULL</em>，即使输入不正确也是有效的。很明显，<code>…</code> 可能非常有用，但如果你像我一样输入错误，其本身也是有风险的。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb7"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co"># Illustrate a problem with calling a function in a function  </span></span>
<span> <span class="co"># LatA$age is typed as LatA$Age but no error, and result = 0  </span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq</a></span><span class="op">(</span>funk<span class="op">=</span><span class="va">vB</span>, observed<span class="op">=</span><span class="va">LatA</span><span class="op">$</span><span class="va">length</span>, p<span class="op">=</span><span class="va">pars</span>, ages<span class="op">=</span><span class="va">LatA</span><span class="op">$</span><span class="va">Age</span><span class="op">)</span> <span class="co"># !!!  </span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>[1] 0</code></pre>
</div>
</div>
<p>如果你匆忙行事，没有给参数命名，那么如果你弄错了参数顺序，也会失败。例如，如果你要输入的是<code>ssq(LatA$length, vB, pars, LatA$age)</code>而不是<code>ssq(vB, LatA$length, pars, LatA$age)</code>，就会出现错误：<em>Error in funk(…): could not find function ” funk “</em>。为了以防万一，你可以自己试试。对你的代码进行试验几乎没什么坏处，不会弄坏你的电脑，而你可能会学到一些东西。</p>
</section><section id="模型拟合" class="level3" data-number="4.4.4"><h3 data-number="4.4.4" class="anchored" data-anchor-id="模型拟合">
<span class="header-section-number">4.4.4</span> 模型拟合</h3>
<p>如果我们绘制 <em>LatA</em> 数据集图（ <a href="#fig-4-2" class="quarto-xref">图&nbsp;<span>4.2</span></a> ），可以看到一些典型的年龄-长度数据。图中有 358 个点（试试 <code>dim(LatA)</code>），许多点彼此重叠，但是当我们使用 <code><a href="https://rdrr.io/r/graphics/plot.default.html">plot()</a></code>函数中 <code><a href="https://rdrr.io/r/grDevices/rgb.html">rgb()</a></code>选项来改变图中颜色的透明度时，较高年龄组鱼类的颜色相对稀疏性就会显现出来。另外，我们可以使用 <code><a href="https://rdrr.io/r/base/jitter.html">jitter()</a></code>为每个绘制点的位置添加噪声，以查看数据点的相对密度。每当你处理经验数据时，总是值得你花时间至少将其绘制成画并探索其属性。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb9"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#plot the LatA data set   Figure 4.2  </span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/parset.html">parset</a></span><span class="op">(</span><span class="op">)</span>        <span class="co"># parset and getmax are two MQMF functions   </span></span>
<span><span class="va">ymax</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/getmax.html">getmax</a></span><span class="op">(</span><span class="va">LatA</span><span class="op">$</span><span class="va">length</span><span class="op">)</span> <span class="co"># simplifies use of base graphics. For  </span></span>
<span> <span class="co"># full colour, with the rgb as set-up below, there must be &gt;= 5 obs  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">LatA</span><span class="op">$</span><span class="va">age</span>,<span class="va">LatA</span><span class="op">$</span><span class="va">length</span>,type<span class="op">=</span><span class="st">"p"</span>,pch<span class="op">=</span><span class="fl">16</span>,cex<span class="op">=</span><span class="fl">1.2</span>,xlab<span class="op">=</span><span class="st">"Age Years"</span>,   </span>
<span>     ylab<span class="op">=</span><span class="st">"Length cm"</span>,col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/grDevices/rgb.html">rgb</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">1</span><span class="op">/</span><span class="fl">5</span><span class="op">)</span>,ylim<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="va">ymax</span><span class="op">)</span>,yaxs<span class="op">=</span><span class="st">"i"</span>,  </span>
<span>     xlim<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">44</span><span class="op">)</span>,panel.first<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/graphics/grid.html">grid</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span>  </span>
<span></span>
<span><span class="co"># ggplot(data = LatA, aes(x = age, y = length)) +</span></span>
<span><span class="co">#   geom_point(size = 3, color = "red", alpha = 0.2) +</span></span>
<span><span class="co">#   labs(x = "Age Years", </span></span>
<span><span class="co">#        y = "Length cm") +</span></span>
<span><span class="co">#   theme_bw() </span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-4-2" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-4-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="04-application_files/figure-html/fig-4-2-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-4-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;4.2: 基于澳大利亚东部样本模拟的 358 条红鱼（<em>Centroberyx affinis</em>）的雌性年龄长度数据。全强度颜色表示 &gt;= 5 个点。
</figcaption></figure>
</div>
</div>
</div>
<p>与其继续推测参数值并手动修改它们，我们可以使用 <code><a href="https://rdrr.io/r/stats/nlm.html">nlm()</a></code> 或 <code><a href="https://rdrr.io/r/stats/optim.html">optim()</a></code>或 <code><a href="https://rdrr.io/r/stats/nlminb.html">nlminb()</a></code>，它们的语法不同)来拟合所选的 <em>LatA</em> 数据的生长模型或曲线。这不仅说明了<code><a href="https://rdrr.io/r/stats/nlm.html">nlm()</a></code>的语法，还说明了另外两个 <strong>MQMF</strong> 实用R函数 <code><a href="https://rdrr.io/pkg/MQMF/man/magnitude.html">magnitude()</a></code>和 <code><a href="https://rdrr.io/pkg/MQMF/man/outfit.html">outfit()</a></code>的使用(请查阅<code><a href="https://rdrr.io/r/stats/nlm.html">?nlm</a></code>、<code><a href="https://rdrr.io/pkg/MQMF/man/magnitude.html">?magnitude</a></code>和 <code><a href="https://rdrr.io/pkg/MQMF/man/outfit.html">?outfit</a></code>)。还可以查看每个函数中的代码（在控制台中输入每个函数的名称，不带参数或括号）。从现在起，我将减少提示你查看所使用函数细节的次数，但是如果看到一个新的函数，希望现查看其帮助、语法，尤其是代码是有意义的，就像查看每个所用变量的内容一样。</p>
<p>3 个生长模型中的每一个都需要估计 3 个参数，我们需要对每个参数进行初始猜测，以启动 <code><a href="https://rdrr.io/r/stats/nlm.html">nlm()</a></code>求解。我们所做的就是为 <code><a href="https://rdrr.io/r/stats/nlm.html">nlm()</a></code>函数的每个形参/实参提供值。此外，我们还使用了 2 个额外的参数，<em>typsize</em> 和 <em>iterlim</em>。<em>typesize</em> 在 <code><a href="https://rdrr.io/r/stats/nlm.html">nlm()</a></code>帮助中定义为”每个参数最小值的估计”。加入这 2 个参数一般有助于稳定搜索算法，因为它可以确保对每个参数值迭代变化尺度大致相同。一种非常常见的替代方法（我们将在更复杂的模型中使用）是在输入 <code><a href="https://rdrr.io/r/stats/nlm.html">nlm()</a></code>时对每个参数进行对数变换，然后在调用的函数中对它们进行反变换，以计算预测值。但是，这只能在保证参数始终为正值情况下才可行。例如，对于 von Bertalanffy 曲线，<span class="math inline">\(t_0\)</span> 参数通常是负值，因此应使用 <code><a href="https://rdrr.io/pkg/MQMF/man/magnitude.html">magnitude()</a></code>而不是对数变换方法。默认的 <code>iterlim=100</code>意味着最多迭代 100 次，这有时是不够的，所以如果迭代达到 100 次，您应该将该数值增加到 1000 。你很快就会发现，在每次模型拟合过程中，唯一改变的是<code><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq()</a></code>中的 <em>funk</em> 所指向的函数和初始参数值。这可以通过有意识地构建生长函数，使其使用完全相同的参数（通过<code>…</code>传递）。您也可以尝试在不设置 <em>typsize</em> 和 <em>interlim</em> 选项的情况下运行其中的一个或两个函数。还请注意，我们运行 Michaelis-Menton 曲线时使用了两个略有不同的初始点。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb10"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co"># use nlm to fit 3 growth curves to LatA, only p and funk change </span></span>
<span><span class="va">ages</span> <span class="op">&lt;-</span> <span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">max</a></span><span class="op">(</span><span class="va">LatA</span><span class="op">$</span><span class="va">age</span><span class="op">)</span> <span class="co"># used in comparisons   </span></span>
<span><span class="va">pars</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">27.0</span>,<span class="fl">0.15</span>,<span class="op">-</span><span class="fl">2.0</span><span class="op">)</span> <span class="co"># von Bertalanffy  </span></span>
<span><span class="va">bestvB</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/nlm.html">nlm</a></span><span class="op">(</span>f<span class="op">=</span><span class="va">ssq</span>,funk<span class="op">=</span><span class="va">vB</span>,observed<span class="op">=</span><span class="va">LatA</span><span class="op">$</span><span class="va">length</span>,p<span class="op">=</span><span class="va">pars</span>,  </span>
<span>             ages<span class="op">=</span><span class="va">LatA</span><span class="op">$</span><span class="va">age</span>,typsize<span class="op">=</span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/magnitude.html">magnitude</a></span><span class="op">(</span><span class="va">pars</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/outfit.html">outfit</a></span><span class="op">(</span><span class="va">bestvB</span>,backtran<span class="op">=</span><span class="cn">FALSE</span>,title<span class="op">=</span><span class="st">"vB"</span><span class="op">)</span>; <span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"\n"</span><span class="op">)</span>   </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>nlm solution:  vB 
minimum     :  1361.421 
iterations  :  24 
code        :  2 &gt;1 iterates in tolerance, probably solution 
         par      gradient
1 26.8353971 -1.134306e-04
2  0.1301587 -6.198614e-03
3 -3.5866989  8.330772e-05</code></pre>
</div>
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb12"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">pars</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">26.0</span>,<span class="fl">0.7</span>,<span class="op">-</span><span class="fl">0.5</span><span class="op">)</span> <span class="co"># Gompertz  </span></span>
<span><span class="va">bestGz</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/nlm.html">nlm</a></span><span class="op">(</span>f<span class="op">=</span><span class="va">ssq</span>,funk<span class="op">=</span><span class="va">Gz</span>,observed<span class="op">=</span><span class="va">LatA</span><span class="op">$</span><span class="va">length</span>,p<span class="op">=</span><span class="va">pars</span>,  </span>
<span>             ages<span class="op">=</span><span class="va">LatA</span><span class="op">$</span><span class="va">age</span>,typsize<span class="op">=</span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/magnitude.html">magnitude</a></span><span class="op">(</span><span class="va">pars</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/outfit.html">outfit</a></span><span class="op">(</span><span class="va">bestGz</span>,backtran<span class="op">=</span><span class="cn">FALSE</span>,title<span class="op">=</span><span class="st">"Gz"</span><span class="op">)</span>; <span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"\n"</span><span class="op">)</span>   </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>nlm solution:  Gz 
minimum     :  1374.36 
iterations  :  28 
code        :  1 gradient close to 0, probably solution 
         par      gradient
1 26.4444554  2.725617e-05
2  0.8682518 -6.452607e-04
3 -0.1635476 -2.042292e-03</code></pre>
</div>
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb14"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">pars</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">26.2</span>,<span class="fl">1.0</span>,<span class="fl">1.0</span><span class="op">)</span> <span class="co"># Michaelis-Menton - first start point  </span></span>
<span><span class="va">bestMM1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/nlm.html">nlm</a></span><span class="op">(</span>f<span class="op">=</span><span class="va">ssq</span>,funk<span class="op">=</span><span class="va">mm</span>,observed<span class="op">=</span><span class="va">LatA</span><span class="op">$</span><span class="va">length</span>,p<span class="op">=</span><span class="va">pars</span>,  </span>
<span>             ages<span class="op">=</span><span class="va">LatA</span><span class="op">$</span><span class="va">age</span>,typsize<span class="op">=</span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/magnitude.html">magnitude</a></span><span class="op">(</span><span class="va">pars</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/outfit.html">outfit</a></span><span class="op">(</span><span class="va">bestMM1</span>,backtran<span class="op">=</span><span class="cn">FALSE</span>,title<span class="op">=</span><span class="st">"MM"</span><span class="op">)</span>; <span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"\n"</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>nlm solution:  MM 
minimum     :  1335.961 
iterations  :  12 
code        :  2 &gt;1 iterates in tolerance, probably solution 
         par    gradient
1 20.6633224 -0.02622725
2  1.4035207 -0.37744267
3  0.9018319 -0.05039237</code></pre>
</div>
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb16"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">pars</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">23.0</span>,<span class="fl">1.0</span>,<span class="fl">1.0</span><span class="op">)</span> <span class="co"># Michaelis-Menton - second start point  </span></span>
<span><span class="va">bestMM2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/nlm.html">nlm</a></span><span class="op">(</span>f<span class="op">=</span><span class="va">ssq</span>,funk<span class="op">=</span><span class="va">mm</span>,observed<span class="op">=</span><span class="va">LatA</span><span class="op">$</span><span class="va">length</span>,p<span class="op">=</span><span class="va">pars</span>,  </span>
<span>             ages<span class="op">=</span><span class="va">LatA</span><span class="op">$</span><span class="va">age</span>,typsize<span class="op">=</span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/magnitude.html">magnitude</a></span><span class="op">(</span><span class="va">pars</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/outfit.html">outfit</a></span><span class="op">(</span><span class="va">bestMM2</span>,backtran<span class="op">=</span><span class="cn">FALSE</span>,title<span class="op">=</span><span class="st">"MM2"</span><span class="op">)</span>; <span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"\n"</span><span class="op">)</span>   </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>nlm solution:  MM2 
minimum     :  1335.957 
iterations  :  25 
code        :  1 gradient close to 0, probably solution 
         par      gradient
1 20.7464274  8.464689e-06
2  1.4183164 -3.856394e-05
3  0.9029899 -1.297065e-04</code></pre>
</div>
</div>
<p>这些都是数值解，它们不能保证是正确的解。请注意，第一个 Michaelis-Menton 解（从 26.2,1,1 开始）的梯度相对较大，但它的 SSQ(1335.96) 非常接近第二个 Michaelis-Menton 模型拟合，而且比 <code>vB</code> 或 <code>Gz</code> 曲线更小（更好）。然而，梯度值表明该模型的拟合可以而且应该得到改进。如果您将参数 <em>a</em>（首个 MM 参数）的初始参数估计值从上次模型拟合中的 26.2 降到了 23，我们就会得到稍有不同的参数值、稍小的 SSQ 以及更小的梯度，从而更有把握地认为结果是个真正的最小值。实际上，如果要运行<code>cbind(mm(bestMM1$estimate,ages)， mm(bestMM2$estimate,ages))</code>，可以计算出预测值的差异从 -0.018 到 0.21%，而如果将 vB 预测值包括在内，MM2 与 vB 预测的差异从 -6.15 到 9.88% (忽略 40.6% 的最大偏差)。你也可以尝试从 vB 模型的估计中省略<em>typsize</em> 参数，这样仍然会得到最佳结果，但可查看梯度以了解为什么使用 <em>typsize</em> 有助于优化。在设置这些示例时，偶尔运行 <code><a href="https://rdrr.io/pkg/MQMF/man/Gz.html">Gz()</a></code>模型会出现 <em>steptol</em> 可能太小的注释，将其从默认的 1e-06 改为 1e-05 可以很快解决这个问题。如果您遇到了这种情况，请在<code><a href="https://rdrr.io/r/stats/nlm.html">nlm()</a></code>命令中添加一条语句 <code>steptol=1e-05</code>，看看诊断是否有所改善。</p>
<p>显而易见的结论是，我们应该经常查阅 <code><a href="https://rdrr.io/r/stats/nlm.html">nlm()</a></code>的诊断注释，考虑得到的解的方案的梯度，并且使用多组初始参数猜测，以确保得到稳定的解。数值求解以软件实现为基础，用于决定何时停止迭代的规则有时会被次优解所欺骗。我们的目标是找到全局最小值，而不是局部最小值。任何非线性模型都可能产生此类次优解，因此自动拟合此类模型并非易事。在这种情况下，永远不要假设在这种情况下你得到的第一个答案一定是你正在寻找的最佳答案，即使描绘的模型拟合看起来是可以接受的。</p>
<p>在函数调用中，如果你为每个参数命名，那么严格来讲，顺序并不重要，但我发现一致的用法可以简化代码的阅读，因此即使使用显式名称，也建议使用标准顺序。如果我们不使用显式名称，则 <code><a href="https://rdrr.io/r/stats/nlm.html">nlm()</a></code>的语法要求首先定义函数最小化（<em>f</em>）。此外，它还要求 <em>f</em> 函数，无论它是什么，在 <em>p</em> 参数中使用初始参数猜测，如果未命名，则必须排在第二位。如果你在控制台中输入 <code>formals(nlm)</code>或 <code>args(nlm)</code>，就可得到可以输入到函数的可能参数以及它们的默认值（如果存在）:</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb18"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#The use of args() and formals()   </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/args.html">args</a></span><span class="op">(</span><span class="va">nlm</span><span class="op">)</span> <span class="co"># formals(nlm) uses more screen space. Try yourself.  </span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>function (f, p, ..., hessian = FALSE, typsize = rep(1, length(p)), 
    fscale = 1, print.level = 0, ndigit = 12, gradtol = 1e-06, 
    stepmax = max(1000 * sqrt(sum((p/typsize)^2)), 1000), steptol = 1e-06, 
    iterlim = 100, check.analyticals = TRUE) 
NULL</code></pre>
</div>
</div>
<p>正如所见，首先要最小化函数 <em>f</em> （在本例中是 <code><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq()</a></code> ），然后是初始参数 <em>p</em>，它必须是<em>f</em>所指向的任何函数所需的第一个参数。接着是省略号(三个点)，它概括了任何函数<em>f</em>的 <code><a href="https://rdrr.io/r/stats/nlm.html">nlm()</a></code>代码，其后是可能的参数集，所有这些参数都具有默认值。我们修改了 <em>typsize</em> 和 <em>iterm</em> (有时也修改了<code><a href="https://rdrr.io/pkg/MQMF/man/Gz.html">Gz()</a></code> 中的 <em>steptol</em>）；请参阅 <code><a href="https://rdrr.io/r/stats/nlm.html">nlm()</a></code>帮助以获得对每种方法的解释。</p>
<p>在R中，”…“ 实际上指的是所需的任何其他输入，例如函数<em>f</em>指向的任何参数（本例中为<code>ssq</code>）。如果 Et <code><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">?ssq</a></code>查看参数或代码或帮助，将会看到所需函数 <em>funk</em>，该函数将用于计算相对于<code><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq()</a></code>的下一个所需输入的期望值，为观测值的向量（如<span class="math inline">\(O_i-E_i\)</span>）。请注意，这里没有明确提到 <em>funk</em> 使用的参数，这些参数假定是通过 …. 传递的。在对 <code><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq()</a></code>的每次调用中，我们都显式地填充了这些参数，例如<code>nlm(f=ssq,funk=Gz, observed=LatA$length, p=pars, ages=LatA$age，)</code>。这样，所有要求都已满足，<code><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq()</a></code>就可以开始工作。如果不小心忽略了<code>ages=LatA$age</code>参数，那么在这种情况下，R 会出现如下揭示：<em>Error in funk(par, independent) : argument “ages” is missing, with no default</em>（我相信你会相信我的，但你自己试试也无妨!)。</p>
<p>就生长曲线模型拟合而言，绘制结果提供了一个直观的比较，说明了三条生长曲线之间的差异（Murrell, 2011）。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb20"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#Female length-at-age + 3 growth fitted curves Figure 4.3  </span></span>
<span><span class="va">predvB</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/vB.html">vB</a></span><span class="op">(</span><span class="va">bestvB</span><span class="op">$</span><span class="va">estimate</span>,<span class="va">ages</span><span class="op">)</span> <span class="co">#get optimumpredicted lengths  </span></span>
<span><span class="va">predGz</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/Gz.html">Gz</a></span><span class="op">(</span><span class="va">bestGz</span><span class="op">$</span><span class="va">estimate</span>,<span class="va">ages</span><span class="op">)</span> <span class="co"># using the outputs  </span></span>
<span><span class="va">predmm</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/mm.html">mm</a></span><span class="op">(</span><span class="va">bestMM2</span><span class="op">$</span><span class="va">estimate</span>,<span class="va">ages</span><span class="op">)</span> <span class="co">#from the nlm analysis above  </span></span>
<span><span class="va">ymax</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/getmax.html">getmax</a></span><span class="op">(</span><span class="va">LatA</span><span class="op">$</span><span class="va">length</span><span class="op">)</span> <span class="co">#try ?getmax or getmax [no brackets]  </span></span>
<span><span class="va">xmax</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/getmax.html">getmax</a></span><span class="op">(</span><span class="va">LatA</span><span class="op">$</span><span class="va">age</span><span class="op">)</span>  <span class="co">#there is also a getmin, not used here  </span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/parset.html">parset</a></span><span class="op">(</span>font<span class="op">=</span><span class="fl">7</span><span class="op">)</span>   <span class="co"># or use parsyn() to prompt for the par syntax  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">LatA</span><span class="op">$</span><span class="va">age</span>,<span class="va">LatA</span><span class="op">$</span><span class="va">length</span>,type<span class="op">=</span><span class="st">"p"</span>,pch<span class="op">=</span><span class="fl">16</span>, col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/grDevices/rgb.html">rgb</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">1</span><span class="op">/</span><span class="fl">5</span><span class="op">)</span>,  </span>
<span>     cex<span class="op">=</span><span class="fl">1.2</span>,xlim<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="va">xmax</span><span class="op">)</span>,ylim<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="va">ymax</span><span class="op">)</span>,yaxs<span class="op">=</span><span class="st">"i"</span>,xlab<span class="op">=</span><span class="st">"Age"</span>,  </span>
<span>     ylab<span class="op">=</span><span class="st">"Length (cm)"</span>,panel.first<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/graphics/grid.html">grid</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">ages</span>,<span class="va">predvB</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">4</span><span class="op">)</span>        <span class="co"># vB    col=4=blue  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">ages</span>,<span class="va">predGz</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">1</span>,lty<span class="op">=</span><span class="fl">2</span><span class="op">)</span>  <span class="co"># Gompertz  1=black  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">ages</span>,<span class="va">predmm</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">3</span>,lty<span class="op">=</span><span class="fl">3</span><span class="op">)</span>  <span class="co"># MM        3=green  </span></span>
<span> <span class="co">#notice the legend function and its syntax.  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/legend.html">legend</a></span><span class="op">(</span><span class="st">"bottomright"</span>,cex<span class="op">=</span><span class="fl">1.2</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"von Bertalanffy"</span>,<span class="st">"Gompertz"</span>,  </span>
<span>       <span class="st">"Michaelis-Menton"</span><span class="op">)</span>,col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">4</span>,<span class="fl">1</span>,<span class="fl">3</span><span class="op">)</span>,lty<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">3</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">3</span>,bty<span class="op">=</span><span class="st">"n"</span><span class="op">)</span>  </span>
<span></span>
<span><span class="co"># ggplot() +</span></span>
<span><span class="co">#   geom_point(data = LatA, aes(x = age, y = length), </span></span>
<span><span class="co">#              color = "red", alpha = 0.2) +</span></span>
<span><span class="co">#   geom_line(aes(x = ages, y = predvB), color = "blue") +</span></span>
<span><span class="co">#   geom_line(aes(x = ages, y = predGz), color = "black") +</span></span>
<span><span class="co">#   geom_line(aes(x = ages, y = predmm), color = "green") +</span></span>
<span><span class="co">#   theme_bw()</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-4-3" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-4-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="04-application_files/figure-html/fig-4-3-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-4-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;4.3: 来自 358 个模拟的雌性红鱼年龄-长度数据，顶部绘制了三条最佳拟合生长曲线。Female Length-at-Age data from 358 simulated female redfish with three optimally fitted growth curves drawn on top.
</figcaption></figure>
</div>
</div>
</div>
<p>在图中使用的 <code><a href="https://rdrr.io/r/grDevices/rgb.html">rgb()</a></code> 函数意味着颜色强度代表观测数量，最强烈的颜色至少表示有五个观测值。很明显，在这份数据中， <code><a href="https://rdrr.io/pkg/MQMF/man/vB.html">vB()</a></code> 和 <code><a href="https://rdrr.io/pkg/MQMF/man/Gz.html">Gz()</a></code> 曲线在大部分观测范围内几乎重合，而 <code><a href="https://rdrr.io/pkg/MQMF/man/mm.html">mm()</a></code> 曲线与其他两条曲线偏离，但主要是在极端值处。Michaelis-Menton 曲线被强制通过原点，而另外两条曲线则不受这种限制（尽管这个想法可能更接近现实）。可以包括幼鱼长度来将高姆珀茨曲线和 von Bertalanffy 曲线向下拉。但生物生长过程很复杂。许多鲨鱼和鳐鱼是胎生，确实在发育后期开始生活时体型显著大于零。始终要记住，这些曲线只是数据的经验性描述，反映现实的能力有限。</p>
<p>大部分可用数据集中在 3 至 12 龄之间（尝试 <code>table(LatA$age)</code> ），然后只有 24 龄以上单次出现。在 3 至 24 龄之间，Gompertz 曲线和 von Bertalanffy 曲线基本上遵循相同轨迹，而 Michaelis-Menton 曲线差异很小（你可以尝试以下代码查看实际差异 <code>cbind(ages, predvB, predGz, predmm)</code> ）。超出这个年龄范围，差异更大，尽管缺乏年轻动物表明捕捞样本的渔具选择性可能无法充分代表 3 龄以下的鱼类。在拟合相对质量（残差平方和）方面，最终的 Michaelis-Menton 曲线最小&nbsp;<code><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq()</a></code>&nbsp;，其次是 von Bertalanffy 曲线，然后是 Gompertz 曲线。但每种模型都为 3 至 24 龄（数据最密集范围）之间的生长提供了合理的平均描述。当老年年龄组的数据如此稀疏时，也存在该样本是否代表这些年龄组种群的问题。质疑数据、所用模型及由此产生的解释，是构建自然过程有用模型的重要方面。</p>
</section><section id="目标模型选择" class="level3" data-number="4.4.5"><h3 data-number="4.4.5" class="anchored" data-anchor-id="目标模型选择">
<span class="header-section-number">4.4.5</span> 目标模型选择</h3>
<p>在上述三种生长模型中，最优模型拟合定义为使预测值与实测值之间的平方和残差最小。根据这一标准，第二个生长模型 Michaelis-Menton 曲线比 von Bertalanffy 曲线和 Gompertz 曲线更适合。但我们真的能说第二条 Michaelis-Menton 曲线比第一条曲线”更好”拟合吗?就最终溶液的梯度而言，第二条曲线显然更好，但严格的拟合标准只是最小 SSQ，差异小于 0.01 个单位。模型选择通常是使用参数的数量和根据所选标准的拟合质量之间的权衡。如果我们设计一个具有更多参数的模型，这通常会导致更大的灵活性和更接近观测数据的改进能力。在极端情况下，如果我们有和观测值一样多的参数，我们可以有一个完美的模型拟合，但是，当然，我们对我们正在建模的系统一无所知。LatA 数据集有 358 个参数，这显然是过度参数化的情况，但如果我们只将参数数量增加到10个呢？毫无疑问，曲线的形状会很奇怪，但 SSQ 可能会更低。Burnham 和 Anderson(2002) 详细讨论了参数数量和模型与数据的拟合质量之间的权衡关系。在 20 世纪 70 年代，人们开始使用信息论来开发一种量化模型参数和模型拟合质量之间权衡的方法。Akaike(1974) 描述了他的Akaike信息标准（AIC），该标准基于最大似然和信息理论原理（稍后会详细介绍），但幸运的是，Burnham 和 Anderson(2002) 在使用最小平方和残差时提供了另一种选择，这是Atkinson（1980）中包含的一种变体:</p>
<p><span id="eq-4_8"><span class="math display">\[
AIC=N \left(\log\left(\hat\sigma^2 \right) \right)+2p  
\qquad(4.8)\]</span></span></p>
<p>其中<span class="math inline">\(N\)</span> 为观测数，<span class="math inline">\(p\)</span> 为”模型内独立调整参数数量”（Akaike，1974，p716），<span class="math inline">\(\hat{\sigma}^2\)</span> 为方差的最大似然估计，仅表示残差平方和除以<span class="math inline">\(N\)</span> 而非 <span class="math inline">\(N-1\)</span> ：</p>
<p><span id="eq-4_9"><span class="math display">\[
\hat\sigma^2 = \frac{\Sigma\varepsilon^2}{N} = \frac{ssq}{N}
\qquad(4.9)\]</span></span></p>
<p>即使有了<em>AIC</em>，也很难确定，当使用最小二乘时，差异是否可以被认为是统计上显著的差异。有与方差分析相关的方法，但当使用最大似然时，这些问题能够得到更可靠的回答，所以我们将在后面的部分中解决这个问题。</p>
<p>如果想在拟合模型时获得生物学上合理的或可站得住脚的解释，那么模型选择不能仅仅依赖于统计拟合的质量。相反，它应该反映理论预期（例如，种群中的平均生长是否包括随着时间的推移个体大小的平稳增长，等等）。除了数据的统计拟合之外，这些考虑因素似乎没有得到足够的重视，但只有在出现生物学上不可信的模型结果或提出不可信的模型结构时才变得重要。它显然有助于理解正在建模的过程的生物学期望。</p>
</section><section id="残差选择对模型拟合的影响" class="level3" data-number="4.4.6"><h3 data-number="4.4.6" class="anchored" data-anchor-id="残差选择对模型拟合的影响">
<span class="header-section-number">4.4.6</span> 残差选择对模型拟合的影响</h3>
<p>在生长模型例子中，我们使用了正态随机偏差，但我们可以问，如果我们使用，例如对数正态偏差，我们是否会得到相同的答案？在这种情况下，我们所需要做的就是在计算残差平方和之前对观测值和预测值进行对数变换（参见下面关于对数正态残差的内容）。</p>
<p><span id="eq-4_10"><span class="math display">\[
ssq=\sum\limits_{i=1}^{n}{{{\left( \log({O_i})- \log({\hat{E_i}}) \right)}^{2}}}
\qquad(4.10)\]</span></span></p>
<p>这里我们继续在 <code><a href="https://rdrr.io/pkg/MQMF/man/outfit.html">outfit()</a></code>中使用 <em>backtran=FALSE</em> 选项，因为我们是对数据进行对数转换，而不是对参数进行对数转换，因此不需要进行反向转换。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb21"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co"># von Bertalanffy   </span></span>
<span><span class="va">pars</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">27.25</span>,<span class="fl">0.15</span>,<span class="op">-</span><span class="fl">3.0</span><span class="op">)</span>  </span>
<span><span class="va">bestvBN</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/nlm.html">nlm</a></span><span class="op">(</span>f<span class="op">=</span><span class="va">ssq</span>,funk<span class="op">=</span><span class="va">vB</span>,observed<span class="op">=</span><span class="va">LatA</span><span class="op">$</span><span class="va">length</span>,p<span class="op">=</span><span class="va">pars</span>,  </span>
<span>             ages<span class="op">=</span><span class="va">LatA</span><span class="op">$</span><span class="va">age</span>,typsize<span class="op">=</span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/magnitude.html">magnitude</a></span><span class="op">(</span><span class="va">pars</span><span class="op">)</span>,iterlim<span class="op">=</span><span class="fl">1000</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/outfit.html">outfit</a></span><span class="op">(</span><span class="va">bestvBN</span>,backtran<span class="op">=</span><span class="cn">FALSE</span>,title<span class="op">=</span><span class="st">"Normal errors"</span><span class="op">)</span>; <span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"\n"</span><span class="op">)</span>   </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>nlm solution:  Normal errors 
minimum     :  1361.421 
iterations  :  22 
code        :  1 gradient close to 0, probably solution 
         par      gradient
1 26.8353990 -3.645466e-07
2  0.1301587 -1.578320e-05
3 -3.5867005  3.198205e-07</code></pre>
</div>
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb23"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co"># modify ssq to account for log-normal errors in ssqL  </span></span>
<span><span class="va">ssqL</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">funk</span>,<span class="va">observed</span>,<span class="va">...</span><span class="op">)</span> <span class="op">{</span>  </span>
<span>  <span class="va">predval</span> <span class="op">&lt;-</span> <span class="fu">funk</span><span class="op">(</span><span class="va">...</span><span class="op">)</span>  </span>
<span>  <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">observed</span><span class="op">)</span> <span class="op">-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">predval</span><span class="op">)</span><span class="op">)</span><span class="op">^</span><span class="fl">2</span>,na.rm<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="op">}</span> <span class="co"># end of ssqL  </span></span>
<span><span class="va">bestvBLN</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/nlm.html">nlm</a></span><span class="op">(</span>f<span class="op">=</span><span class="va">ssqL</span>,funk<span class="op">=</span><span class="va">vB</span>,observed<span class="op">=</span><span class="va">LatA</span><span class="op">$</span><span class="va">length</span>,p<span class="op">=</span><span class="va">pars</span>,  </span>
<span>             ages<span class="op">=</span><span class="va">LatA</span><span class="op">$</span><span class="va">age</span>,typsize<span class="op">=</span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/magnitude.html">magnitude</a></span><span class="op">(</span><span class="va">pars</span><span class="op">)</span>,iterlim<span class="op">=</span><span class="fl">1000</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/outfit.html">outfit</a></span><span class="op">(</span><span class="va">bestvBLN</span>,backtran<span class="op">=</span><span class="cn">FALSE</span>,title<span class="op">=</span><span class="st">"Log-Normal errors"</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>nlm solution:  Log-Normal errors 
minimum     :  3.153052 
iterations  :  25 
code        :  1 gradient close to 0, probably solution 
         par      gradient
1 26.4409587  8.898258e-08
2  0.1375784  7.546830e-06
3 -3.2946086 -1.122823e-07</code></pre>
</div>
</div>
<p>在这种情况下，使用正态和对数正态残差产生的曲线几乎没有区别（ <a href="#fig-4-4" class="quarto-xref">图&nbsp;<span>4.4</span></a> ）。尽管它们的参数不同（使用 <code>ylim=c(10,ymax)</code> 使差异更明显）。除了视觉上的不同，不同的模型甚至没有可比性。如果我们比较它们各自的平方和残差，一个是 1361.0，另一个只有 3.153。当我们考虑到平方和计算中对数变换的影响时，这并不奇怪。但这意味着我们不能只看表格输出，然后决定哪个版本比另一个更适合数据。它们是严格不相称的，尽管它们使用的是完全相同的模型。不同残差结构的使用需要在考虑相对模型拟合以外的方式进行辩护。这个例子强调，虽然模型的选择显然很重要，但残差结构的选择也是模型结构的一部分，同样重要。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb25"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co"># Now plot the resultibng two curves and the data Fig 4.4  </span></span>
<span><span class="va">predvBN</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/vB.html">vB</a></span><span class="op">(</span><span class="va">bestvBN</span><span class="op">$</span><span class="va">estimate</span>,<span class="va">ages</span><span class="op">)</span>   </span>
<span><span class="va">predvBLN</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/vB.html">vB</a></span><span class="op">(</span><span class="va">bestvBLN</span><span class="op">$</span><span class="va">estimate</span>,<span class="va">ages</span><span class="op">)</span>   </span>
<span><span class="va">ymax</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/getmax.html">getmax</a></span><span class="op">(</span><span class="va">LatA</span><span class="op">$</span><span class="va">length</span><span class="op">)</span>   </span>
<span><span class="va">xmax</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/getmax.html">getmax</a></span><span class="op">(</span><span class="va">LatA</span><span class="op">$</span><span class="va">age</span><span class="op">)</span>      </span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/parset.html">parset</a></span><span class="op">(</span><span class="op">)</span>                </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">LatA</span><span class="op">$</span><span class="va">age</span>,<span class="va">LatA</span><span class="op">$</span><span class="va">length</span>,type<span class="op">=</span><span class="st">"p"</span>,pch<span class="op">=</span><span class="fl">16</span>, col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/grDevices/rgb.html">rgb</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">1</span><span class="op">/</span><span class="fl">5</span><span class="op">)</span>,  </span>
<span>     cex<span class="op">=</span><span class="fl">1.2</span>,xlim<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="va">xmax</span><span class="op">)</span>,ylim<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="va">ymax</span><span class="op">)</span>,yaxs<span class="op">=</span><span class="st">"i"</span>,xlab<span class="op">=</span><span class="st">"Age"</span>,  </span>
<span>     ylab<span class="op">=</span><span class="st">"Length (cm)"</span>,panel.first<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/graphics/grid.html">grid</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">ages</span>,<span class="va">predvBN</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">4</span>,lty<span class="op">=</span><span class="fl">2</span><span class="op">)</span>   <span class="co"># add Normal dashed  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">ages</span>,<span class="va">predvBLN</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">1</span><span class="op">)</span>        <span class="co"># add Log-Normal solid  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/legend.html">legend</a></span><span class="op">(</span><span class="st">"bottomright"</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Normal Errors"</span>,<span class="st">"Log-Normal Errors"</span><span class="op">)</span>,  </span>
<span>       col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">4</span>,<span class="fl">1</span><span class="op">)</span>,lty<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">3</span>,bty<span class="op">=</span><span class="st">"n"</span>,cex<span class="op">=</span><span class="fl">1.2</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-4-4" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-4-4-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="04-application_files/figure-html/fig-4-4-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-4-4-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;4.4: Female Length-at-Age data from 358 female redfish, Centroberyx affinis, with two von Bertalanffy growth curves fitted using Normal and Log-Normal residuals.
</figcaption></figure>
</div>
</div>
</div>
</section><section id="关于初始模型拟合的说明" class="level3" data-number="4.4.7"><h3 data-number="4.4.7" class="anchored" data-anchor-id="关于初始模型拟合的说明">
<span class="header-section-number">4.4.7</span> 关于初始模型拟合的说明</h3>
<p>上面例子中的曲线比较本身就很有趣，不过，我们还说明了 <code><a href="https://rdrr.io/r/stats/nlm.html">nlm()</a></code> 的语法以及如何将模型拟合到数据中。将函数作为参数传递给另一个函数的能力（就像这里我们将 <code>ssq</code> 作为 <em>f</em> 传递给 <code><a href="https://rdrr.io/r/stats/nlm.html">nlm()</a></code>，将 <code>vB</code>、<code>Gz</code> 和 <code>mm</code> 作为 <em>funk</em> 传递给 <code><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq()</a></code>）是 R 的优势之一，但也是其复杂性所在。它简化了<code><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq()</a></code>等函数的重用，在这些函数中，我们只需改变输入函数，就能从本质上相同的代码中得到完全不同的答案。熟悉这些方法的最佳途径是使用自己的数据集。绘制您的数据和任何模型拟合图，因为如果模型拟合图看起来不寻常，那么很可能就是不寻常的，需要再三审视。</p>
<p>使用平方和法可以取得很好的效果，但在处理现实世界的多样性时，要求在期望值附近的残差呈正态分布以及方差恒定的假设是有限制的。为了使用正态分布以外的概率密度分布和非恒定方差，我们应该转而使用最大似然法。</p>
</section></section><section id="最大似然" class="level2" data-number="4.5"><h2 data-number="4.5" class="anchored" data-anchor-id="最大似然">
<span class="header-section-number">4.5</span> 最大似然</h2>
<p>在 R 中使用似然比较简单，因为有许多概率密度函数（PDF）的内置函数以及一系列定义其他 PDF 的软件包。再重复一遍，最大似然法的目的是使用软件搜索模型参数集，使观测数据的总似然最大化。要使用这一最优模型拟合标准，需要对模型进行定义，以便将每个观测值（可用数据）的概率或似然值指定为模型中参数值和其他变量的函数（ <a href="#eq-4_2" class="quarto-xref">公式&nbsp;<span>4.2</span></a> 和 <a href="#eq-4_11" class="quarto-xref">公式&nbsp;<span>4.11</span></a> ）。重要的是，这种规范包括对所选 PDF 的变异性或扩散性的估计（正态分布中的 <span class="math inline">\(\sigma\)</span> 只是最小二乘法的副产品）。使用最大似然法的一个主要优点是，残差结构或关于数据预期中心倾向的观测值的预期分布不一定是正态分布。如果可以定义概率密度函数 (PDF)，则可以在最大似然法框架中使用；有关许多有用概率密度函数的定义，请参见 Forbes et al, (2011)。</p>
<section id="简要示例" class="level3" data-number="4.5.1"><h3 data-number="4.5.1" class="anchored" data-anchor-id="简要示例">
<span class="header-section-number">4.5.1</span> 简要示例</h3>
<p>我们将使用众所周知的正态分布来说明这些方法，然后扩展该方法以包含一系列可选的 PDF。对于数据模型拟合而言，每个PDF的主要意义在于定义单个观测值的概率密度或似然值。对于平均期望值为 <span class="math inline">\(\bar x\)</span> 或 <span class="math inline">\(\mu\)</span> 的正态分布，给定单个值 <span class="math inline">\(x_i\)</span> 的概率密度或似然定义为:</p>
<p><span id="eq-4_11"><span class="math display">\[
L\left( {x_i}|\mu_{i} ,\sigma  \right)=\frac{1}{\sigma \sqrt{2\pi }}{{e}^{\left( \frac{-{{\left( {x_i}-\mu_{i}  \right)}^{2}}}{2\sigma^2 } \right)}}  
\qquad(4.11)\]</span></span></p>
<p>其中 <span class="math inline">\(\sigma\)</span> 为与 <span class="math inline">\(\mu_i\)</span> 相关的标准差。这确定了最小二乘法和最大似然方法之间的直接区别，在后者中，需要一个 PDF 的完整定义，在正态分布的情况下，它包括对均值估计 <span class="math inline">\(\mu\)</span> 周围残差的标准偏差的显式估计。这样的估计不需要最小二乘，虽然很容易从 SSQ 值中得到。</p>
<p>例如，我们可以从正态分布中生成一个观测样本(参见<code><a href="https://rdrr.io/r/stats/Normal.html">?rnorm</a></code>)，然后计算该样本的均值和标准差，并比较给定的样本值与 <em>rnorm</em> 函数中使用的原始均值和标准差的参数估计值的可能性有多大（ <a href="#tbl-4-1" class="quarto-xref">表&nbsp;<span>4.1</span></a> ）：</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb26"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co"># Illustrate Normal random likelihoods. see Table 4.1  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">12345</span><span class="op">)</span>       <span class="co"># make the use of random numbers repeatable  </span></span>
<span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span><span class="op">(</span><span class="fl">10</span>,mean<span class="op">=</span><span class="fl">5.0</span>,sd<span class="op">=</span><span class="fl">1.0</span><span class="op">)</span>      <span class="co"># pseudo-randomly generate 10   </span></span>
<span><span class="va">avx</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span>                      <span class="co"># normally distributed values  </span></span>
<span><span class="va">sdx</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/sd.html">sd</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span>          <span class="co"># estimate the mean and stdev of the sample            </span></span>
<span><span class="va">L1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span><span class="op">(</span><span class="va">x</span>,mean<span class="op">=</span><span class="fl">5.0</span>,sd<span class="op">=</span><span class="fl">1.0</span><span class="op">)</span>   <span class="co"># obtain likelihoods, L1, L2 for   </span></span>
<span><span class="va">L2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span><span class="op">(</span><span class="va">x</span>,mean<span class="op">=</span><span class="va">avx</span>,sd<span class="op">=</span><span class="va">sdx</span><span class="op">)</span>    <span class="co"># each data point for both sets  </span></span>
<span><span class="va">result</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span><span class="va">x</span>,<span class="va">L1</span>,<span class="va">L2</span>,<span class="st">"L2gtL1"</span><span class="op">=</span><span class="op">(</span><span class="va">L2</span><span class="op">&gt;</span><span class="va">L1</span><span class="op">)</span><span class="op">)</span>      <span class="co"># which is larger?  </span></span>
<span><span class="va">result</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span><span class="op">(</span><span class="va">result</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="cn">NA</span>,<span class="fu"><a href="https://rdrr.io/r/base/prod.html">prod</a></span><span class="op">(</span><span class="va">L1</span><span class="op">)</span>,<span class="fu"><a href="https://rdrr.io/r/base/prod.html">prod</a></span><span class="op">(</span><span class="va">L2</span><span class="op">)</span>,<span class="fl">1</span><span class="op">)</span><span class="op">)</span> <span class="co"># result+totals  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html">rownames</a></span><span class="op">(</span><span class="va">result</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">10</span>,<span class="st">"product"</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html">colnames</a></span><span class="op">(</span><span class="va">result</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"x"</span>,<span class="st">"original"</span>,<span class="st">"estimated"</span>,<span class="st">"est &gt; orig"</span><span class="op">)</span>  </span>
<span><span class="fu">knitr</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/knitr/man/kable.html">kable</a></span><span class="op">(</span><span class="va">result</span><span class="op">)</span> </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div id="tbl-4-1" class="cell quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-4-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
表&nbsp;4.1: 使用正态随机值及相关正态似然函数的示例。估计列具有更大的总似然值。1=真，0=假。
</figcaption><div aria-describedby="tbl-4-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell-output-display">
<table class="do-not-create-environment cell table table-sm table-striped small">
<thead><tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: right;">x</th>
<th style="text-align: right;">original</th>
<th style="text-align: right;">estimated</th>
<th style="text-align: right;">est &gt; orig</th>
</tr></thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">1</td>
<td style="text-align: right;">5.585529</td>
<td style="text-align: right;">0.3360953</td>
<td style="text-align: right;">0.3320130</td>
<td style="text-align: right;">0</td>
</tr>
<tr class="even">
<td style="text-align: left;">2</td>
<td style="text-align: right;">5.709466</td>
<td style="text-align: right;">0.3101778</td>
<td style="text-align: right;">0.2868818</td>
<td style="text-align: right;">0</td>
</tr>
<tr class="odd">
<td style="text-align: left;">3</td>
<td style="text-align: right;">4.890697</td>
<td style="text-align: right;">0.3965663</td>
<td style="text-align: right;">0.4901017</td>
<td style="text-align: right;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">4</td>
<td style="text-align: right;">4.546503</td>
<td style="text-align: right;">0.3599578</td>
<td style="text-align: right;">0.4536973</td>
<td style="text-align: right;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">5</td>
<td style="text-align: right;">5.605887</td>
<td style="text-align: right;">0.3320438</td>
<td style="text-align: right;">0.3246562</td>
<td style="text-align: right;">0</td>
</tr>
<tr class="even">
<td style="text-align: left;">6</td>
<td style="text-align: right;">3.182044</td>
<td style="text-align: right;">0.0764269</td>
<td style="text-align: right;">0.0574370</td>
<td style="text-align: right;">0</td>
</tr>
<tr class="odd">
<td style="text-align: left;">7</td>
<td style="text-align: right;">5.630099</td>
<td style="text-align: right;">0.3271127</td>
<td style="text-align: right;">0.3158617</td>
<td style="text-align: right;">0</td>
</tr>
<tr class="even">
<td style="text-align: left;">8</td>
<td style="text-align: right;">4.723816</td>
<td style="text-align: right;">0.3840136</td>
<td style="text-align: right;">0.4827694</td>
<td style="text-align: right;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">9</td>
<td style="text-align: right;">4.715840</td>
<td style="text-align: right;">0.3831564</td>
<td style="text-align: right;">0.4819139</td>
<td style="text-align: right;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">10</td>
<td style="text-align: right;">4.080678</td>
<td style="text-align: right;">0.2614493</td>
<td style="text-align: right;">0.3073533</td>
<td style="text-align: right;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">product</td>
<td style="text-align: right;">NA</td>
<td style="text-align: right;">0.0000048</td>
<td style="text-align: right;">0.0000089</td>
<td style="text-align: right;">1</td>
</tr>
</tbody>
</table>
</div>
</div>
</figure>
</div>
</div>
<p><a href="#tbl-4-1" class="quarto-xref">表&nbsp;<span>4.1</span></a> 的最下面一行包含每列似然值的乘积(使用R函数 <code><a href="https://rdrr.io/r/base/prod.html">prod()</a></code> 求得)。毫不奇怪，当我们使用样本的均值和标准差估计(估计，L2)而不是原始值的 <em>mean=5</em> 和 <em>sd=1.0</em> (原始，L1)时，求得最大似然，即 <span class="math inline">\(8.9201095^{-6} &gt; 4.7521457 ^{-6}\)</span>。在本例中，我可以确定这些值，因为在代码开始时使用了R函数 <code><a href="https://rdrr.io/r/base/Random.html">set.seed()</a></code> ，以便在特定位置启动伪随机数生成器。如果你通常使用 <code><a href="https://rdrr.io/r/base/Random.html">set.seed()</a></code>，不会重复使用相同的旧序列，例如 <span class="math inline">\(12345\)</span>，因为您可能会破坏伪随机数是随机数序列的良好近似值的想法，也许可以使用 <code><a href="https://rdrr.io/pkg/MQMF/man/getseed.html">getseed()</a></code>来提供合适的种子数。</p>
<p>因此，<code><a href="https://rdrr.io/r/stats/Normal.html">rnorm()</a></code> 函数提供了由均值和标准差确定分布中的伪随机数，<code><a href="https://rdrr.io/r/stats/Normal.html">dnorm()</a></code> 函数提供了观测值在均值和标准差条件下的概率密度或似然（相当于 <a href="#eq-4_11" class="quarto-xref">公式&nbsp;<span>4.11</span></a> ）。累积概率密度函数（cdf）由函数 <code><a href="https://rdrr.io/r/stats/Normal.html">pnorm()</a></code> 提供，量化值由 <code><a href="https://rdrr.io/r/stats/Normal.html">qnorm()</a></code> 确定。平均值自然具有最大的似然。还要注意的是，正态曲线是围绕均值对称的。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb27"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co"># some examples of pnorm, dnorm, and qnorm, all mean = 0  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"x = 0.0        Likelihood ="</span>,<span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span><span class="op">(</span><span class="fl">0.0</span>,mean<span class="op">=</span><span class="fl">0</span>,sd<span class="op">=</span><span class="fl">1</span><span class="op">)</span>,<span class="st">"\n"</span><span class="op">)</span>   </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>x = 0.0        Likelihood = 0.3989423 </code></pre>
</div>
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb29"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"x = 1.95996395 Likelihood ="</span>,<span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span><span class="op">(</span><span class="fl">1.95996395</span>,mean<span class="op">=</span><span class="fl">0</span>,sd<span class="op">=</span><span class="fl">1</span><span class="op">)</span>,<span class="st">"\n"</span><span class="op">)</span>   </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>x = 1.95996395 Likelihood = 0.05844507 </code></pre>
</div>
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb31"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"x =-1.95996395 Likelihood ="</span>,<span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span><span class="op">(</span><span class="op">-</span><span class="fl">1.95996395</span>,mean<span class="op">=</span><span class="fl">0</span>,sd<span class="op">=</span><span class="fl">1</span><span class="op">)</span>,<span class="st">"\n"</span><span class="op">)</span>   </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>x =-1.95996395 Likelihood = 0.05844507 </code></pre>
</div>
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb33"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co"># 0.5 = half cumulative distribution  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"x = 0.0        cdf = "</span>,<span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">pnorm</a></span><span class="op">(</span><span class="fl">0</span>,mean<span class="op">=</span><span class="fl">0</span>,sd<span class="op">=</span><span class="fl">1</span><span class="op">)</span>,<span class="st">"\n"</span><span class="op">)</span>   </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>x = 0.0        cdf =  0.5 </code></pre>
</div>
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb35"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"x = 0.6744899  cdf = "</span>,<span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">pnorm</a></span><span class="op">(</span><span class="fl">0.6744899</span>,mean<span class="op">=</span><span class="fl">0</span>,sd<span class="op">=</span><span class="fl">1</span><span class="op">)</span>,<span class="st">"\n"</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>x = 0.6744899  cdf =  0.75 </code></pre>
</div>
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb37"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"x = 0.75       Quantile ="</span>,<span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">qnorm</a></span><span class="op">(</span><span class="fl">0.75</span><span class="op">)</span>,<span class="st">"\n"</span><span class="op">)</span> <span class="co"># reverse pnorm  </span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>x = 0.75       Quantile = 0.6744898 </code></pre>
</div>
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb39"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"x = 1.95996395 cdf = "</span>,<span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">pnorm</a></span><span class="op">(</span><span class="fl">1.95996395</span>,mean<span class="op">=</span><span class="fl">0</span>,sd<span class="op">=</span><span class="fl">1</span><span class="op">)</span>,<span class="st">"\n"</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>x = 1.95996395 cdf =  0.975 </code></pre>
</div>
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb41"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"x =-1.95996395 cdf = "</span>,<span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">pnorm</a></span><span class="op">(</span><span class="op">-</span><span class="fl">1.95996395</span>,mean<span class="op">=</span><span class="fl">0</span>,sd<span class="op">=</span><span class="fl">1</span><span class="op">)</span>,<span class="st">"\n"</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>x =-1.95996395 cdf =  0.025 </code></pre>
</div>
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb43"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"x = 0.975      Quantile ="</span>,<span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">qnorm</a></span><span class="op">(</span><span class="fl">0.975</span><span class="op">)</span>,<span class="st">"\n"</span><span class="op">)</span> <span class="co"># expect ~1.96  </span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>x = 0.975      Quantile = 1.959964 </code></pre>
</div>
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb45"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co"># try x &lt;- seq(-5,5,0.2); round(dnorm(x,mean=0.0,sd=1.0),5)  </span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>我们可以看到，单个似然值可能是相对较大的数字，但当它们相乘时，很快就会变成相对较小的数字。当观测数据的数量增加时，就会出现误差。即使只有十个数字，当我们将所有单个似然值相乘（使用 <code><a href="https://rdrr.io/r/base/prod.html">prod()</a></code>）时，结果也会很快变得非常小。如果使用与 <a href="#tbl-4-1" class="quarto-xref">表&nbsp;<span>4.1</span></a> 中的十个数字类似的另外十个数字，总似然很容易降到 <span class="math inline">\(1e-11\)</span> 或 <span class="math inline">\(1e-12\)</span>。随着观察次数的增加，出现四舍五入错误的几率（即使在 64 位计算机上）也开始增加。与其将许多小数相乘得到一个极小的数，不如将这些小数相乘的标准解决方案是对似然值进行自然对数变换，然后相加。最大化对数变换似然值之和与最大化单个似然值之积一样，都能获得最佳参数。此外，许多软件中的优化器似乎都是为了最有效地最小化某个函数而设计的。简单的解决方案是，我们不最大化单个似然的乘积，而是最小化负对数似然的总和（<em>-veLL</em> 或 <code><a href="https://rdrr.io/pkg/MQMF/man/negLL.html">negLL()</a></code>）。</p>
</section></section><section id="正态分布的似然" class="level2" data-number="4.6"><h2 data-number="4.6" class="anchored" data-anchor-id="正态分布的似然">
<span class="header-section-number">4.6</span> 正态分布的似然</h2>
<p>概率似乎是一种相当奇怪的生物。当它们来自连续的概率密度函数（PDFs）时，尽管它们具有许多相同的属性，但严格来说它们并不是概率（Edwards，1972 ）。严格来讲，它们与概率密度函数下某一点的概率密度有关。根据概率的定义，整条曲线下的面积总和必须为 1.0，但连续概率密度函数任何一点下的面积都会变得无穷小。正态似然的定义使用 <a href="#eq-4_11" class="quarto-xref">公式&nbsp;<span>4.11</span></a> ），而累积密度函数为:</p>
<p><span id="eq-4_12"><span class="math display">\[
{cdf}=1=\int\limits_{x=-\infty }^{\infty }{\frac{1}{\sigma \sqrt{2\pi }}}{{e}^{\left( \frac{-{{\left( x-\mu  \right)}^{2}}}{2{{\sigma }^{2}}} \right)}}
\qquad(4.12)\]</span></span></p>
<p>我们可以使用 <code><a href="https://rdrr.io/r/stats/Normal.html">dnorm()</a></code> 和 <code><a href="https://rdrr.io/r/stats/Normal.html">pnorm()</a></code> 计算似然和累积密度函数（cdf）（ <a href="#fig-4-5" class="quarto-xref">图&nbsp;<span>4.5</span></a> ）。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb46"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co"># Density plot and cumulative distribution for Normal   Fig 4.5  </span></span>
<span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="op">-</span><span class="fl">5</span>,<span class="fl">5</span>,<span class="fl">0.1</span><span class="op">)</span>  <span class="co"># a sequence of values around a mean of 0.0  </span></span>
<span><span class="va">NL</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span><span class="op">(</span><span class="va">x</span>,mean<span class="op">=</span><span class="fl">0</span>,sd<span class="op">=</span><span class="fl">1.0</span><span class="op">)</span>   <span class="co"># normal likelihoods for each X  </span></span>
<span><span class="va">CD</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">pnorm</a></span><span class="op">(</span><span class="va">x</span>,mean<span class="op">=</span><span class="fl">0</span>,sd<span class="op">=</span><span class="fl">1.0</span><span class="op">)</span>   <span class="co"># cumulative density vs X  </span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/plot1.html">plot1</a></span><span class="op">(</span><span class="va">x</span>,<span class="va">CD</span>,xlab<span class="op">=</span><span class="st">"x = StDev from Mean"</span>,ylab<span class="op">=</span><span class="st">"Likelihood and CDF"</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">x</span>,<span class="va">NL</span>,lwd<span class="op">=</span><span class="fl">3</span>,col<span class="op">=</span><span class="fl">2</span>,lty<span class="op">=</span><span class="fl">3</span><span class="op">)</span> <span class="co"># dashed line as these are points  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html">abline</a></span><span class="op">(</span>h<span class="op">=</span><span class="fl">0.5</span>,col<span class="op">=</span><span class="fl">4</span>,lwd<span class="op">=</span><span class="fl">1</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-4-5" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-4-5-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="04-application_files/figure-html/fig-4-5-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-4-5-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;4.5: 一条虚线红色曲线描绘了均值为 0 和标准差为 1.0 的预期正态似然，以及作为黑色线的相同正态似然的累积密度。蓝线标识了累积概率为 0.5。
</figcaption></figure>
</div>
</div>
</div>
<p>这听起来不错，但在这样的曲线下， <span class="math inline">\(x\)</span> 变量的特定值来说，确定这样一条曲线下的特定值意味着什么呢？在 <a href="#fig-4-5" class="quarto-xref">图&nbsp;<span>4.5</span></a> 中，我们用虚线表示图中的似然是局部估计，不构成连续的线。每个都表示在给定 <span class="math inline">\(x\)</span> 值处的似然。如前所述，对于 <span class="math inline">\(mean= 0.0\)</span> 和 <span class="math inline">\(stdev = 1.0\)</span> 的分布，在 <span class="math inline">\(0.0\)</span> 值处的概率密度为 <span class="math inline">\(0.3989423\)</span>。让我们简单地查看一下似然和概率之间可能存在的混淆。如果我们考虑概率密度函数的一小部分，在 <span class="math inline">\(x = 3.4\)</span> 到 <span class="math inline">\(3.6\)</span>的值之间 <span class="math inline">\(mean= 5.0\)</span>，<span class="math inline">\(st.dev = 1.0\)</span> 的概率密度函数，我们可能会看到类似 <a href="#fig-4-6" class="quarto-xref">图&nbsp;<span>4.6</span></a> 的情况:</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb47"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#function facilitates exploring different polygons Fig 4.6  </span></span>
<span><span class="va">plotpoly</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">mid</span>,<span class="va">delta</span>,<span class="va">av</span><span class="op">=</span><span class="fl">5.0</span>,<span class="va">stdev</span><span class="op">=</span><span class="fl">1.0</span><span class="op">)</span> <span class="op">{</span>  </span>
<span>   <span class="va">neg</span> <span class="op">&lt;-</span> <span class="va">mid</span><span class="op">-</span><span class="va">delta</span>;  <span class="va">pos</span> <span class="op">&lt;-</span> <span class="va">mid</span><span class="op">+</span><span class="va">delta</span>  </span>
<span>   <span class="va">pdval</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">mid</span>,<span class="va">neg</span>,<span class="va">pos</span><span class="op">)</span>,mean<span class="op">=</span><span class="va">av</span>,sd<span class="op">=</span><span class="va">stdev</span><span class="op">)</span>  </span>
<span>   <span class="fu"><a href="https://rdrr.io/r/graphics/polygon.html">polygon</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">neg</span>,<span class="va">neg</span>,<span class="va">mid</span>,<span class="va">neg</span><span class="op">)</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">pdval</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span>,<span class="va">pdval</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>,<span class="va">pdval</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>,  </span>
<span>                          <span class="va">pdval</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span><span class="op">)</span>,col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/grDevices/rgb.html">rgb</a></span><span class="op">(</span><span class="fl">0.25</span>,<span class="fl">0.25</span>,<span class="fl">0.25</span>,<span class="fl">0.5</span><span class="op">)</span><span class="op">)</span>  </span>
<span>   <span class="fu"><a href="https://rdrr.io/r/graphics/polygon.html">polygon</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">pos</span>,<span class="va">pos</span>,<span class="va">mid</span>,<span class="va">pos</span><span class="op">)</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">pdval</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>,<span class="va">pdval</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span>,<span class="va">pdval</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>,  </span>
<span>                                <span class="va">pdval</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span>,col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/grDevices/rgb.html">rgb</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">1</span>,<span class="fl">0</span>,<span class="fl">0.5</span><span class="op">)</span><span class="op">)</span>     </span>
<span>   <span class="fu"><a href="https://rdrr.io/r/graphics/polygon.html">polygon</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">mid</span>,<span class="va">neg</span>,<span class="va">neg</span>,<span class="va">mid</span>,<span class="va">mid</span><span class="op">)</span>,  </span>
<span>        <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">0</span>,<span class="va">pdval</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>,<span class="va">pdval</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>,<span class="fl">0</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">2</span>,lty<span class="op">=</span><span class="fl">1</span>,border<span class="op">=</span><span class="fl">2</span><span class="op">)</span>  </span>
<span>   <span class="fu"><a href="https://rdrr.io/r/graphics/polygon.html">polygon</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">mid</span>,<span class="va">pos</span>,<span class="va">pos</span>,<span class="va">mid</span>,<span class="va">mid</span><span class="op">)</span>,  </span>
<span>        <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">0</span>,<span class="va">pdval</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>,<span class="va">pdval</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>,<span class="fl">0</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">2</span>,lty<span class="op">=</span><span class="fl">1</span>,border<span class="op">=</span><span class="fl">2</span><span class="op">)</span>   </span>
<span>   <span class="fu"><a href="https://rdrr.io/r/graphics/text.html">text</a></span><span class="op">(</span><span class="fl">3.395</span>,<span class="fl">0.025</span>,<span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste0</a></span><span class="op">(</span><span class="st">"~"</span>,<span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="op">(</span><span class="fl">2</span><span class="op">*</span><span class="op">(</span><span class="va">delta</span><span class="op">*</span><span class="va">pdval</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span><span class="op">)</span>,<span class="fl">7</span><span class="op">)</span><span class="op">)</span>,</span>
<span>        cex<span class="op">=</span><span class="fl">1.1</span>,pos<span class="op">=</span><span class="fl">4</span><span class="op">)</span>  </span>
<span>   <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="fl">2</span><span class="op">*</span><span class="op">(</span><span class="va">delta</span><span class="op">*</span><span class="va">pdval</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span><span class="op">)</span> <span class="co"># approx probability, see below  </span></span>
<span><span class="op">}</span> <span class="co"># end of plotpoly, a temporary function to enable flexibility  </span></span>
<span> <span class="co">#This code can be re-run with different values for delta  </span></span>
<span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fl">3.4</span>,<span class="fl">3.6</span>,<span class="fl">0.05</span><span class="op">)</span> <span class="co"># where under the normal curve to examine  </span></span>
<span><span class="va">pd</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span><span class="op">(</span><span class="va">x</span>,mean<span class="op">=</span><span class="fl">5.0</span>,sd<span class="op">=</span><span class="fl">1.0</span><span class="op">)</span> <span class="co">#prob density for each X value  </span></span>
<span><span class="va">mid</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span>      </span>
<span><span class="va">delta</span> <span class="op">&lt;-</span> <span class="fl">0.05</span>  <span class="co"># how wide either side of the sample mean to go?   </span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/parset.html">parset</a></span><span class="op">(</span><span class="op">)</span>       <span class="co"># a pre-defined MQMF base graphics set-up for par  </span></span>
<span><span class="va">ymax</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/getmax.html">getmax</a></span><span class="op">(</span><span class="va">pd</span><span class="op">)</span>    <span class="co"># find maximum y value for the plot  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">x</span>,<span class="va">pd</span>,type<span class="op">=</span><span class="st">"l"</span>,xlab<span class="op">=</span><span class="st">"Variable x"</span>,ylab<span class="op">=</span><span class="st">"Probability Density"</span>,  </span>
<span>     ylim<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="va">ymax</span><span class="op">)</span>,yaxs<span class="op">=</span><span class="st">"i"</span>,lwd<span class="op">=</span><span class="fl">2</span>,panel.first<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/graphics/grid.html">grid</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="va">approxprob</span> <span class="op">&lt;-</span> <span class="fu">plotpoly</span><span class="op">(</span><span class="va">mid</span>,<span class="va">delta</span><span class="op">)</span>  <span class="co">#use function defined above  </span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-4-6" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-4-6-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="04-application_files/figure-html/fig-4-6-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-4-6-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;4.6: 正态分布变量 X 的概率密度，均值为 5.0，标准差为 1.0。在 x = 3.5 处的 PDF 值为 0.129518，因此红色框线所围成的矩形的面积是 0.0129518，这近似于 3.45 到 3.55 之间的总概率，实际上应该是曲线下的面积。
</figcaption></figure>
</div>
</div>
</div>
<p>完整概率密度函数（ PDF） 下的面积总和为 1.0，因此得到 <a href="#fig-4-6" class="quarto-xref">图&nbsp;<span>4.6</span></a> 中 <span class="math inline">\(3.45\)</span> 和 <span class="math inline">\(3.55\)</span> 之间值的概率是长方形面积减去左三角形面积再加上右三角形面积之和。三角形几乎是对称的，因此可以近似地相互抵消，所以近似解法就是将其中一个长方形的面积乘以 <span class="math inline">\(2.0\)</span>。当 delta（长方形在 <span class="math inline">\(x\)</span> 轴上的宽度）为 <span class="math inline">\(0.05\)</span> 时，概率 <span class="math inline">\(= 0.0129518\)</span>。如果将 delta 值改为 <span class="math inline">\(0.01\)</span>，那么近似概率 <span class="math inline">\(= 0.0025904\)</span>，随着 delta 值的减小，总概率也随之减小，尽管 <span class="math inline">\(3.5\)</span> 时的概率密度仍为 <span class="math inline">\(0.1295176\)</span>。显然，似然值与连续 PDF 中的概率并不相同（见 Edwards, 1972）。曲线下面积概率的最佳估计值为 <code>pnorm(3.55,5,1) - pnorm(3.45,5,1)</code>，即 = 0.0129585。</p>
<section id="与平方和等价性" class="level3" data-number="4.6.1"><h3 data-number="4.6.1" class="anchored" data-anchor-id="与平方和等价性">
<span class="header-section-number">4.6.1</span> 与平方和等价性</h3>
<p>当使用正态似然来拟合数据模型时，我们实际做的是设置，使得每个可用观测值的负对数似然之和最小化。幸运的是，我们可以使用<code><a href="https://rdrr.io/r/stats/Normal.html">dnorm()</a></code>来估计似然。事实上，如果我们使用正态分布残差或对数变换的对数正态分布数据使用极大似然方法拟合模型，则得到的参数估计与使用最小二乘法得到的参数估计相同(参见下文 <a href="#eq-4_19" class="quarto-xref">公式&nbsp;<span>4.19</span></a> 的推导和形式)。拟合模型需要生成一组预测值 <span class="math inline">\(\hat x\)</span> (x-hat)，为其他自变量 <span class="math inline">\(\theta(x)\)</span> 的函数，其中 <span class="math inline">\(\theta\)</span> 是函数关系中使用的参数列。<span class="math inline">\(n\)</span> 个观测值的对数似然定义为:</p>
<p><span id="eq-4_13"><span class="math display">\[
LL(x|\theta)=\sum\limits_{i=1}^{n}{log\left( \frac{1}{\hat{\sigma }\sqrt{2\pi }}{{e}^{\left( \frac{-{{\left( {x_i}-{{\hat{x}}_{i}} \right)}^{2}}}{2{{{\hat{\sigma }}}^{2}}} \right)}} \right)}  
\qquad(4.13)\]</span></span></p>
<p><span class="math inline">\(LL(x|\theta)\)</span> 读作给定 <span class="math inline">\(\theta\)</span> 个参数（<span class="math inline">\(\mu\)</span> 和 <span class="math inline">\(\hat \sigma\)</span>）时观测值 <span class="math inline">\(x\)</span> 的对数似然；符号”|“读作”给定”。这个看似复杂的方程式其实可以大大简化。首先，我们可以将指数项之前的常数移到求和项之外，乘以 <span class="math inline">\(n\)</span> ，然后将剩余指数项的自然对数反变换为指数：</p>
<p><span id="eq-4_14"><span class="math display">\[
LL(x|\theta)=n \log\left( \frac{1}{\hat{\sigma }\sqrt{2\pi }} \right)+\frac{1}{2{\hat{\sigma }^{2}}}\sum\limits_{i=1}^{n}{\left( -{{\left( x_i-\hat{x}_i \right)}^{2}} \right)}  
\qquad(4.14)\]</span></span></p>
<p><span class="math inline">\(\hat \sigma^2\)</span> 是数据方差的最大似然估计（记住是除以 <span class="math inline">\(n\)</span> 而非 <span class="math inline">\(n-1\)</span>）：</p>
<p><span id="eq-4_15"><span class="math display">\[
{{\hat{\sigma }}^{2}}=\frac{\sum\limits_{i=1}^{n}{{{\left( x_i-\hat{x}_i \right)}^{2}}}}{n}
\qquad(4.15)\]</span></span></p>
<p>如果用 <a href="#eq-4_15" class="quarto-xref">公式&nbsp;<span>4.15</span></a> 中 <span class="math inline">\(\hat \sigma^2\)</span> 代入 <a href="#eq-4_14" class="quarto-xref">公式&nbsp;<span>4.14</span></a> ，则 <span class="math inline">\((x_i-\hat x_i)^2\)</span> 用 <span class="math inline">\(-n/2\)</span> 代替：</p>
<p><span id="eq-4_16"><span class="math display">\[
LL(x|\theta)=n{\log}\left( \left( {\hat{\sigma }\sqrt{2\pi }} \right)^{-1} \right) - \frac{n}{2}  
\qquad(4.16)\]</span></span></p>
<p>化简平方根意味着将 <span class="math inline">\(- 1\)</span> 移至对数项外面，<span class="math inline">\(n\)</span> 变成 <span class="math inline">\(- n\)</span>，我们可以将平方根变成指数 <span class="math inline">\(1/2\)</span>，然后将 <span class="math inline">\(\log(\hat \sigma)\)</span> 项加到 <span class="math inline">\(\pi\)</span> 项上：</p>
<p><span id="eq-4_17"><span class="math display">\[
LL(x|\theta)=-n\left( {\log}\left( {{\left( 2\pi  \right)}^{\frac{1}{2}}} \right)+{\log}\left( {\hat{\sigma }} \right) \right)-\frac{n}{2}  
\qquad(4.17)\]</span></span></p>
<p>将幂指数 <span class="math inline">\(1/2\)</span> 移到第1个 <em>log</em> 项外：</p>
<p><span id="eq-4_18"><span class="math display">\[
LL(x|\theta)=-\frac{n}{2}\left( {\log}\left( 2\pi  \right)+2{\log}\left( {\hat{\sigma }} \right) \right)-\frac{n}{2}    
\qquad(4.18)\]</span></span></p>
<p>然后将 <span class="math inline">\(n/2\)</span> 简化，并将整个方程两边乘以 <span class="math inline">\(- 1\)</span>，以转换为负对数似然，从而得到正态分布值的负对数似然的最终简化:</p>
<p><span id="eq-4_19"><span class="math display">\[
-LL(x|\theta)=\frac{n}{2}\left( {\log}\left( 2\pi  \right) + 2{\log} \left( {\hat{\sigma }} \right) + 1 \right)  
\qquad(4.19)\]</span></span></p>
<p>其中唯一的非常数部分是 <span class="math inline">\(\hat \sigma\)</span> 的值，它是残差平方和除以 <span class="math inline">\(n\)</span> 的平方根，所以现在应该很清楚了，为什么使用最大似然时获得的参数，如果使用正态随机误差，与从最小二乘方法得到的参数相同。</p>
</section><section id="应用正态似然拟合数据模型" class="level3" data-number="4.6.2"><h3 data-number="4.6.2" class="anchored" data-anchor-id="应用正态似然拟合数据模型">
<span class="header-section-number">4.6.2</span> 应用正态似然拟合数据模型</h3>
<p>我们可以使用数据集 <em>LatA</em> 中的模拟雌性红鱼数据重复这个例子，图，</p>
<p>我们可以使用数据集 LatA中的模拟雌性红鱼数据来重复这个例子（ <a href="#fig-4-7" class="quarto-xref">图&nbsp;<span>4.7</span></a> ），我们用它来说明平方残差之和的使用。理想情况下，我们应该得到相同的答案，但估计值为 <span class="math inline">\(\sigma\)</span> 的估计值。<strong>MQMF</strong> 函数 <code><a href="https://rdrr.io/pkg/MQMF/man/plot1.html">plot1()</a></code> 只是绘制单个图形（<em>type=“l”</em>或 <em>type=“p”</em>；请参阅 <code><a href="https://rdrr.io/pkg/MQMF/man/plot1.html">?plot1</a></code>）的一种快速方法，没有太多空白。如果你比我更喜欢空白，请编辑 <code><a href="https://rdrr.io/pkg/MQMF/man/plot1.html">plot1()</a></code>！</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb48"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#plot of length-at-age data  Fig 4.7  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="va">LatA</span><span class="op">)</span> <span class="co"># load the redfish data set into memory and plot it  </span></span>
<span><span class="va">ages</span> <span class="op">&lt;-</span> <span class="va">LatA</span><span class="op">$</span><span class="va">age</span>;  <span class="va">lengths</span> <span class="op">&lt;-</span> <span class="va">LatA</span><span class="op">$</span><span class="va">length</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/plot1.html">plot1</a></span><span class="op">(</span><span class="va">ages</span>,<span class="va">lengths</span>,xlab<span class="op">=</span><span class="st">"Age"</span>,ylab<span class="op">=</span><span class="st">"Length"</span>,type<span class="op">=</span><span class="st">"p"</span>,cex<span class="op">=</span><span class="fl">0.8</span>,  </span>
<span>      pch<span class="op">=</span><span class="fl">16</span>,col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/grDevices/rgb.html">rgb</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">1</span><span class="op">/</span><span class="fl">5</span><span class="op">)</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-4-7" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-4-7-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="04-application_files/figure-html/fig-4-7-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-4-7-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;4.7: LatA 数据集中包含的雌性红鱼 Centroberyx affinis 的年龄-长度数据。全彩表示 &gt;= 5 个点。
</figcaption></figure>
</div>
</div>
</div>
<p>现在，我们可以使用 <strong>MQMF</strong> 函数 <code><a href="https://rdrr.io/pkg/MQMF/man/negNLL.html">negNLL()</a></code>（负正态对数似然值）以确定使用正态随机误差的负对数似然值之和（<code><a href="https://rdrr.io/pkg/MQMF/man/negLL.html">negLL()</a></code>对对数正态分布数据也有同样的作用）。如果你查看一下 <code><a href="https://rdrr.io/pkg/MQMF/man/negNLL.html">negNLL()</a></code> 的代码，就会发现它与 <code><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq()</a></code> 一样，都是将一个函数作为参数传递给它，然后用它来计算每个输入年龄的预测平均值（在本例中是使用 <strong>MQMF</strong> 函数 <code><a href="https://rdrr.io/pkg/MQMF/man/vB.html">vB()</a></code>计算的年龄长度），然后使用 <code><a href="https://rdrr.io/r/stats/Normal.html">dnorm()</a></code> 以预测值作为平均值，并使用数据中的年龄-长度观测值来计算 <code>-veLL</code> 之和。年龄数据是通过省略号（…）传递的，并没有在 <code><a href="https://rdrr.io/pkg/MQMF/man/negNLL.html">negNLL()</a></code> 中明确声明为参数。该函数在结构上与 <code><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq()</a></code> 非常相似，输入要求完全相同，但 <em>pars</em> 是显式传递的，而不是在…中传递，因为 <em>pars</em> 的最后一个值必须是残差的 stdev，它将在 <code><a href="https://rdrr.io/pkg/MQMF/man/negNLL.html">negNLL()</a></code> 中使用，而不只是在 <em>funk</em> 中使用。因此，<code><a href="https://rdrr.io/pkg/MQMF/man/negNLL.html">negNLL()</a></code>的运行方式与<code><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq()</a></code>非常相似，它是调用函数生成预测值的封装程序，然后使用 <code><a href="https://rdrr.io/r/stats/Normal.html">dnorm()</a></code> 在每次调用时返回一个数字。因此，<code><a href="https://rdrr.io/r/stats/nlm.html">nlm()</a></code> 会最小化 <code><a href="https://rdrr.io/pkg/MQMF/man/negNLL.html">negNLL()</a></code>，而 <code><a href="https://rdrr.io/pkg/MQMF/man/negNLL.html">negNLL()</a></code> 又会调用 <code><a href="https://rdrr.io/pkg/MQMF/man/vB.html">vB()</a></code>。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb49"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co"># Fit the vB growth curve using maximum likelihood  </span></span>
<span><span class="va">pars</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span>Linf<span class="op">=</span><span class="fl">27.0</span>,K<span class="op">=</span><span class="fl">0.15</span>,t0<span class="op">=</span><span class="op">-</span><span class="fl">3.0</span>,sigma<span class="op">=</span><span class="fl">2.5</span><span class="op">)</span> <span class="co"># starting values  </span></span>
<span> <span class="co"># note, estimate for sigma is required for maximum likelihood  </span></span>
<span><span class="va">ansvB</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/nlm.html">nlm</a></span><span class="op">(</span>f<span class="op">=</span><span class="va">negNLL</span>,p<span class="op">=</span><span class="va">pars</span>,funk<span class="op">=</span><span class="va">vB</span>,observed<span class="op">=</span><span class="va">lengths</span>,ages<span class="op">=</span><span class="va">ages</span>,  </span>
<span>             typsize<span class="op">=</span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/magnitude.html">magnitude</a></span><span class="op">(</span><span class="va">pars</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/outfit.html">outfit</a></span><span class="op">(</span><span class="va">ansvB</span>,backtran<span class="op">=</span><span class="cn">FALSE</span>,title<span class="op">=</span><span class="st">"vB by minimum -veLL"</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>nlm solution:  vB by minimum -veLL 
minimum     :  747.0795 
iterations  :  26 
code        :  1 gradient close to 0, probably solution 
         par     gradient
1 26.8354474 4.490629e-07
2  0.1301554 1.659593e-05
3 -3.5868868 2.852562e-07
4  1.9500896 8.278354e-06</code></pre>
</div>
</div>
<p>如果回顾一下 von Bertalanffy 曲线的 <code><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq()</a></code> 例子，你会看到我们从358尾鱼的样本中得到SSQ值为 <span class="math inline">\(1361.421\)</span> （试试 <code>nrow(LatA)</code>）。因此 <code><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq()</a></code> 方法对 <span class="math inline">\(\sigma\)</span> 的估计值为 <span class="math inline">\(\sqrt{(1361.421/358)}=1.95009\)</span>，与预期的最大似然估计基本相同。</p>
<p>和以前一样，我们所需要做的就是把一个不同的生长曲线函数代入 <code><a href="https://rdrr.io/pkg/MQMF/man/negNLL.html">negNLL()</a></code> 就可得到结果。我们只需要记住在 <span class="math inline">\(p\)</span> 向量中包含第四个参数(<span class="math inline">\(\sigma\)</span> )。同样，使用正态随机误差得到的数值解与使用 <code><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq()</a></code> 方法得到的数值解本质上是相同的。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb51"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#Now fit the Michaelis-Menton curve  </span></span>
<span><span class="va">pars</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span>a<span class="op">=</span><span class="fl">23.0</span>,b<span class="op">=</span><span class="fl">1.0</span>,c<span class="op">=</span><span class="fl">1.0</span>,sigma<span class="op">=</span><span class="fl">3.0</span><span class="op">)</span> <span class="co"># Michaelis-Menton</span></span>
<span><span class="va">ansMM</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/nlm.html">nlm</a></span><span class="op">(</span>f<span class="op">=</span><span class="va">negNLL</span>,p<span class="op">=</span><span class="va">pars</span>,funk<span class="op">=</span><span class="va">mm</span>,observed<span class="op">=</span><span class="va">lengths</span>,ages<span class="op">=</span><span class="va">ages</span>,  </span>
<span>             typsize<span class="op">=</span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/magnitude.html">magnitude</a></span><span class="op">(</span><span class="va">pars</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/outfit.html">outfit</a></span><span class="op">(</span><span class="va">ansMM</span>,backtran<span class="op">=</span><span class="cn">FALSE</span>,title<span class="op">=</span><span class="st">"MM by minimum -veLL"</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>nlm solution:  MM by minimum -veLL 
minimum     :  743.6998 
iterations  :  34 
code        :  1 gradient close to 0, probably solution 
         par      gradient
1 20.7464280 -6.195246e-06
2  1.4183165  1.601881e-05
3  0.9029899  2.461309e-04
4  1.9317669 -3.359816e-06</code></pre>
</div>
</div>
<p>同样，解决方案的梯度很小，这增加了解决方案不仅仅是局部最小值的信心，所以我们应该画出解决方案，看看它与数据的相对拟合。</p>
<p>通过在数据点上绘制拟合曲线，数据不会遮挡线条。现在可以从该分析中产生的实际预测，也可以与残值一起制成表格。通过包含单个残差的平方，可以更清楚地看出哪些点(见记录3)可能具有最大的影响。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb53"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#plot optimum solutions for vB and mm. Fig 4.8  </span></span>
<span><span class="va">Age</span> <span class="op">&lt;-</span> <span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">max</a></span><span class="op">(</span><span class="va">ages</span><span class="op">)</span> <span class="co"># used in comparisons   </span></span>
<span><span class="va">predvB</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/vB.html">vB</a></span><span class="op">(</span><span class="va">ansvB</span><span class="op">$</span><span class="va">estimate</span>,<span class="va">Age</span><span class="op">)</span> <span class="co">#optimum solution  </span></span>
<span><span class="va">predMM</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/mm.html">mm</a></span><span class="op">(</span><span class="va">ansMM</span><span class="op">$</span><span class="va">estimate</span>,<span class="va">Age</span><span class="op">)</span> <span class="co">#optimum solution  </span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/parset.html">parset</a></span><span class="op">(</span><span class="op">)</span>                       <span class="co"># plot the deata points first</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">ages</span>,<span class="va">lengths</span>,xlab<span class="op">=</span><span class="st">"Age"</span>,ylab<span class="op">=</span><span class="st">"Length"</span>,type<span class="op">=</span><span class="st">"p"</span>,pch<span class="op">=</span><span class="fl">16</span>,  </span>
<span>     ylim<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">10</span>,<span class="fl">33</span><span class="op">)</span>,panel.first<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/graphics/grid.html">grid</a></span><span class="op">(</span><span class="op">)</span>,col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/grDevices/rgb.html">rgb</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">1</span><span class="op">/</span><span class="fl">3</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">Age</span>,<span class="va">predvB</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">4</span><span class="op">)</span>     <span class="co"># then add the growth curves</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">Age</span>,<span class="va">predMM</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">1</span>,lty<span class="op">=</span><span class="fl">2</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/legend.html">legend</a></span><span class="op">(</span><span class="st">"bottomright"</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"von Bertalanffy"</span>,<span class="st">"Michaelis-Menton"</span><span class="op">)</span>,  </span>
<span>       col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">4</span>,<span class="fl">1</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">3</span>,bty<span class="op">=</span><span class="st">"n"</span>,cex<span class="op">=</span><span class="fl">1.2</span>,lty<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">2</span><span class="op">)</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-4-8" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-4-8-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="04-application_files/figure-html/fig-4-8-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-4-8-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;4.8: 雌性 LatA 红鱼数据拟合的最优 von Bertalanffy 和 Michaelis-Menton 生长曲线。注意两条曲线在观测数据最集中的区域几乎重合。注意 y 轴从 10 开始。
</figcaption></figure>
</div>
</div>
</div>
<p>通常，我们会生成残差图来检查残差特征（ <a href="#fig-4-9" class="quarto-xref">图&nbsp;<span>4.9</span></a> ）。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb54"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co"># residual plot for vB curve   Fig 4.9  </span></span>
<span><span class="va">predvB</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/vB.html">vB</a></span><span class="op">(</span><span class="va">ansvB</span><span class="op">$</span><span class="va">estimate</span>,<span class="va">ages</span><span class="op">)</span> <span class="co"># predicted values for age data  </span></span>
<span><span class="va">resids</span> <span class="op">&lt;-</span> <span class="va">lengths</span> <span class="op">-</span> <span class="va">predvB</span>               <span class="co"># calculate vB residuals   </span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/plot1.html">plot1</a></span><span class="op">(</span><span class="va">ages</span>,<span class="va">resids</span>,type<span class="op">=</span><span class="st">"p"</span>,col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/grDevices/rgb.html">rgb</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">1</span><span class="op">/</span><span class="fl">3</span><span class="op">)</span>,xlim<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">43</span><span class="op">)</span>,  </span>
<span>      pch<span class="op">=</span><span class="fl">16</span>,xlab<span class="op">=</span><span class="st">"Ages Years"</span>,ylab<span class="op">=</span><span class="st">"Residuals"</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html">abline</a></span><span class="op">(</span>h<span class="op">=</span><span class="fl">0.0</span>,col<span class="op">=</span><span class="fl">1</span>,lty<span class="op">=</span><span class="fl">2</span><span class="op">)</span>    <span class="co"># emphasize the zero line</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-4-9" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-4-9-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="04-application_files/figure-html/fig-4-9-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-4-9-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;4.9: The residual values for von Bertalanffy curve fitted to the female LatA data. There is a clear pattern between the ages of 3 - 10, which reflects the nature of residuals when the mean expected length for a given age is constant and compared to these rounded length measurements
</figcaption></figure>
</div>
</div>
</div>
<p>生长数据的图（<a href="#fig-4-8" class="quarto-xref">图&nbsp;<span>4.8</span></a> 和 <a href="#fig-4-9" class="quarto-xref">图&nbsp;<span>4.9</span></a> ）中，数据的网格性质清楚地表明测量的长度精确到厘米，年龄四舍五入到最接近的整年。在 x 轴和 y 轴上的这种舍入与我们用经典的 y-on-x 方法拟合这些模型的问题相结合（Ricker, 1973），并且假设在 x 轴上的测量没有变化，但不幸的是，与年龄有关，这个假设是完全错误的。从本质上讲，我们将长度和年龄的变量视为离散的，而不是连续的，年龄数据是精确的，没有误差。这些特征值得进一步探索，但也有助于强调，当处理来自生活世界的数据时，很难收集，而且通常我们处理的信息并不完美。在渔业和现实世界的生态学中建立模型的真正诀窍是从那些不太完美的数据中获得有用和有趣的信息，并以一种站得住的方式这样做。</p>
</section></section><section id="对数正态似然" class="level2" data-number="4.7"><h2 data-number="4.7" class="anchored" data-anchor-id="对数正态似然">
<span class="header-section-number">4.7</span> 对数正态似然</h2>
<p>正态分布具有高于或低于预期平均值的加性残差误差，这是众所周知的，其特性构成了许多有关自然的直觉的基础。然而，在开发种群中发现的许多变量（CPUE、渔获量、努力量……）都呈现出高度倾斜的分布，中心倾向并不位于分布的中心（正态分布就是这样）。对数正态分布（Log-Normal distribution）是用于描述此类数据的一种非常常见的 PDF 分布：</p>
<p><span id="eq-4_20"><span class="math display">\[
L\left( x_i|m_i ,\sigma  \right)=\frac{1}{{x_i}\sigma \sqrt{2\pi }}{{e}^{\left( \frac{-{{\left(\log{(x_{i})}-\log{(m_i)}  \right)}^{2}}}{2\sigma^2 } \right)}}  
\qquad(4.20)\]</span></span></p>
<p>其中， <span class="math inline">\(L(x_i | m, \sigma\)</span> 为数据点 <span class="math inline">\(x_i\)</span> 的似然，<span class="math inline">\(m_i\)</span> 为 <span class="math inline">\(i\)</span> 点变量实例的中位数，<span class="math inline">\(m= e^{\mu}\)</span> （ <span class="math inline">\(\mu = \log(m)\)</span> ）。用 <span class="math inline">\(\log(x)\)</span> 的均值估算 <span class="math inline">\(\mu\)</span>，<span class="math inline">\(\sigma\)</span> 是 <span class="math inline">\(\log(x)\)</span> 的标准差。</p>
<p>对数正态似然方程（<a href="#eq-4_20" class="quarto-xref">公式&nbsp;<span>4.20</span></a> ）在视觉上与正态分布相似，不同之处在于对数正态分布的残差是乘性的，而不是加性的。详细地说，每个似然乘以观测值的倒数，观测值和期望值进行对数变换。具体上讲，每个似然乘以观测值的倒数，观测值和期望值进行对数变换。对观测数据和期望值的对数变换意味着，我们不是使用 <span class="math inline">\(x_i-m_i\)</span> 的变量，而是使用等价的 <span class="math inline">\(x_i/m_i\)</span> 计算残差。这意味着观测值除以预期值，而不是从观测值中减去预期值。所有这些残差都将是正值，并将围绕 1.0 的值变化。残差为 1.0 意味着数据点完全符合该数据点的预期中值。</p>
<section id="对数正态似然的简化" class="level3" data-number="4.7.1"><h3 data-number="4.7.1" class="anchored" data-anchor-id="对数正态似然的简化">
<span class="header-section-number">4.7.1</span> 对数正态似然的简化</h3>
<p>与正态似然一样，对数正态似然也可以简化，以方便后续计算：</p>
<p><span id="eq-4_21"><span class="math display">\[
-LL(x|\theta)=\frac{n}{2}\left( {\log}\left( 2\pi  \right)+2{\log}\left( {\hat{\sigma }} \right) + 1 \right)+\sum\limits_{i=1}^{n}{{\log}\left( {{x}_{i}} \right)}  
\qquad(4.21)\]</span></span></p>
<p><span class="math inline">\(\hat \sigma^2\)</span> 的最大似然估计是：</p>
<p><span id="eq-4_22"><span class="math display">\[
{{\hat{\sigma }}^{2}}=\sum\limits_{i=1}^{n}{\frac{{{\left( log\left( {{x}_{i}} \right)-log\left( {{{\hat{x}}}_{i}} \right) \right)}^{2}}}{n}}  
\qquad(4.22)\]</span></span></p>
<p>再次注意方差的最大似然估计用 <span class="math inline">\(n\)</span> 而非 <span class="math inline">\(n-1\)</span>。 <a href="#eq-4_21" class="quarto-xref">公式&nbsp;<span>4.21</span></a> 末尾的 <span class="math inline">\(\sum \log(x)\)</span> 项是常量，在拟合模型时经常忽略掉。如上所述，假设我们忽略 <span class="math inline">\(\sum \log(x)\)</span> 项，那么 <a href="#eq-4_22" class="quarto-xref">公式&nbsp;<span>4.22</span></a> 似乎与正态分布相同（ <a href="#eq-4_13" class="quarto-xref">公式&nbsp;<span>4.13</span></a> ）。然而，现在 <span class="math inline">\(\sigma\)</span> 需要将观测值和预测值进行对数转换（ <a href="#eq-4_22" class="quarto-xref">公式&nbsp;<span>4.22</span></a> ）。因此，只要在分析前对数据和预测值进行对数变换，我们就可以使用与正态似然相关的函数（如 <code><a href="https://rdrr.io/pkg/MQMF/man/negNLL.html">negNLL()</a></code>）来拟合使用对数正态残差的模型。不过，一般情况下，我们会使用 <code><a href="https://rdrr.io/pkg/MQMF/man/negLL.html">negLL()</a></code>，它需要对数变换的观测值和一个生成预测值对数的函数（见 <code><a href="https://rdrr.io/pkg/MQMF/man/negLL.html">?negLL</a></code>）。</p>
</section><section id="对数正态分布的性质" class="level3" data-number="4.7.2"><h3 data-number="4.7.2" class="anchored" data-anchor-id="对数正态分布的性质">
<span class="header-section-number">4.7.2</span> 对数正态分布的性质</h3>
<p>对于正态分布，我们知道分布的期望均值、中位数和模都是相同的，但对于对数正态分布，情况并非如此。给定一组连续变量 <span class="math inline">\(x\)</span> 的值，其中位数的估计值为</p>
<p><span id="eq-4_23"><span class="math display">\[
\text{median} =m = e^{\mu}
\qquad(4.23)\]</span></span></p>
<p>其中 <span class="math inline">\(\mu\)</span> 是 <span class="math inline">\(\log(x)\)</span> 的均值，对数正态分布的模定义为：</p>
<p><span id="eq-4_24"><span class="math display">\[
\text{mode} = \dfrac{m}{e^{\sigma^2}}=e^{(\mu-\sigma^2)}
\qquad(4.24)\]</span></span></p>
<p>其中 <span class="math inline">\(\sigma\)</span> 是 <span class="math inline">\(\log(x)\)</span> 的标准差。最终，对数正态分布的均值或期望值定义为：</p>
<p><span id="eq-4_25"><span class="math display">\[
\bar{x} = me^{(\sigma^2/2)} = e^{(\mu + \sigma^2/2)}
\qquad(4.25)\]</span></span></p>
<p>这些方程（ <a href="#eq-4_23" class="quarto-xref">公式&nbsp;<span>4.23</span></a> 到 <a href="#eq-4_25" class="quarto-xref">公式&nbsp;<span>4.25</span></a> ） 表明对数正态分布总是右斜（在模的右侧有一长尾）。此外，与正态分布相比，对数正态分布仅定义了 <span class="math inline">\(x\)</span> 为正值的情形，见 <a href="#fig-4-10" class="quarto-xref">图&nbsp;<span>4.10</span></a> 。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb55"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co"># meanlog and sdlog affects on mode and spread of lognormal Fig 4.10   </span></span>
<span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fl">0.05</span>,<span class="fl">5.0</span>,<span class="fl">0.01</span><span class="op">)</span>  <span class="co"># values must be greater than 0.0  </span></span>
<span><span class="va">y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Lognormal.html">dlnorm</a></span><span class="op">(</span><span class="va">x</span>,meanlog<span class="op">=</span><span class="fl">0</span>,sdlog<span class="op">=</span><span class="fl">1.2</span>,log<span class="op">=</span><span class="cn">FALSE</span><span class="op">)</span> <span class="co">#dlnorm=likelihoods  </span></span>
<span><span class="va">y2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Lognormal.html">dlnorm</a></span><span class="op">(</span><span class="va">x</span>,meanlog<span class="op">=</span><span class="fl">0</span>,sdlog<span class="op">=</span><span class="fl">1.0</span>,log<span class="op">=</span><span class="cn">FALSE</span><span class="op">)</span><span class="co">#from log-normal   </span></span>
<span><span class="va">y3</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Lognormal.html">dlnorm</a></span><span class="op">(</span><span class="va">x</span>,meanlog<span class="op">=</span><span class="fl">0</span>,sdlog<span class="op">=</span><span class="fl">0.6</span>,log<span class="op">=</span><span class="cn">FALSE</span><span class="op">)</span><span class="co">#distribution   </span></span>
<span><span class="va">y4</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Lognormal.html">dlnorm</a></span><span class="op">(</span><span class="va">x</span>,<span class="fl">0.75</span>,<span class="fl">0.6</span><span class="op">)</span>         <span class="co">#log=TRUE = log-likelihoods  </span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/parset.html">parset</a></span><span class="op">(</span>plots<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">2</span><span class="op">)</span><span class="op">)</span> <span class="co">#MQMF shortcut plot formatting function  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">x</span>,<span class="va">y3</span>,type<span class="op">=</span><span class="st">"l"</span>,lwd<span class="op">=</span><span class="fl">2</span>,panel.first<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/graphics/grid.html">grid</a></span><span class="op">(</span><span class="op">)</span>,  </span>
<span>     ylab<span class="op">=</span><span class="st">"Log-Normal Likelihood"</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">x</span>,<span class="va">y</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">2</span>,lty<span class="op">=</span><span class="fl">2</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">x</span>,<span class="va">y2</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">3</span>,lty<span class="op">=</span><span class="fl">3</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">x</span>,<span class="va">y4</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">4</span>,lty<span class="op">=</span><span class="fl">4</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/legend.html">legend</a></span><span class="op">(</span><span class="st">"topright"</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"meanlog sdlog"</span>,<span class="st">"    0.0      0.6"</span>,  </span>
<span><span class="st">"    0.0      1.0"</span>,<span class="st">"    0.0      1.2"</span>,<span class="st">"    0.75    0.6"</span><span class="op">)</span>,  </span>
<span>       col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">1</span>,<span class="fl">3</span>,<span class="fl">2</span>,<span class="fl">4</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">3</span>,bty<span class="op">=</span><span class="st">"n"</span>,cex<span class="op">=</span><span class="fl">1.0</span>,lty<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">1</span>,<span class="fl">3</span>,<span class="fl">2</span>,<span class="fl">4</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span>,<span class="va">y3</span>,type<span class="op">=</span><span class="st">"l"</span>,lwd<span class="op">=</span><span class="fl">2</span>,panel.first<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/graphics/grid.html">grid</a></span><span class="op">(</span><span class="op">)</span>,ylab<span class="op">=</span><span class="st">""</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span>,<span class="va">y</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">2</span>,lty<span class="op">=</span><span class="fl">2</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span>,<span class="va">y2</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">3</span>,lty<span class="op">=</span><span class="fl">3</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span>,<span class="va">y4</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">4</span>,lty<span class="op">=</span><span class="fl">4</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-4-10" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-4-10-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="04-application_files/figure-html/fig-4-10-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-4-10-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;4.10: 两幅展示对数正态概率密度函数的图。左图是一组不同参数集的似然分布，右图是前四个对数正态分布的对数变换版本。&nbsp;Two plots illustrating the Log-Normal probability density function. Left is a group of likelihood distributions for different parameter sets, while right is the log-transformed versions of these first four Log-Normal distributions.
</figcaption></figure>
</div>
</div>
</div>
<p>同样，可以从对数正态分布生成随机数，与之前一样，对数变换应生成正态分布, 如 <a href="#fig-4-11" class="quarto-xref">图&nbsp;<span>4.11</span></a> 所示。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb56"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">12354</span><span class="op">)</span> <span class="co"># plot random log-normal numbers as Fig 4.11  </span></span>
<span><span class="va">meanL</span> <span class="op">&lt;-</span> <span class="fl">0.7</span>;   <span class="va">sdL</span> <span class="op">&lt;-</span> <span class="fl">0.5</span>  <span class="co"># generate 5000 random log-normal   </span></span>
<span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Lognormal.html">rlnorm</a></span><span class="op">(</span><span class="fl">5000</span>,meanlog <span class="op">=</span> <span class="va">meanL</span>,sdlog <span class="op">=</span> <span class="va">sdL</span><span class="op">)</span> <span class="co"># values  </span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/parset.html">parset</a></span><span class="op">(</span>plots<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">2</span><span class="op">)</span><span class="op">)</span> <span class="co"># simplifies the plots par() definition  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html">hist</a></span><span class="op">(</span><span class="va">x</span><span class="op">[</span><span class="va">x</span> <span class="op">&lt;</span> <span class="fl">8.0</span><span class="op">]</span>,breaks<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">8</span>,<span class="fl">0.25</span><span class="op">)</span>,col<span class="op">=</span><span class="fl">0</span>,main<span class="op">=</span><span class="st">""</span><span class="op">)</span>   </span>
<span><span class="va">meanx</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">)</span>; <span class="va">sdx</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/sd.html">sd</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="va">outstat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">meanx</span><span class="op">-</span><span class="op">(</span><span class="va">sdx</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span><span class="op">)</span>,<span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">meanx</span><span class="op">)</span>,<span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">meanx</span><span class="op">+</span><span class="op">(</span><span class="va">sdx</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span><span class="op">/</span><span class="fl">2</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html">abline</a></span><span class="op">(</span>v<span class="op">=</span><span class="va">outstat</span>,col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">4</span>,<span class="fl">1</span>,<span class="fl">2</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">3</span>,lty<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">3</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/legend.html">legend</a></span><span class="op">(</span><span class="st">"topright"</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"mode"</span>,<span class="st">"median"</span>,<span class="st">"bias-correct"</span><span class="op">)</span>,  </span>
<span>       col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">4</span>,<span class="fl">1</span>,<span class="fl">2</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">3</span>,bty<span class="op">=</span><span class="st">"n"</span>,cex<span class="op">=</span><span class="fl">1.2</span>,lty<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">3</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="va">outh</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/graphics/hist.html">hist</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span>,breaks<span class="op">=</span><span class="fl">30</span>,col<span class="op">=</span><span class="fl">0</span>,main<span class="op">=</span><span class="st">""</span><span class="op">)</span>   <span class="co"># approxnormal  </span></span>
<span><span class="va">hans</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/addnorm.html">addnorm</a></span><span class="op">(</span><span class="va">outh</span>,<span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">)</span> <span class="co">#MQMF function; try  ?addnorm  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">hans</span><span class="op">$</span><span class="va">x</span>,<span class="va">hans</span><span class="op">$</span><span class="va">y</span>,lwd<span class="op">=</span><span class="fl">3</span>,col<span class="op">=</span><span class="fl">1</span><span class="op">)</span> <span class="co"># type addnorm into the console  </span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-4-11" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-4-11-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="04-application_files/figure-html/fig-4-11-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-4-11-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;4.11: 5000 个随机点的对数正态分布，meanlog=0.7，sdlog=0.5，显示偏差校正后的平均值、模式和中位数。右侧是拟合正态分布的对数变换版本。A Log-Normal distribution of 5000 random points with meanlog=0.7 and sdlog=0.5 showing the bias-corrected mean, the mode, and the median. On the right is the log-transformed version with a fitted normal distribution.
</figcaption></figure>
</div>
</div>
</div>
<p>我们可以检查输入参数的预期统计量，并将其与变量 outstat 中的参数估计进行比较。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb57"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#examine log-normal propoerties. It is a bad idea to reuse   </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">12345</span><span class="op">)</span> <span class="co">#'random' seeds, use getseed() for suggestions  </span></span>
<span><span class="va">meanL</span> <span class="op">&lt;-</span> <span class="fl">0.7</span>;   <span class="va">sdL</span> <span class="op">&lt;-</span> <span class="fl">0.5</span>  <span class="co">#5000 random log-normal values then  </span></span>
<span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Lognormal.html">rlnorm</a></span><span class="op">(</span><span class="fl">5000</span>,meanlog <span class="op">=</span> <span class="va">meanL</span>,sdlog <span class="op">=</span> <span class="va">sdL</span><span class="op">)</span> <span class="co">#try with only 500   </span></span>
<span><span class="va">meanx</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">)</span>; <span class="va">sdx</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/sd.html">sd</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"               Original  Sample \n"</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>               Original  Sample </code></pre>
</div>
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb59"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"Mode(x)     = "</span>,<span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">meanL</span> <span class="op">-</span> <span class="va">sdL</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span>,<span class="va">outstat</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>,<span class="st">"\n"</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>Mode(x)     =  1.568312 1.603512 </code></pre>
</div>
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb61"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"Median(x)   = "</span>,<span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">meanL</span><span class="op">)</span>,<span class="va">outstat</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span>,<span class="st">"\n"</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>Median(x)   =  2.013753 2.052606 </code></pre>
</div>
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb63"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"Mean(x)     = "</span>,<span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">meanL</span> <span class="op">+</span> <span class="op">(</span><span class="va">sdL</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span><span class="op">/</span><span class="fl">2</span><span class="op">)</span>,<span class="va">outstat</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span>,<span class="st">"\n"</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>Mean(x)     =  2.281881 2.322321 </code></pre>
</div>
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb65"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"Mean(log(x) =  0.7     "</span>,<span class="va">meanx</span>,<span class="st">"\n"</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>Mean(log(x) =  0.7      0.7001096 </code></pre>
</div>
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb67"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"sd(log(x)   =  0.5     "</span>,<span class="va">sdx</span>,<span class="st">"\n"</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>sd(log(x)   =  0.5      0.4944283 </code></pre>
</div>
</div>
<p>中位数与均值之间的差异，即 <span class="math inline">\(+ (\sigma^2/2)\)</span> 项，被称为偏差修正项，并试图通过将中心倾向的测量值进一步向右偏离模式来解释分布的向右偏斜。模似乎位于最高组的左侧，但这只是反映了 R 绘制直方图的方式（您可以增加一半的二进制宽度来解决这个视觉问题）。</p>
</section><section id="应用对数似然拟合曲线" class="level3" data-number="4.7.3"><h3 data-number="4.7.3" class="anchored" data-anchor-id="应用对数似然拟合曲线">
<span class="header-section-number">4.7.3</span> 应用对数似然拟合曲线</h3>
<p>我们可以使用 Penn 和 Caputi（1986）关于澳大利亚埃克斯茅斯湾老虎虾（<em>Penaeus semisulcatus</em>；MQMF 数据集 <em>tigers</em>）的产卵种群生物量及其补充量数据。种群补充关系通常假定为对数正态残差（有时为伽马分布，见后），通常在种群评估模型中得出。Penn 和 Caputi（1986 年）使用的是 Ricker 曲线，但作为替代方案，我们将尝试根据这些观测数据拟合 Beverton-Holt 种群补充量曲线（我们将在静态模型一章中更详细地研究种群补充量关系）。Beverton-Holt 种群补充量关系可以有多种形式，但在本例中我们将使用 <a href="#eq-4_26" class="quarto-xref">公式&nbsp;<span>4.26</span></a> ：</p>
<p><span id="eq-4_26"><span class="math display">\[
R_t=\frac{aB_t}{b+B_t}e^{N(0,\sigma^2)}   
\qquad(4.26)\]</span></span></p>
<p>其中 <span class="math inline">\(R_t\)</span> 是年 <span class="math inline">\(t\)</span> 的补充量， <span class="math inline">\(B_t\)</span> 是繁殖亲体量，它能生产出 <span class="math inline">\(R_t\)</span> 的补充量，<span class="math inline">\(a\)</span> 是渐近最大补充量水平，<span class="math inline">\(b\)</span> 是生产最大补充量的 50% 时的繁殖亲体量。残差误差是 <span class="math inline">\(\mu=0\)</span>、方差为 <span class="math inline">\(\sigma^2\)</span> 的对数分布，这些参数可以通过对数据进行模型拟合得到。我们将继续使用 <code><a href="https://rdrr.io/pkg/MQMF/man/negNLL.html">negNLL()</a></code>，但如果您检查一下 <code><a href="https://rdrr.io/pkg/MQMF/man/negNLL.html">negNLL()</a></code> 的代码，就会发现我们需要输入对数变换后的观测补充量水平，并编写一个简短函数来计算预测补充量水平的对数。我们将再次使用 <code><a href="https://rdrr.io/r/stats/nlm.html">nlm()</a></code> 来最小化 <code><a href="https://rdrr.io/pkg/MQMF/man/negNLL.html">negNLL()</a></code> 的输出结果。当我们考虑 <a href="#tbl-4-2" class="quarto-xref">表&nbsp;<span>4.2</span></a> 中的对数正态残差（观测补充量/预测补充量）时，注意到有两个特殊的残差值，一个接近 <span class="math inline">\(2.04\)</span>，另一个接近 <span class="math inline">\(0.44\)</span>。低点的潜在影响可能值得进一步研究，因为它是相对特殊的事件（事实上，它似乎受到气旋发生的影响，Penn 和 Caputi，1986 ）。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb69"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co"># fit a Beverton-Holt recruitment curve to tigers data Table 4.2  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="va">tigers</span><span class="op">)</span>   <span class="co"># use the tiger prawn data set  </span></span>
<span><span class="va">lbh</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">p</span>,<span class="va">biom</span><span class="op">)</span> <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="op">(</span><span class="va">p</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">*</span><span class="va">biom</span><span class="op">)</span><span class="op">/</span><span class="op">(</span><span class="va">p</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span> <span class="op">+</span> <span class="va">biom</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>  </span>
<span> <span class="co">#note we are returning the log of Beverton-Holt recruitment </span></span>
<span><span class="va">pars</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"a"</span><span class="op">=</span><span class="fl">25</span>,<span class="st">"b"</span><span class="op">=</span><span class="fl">4.5</span>,<span class="st">"sigma"</span><span class="op">=</span><span class="fl">0.4</span><span class="op">)</span>   <span class="co"># includes a sigma  </span></span>
<span><span class="va">best</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/nlm.html">nlm</a></span><span class="op">(</span><span class="va">negNLL</span>,<span class="va">pars</span>,funk<span class="op">=</span><span class="va">lbh</span>,observed<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">tigers</span><span class="op">$</span><span class="va">Recruit</span><span class="op">)</span>,  </span>
<span>            biom<span class="op">=</span><span class="va">tigers</span><span class="op">$</span><span class="va">Spawn</span>,typsize<span class="op">=</span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/magnitude.html">magnitude</a></span><span class="op">(</span><span class="va">pars</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/outfit.html">outfit</a></span><span class="op">(</span><span class="va">best</span>,backtran<span class="op">=</span><span class="cn">FALSE</span>,title<span class="op">=</span><span class="st">"Beverton-Holt Recruitment"</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>nlm solution:  Beverton-Holt Recruitment 
minimum     :  5.244983 
iterations  :  16 
code        :  1 gradient close to 0, probably solution 
        par      gradient
1 27.344523 -5.109267e-08
2  4.000166  1.265602e-07
3  0.351939  1.789283e-06</code></pre>
</div>
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb71"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">predR</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="fu">lbh</span><span class="op">(</span><span class="va">best</span><span class="op">$</span><span class="va">estimate</span>,<span class="va">tigers</span><span class="op">$</span><span class="va">Spawn</span><span class="op">)</span><span class="op">)</span>   </span>
<span> <span class="co">#note exp(lbh(...)) is the median because no bias adjustment  </span></span>
<span><span class="va">result</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span><span class="va">tigers</span>,<span class="va">predR</span>,<span class="va">tigers</span><span class="op">$</span><span class="va">Recruit</span><span class="op">/</span><span class="va">predR</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<div id="tbl-4-2" class="cell quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-4-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
表&nbsp;4.2: The Exmouth Gulf tiger prawn data set of spawning biomass with consequent recruitment levels, with the predicted recruitment level from the optimum model fit, along with the Log-Normal
</figcaption><div aria-describedby="tbl-4-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell-output-display">
<table class="do-not-create-environment cell table table-sm table-striped small">
<thead><tr class="header">
<th style="text-align: right;">SpawnB</th>
<th style="text-align: right;">Recruit</th>
<th style="text-align: right;">PredR</th>
<th style="text-align: right;">Residual</th>
</tr></thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">2.4</td>
<td style="text-align: right;">11.6</td>
<td style="text-align: right;">10.25393</td>
<td style="text-align: right;">1.1312736</td>
</tr>
<tr class="even">
<td style="text-align: right;">3.2</td>
<td style="text-align: right;">7.1</td>
<td style="text-align: right;">12.15284</td>
<td style="text-align: right;">0.5842256</td>
</tr>
<tr class="odd">
<td style="text-align: right;">3.9</td>
<td style="text-align: right;">14.3</td>
<td style="text-align: right;">13.49891</td>
<td style="text-align: right;">1.0593447</td>
</tr>
<tr class="even">
<td style="text-align: right;">5.7</td>
<td style="text-align: right;">19.1</td>
<td style="text-align: right;">16.06816</td>
<td style="text-align: right;">1.1886865</td>
</tr>
<tr class="odd">
<td style="text-align: right;">6.0</td>
<td style="text-align: right;">12.4</td>
<td style="text-align: right;">16.40644</td>
<td style="text-align: right;">0.7558007</td>
</tr>
<tr class="even">
<td style="text-align: right;">7.4</td>
<td style="text-align: right;">19.7</td>
<td style="text-align: right;">17.74969</td>
<td style="text-align: right;">1.1098783</td>
</tr>
<tr class="odd">
<td style="text-align: right;">8.2</td>
<td style="text-align: right;">37.5</td>
<td style="text-align: right;">18.37886</td>
<td style="text-align: right;">2.0403883</td>
</tr>
<tr class="even">
<td style="text-align: right;">10.0</td>
<td style="text-align: right;">18.4</td>
<td style="text-align: right;">19.53157</td>
<td style="text-align: right;">0.9420646</td>
</tr>
<tr class="odd">
<td style="text-align: right;">10.1</td>
<td style="text-align: right;">22.1</td>
<td style="text-align: right;">19.58698</td>
<td style="text-align: right;">1.1283005</td>
</tr>
<tr class="even">
<td style="text-align: right;">10.4</td>
<td style="text-align: right;">26.9</td>
<td style="text-align: right;">19.74859</td>
<td style="text-align: right;">1.3621223</td>
</tr>
<tr class="odd">
<td style="text-align: right;">11.3</td>
<td style="text-align: right;">19.2</td>
<td style="text-align: right;">20.19541</td>
<td style="text-align: right;">0.9507111</td>
</tr>
<tr class="even">
<td style="text-align: right;">12.8</td>
<td style="text-align: right;">21.0</td>
<td style="text-align: right;">20.83372</td>
<td style="text-align: right;">1.0079815</td>
</tr>
<tr class="odd">
<td style="text-align: right;">18.0</td>
<td style="text-align: right;">9.9</td>
<td style="text-align: right;">22.37262</td>
<td style="text-align: right;">0.4425051</td>
</tr>
<tr class="even">
<td style="text-align: right;">24.0</td>
<td style="text-align: right;">26.8</td>
<td style="text-align: right;">23.43802</td>
<td style="text-align: right;">1.1434411</td>
</tr>
</tbody>
</table>
</div>
</div>
</figure>
</div>
</div>
<p>我们可以绘制出解，直观地比较数据拟合结果：</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb72"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co"># Fig 4.12 visual examination of the fit to the tigers data  </span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/plot1.html">plot1</a></span><span class="op">(</span><span class="va">tigers</span><span class="op">$</span><span class="va">Spawn</span>,<span class="va">predR</span>,xlab<span class="op">=</span><span class="st">"Spawning Biomass"</span>,<span class="st">"Recruitment"</span>,  </span>
<span>      maxy<span class="op">=</span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/getmax.html">getmax</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">predR</span>,<span class="va">tigers</span><span class="op">$</span><span class="va">Recruit</span><span class="op">)</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">2</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html">points</a></span><span class="op">(</span><span class="va">tigers</span><span class="op">$</span><span class="va">Spawn</span>,<span class="va">tigers</span><span class="op">$</span><span class="va">Recruit</span>,pch<span class="op">=</span><span class="fl">16</span>,cex<span class="op">=</span><span class="fl">1.1</span>,col<span class="op">=</span><span class="fl">2</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-4-12" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-4-12-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="04-application_files/figure-html/fig-4-12-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-4-12-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;4.12: The optimum fit to the Exmouth Gulf tiger prawns Beverton-Holt stock recruitment relationship using log-normal likelihoods.
</figcaption></figure>
</div>
</div>
</div>
</section><section id="应用对数正态误差拟合动态模型" class="level3" data-number="4.7.4"><h3 data-number="4.7.4" class="anchored" data-anchor-id="应用对数正态误差拟合动态模型">
<span class="header-section-number">4.7.4</span> 应用对数正态误差拟合动态模型</h3>
<p>本例中，我们将回顾第 <a href="07-spm.html" class="quarto-xref"><span>7</span></a> 章“剩余生产模型 ”中的一个例子（并在第 <a href="03-simpopmodel.html" class="quarto-xref"><span>3</span></a> 章“简单种群模型 ”中查看）。具体而言，我们将使用所谓的Schaefer（1954，1957）剩余生产模型（Hilborn 和 Walters，1992；Polacheck 等，1993；Prager，1994；Haddon，2011）。用于描述 Schaefer 模型的最简单方程包含两个项：</p>
<p><span id="eq-4_27"><span class="math display">\[
\begin{aligned}  
  {B_0} &amp;= {B_{init}} \\   
  {B_{t+1}} &amp;= {B_t}+r{B_t}\left( 1-\frac{{B_t}}{K} \right)-{C_t}   
\end{aligned}    
\qquad(4.27)\]</span></span></p>
<p>其中 <span class="math inline">\(r\)</span> 是内禀自然增长率（种群增长率项），<span class="math inline">\(K\)</span> 是环境容纳量或未被捕捞时的生物量，一般用 <span class="math inline">\(B_0\)</span> 表示（注意的是，这里的 <span class="math inline">\(B_0\)</span> 简单地表示 <span class="math inline">\(t=0\)</span> 时的初始生物量），<span class="math inline">\(B_{init}\)</span> 可能已衰退低于 <span class="math inline">\(K\)</span>。<span class="math inline">\(B_t\)</span> 表示年 <span class="math inline">\(t\)</span> 可用生物量，那么 <span class="math inline">\(B_{init}\)</span> 是第一年中可用生物量。如果资源未被捕捞，那么 <span class="math inline">\(B_{init} =K\)</span>，但在其他情况下，它将构成一个单独的模型参数。最后， <span class="math inline">\(C_t\)</span> 是年 <span class="math inline">\(t\)</span> 中捕捞的总获量。当然，时间步长不必以年为单位，可能需要更短的时间，这取决于相关物种的生物学特性，不过，使用年是很常见的。注意 <a href="#eq-4_27" class="quarto-xref">公式&nbsp;<span>4.27</span></a> 中没有误差项。这意味着种群动态是确定的，渔获量是已知的，没有误差。估算该模型的参数就是使用观察误差估算的一个例子。</p>
<p><a href="#eq-4_27" class="quarto-xref">公式&nbsp;<span>4.27</span></a> 中的简单动态模型，在所需参数（<span class="math inline">\(B_{init}\)</span>、<span class="math inline">\(r\)</span> 及 <span class="math inline">\(K\)</span> ）已知时，将初始生物量向前推算，生成种群生物量水平的时间序列。如果有相对丰度指数的时间序列（可能是调查得出的生物量估计值，也可能是渔业相关数据得出的标准化单位努力量渔获量（CPUE）），就可以将剩余产量模型与自然界的观测结果进行比较。在下面的例子中，我们将使用 <strong>MQMF</strong> 数据集 <em>abdat</em> 中潜水捕捞无脊椎动物的渔获量和 CPUE。假设相对丰度指数与种群生物量之间存在简单的线性关系：</p>
<p><span id="eq-4_28"><span class="math display">\[
{I_t}=\frac{C_t}{E_t}=q{B_t}e^{\varepsilon}{ \;\;\;\;\;\;  \text{or}  \;\;\;\;\;\; } {C_t}=q{E_t}{B_t}e^{\varepsilon}  
\qquad(4.28)\]</span></span></p>
<p>其中 <span class="math inline">\(I_t\)</span> 是年 <span class="math inline">\(t\)</span> 的观测 CPUE，<span class="math inline">\(E_t\)</span> 是年 <span class="math inline">\(t\)</span> 的努力量， <span class="math inline">\(q\)</span> 为可捕系数（Arreguin-Sanchez, 1996），<span class="math inline">\(e^{\varepsilon}\)</span> 表示CPUE 和 种群生物量关系的对数正态残差误差。 该 <span class="math inline">\(q\)</span> 可以作为一个参数直接估算，尽管也有所谓的闭合形式估算值（Polacheck 等，1993）：</p>
<p><span id="eq-4_29"><span class="math display">\[
q={e}^{\frac{1}{n}{\sum{\log}\left( \frac{{{I}_{t}}}{{{{\hat{B}}}_{t}}} \right)}}=\exp \left( {\frac{1}{n}}\sum{\log}\left( \frac{{I}_{t}}{\hat{B}_{t}} \right) \right)  
\qquad(4.29)\]</span></span></p>
<p>基本上就是观测到的 CPUE 向量的几何平均数除以预测的每年生物量水平。使用这种封闭形式的一个好处是，在拟合数据时，模型需要估计的参数较少。它还强调 <span class="math inline">\(q\)</span> 参数只是一个比例因子，反映了可开发生物量与相对丰度指数之间的假定线性关系。如果假定存在非线性关系，则需要更复杂的可捕量表示方法。</p>
<p>上例中拟合的种群增殖曲线使用了一个相对简单的方程和相关函数作为拟合模型，但模型中不涉及动态变化。当试图将 <a href="#eq-4_27" class="quarto-xref">公式&nbsp;<span>4.27</span></a> 至 <a href="#eq-4_29" class="quarto-xref">公式&nbsp;<span>4.29</span></a> 中描述的剩余产量模型与观测到的 CPUE 和渔获量数据进行拟合时，得出预测 CPUE 的函数需要更加复杂，因为它需要包含种群动态。对于简单的非动态模型，自变量和因变量的使用相对简单。在此，我们将说明（并强化）在将动态模型拟合到数据时需要做哪些工作。</p>
<p>我们将使用名为 <em>abdat</em> 的 <strong>MQMF</strong> 数据集，该数据集因包含鲍鱼数据而得名。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb73"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="va">abdat</span><span class="op">)</span>  <span class="co"># plot abdat fishery data using a MQMF helper  Fig 4.13  </span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/plotspmdat.html">plotspmdat</a></span><span class="op">(</span><span class="va">abdat</span><span class="op">)</span> <span class="co"># function to quickly plot catch and cpue</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-4-13" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-4-13-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="04-application_files/figure-html/fig-4-13-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-4-13-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;4.13: The abdat data set plotting the catch and the cpue through time to illustrate their relationship.
</figcaption></figure>
</div>
</div>
</div>
<p>我们需要在 <code><a href="https://rdrr.io/r/stats/nlm.html">nlm()</a></code> 中使用两个函数来找到最佳参数。您应该检查每个函数的代码，并了解它们与所用方程的关系。第一个函数用于计算预测 cpue 的对数（我们使用 <code><a href="https://rdrr.io/pkg/MQMF/man/simpspm.html">simpspm()</a></code>），第二个函数用于计算 <em>-veLL</em>，其中我们使用对数正态残差误差来表示 cpue 数据的残差（因此我们使用 <code><a href="https://rdrr.io/pkg/MQMF/man/negLL.html">negLL()</a></code>；将其代码与 <code><a href="https://rdrr.io/pkg/MQMF/man/negNLL.html">negNLL()</a></code> 进行比较）。请注意模型参数将进行对数变换的预期，我们这样做是因为它通常比使用 <em>typsize</em> 选项更稳定。你应该通过尝试不同的起始点来实验这段代码。你应该仔细检查 <code>simpspm</code> 和 <code><a href="https://rdrr.io/pkg/MQMF/man/negLL.html">negLL()</a></code> 的代码，直到理解它们之间的相互作用，并相信您可以用不同的数据集重复这一分析（参见第 <a href="07-spm.html" class="quarto-xref"><span>7</span></a> 章“剩余产量模型 ” ）。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb74"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co"># Use log-transformed parameters for increased stability when  </span></span>
<span> <span class="co"># fitting the surplus production model to the abdat data-set  </span></span>
<span><span class="va">param</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span>r<span class="op">=</span> <span class="fl">0.42</span>,K<span class="op">=</span><span class="fl">9400</span>,Binit<span class="op">=</span><span class="fl">3400</span>,sigma<span class="op">=</span><span class="fl">0.05</span><span class="op">)</span><span class="op">)</span>   </span>
<span><span class="va">obslog</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">abdat</span><span class="op">$</span><span class="va">cpue</span><span class="op">)</span> <span class="co">#input log-transformed observed data  </span></span>
<span><span class="va">bestmod</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/nlm.html">nlm</a></span><span class="op">(</span>f<span class="op">=</span><span class="va">negLL</span>,p<span class="op">=</span><span class="va">param</span>,funk<span class="op">=</span><span class="va">simpspm</span>,indat<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/matrix.html">as.matrix</a></span><span class="op">(</span><span class="va">abdat</span><span class="op">)</span>,  </span>
<span>               logobs<span class="op">=</span><span class="va">obslog</span><span class="op">)</span>  <span class="co"># no typsize, or iterlim needed  </span></span>
<span> <span class="co">#backtransform estimates, outfit's default, as log-transformed   </span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/outfit.html">outfit</a></span><span class="op">(</span><span class="va">bestmod</span>,backtran <span class="op">=</span> <span class="cn">TRUE</span>,title<span class="op">=</span><span class="st">"abdat"</span><span class="op">)</span>        <span class="co"># in param  </span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>nlm solution:  abdat 
minimum     :  -41.37511 
iterations  :  20 
code        :  2 &gt;1 iterates in tolerance, probably solution 
         par      gradient   transpar
1 -0.9429555  6.743051e-06    0.38948
2  9.1191569 -9.223729e-05 9128.50173
3  8.1271026  1.059182e-04 3384.97779
4 -3.1429030 -8.116218e-07    0.04316</code></pre>
</div>
</div>
<p>将观察到的数据与最优模型的预测值对比绘制成图总是一个好主意。在这里，我们将它们绘制成对数比例，以准确说明拟合结果，并帮助确定哪些点与预测值相差最大。由于很少有人能直观地掌握对数标度，因此在标称标度上绘制数据和拟合结果也是一个好主意，此外，我们通常还会绘制残差图来寻找规律。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb76"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co"># Fig 4.14 Examine fit of predicted to data  </span></span>
<span><span class="va">predce</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/simpspm.html">simpspm</a></span><span class="op">(</span><span class="va">bestmod</span><span class="op">$</span><span class="va">estimate</span>,<span class="va">abdat</span><span class="op">)</span> <span class="co">#compare obs vs pred  </span></span>
<span><span class="va">ymax</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/getmax.html">getmax</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">predce</span>,<span class="va">obslog</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/plot1.html">plot1</a></span><span class="op">(</span><span class="va">abdat</span><span class="op">$</span><span class="va">year</span>,<span class="va">obslog</span>,type<span class="op">=</span><span class="st">"p"</span>,maxy<span class="op">=</span><span class="va">ymax</span>,ylab<span class="op">=</span><span class="st">"Log(CPUE)"</span>,  </span>
<span>     xlab<span class="op">=</span><span class="st">"Year"</span>,cex<span class="op">=</span><span class="fl">0.9</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">abdat</span><span class="op">$</span><span class="va">year</span>,<span class="va">predce</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">2</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-4-14" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-4-14-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="04-application_files/figure-html/fig-4-14-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-4-14-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;4.14: The optimum fit of the Schaefer surplus production model to the abdat data set plotted in log-space on the y-axis.
</figcaption></figure>
</div>
</div>
</div>
</section></section><section id="二项式分布的似然" class="level2" data-number="4.8"><h2 data-number="4.8" class="anchored" data-anchor-id="二项式分布的似然">
<span class="header-section-number">4.8</span> 二项式分布的似然</h2>
<p>到目前为止，通过正态分布和对数正态分布，我们一直在处理连续变量（如产卵生物量和 cpue）特定值的似然。当然，有些观测结果和事件在本质上是离散的。常见的例子包括动物是否成熟、是否有标签或类似的 “是”/“否”情况。与连续变量不同，当使用离散型分布（如二项分布）计算特定值（如在 <span class="math inline">\(n\)</span> 个观测样本中看到 <span class="math inline">\(m\)</span> 个标记的似然）的似然时，它们是真正的概率，而不仅仅是概率密度。这样，就避免了理解并非真实概率的似然的复杂性；这可能就是为什么许多介绍极大似然方法的文章倾向于从使用二项分布的例子开始的原因。</p>
<p>在观察结果有真有假的情况下（所谓伯努利试验；例如，捕获的鱼要么有标记，要么没有标记），<span class="math inline">\(n\)</span> 次观察（试验）的成功概率为参数 <span class="math inline">\(p\)</span>，那么通常最好使用二项分布来描述观察结果。二项分布概率密度函数产生真实概率，有两个参数：<span class="math inline">\(n\)</span>，即试验次数（样本大小）；<span class="math inline">\(p\)</span>，即试验成功的概率（事件/观察结果证明为真）：</p>
<p><span id="eq-4_30"><span class="math display">\[
P\left\{ m|n,p \right\}=\left[ \frac{n!}{m!\left( n-m \right)!} \right]{{p}^{m}}{{\left( 1-p \right)}^{\left( n-m \right)}}  
\qquad(4.30)\]</span></span></p>
<p>读为给定 <span class="math inline">\(n\)</span> 次试验中 <span class="math inline">\(m\)</span> 个事件为真的概率（如 <span class="math inline">\(n\)</span> 个观测样本中出现 <span class="math inline">\(m\)</span> 个标记），其中 <span class="math inline">\(p\)</span> 是事件为真的概率。项 <span class="math inline">\((1-p)\)</span> 常写作 <span class="math inline">\(q\)</span>，即 <span class="math inline">\((1-p) =q\)</span>。 “！”符号表示阶乘。方括号中的项是组合数，是从 <span class="math inline">\(n\)</span> 个元素中一次取 <span class="math inline">\(m\)</span> 个元素形成的组合数，有时写成:</p>
<p><span id="eq-4_31"><span class="math display">\[
\left( \begin{matrix}  
   n  \\  
   m  \\  
\end{matrix} \right)=\frac{n!}{m!\left( n-m \right)!}  
\qquad(4.31)\]</span></span></p>
<p>总有 <span class="math inline">\(n \geq m\)</span> 的情况，因为一个人不可能有比试验更多的成功。</p>
<section id="二项式似然的示例" class="level3" data-number="4.8.1"><h3 data-number="4.8.1" class="anchored" data-anchor-id="二项式似然的示例">
<span class="header-section-number">4.8.1</span> 二项式似然的示例</h3>
<p>作为第一个示例子，我们可以从一个种群中只捕捞雄性（澳大利亚昆士兰州捕捞泥蟹（<em>Scylla serrata</em>）就是一个例子）。人们可能会问，这种管理策略是否会对特定种群中合法规格动物的性别比例产生负面影响。在一个假设的 <span class="math inline">\(60\)</span> 只动物样本中，如果我们获得了 <span class="math inline">\(40\)</span> 只雌性动物，而只有 <span class="math inline">\(20\)</span> 只雄性动物，那么我们是否可以得出结论，渔业对性别比例产生了影响？回答这个问题的一种方法是研究出现这种结果的相对似然（虽然二项式似然是真正的概率，但我们仍将其称为似然）。典型的性别比为 <span class="math inline">\(1:1\)</span>，这意味着我们可能会期望从 <span class="math inline">\(60\)</span> 个样本中找到 <span class="math inline">\(30\)</span> 只雄性动物，因此，如果我们在本例中宣布找到一只雄性动物是成功的，我们就应该研究不同 <span class="math inline">\(m\)</span> 值的似然（ <span class="math inline">\(n\)</span> 个样本中雄性个体数），并确定在样本中找到 <span class="math inline">\(m=20\)</span> 的相对似然。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb77"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#Use Binomial distribution to test biased sex-ratio Fig 4.15  </span></span>
<span><span class="va">n</span> <span class="op">&lt;-</span> <span class="fl">60</span>    <span class="co"># a sample of 60 animals  </span></span>
<span><span class="va">p</span> <span class="op">&lt;-</span> <span class="fl">0.5</span>   <span class="co"># assume a sex-ration of 1:1   </span></span>
<span><span class="va">m</span> <span class="op">&lt;-</span> <span class="fl">1</span><span class="op">:</span><span class="fl">60</span>  <span class="co"># how likely is each of the 60 possibilites?  </span></span>
<span><span class="va">binom</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Binomial.html">dbinom</a></span><span class="op">(</span><span class="va">m</span>,<span class="va">n</span>,<span class="va">p</span><span class="op">)</span>   <span class="co"># get individual likelihoods  </span></span>
<span><span class="va">cumbin</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Binomial.html">pbinom</a></span><span class="op">(</span><span class="va">m</span>,<span class="va">n</span>,<span class="va">p</span><span class="op">)</span>  <span class="co"># get cumulative distribution  </span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/plot1.html">plot1</a></span><span class="op">(</span><span class="va">m</span>,<span class="va">binom</span>,type<span class="op">=</span><span class="st">"h"</span>,xlab<span class="op">=</span><span class="st">"Number of Males"</span>,ylab<span class="op">=</span><span class="st">"Probability"</span><span class="op">)</span>   </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html">abline</a></span><span class="op">(</span>v<span class="op">=</span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/which.closest.html">which.closest</a></span><span class="op">(</span><span class="fl">0.025</span>,<span class="va">cumbin</span><span class="op">)</span>,col<span class="op">=</span><span class="fl">2</span>,lwd<span class="op">=</span><span class="fl">2</span><span class="op">)</span> <span class="co"># lower 95% CI  </span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-4-15" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-4-15-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="04-application_files/figure-html/fig-4-15-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-4-15-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;4.15: 如果性别比为 1:1，那么在 60 只动物样本中只观察到 20 只雄性动物的可能性有多大。垂直红线是 95% 置信区间的下限，表明只观察到 20 只的可能性不大。A graphical answer to the question of how likely is it to obtain only 20 males in a sample of 60 animals if the sex ratio is 1:1. The vertical red line is the lower bound of the 95% confidence intervals, which suggests that observing only 20 would be unlikely.
</figcaption></figure>
</div>
</div>
</div>
<p>我们可以通过检查 <em>binom</em>（单个似然）和 <em>cumbin</em>（累积二项式似然）的内容来研究具体值。但很明显，如果性别比为 <span class="math inline">\(1:1\)</span>，那么获得少于 <span class="math inline">\(18\)</span> 或多于 <span class="math inline">\(42\)</span> 的可能性都非常小。事实上，只有 <span class="math inline">\(20\)</span> 个雄性的可能性不到 95%。通过研究 <em>binom[20]</em>，我们可以看到，得到整整 <span class="math inline">\(20\)</span> 个雄性（假设性别比为 1:1）的似然刚刚超过 <span class="math inline">\(1%\)</span> 的三分之一（<span class="math inline">\(0.003636\)</span>），而 <em>cumbin[20]</em> 告诉我们，得到 <span class="math inline">\(20\)</span> 个或更少的概率只有 <span class="math inline">\(0.006745\)</span>）。我们当然有理由说，从这一群中抽取样本的性别比率出现了下降。我们还在累积概率约为 <span class="math inline">\(0.025\)</span> 的地方划了一条垂直线。由于我们对上限并不感兴趣，我们可以使用 <span class="math inline">\(0.05\)</span>，这样会更保守一些。但是，这种上限具有任意性，真正重要的是，捕鱼对性别比率没有重要影响的证据权重是多少？</p>
<p>请注意，当样本相对较大时，二项分布会变得对称。不过，尾部比正态分布窄。对于较小的样本，尤其是低 <span class="math inline">\(p\)</span> 值，二项分布可能会高度倾斜，零成功率值具有特定的概率。</p>
<p>与其确定一个给定的性别比例是否合理，我们可以寻找使 <span class="math inline">\(60\)</span> 个样本中有 <span class="math inline">\(20\)</span> 个雄性的似然最大化的性别比例（ <span class="math inline">\(p\)</span> 值）。我们期望它是 <span class="math inline">\(20/60(0.333…)\)</span>，但仍然有兴趣知道合理值的范围。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb78"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co"># plot relative likelihood of different p values Fig 4.16  </span></span>
<span><span class="va">n</span> <span class="op">&lt;-</span> <span class="fl">60</span>  <span class="co"># sample size; should really plot points as each independent   </span></span>
<span><span class="va">m</span> <span class="op">&lt;-</span> <span class="fl">20</span>  <span class="co"># number of successes = finding a male  </span></span>
<span><span class="va">p</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fl">0.1</span>,<span class="fl">0.6</span>,<span class="fl">0.001</span><span class="op">)</span> <span class="co">#range of probability we find a male   </span></span>
<span><span class="va">lik</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Binomial.html">dbinom</a></span><span class="op">(</span><span class="va">m</span>,<span class="va">n</span>,<span class="va">p</span><span class="op">)</span>    <span class="co"># R function for binomial likelihoods  </span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/plot1.html">plot1</a></span><span class="op">(</span><span class="va">p</span>,<span class="va">lik</span>,type<span class="op">=</span><span class="st">"l"</span>,xlab<span class="op">=</span><span class="st">"Prob. of 20 Males"</span>,ylab<span class="op">=</span><span class="st">"Prob."</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html">abline</a></span><span class="op">(</span>v<span class="op">=</span><span class="va">p</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/which.min.html">which.max</a></span><span class="op">(</span><span class="va">lik</span><span class="op">)</span><span class="op">]</span>,col<span class="op">=</span><span class="fl">2</span>,lwd<span class="op">=</span><span class="fl">2</span><span class="op">)</span> <span class="co"># try "p" instead of "l"  </span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-4-16" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-4-16-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="04-application_files/figure-html/fig-4-16-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-4-16-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;4.16: Representing the relative likelihood of the proportional sex-ratio when a sample exhibits only 20 males out of 60. Note that the likelihood of there having been a sex-ratio of 0.5 is confirmed as very low.
</figcaption></figure>
</div>
</div>
</div>
<p>当我们只搜索一个参数时，使用 <code><a href="https://rdrr.io/r/stats/optimize.html">optimize()</a></code>（或 <code><a href="https://rdrr.io/r/stats/optimize.html">optimise()</a></code>，查看 <code><a href="https://rdrr.io/r/stats/optimize.html">?optimize</a></code>）比使用 <code><a href="https://rdrr.io/r/stats/nlm.html">nlm()</a></code> 更有效。它需要一个函数，该函数的第一个项是要在定义的区间内最小化或最大化的值，在本例中为 <span class="math inline">\(p\)</span>，定义的区间内最小化或最大化的值，因此 <code><a href="https://rdrr.io/r/stats/Binomial.html">dbinom()</a></code> 使用了简单的封装函数。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb79"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co"># find best estimate using optimize to finely search an interval  </span></span>
<span><span class="va">n</span> <span class="op">&lt;-</span> <span class="fl">60</span>; <span class="va">m</span> <span class="op">&lt;-</span> <span class="fl">20</span>  <span class="co"># trials and successes  </span></span>
<span><span class="va">p</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.1</span>,<span class="fl">0.6</span><span class="op">)</span> <span class="co">#range of probability we find a male   </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/stats/optimize.html">optimize</a></span><span class="op">(</span><span class="kw">function</span><span class="op">(</span><span class="va">p</span><span class="op">)</span> <span class="op">{</span><span class="fu"><a href="https://rdrr.io/r/stats/Binomial.html">dbinom</a></span><span class="op">(</span><span class="va">m</span>,<span class="va">n</span>,<span class="va">p</span><span class="op">)</span><span class="op">}</span>,interval<span class="op">=</span><span class="va">p</span>,maximum<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>$maximum
[1] 0.3333168

$objective
[1] 0.1087251</code></pre>
</div>
</div>
</section><section id="开放海湾幼年海狗种群数量" class="level3" data-number="4.8.2"><h3 data-number="4.8.2" class="anchored" data-anchor-id="开放海湾幼年海狗种群数量">
<span class="header-section-number">4.8.2</span> 开放海湾幼年海狗种群数量</h3>
<p>与其使用第二个假设的例子，不如使用一个真实案例的数据更有意思。对新西兰南岛西海岸开阔湾群岛上的新西兰海狗（<em>Arctocephalus forsteri</em>）幼崽种群进行了适当的研究（Greaves，1992 ；York 和 Kozlof，1987 ）。新西兰海狗在 19 世纪被大量捕杀后一直在恢复，目前在南岛和北岛都发现了新的出没地点。1894 年，新西兰正式停止了对毛皮海豹的捕猎，1978 年开始在新西兰专属经济区内对其进行全面保护（Greaves，1992 ）。格里夫斯女士与新西兰保护部合作，前往其中一个近海岛屿，并在岛上度过了一周的时间。她剪掉了 151 只海狗幼崽头上的一小块护毛，给它们做了标记，然后对海狗群进行了多次巡视，以重新观察被标记的海狗（Greaves，1992 ）。每次巡视都是进一步的抽样调查，每次抽样调查都发现了不同数量的被标记动物。问题是：海狗幼崽种群的数量（<span class="math inline">\(X\)</span>）是多少？</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb81"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co"># Juvenile furseal data-set Greaves, 1992.  Table 4.3  </span></span>
<span><span class="va">furseal</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">32</span>,<span class="fl">222</span>,<span class="fl">1020</span>,<span class="fl">704</span>,<span class="fl">1337</span>,<span class="fl">161.53</span>,<span class="fl">31</span>,<span class="fl">181</span>,<span class="fl">859</span>,<span class="fl">593</span>,<span class="fl">1125</span>,  </span>
<span>             <span class="fl">135.72</span>,<span class="fl">29</span>,<span class="fl">185</span>,<span class="fl">936</span>,<span class="fl">634</span>,<span class="fl">1238</span>,<span class="fl">153.99</span><span class="op">)</span>  </span>
<span><span class="va">columns</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"tagged(m)"</span>,<span class="st">"Sample(n)"</span>,<span class="st">"Population(X)"</span>,  </span>
<span>             <span class="st">"95%Lower"</span>,<span class="st">"95%Upper"</span>,<span class="st">"StErr"</span><span class="op">)</span>  </span>
<span><span class="va">furs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="va">furseal</span>,nrow<span class="op">=</span><span class="fl">3</span>,ncol<span class="op">=</span><span class="fl">6</span>,dimnames<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="cn">NULL</span>,<span class="va">columns</span><span class="op">)</span>,  </span>
<span>               byrow<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb82"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">knitr</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/knitr/man/kable.html">kable</a></span><span class="op">(</span><span class="va">furs</span><span class="op">)</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div id="tbl-4-3" class="cell quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-4-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
表&nbsp;4.3: 格雷夫斯（1992）在新西兰南岛西海岸开阔湾岛对新西兰海狗幼崽进行的三次计数。种群估计值、标准误差和置信区间均采用确定性方程计算得出。前两行为独立计数，后一行为六次独立计数的平均值。Three of the counts of New Zealand fur seal pups made by Greaves (1992) on Open Bay Island, West Coast, South Island, New Zealand. The Population estimates, Standard error and confidence intervals were calculated using deterministic equations. The top two rows were independent counts while the bottom row averages six separate counts.
</figcaption><div aria-describedby="tbl-4-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell-output-display">
<table class="do-not-create-environment cell table table-sm table-striped small">
<thead><tr class="header">
<th style="text-align: right;">tagged(m)</th>
<th style="text-align: right;">Sample(n)</th>
<th style="text-align: right;">Population(X)</th>
<th style="text-align: right;">95%Lower</th>
<th style="text-align: right;">95%Upper</th>
<th style="text-align: right;">StErr</th>
</tr></thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">32</td>
<td style="text-align: right;">222</td>
<td style="text-align: right;">1020</td>
<td style="text-align: right;">704</td>
<td style="text-align: right;">1337</td>
<td style="text-align: right;">161.53</td>
</tr>
<tr class="even">
<td style="text-align: right;">31</td>
<td style="text-align: right;">181</td>
<td style="text-align: right;">859</td>
<td style="text-align: right;">593</td>
<td style="text-align: right;">1125</td>
<td style="text-align: right;">135.72</td>
</tr>
<tr class="odd">
<td style="text-align: right;">29</td>
<td style="text-align: right;">185</td>
<td style="text-align: right;">936</td>
<td style="text-align: right;">634</td>
<td style="text-align: right;">1238</td>
<td style="text-align: right;">153.99</td>
</tr>
</tbody>
</table>
</div>
</div>
</figure>
</div>
</div>
<p>所有标记实验的常规假设均适用；即我们处理的是一个封闭种群–没有迁入或迁出，在实验期间没有自然死亡或标记死亡，没有标记丢失，标记不会影响动物的重捕概率。最后，在不同的日子里，幼崽可以四处走动，因此看到的动物都是相互独立的。格里夫斯（1992）估计了所有这些影响，并在她的分析中考虑了这些影响。在对标记进行标记和重新观察后，利用彼得森估算器找到了确定性答案（Caughley, 1977; Seber, 1982）：</p>
<p><span id="eq-4_32"><span class="math display">\[
\frac{{{n}_{1}}}{X}=\frac{m}{n} \;\;\;\;\;\; \therefore \;\;\;\;\;\; \hat{X}=\frac{{{n}_{1}}n}{m}  
\qquad(4.32)\]</span></span></p>
<p>其中 <span class="math inline">\(n_1\)</span> 是种群中标记数量， <span class="math inline">\(n\)</span> 是后续样本量，<span class="math inline">\(m\)</span> 是回捕的标记数，<span class="math inline">\(\hat X\)</span> 是估算的资源量。另一种估计方法是对第二个样本的计数进行调整，以考虑到在这种情况下我们处理的是离散事件这一事实。这就是贝利调整（Bailey’s adjustment）（Caughley，1977）：</p>
<p><span id="eq-4_33"><span class="math display">\[
\hat{X}=\frac{{{n}_{1}}\left( n+1 \right)}{m+1}  
\qquad(4.33)\]</span></span></p>
<p>相关的标准误差估计值用于使用正态近似法计算近似的 95% 置信区间，从而在使用确定性方程时得出对称的置信区间。</p>
<p><span id="eq-4_34"><span class="math display">\[
StErr=\sqrt{\frac{n_{1}^{2}\left( n+1 \right)\left( n-m \right)}{{{\left( m+1 \right)}^{2}}\left( m+2 \right)}}  
\qquad(4.34)\]</span></span></p>
<p>这些方程可以用来证实 <a href="#tbl-4-3" class="quarto-xref">表&nbsp;<span>4.3</span></a> 中的估计。然而，与其使用确定性方程，一个好的替代方法是使用二项概率密度函数应用最大似然来估计总体大小 <span class="math inline">\(\hat  X\)</span>。</p>
<p>我们只估计一个参数，<span class="math inline">\(\hat X\)</span>，即总体大小，这需要搜索使数据的似然最大化的总体大小。对于二项分布，<span class="math inline">\(P \{m | n, p\}\)</span>，<a href="#eq-4_30" class="quarto-xref">公式&nbsp;<span>4.30</span></a> 给出了在标记比例为 <span class="math inline">\(p\)</span> 的总体中，从 <span class="math inline">\(n\)</span> 个样本中观察到 <span class="math inline">\(m\)</span> 个标记个体的概率(Snedecor和Cochran, 1967, 1989;Forbes et al, 2011)。标记的幼崽比例与总体大小 <span class="math inline">\(\hat X\)</span> 和最初标记的幼崽数量( 151 只)有关。因此 <span class="math inline">\(p = 151 / \hat X\)</span>。我们将重新分析 <a href="#tbl-4-3" class="quarto-xref">表&nbsp;<span>4.3</span></a> 中的前两个样本。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb83"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co"># analyse two pup counts 32 from 222, and 31 from 181, rows 1-2 in  </span></span>
<span> <span class="co"># Table 4.3.   Now set-up storage for solutions  </span></span>
<span><span class="va">optsol</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">0</span>,nrow<span class="op">=</span><span class="fl">2</span>,ncol<span class="op">=</span><span class="fl">2</span>,  </span>
<span>                 dimnames<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="va">furs</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">]</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"p"</span>,<span class="st">"Likelihood"</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="va">X</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fl">525</span>,<span class="fl">1850</span>,<span class="fl">1</span><span class="op">)</span> <span class="co"># range of potential population sizes  </span></span>
<span><span class="va">p</span> <span class="op">&lt;-</span> <span class="fl">151</span><span class="op">/</span><span class="va">X</span>  <span class="co">#range of proportion tagged; 151 originally tagged  </span></span>
<span><span class="va">m</span> <span class="op">&lt;-</span> <span class="va">furs</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">+</span> <span class="fl">1</span> <span class="co">#tags observed, with Bailey's adjustment  </span></span>
<span><span class="va">n</span> <span class="op">&lt;-</span> <span class="va">furs</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">+</span> <span class="fl">1</span> <span class="co"># sample size with Bailey's adjustment  </span></span>
<span><span class="va">lik1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Binomial.html">dbinom</a></span><span class="op">(</span><span class="va">m</span>,<span class="va">n</span>,<span class="va">p</span><span class="op">)</span> <span class="co"># individaul likelihoods  </span></span>
<span> <span class="co">#find best estimate with optimize to finely search an interval  </span></span>
<span> <span class="co">#use unlist to convert the output list into a vector  </span></span>
<span> <span class="co">#Note use of Bailey's adjustment (m+1), (n+1) Caughley, (1977)  </span></span>
<span><span class="va">optsol</span><span class="op">[</span><span class="fl">1</span>,<span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/unlist.html">unlist</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/optimize.html">optimize</a></span><span class="op">(</span><span class="kw">function</span><span class="op">(</span><span class="va">p</span><span class="op">)</span> <span class="op">{</span><span class="fu"><a href="https://rdrr.io/r/stats/Binomial.html">dbinom</a></span><span class="op">(</span><span class="va">m</span>,<span class="va">n</span>,<span class="va">p</span><span class="op">)</span><span class="op">}</span>,<span class="va">p</span>,  </span>
<span>                              maximum<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="va">m</span> <span class="op">&lt;-</span> <span class="va">furs</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">]</span><span class="op">+</span><span class="fl">1</span>;  <span class="va">n</span> <span class="op">&lt;-</span> <span class="va">furs</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">]</span><span class="op">+</span><span class="fl">1</span> <span class="co">#repeat for sample2  </span></span>
<span><span class="va">lik2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Binomial.html">dbinom</a></span><span class="op">(</span><span class="va">m</span>,<span class="va">n</span>,<span class="va">p</span><span class="op">)</span>    </span>
<span><span class="va">totlik</span> <span class="op">&lt;-</span> <span class="va">lik1</span> <span class="op">*</span> <span class="va">lik2</span> <span class="co">#Joint likelihood of 2 vectors  </span></span>
<span><span class="va">optsol</span><span class="op">[</span><span class="fl">2</span>,<span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/unlist.html">unlist</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/optimize.html">optimize</a></span><span class="op">(</span><span class="kw">function</span><span class="op">(</span><span class="va">p</span><span class="op">)</span> <span class="op">{</span><span class="fu"><a href="https://rdrr.io/r/stats/Binomial.html">dbinom</a></span><span class="op">(</span><span class="va">m</span>,<span class="va">n</span>,<span class="va">p</span><span class="op">)</span><span class="op">}</span>,<span class="va">p</span>,  </span>
<span>                              maximum<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>我们当然可以将结果制成表格，但更清楚的是将它们绘制为每个假设总体大小的似然(在这里是概率)。然后我们可以使用变量 <em>optsol</em> 中的 <span class="math inline">\(p\)</span> 列来计算每种情况下的最佳总体大小。该图的优点是，人们可以立即看到每个样本的似然曲线的重叠，并获得任何百分位数置信区间都不是对称的印象。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb84"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co"># Compare outcome for 2 independent seal estimates Fig 4.17  </span></span>
<span> <span class="co"># Should plot points not a line as each are independent   </span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/plot1.html">plot1</a></span><span class="op">(</span><span class="va">X</span>,<span class="va">lik1</span>,type<span class="op">=</span><span class="st">"l"</span>,xlab<span class="op">=</span><span class="st">"Total Pup Numbers"</span>,  </span>
<span>      ylab<span class="op">=</span><span class="st">"Probability"</span>,maxy<span class="op">=</span><span class="fl">0.085</span>,lwd<span class="op">=</span><span class="fl">2</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html">abline</a></span><span class="op">(</span>v<span class="op">=</span><span class="va">X</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/which.min.html">which.max</a></span><span class="op">(</span><span class="va">lik1</span><span class="op">)</span><span class="op">]</span>,col<span class="op">=</span><span class="fl">1</span>,lwd<span class="op">=</span><span class="fl">1</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">X</span>,<span class="va">lik2</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">2</span>,lty<span class="op">=</span><span class="fl">3</span><span class="op">)</span>  <span class="co"># add line to plot  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html">abline</a></span><span class="op">(</span>v<span class="op">=</span><span class="va">X</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/which.min.html">which.max</a></span><span class="op">(</span><span class="va">lik2</span><span class="op">)</span><span class="op">]</span>,col<span class="op">=</span><span class="fl">2</span>,lwd<span class="op">=</span><span class="fl">1</span><span class="op">)</span> <span class="co"># add optimum  </span></span>
<span> <span class="co">#given p = 151/X, then X = 151/p and p = optimum proportion   </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/legend.html">legend</a></span><span class="op">(</span><span class="st">"topright"</span>,legend<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="op">(</span><span class="fl">151</span><span class="op">/</span><span class="va">optsol</span><span class="op">[</span>,<span class="st">"p"</span><span class="op">]</span><span class="op">)</span><span class="op">)</span>,col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">2</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">3</span>,  </span>
<span>       bty<span class="op">=</span><span class="st">"n"</span>,cex<span class="op">=</span><span class="fl">1.1</span>,lty<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">3</span><span class="op">)</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-4-17" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-4-17-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="04-application_files/figure-html/fig-4-17-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-4-17-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;4.17: 通过标记实验，对151只海狗进行了标记，得出了海狗种群大小的两种估计，种群大小与似然分布(Greaves, 1992)。右边的黑线来自222只观察到的幼崽的32个标记，而左边的虚线来自181只观察到的31个标记。模型(最佳种群估计值)由竖线和图例表示。
</figcaption></figure>
</div>
</div>
</div>
</section><section id="使用多个独立样本" class="level3" data-number="4.8.3"><h3 data-number="4.8.3" class="anchored" data-anchor-id="使用多个独立样本">
<span class="header-section-number">4.8.3</span> 使用多个独立样本</h3>
<p>如果有多个调查、观测或样本，或不同类型的数据，而这些数据又是相互独立的，那么就有可能将这些估计值合并起来，以改进总体估计值。就像概率一样，一组独立观测数据的似然是特定观测数据似然的乘积。因此，我们可以将刚才研究的两个样本的每个种群大小的似然值相乘，得到一个联合似然值，在前面的例子中，这个似然值被放入变量 <em>totlik</em> 中，<a href="#fig-4-18" class="quarto-xref">图&nbsp;<span>4.18</span></a>。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb85"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#Combined likelihood from 2 independent samples Fig 4.18  </span></span>
<span><span class="va">totlik</span> <span class="op">&lt;-</span> <span class="va">totlik</span><span class="op">/</span><span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">totlik</span><span class="op">)</span> <span class="co"># rescale so the total sums to one  </span></span>
<span><span class="va">cumlik</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cumsum.html">cumsum</a></span><span class="op">(</span><span class="va">totlik</span><span class="op">)</span> <span class="co">#approx cumulative likelihood for CI      </span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/plot1.html">plot1</a></span><span class="op">(</span><span class="va">X</span>,<span class="va">totlik</span>,type<span class="op">=</span><span class="st">"l"</span>,lwd<span class="op">=</span><span class="fl">2</span>,xlab<span class="op">=</span><span class="st">"Total Pup Numbers"</span>,  </span>
<span>      ylab<span class="op">=</span><span class="st">"Posterior Joint Probability"</span><span class="op">)</span>  </span>
<span><span class="va">percs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">X</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/which.closest.html">which.closest</a></span><span class="op">(</span><span class="fl">0.025</span>,<span class="va">cumlik</span><span class="op">)</span><span class="op">]</span>,<span class="va">X</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/which.min.html">which.max</a></span><span class="op">(</span><span class="va">totlik</span><span class="op">)</span><span class="op">]</span>,  </span>
<span>           <span class="va">X</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/which.closest.html">which.closest</a></span><span class="op">(</span><span class="fl">0.975</span>,<span class="va">cumlik</span><span class="op">)</span><span class="op">]</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html">abline</a></span><span class="op">(</span>v<span class="op">=</span><span class="va">percs</span>,lwd<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">1</span><span class="op">)</span>,col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">1</span>,<span class="fl">2</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/legend.html">legend</a></span><span class="op">(</span><span class="st">"topright"</span>,legend<span class="op">=</span><span class="va">percs</span>,lwd<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">4</span>,<span class="fl">2</span><span class="op">)</span>,bty<span class="op">=</span><span class="st">"n"</span>,col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">1</span>,<span class="fl">2</span><span class="op">)</span>,  </span>
<span>       cex<span class="op">=</span><span class="fl">1.2</span><span class="op">)</span>  <span class="co"># now compare with averaged count  </span></span>
<span><span class="va">m</span> <span class="op">&lt;-</span> <span class="va">furs</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">1</span><span class="op">]</span>;  <span class="va">n</span> <span class="op">&lt;-</span> <span class="va">furs</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">2</span><span class="op">]</span> <span class="co"># likelihoods for the   </span></span>
<span><span class="va">lik3</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Binomial.html">dbinom</a></span><span class="op">(</span><span class="va">m</span>,<span class="va">n</span>,<span class="va">p</span><span class="op">)</span>            <span class="co"># average of six samples  </span></span>
<span><span class="va">lik4</span> <span class="op">&lt;-</span> <span class="va">lik3</span><span class="op">/</span><span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">lik3</span><span class="op">)</span>  <span class="co"># rescale for comparison with totlik  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">X</span>,<span class="va">lik4</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">3</span>,lty<span class="op">=</span><span class="fl">2</span><span class="op">)</span> <span class="co">#add 6 sample average to plot  </span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-4-18" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-4-18-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="04-application_files/figure-html/fig-4-18-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-4-18-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;4.18: 前两个海狗幼崽样本的综合似然（黑线）。与单个样本相比，这些样本的百分位数置信区间（垂直细红线）更小。六个样本的平均计数和样本量（绿色虚线）在平均位置上与单个样本相似，但百分比置信区间更宽。图例显示了组合似然曲线的最佳值和 95% 百分位数 CI。The combined likelihood from the first two fur seal pup samples (black line). These have tighter percentile confidence intervals (vertical thin red lines) than the individual samples. The average count and sample size of six samples (green dashed line) remains similar in mean location to the single samples but would have much wider CI. The legend shows the optimum and the 95% percentile CI foir the combined likelihoods curve.
</figcaption></figure>
</div>
</div>
</div>
<p>请注意，虽然中心倾向仍然非常相似，但从组合似然值（红色细线）得出的 95% 置信区间比从六个组合样本得出的平均值要小，而且在平均值周围不对称。与所有分析一样，只要使用的程序是站得住脚的，那么分析就可以继续进行（例如，在这种情况下，可以说样本是独立的，这意味着它们在时间上相隔足够远，因此无法得知被标记幼崽的位置，幼崽也可以移动等）。这与贝叶斯方法利用新数据的似然更新先验概率有相似之处。具体的贝叶斯方法将在后面详细介绍。对六个样本取平均值以获得平均计数和样本大小的方法提供了非常相似的种群估计值，但其不确定性范围更大。取这些样本的平均值并不是最佳的分析策略。</p>
</section><section id="分析方法" class="level3" data-number="4.8.4"><h3 data-number="4.8.4" class="anchored" data-anchor-id="分析方法">
<span class="header-section-number">4.8.4</span> 分析方法</h3>
<p>有些生物过程，如动物是否成熟、是否被渔具选择捕捞等，非常适合用二项分布作为观测的基础进行分析。然而，这类过程是以累积的方式运行的，例如，随着时间的推移，种群中成熟的群体百分比最终应达到 100%。这种过程通常可以用众所周知的 logistic 曲线来很好地描述。我们可以使用数值方法来估计 logistic 模型参数，也可以使用二项分布的广义线性模型。我们将在本章之后的静态模型一章中介绍这些方法。</p>
</section></section><section id="其它分布" class="level2" data-number="4.9"><h2 data-number="4.9" class="anchored" data-anchor-id="其它分布">
<span class="header-section-number">4.9</span> 其它分布</h2>
<p>在基础 stats R 软件包中（使用 <code><a href="https://rdrr.io/r/utils/sessionInfo.html">sessionInfo()</a></code> 确定加载的 7 个基础软件包），有许多分布的概率密度函数。事实上，只要在控制台中输入 <code><a href="https://rdrr.io/r/stats/Distributions.html">?Distributions</a></code>（不带括号），就能立即获得 R 中可用的分布列表。此外，CRAN 系统中还有一个关于分布的任务视图，网址是：https://CRAN.R-project.org/view=Distributions。该任务视图提供了详细的讨论，同时也指向了大量独立软件包，这些软件包提供了更广泛的统计分布。</p>
<p>在渔业科学中，有几种其他分布可以直接使用。它们都有用于计算似然的概率密度函数（以 <em>d</em> 开头，如 <code><a href="https://rdrr.io/r/stats/Multinom.html">dmultinom()</a></code>），而且通常都有随机数生成器（以 r 开头，如 <code><a href="https://rdrr.io/r/stats/GammaDist.html">rgamma()</a></code>）。如果你查看一些函数的帮助，就会明白其中的含义和概要。下面我们将详细介绍几种对渔业和生态工作更有用的随机数生成器（另见 Forbes 等，2011 ）。</p>
</section><section id="多项式分布的似然" class="level2" data-number="4.10"><h2 data-number="4.10" class="anchored" data-anchor-id="多项式分布的似然">
<span class="header-section-number">4.10</span> 多项式分布的似然</h2>
<p>如上文所述，当观测结果有两种可能结果（真/假、标记/未标记、成熟/未成熟）时，我们会使用二项分布。不过，在很多情况下，观测结果可能会有两种以上的离散结果，在这种情况下，我们可以使用多项分布。在处理长度或年龄样本内的频率分布时，就会出现这种情况；例如，随机给定一尾鱼，它的年龄可能只是众多年龄类别中的一个。在这种多变量意义上，多项式分布是二项分布的扩展。多项式分布是另一种离散分布，它提供的是不同的概率，而不仅仅是似然。</p>
<p>对于二项分布，我们使用 <span class="math inline">\(P (m|n, P)\)</span> 来表示似然。对于多项式，这需要扩展，这样就不是只有两个结果(一个概率 <span class="math inline">\(p\)</span> )，而是在 <span class="math inline">\(n\)</span> 个观测值的样本中，我们有 <span class="math inline">\(k\)</span> 个可能结果中的每一个的概率( <span class="math inline">\(k_p\)</span> )。多项式分布的概率密度函数为(Forbes et al .， 2011):</p>
<p><span id="eq-4_35"><span class="math display">\[
P\left\{ {{x}_{i}}|n,{{p}_{1}},{{p}_{2}},...,{{p}_{k}} \right\}=n!\prod\limits_{i=1}^{k}{\frac{\hat{p}_{i}^{{{x}_{i}}}}{x!}}  
\qquad(4.35)\]</span></span></p>
<p>其中 <span class="math inline">\(x_i\)</span> 是 <span class="math inline">\(n\)</span> 个样本中 <span class="math inline">\(i\)</span> 类事件发生的次数(在统计文献中通常称为试验)，<span class="math inline">\(p_i\)</span> 是 <span class="math inline">\(k\)</span> 类可能事件中每种事件的单独概率。每种事件类型的期望为 <span class="math inline">\(E(x_i) = np_i\)</span>，其中 <span class="math inline">\(n\)</span> 为样本量，<span class="math inline">\(p_i\)</span> 为事件类型 <span class="math inline">\(i\)</span> 的概率。由于 PDF 中存在阶乘项，这可能导致数值溢出问题，因此进行对数转换:</p>
<p><span id="eq-4_36"><span class="math display">\[
\begin{aligned}
P\{x_i|n,p_1, \cdots, p_k\} &amp;=n! \prod_{i=1}^{k} \dfrac{\hat p_i^{x_i}}{x_i !} \\
LL\left\{ {{x}_{i}}|n,{{p}_{1}},...,{{p}_{k}} \right\}&amp;=\sum\limits_{j=1}^{n}{\log\left( j \right)}+\sum\limits_{i=1}^{k}{\left[ {{x}_{i}}\log\left( {{{\hat{p}}}_{i}} \right)-\sum\limits_{j=1}^{x}{\log\left( j \right)} \right]}  
\end{aligned}
\qquad(4.36)\]</span></span></p>
<p>实际上，对数变换后的阶乘项 <span class="math inline">\(n!\)</span> 还有 <span class="math inline">\(x!\)</span>，涉及 <span class="math inline">\(\log(j)\)</span> 的和，其中 <span class="math inline">\(j\)</span>从 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(n\)</span>, <span class="math inline">\(1\)</span> 到 <span class="math inline">\(x\)</span> 的步长总是常数，通常在计算中被省略，此外负对数似然在最小化中使用:</p>
<p><span id="eq-4_37"><span class="math display">\[
-LL\left\{{x_i}|n,{p_1},{p_2},...,{p_k} \right\} \;\;= \;\; -\sum\limits_{i=1}^{k}{\left[ {x_i}\log\left( {{\hat{p}}_{i}} \right)\right]}  
\qquad(4.37)\]</span></span></p>
<p>我们有理由费心研究概率密度函数的简化方法，因为 R 中已经开发出了非常适用于计算概率密度函数的函数。了解我们所使用的任何函数的作用始终是个好主意，这也是了解我们希望在分析中使用的任何统计函数的属性的明智之举。在某些情况下，例如 R 的 <code><a href="https://rdrr.io/r/stats/Multinom.html">dmultinom()</a></code> 用于多项式分布，它的帮助页面告诉我们，它目前还没有矢量化，因此在渔业中的使用有点笨拙。相反，我们将在 <strong>MQMF</strong> 函数 <code><a href="https://rdrr.io/pkg/MQMF/man/mnnegLL.html">mnnegLL()</a></code> 中对 <a href="#eq-4_37" class="quarto-xref">公式&nbsp;<span>4.37</span></a> 进行 R 运行。此外，在只处理几百个观测值时，计算速度的差异并不重要，但如果要重复计算一组数据的总对数似然几百万次（在渔业模型中使用马尔可夫链-蒙特-卡洛或 MCMC（有时为 McMC）时很有可能出现这种情况），那么任何节省时间的方法都是有价值的。我们将在讨论贝叶斯方法和其他方法来描述模型和数据中固有的不确定性时讨论这些问题。</p>
<section id="使用多项式分布" class="level3" data-number="4.10.1"><h3 data-number="4.10.1" class="anchored" data-anchor-id="使用多项式分布">
<span class="header-section-number">4.10.1</span> 使用多项式分布</h3>
<p>在对年龄或大小组成数据进行模型拟合时，通常使用多项式分布来表示观测结果在可能类别中的预期分布。我们将以塔斯马尼亚德文特河口希望岛的黑唇鲍（<em>Haliotis rubra</em>）幼体的生长模态分析研究为例（Helidoniotis 和 Haddon，2012）。在 1992 年 11 月采集的样本中，以 2 毫米组距绘图时两个模式非常明显。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb86"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#plot counts x shell-length of 2 cohorts   Figure 4.19  </span></span>
<span><span class="va">cw</span> <span class="op">&lt;-</span> <span class="fl">2</span>  <span class="co"># 2 mm size classes, of which mids are the centers  </span></span>
<span><span class="va">mids</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fl">8</span>,<span class="fl">54</span>,<span class="va">cw</span><span class="op">)</span> <span class="co">#each size class = 2 mm as in 7-9, 9-11, ...  </span></span>
<span><span class="va">obs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">6</span>,<span class="fl">12</span>,<span class="fl">35</span>,<span class="fl">40</span>,<span class="fl">29</span>,<span class="fl">23</span>,<span class="fl">13</span>,<span class="fl">7</span>,<span class="fl">10</span>,<span class="fl">14</span>,<span class="fl">11</span>,<span class="fl">16</span>,<span class="fl">11</span>,<span class="fl">11</span>,<span class="fl">9</span>,<span class="fl">8</span>,<span class="fl">5</span>,<span class="fl">2</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span><span class="op">)</span>  </span>
<span> <span class="co"># data from (Helidoniotis and Haddon, 2012)  </span></span>
<span><span class="va">dat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">as.matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span><span class="va">mids</span>,<span class="va">obs</span><span class="op">)</span><span class="op">)</span> <span class="co">#xy matrix needed by inthist  </span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/parset.html">parset</a></span><span class="op">(</span><span class="op">)</span>  <span class="co">#set up par declaration then use an MQMF function   </span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/inthist.html">inthist</a></span><span class="op">(</span><span class="va">dat</span>,col<span class="op">=</span><span class="fl">2</span>,border<span class="op">=</span><span class="fl">3</span>,width<span class="op">=</span><span class="fl">1.8</span>, <span class="co">#histogram of integers  </span></span>
<span>     xlabel<span class="op">=</span><span class="st">"Shell Length mm"</span>,ylabel<span class="op">=</span><span class="st">"Frequency"</span>,xmin<span class="op">=</span><span class="fl">7</span>,xmax<span class="op">=</span><span class="fl">55</span><span class="op">)</span>   </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-4-19" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-4-19-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="04-application_files/figure-html/fig-4-19-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-4-19-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;4.19: The length-frequency counts of a sample of juvenile abalone from the south-east of Tasmania illustrating two modes taken in 1992.
</figcaption></figure>
</div>
</div>
</div>
<p>假设数据中的可观测模式与不同的世代或栖息地有关，并且我们希望估计每个世代的属性。使用正态概率密度函数来描述每种模式/队列中每个大小组的预期相对频率，并将其组合起来生成样本中 <span class="math inline">\(k\)</span> 个 2mm 长度组中每一个的期望相对频率(Helidoniotis和Haddon, 2012)。需要五个参数，每个世代的均值和标准差，以及第一个世代中包含的观测总数的比例(第二个世代的比例是通过减去1.0得到的)。因此，使用 <span class="math inline">\(\theta=(\mu_c, \sigma_c, \varphi)\)</span>，其中，在这种情况下，有 <span class="math inline">\(c=2\)</span> 个世代，我们可以得到每个大小分组内观测值的期望比例。一种方法是计算每个 2mm 分组中心的相对似然，乘以样本总数，再根据分配给每个世代的比例进行调节<a href="#eq-4_38" class="quarto-xref">公式&nbsp;<span>4.38</span></a>。</p>
<p><span id="eq-4_38"><span class="math display">\[
\begin{aligned}  
{{{\hat{N}}}_{i}} &amp;= {{\varphi }_{1}}n\sum\limits_{{{S}_{i}}=6}^{56}{\frac{1}{{{\sigma }_{1}}\sqrt{2\pi }}}\exp \left( \frac{-\left( {{S}_{i}}-{{\mu }_{1}} \right)}{2{{\sigma }_{1}}} \right)  \\   
  &amp;+ \left( 1-{{\varphi }_{2}} \right)n\sum\limits_{{{S}_{i}}=6}^{56}{\frac{1}{{{\sigma }_{2}}\sqrt{2\pi }}}\exp \left( \frac{-\left( {{S}_{i}}-{{\mu }_{2}} \right)}{2{{\sigma }_{2}}} \right) \\   
  {{p}_{i}} &amp;= {{{\hat{N}}}_{i}}/\sum{{{{\hat{N}}}_{i}}} \\   
\end{aligned}  
\qquad(4.38)\]</span></span></p>
<p>其中 <span class="math inline">\(\hat N_i\)</span> 是每个分组 <span class="math inline">\(i\)</span> 中观测的期望数，<span class="math inline">\(i\)</span> 表示分组数（这晨在7-55mm 之间为 2mm 的步长，中心值为 <span class="math inline">\(8, \cdots, 54\)</span>）。<span class="math inline">\(\varphi (phi)\)</span> 是世代 1 中发现的观测总数 <span class="math inline">\(n\)</span> 的比例，<span class="math inline">\(\mu_c\)</span> 为每个世代 <span class="math inline">\(c\)</span> 的平均大小，<span class="math inline">\(\sigma_c\)</span> 为它们的标准差。 <a href="#eq-4_38" class="quarto-xref">公式&nbsp;<span>4.38</span></a> 最后一行的 <span class="math inline">\(p_i\)</span> 是分组 <span class="math inline">\(i\)</span> 中观测值的期望比例，其中 <span class="math inline">\(S_i\)</span> 是每个分组的中点。</p>
<p>或者，更准确地说，我们可以从每个大小类的顶部的累积概率中减去每个大小类i的底部的累积概率。然而，一般来说，这在分析中几乎没有什么不同，所以这里我们将只关注第一种方法(您可以尝试自己实现替代方法来进行比较，因为有时相信打印出来的一切并不是一个好主意!)。</p>
<p>无论采用哪种方法，我们都需要定义两个正态分布，并求和它们的相对贡献。我们可以使用对数正态分布或伽马分布等其他累积统计分布来代替正态分布。如果没有令人信服的理由来证明使用其中一种分布是正确的，那么理想的做法是比较使用其他分布与现有数据的相对拟合程度。</p>
<p>为了获得预期频率与观测频率进行比较，有必要限制预期总数与观测总数大致相同。多项式的负对数似然值为</p>
<p><span id="eq-4_39"><span class="math display">\[
-LL\left\{ N|{\mu_c},{\sigma_c},{\varphi} \right\}=-\sum\limits_{c=1}^{2}\sum\limits_{i=1}^{k}{{N_i}\log\left( {{\hat{p}}_i} \right)}=-\sum\limits_{i=1}^{k}{{N_i}\log\left( \frac{{{\hat{N}}_i}}{\sum{{{\hat{N}}_i}}} \right)}    
\qquad(4.39)\]</span></span></p>
<p>其中，<span class="math inline">\(\mu_c\)</span> 和 <span class="math inline">\(\sigma_c\)</span> 是 <span class="math inline">\(c\)</span> 世代假设生成观察分布的均值和标准差。有 <span class="math inline">\(k\)</span> 个分组和 2 个世代 <span class="math inline">\(c\)</span>，<span class="math inline">\(N_i\)</span> 是分组 <span class="math inline">\(i\)</span> 的观测频率， <span class="math inline">\(\hat p_i\)</span> 是组合分布分组 <span class="math inline">\(i\)</span> 内期望比例。 目标是最小化负对数似然，以找到 <span class="math inline">\(c\)</span> 个正态分布参数和 <span class="math inline">\(\varphi\)</span> 的最佳组合。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb87"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#cohort data with 2 guess-timated normal curves Fig 4.20  </span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/parset.html">parset</a></span><span class="op">(</span><span class="op">)</span>  <span class="co"># set up the required par declaration  </span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/inthist.html">inthist</a></span><span class="op">(</span><span class="va">dat</span>,col<span class="op">=</span><span class="fl">0</span>,border<span class="op">=</span><span class="fl">8</span>,width<span class="op">=</span><span class="fl">1.8</span>,xlabel<span class="op">=</span><span class="st">"Shell Length mm"</span>,  </span>
<span>        ylabel<span class="op">=</span><span class="st">"Frequency"</span>,xmin<span class="op">=</span><span class="fl">7</span>,xmax<span class="op">=</span><span class="fl">55</span>,lwd<span class="op">=</span><span class="fl">2</span><span class="op">)</span>  <span class="co"># MQMF function        </span></span>
<span> <span class="co">#Guess normal parameters and plot those curves on histogram  </span></span>
<span><span class="va">av</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">18.0</span>,<span class="fl">34.5</span><span class="op">)</span>    <span class="co"># the initial trial and error means and  </span></span>
<span><span class="va">stdev</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2.75</span>,<span class="fl">5.75</span><span class="op">)</span>  <span class="co"># their standard deviations  </span></span>
<span><span class="va">prop1</span> <span class="op">&lt;-</span> <span class="fl">0.55</span>       <span class="co">#  proportion of observations in cohort 1  </span></span>
<span><span class="va">n</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">obs</span><span class="op">)</span> <span class="co">#262 observations, now calculate expected counts  </span></span>
<span><span class="va">cohort1</span> <span class="op">&lt;-</span> <span class="op">(</span><span class="va">n</span><span class="op">*</span><span class="va">prop1</span><span class="op">*</span><span class="va">cw</span><span class="op">)</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span><span class="op">(</span><span class="va">mids</span>,<span class="va">av</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>,<span class="va">stdev</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span> <span class="co"># for each  </span></span>
<span><span class="va">cohort2</span> <span class="op">&lt;-</span> <span class="op">(</span><span class="va">n</span><span class="op">*</span><span class="op">(</span><span class="fl">1</span><span class="op">-</span><span class="va">prop1</span><span class="op">)</span><span class="op">*</span><span class="va">cw</span><span class="op">)</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span><span class="op">(</span><span class="va">mids</span>,<span class="va">av</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span>,<span class="va">stdev</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span><span class="op">)</span><span class="co"># cohort  </span></span>
<span> <span class="co">#(n*prop1*cw) scales likelihoods to suit the 2mm class width  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">mids</span>,<span class="va">cohort1</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">1</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">mids</span>,<span class="va">cohort2</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">4</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-4-20" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-4-20-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="04-application_files/figure-html/fig-4-20-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-4-20-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;4.20: 根据对 1992 年塔斯马尼亚南部采样的幼鲍长度-频率计数的初始参数猜测得出的两个正态分布。Two Normal distributions from initial parameter guesses imposed upon the length-frequency counts of juvenile abalone from southern Tasmania sampled in 1992.
</figcaption></figure>
</div>
</div>
</div>
<p>两种模式的初始试验和误差猜测的中心估计值似乎是合理的，但左侧世代中的散布似乎太小，世代间的比例分配似乎偏向于第一个世代。由于比例会以非线性方式改变数值，因此寻找最佳似然值对起始值很敏感。我们可以将 <code><a href="https://rdrr.io/r/stats/nlm.html">nlm()</a></code> 应用于一个封装函数来生成多项式的负对数似然估计值，从而寻找一个更理想的参数集，就象 <a href="#eq-4_39" class="quarto-xref">公式&nbsp;<span>4.39</span></a> 中定义的那样。如前所述，我们需要一个函数来生成每个大小分组中观测值的预测数，在 <strong>MQMF</strong> 中我们称之为 <code><a href="https://rdrr.io/pkg/MQMF/man/predfreq.html">predfreq()</a></code>。我们还需要一个封装函数来计算使用 <code><a href="https://rdrr.io/pkg/MQMF/man/predfreq.html">predfreq()</a></code> 函数的负对数似然，这里我们将其称为 <code>wrapper()</code>（见下面的代码块）。在开发 <code><a href="https://rdrr.io/pkg/MQMF/man/predfreq.html">predfreq()</a></code> 函数时，我们要求对参数进行排序，首先是拟合的各世代的均值，然后是标准差，最后是分配给除最后一世代之外的所有世代的比例。这样，算法就能在规定的位置找到所需的参数。因此，对于三个世代的问题来说， 在 R 语言中，我们将有 <span class="math inline">\(pars={c(\mu_1,\mu_2,\mu_3,\sigma_1,\sigma_2,\sigma_3,\varphi_1,\varphi2)}\)</span>。我们还加入了使用累积正态概率密度的选项。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb88"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#wrapper function for calculating the multinomial log-likelihoods  </span></span>
<span> <span class="co">#using predfreq and mnnegLL, Use ? and examine their code  </span></span>
<span><span class="va">wrapper</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">pars</span>,<span class="va">obs</span>,<span class="va">sizecl</span>,<span class="va">midval</span><span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span> <span class="op">{</span>  </span>
<span>  <span class="va">freqf</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/predfreq.html">predfreq</a></span><span class="op">(</span><span class="va">pars</span>,<span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">obs</span><span class="op">)</span>,sizecl<span class="op">=</span><span class="va">sizecl</span>,midval<span class="op">=</span><span class="va">midval</span><span class="op">)</span>  </span>
<span>  <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/mnnegLL.html">mnnegLL</a></span><span class="op">(</span><span class="va">obs</span>,<span class="va">freqf</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="op">}</span> <span class="co"># end of wrapper which uses MQMF::predfreq and MQMF::mnnegLL  </span></span>
<span><span class="va">mids</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fl">8</span>,<span class="fl">54</span>,<span class="fl">2</span><span class="op">)</span> <span class="co"># each size class = 2 mm as in 7-9, 9-11, ...  </span></span>
<span><span class="va">av</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">18.0</span>,<span class="fl">34.5</span><span class="op">)</span>   <span class="co"># the trial and error means and  </span></span>
<span><span class="va">stdev</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2.95</span>,<span class="fl">5.75</span><span class="op">)</span>  <span class="co"># standard deviations  </span></span>
<span><span class="va">phi1</span> <span class="op">&lt;-</span> <span class="fl">0.55</span>      <span class="co"># proportion of observations in cohort 1  </span></span>
<span><span class="va">pars</span> <span class="op">&lt;-</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">av</span>,<span class="va">stdev</span>,<span class="va">phi1</span><span class="op">)</span>  <span class="co"># combine parameters into a vector  </span></span>
<span><span class="fu">wrapper</span><span class="op">(</span><span class="va">pars</span>,obs<span class="op">=</span><span class="va">obs</span>,sizecl<span class="op">=</span><span class="va">mids</span><span class="op">)</span> <span class="co"># calculate total -veLL  </span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>[1] 708.3876</code></pre>
</div>
</div>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb90"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co"># First use the midpoints  </span></span>
<span><span class="va">bestmod</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/nlm.html">nlm</a></span><span class="op">(</span>f<span class="op">=</span><span class="va">wrapper</span>,p<span class="op">=</span><span class="va">pars</span>,obs<span class="op">=</span><span class="va">obs</span>,sizecl<span class="op">=</span><span class="va">mids</span>,midval<span class="op">=</span><span class="cn">TRUE</span>,   </span>
<span>               typsize<span class="op">=</span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/magnitude.html">magnitude</a></span><span class="op">(</span><span class="va">pars</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/outfit.html">outfit</a></span><span class="op">(</span><span class="va">bestmod</span>,backtran<span class="op">=</span><span class="cn">FALSE</span>,title<span class="op">=</span><span class="st">"Using Midpts"</span><span class="op">)</span>; <span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"\n"</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>nlm solution:  Using Midpts 
minimum     :  706.1841 
iterations  :  27 
code        :  1 gradient close to 0, probably solution 
         par      gradient
1 18.3300619  6.369667e-06
2 33.7907454  4.467972e-06
3  3.0390094 -2.839356e-05
4  6.0306017  6.993965e-06
5  0.5763628  7.495453e-05</code></pre>
</div>
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb92"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#Now use the size class bounds and cumulative distribution  </span></span>
<span> <span class="co">#more sensitive to starting values, so use best pars from midpoints  </span></span>
<span><span class="va">X</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="op">(</span><span class="va">mids</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">-</span><span class="va">cw</span><span class="op">/</span><span class="fl">2</span><span class="op">)</span>,<span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/utils/head.html">tail</a></span><span class="op">(</span><span class="va">mids</span>,<span class="fl">1</span><span class="op">)</span><span class="op">+</span><span class="va">cw</span><span class="op">/</span><span class="fl">2</span><span class="op">)</span>,<span class="va">cw</span><span class="op">)</span>  </span>
<span><span class="va">bestmodb</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/nlm.html">nlm</a></span><span class="op">(</span>f<span class="op">=</span><span class="va">wrapper</span>,p<span class="op">=</span><span class="va">bestmod</span><span class="op">$</span><span class="va">estimate</span>,obs<span class="op">=</span><span class="va">obs</span>,sizecl<span class="op">=</span><span class="va">X</span>,  </span>
<span>                midval<span class="op">=</span><span class="cn">FALSE</span>,typsize<span class="op">=</span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/magnitude.html">magnitude</a></span><span class="op">(</span><span class="va">pars</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/outfit.html">outfit</a></span><span class="op">(</span><span class="va">bestmodb</span>,backtran<span class="op">=</span><span class="cn">FALSE</span>,title<span class="op">=</span><span class="st">"Using size-class bounds"</span><span class="op">)</span>   </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>nlm solution:  Using size-class bounds 
minimum     :  706.1815 
iterations  :  24 
code        :  1 gradient close to 0, probably solution 
         par      gradient
1 18.3299573  2.356852e-06
2 33.7903327 -4.690083e-06
3  2.9831560  2.221789e-05
4  6.0030194 -2.882406e-05
5  0.5763426 -5.168099e-05</code></pre>
</div>
</div>
<p>现在对照原始数据绘制这些最优解。绘制数据图非常简单，但随后我们需要找出每种情况下的最优参数，并计算出每个参数的隐含正态分布。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb94"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#prepare the predicted Normal distribution curves  </span></span>
<span><span class="va">pars</span> <span class="op">&lt;-</span> <span class="va">bestmod</span><span class="op">$</span><span class="va">estimate</span> <span class="co"># best estimate using mid-points  </span></span>
<span><span class="va">cohort1</span> <span class="op">&lt;-</span> <span class="op">(</span><span class="va">n</span><span class="op">*</span><span class="va">pars</span><span class="op">[</span><span class="fl">5</span><span class="op">]</span><span class="op">*</span><span class="va">cw</span><span class="op">)</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span><span class="op">(</span><span class="va">mids</span>,<span class="va">pars</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>,<span class="va">pars</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span><span class="op">)</span>   </span>
<span><span class="va">cohort2</span> <span class="op">&lt;-</span> <span class="op">(</span><span class="va">n</span><span class="op">*</span><span class="op">(</span><span class="fl">1</span><span class="op">-</span><span class="va">pars</span><span class="op">[</span><span class="fl">5</span><span class="op">]</span><span class="op">)</span><span class="op">*</span><span class="va">cw</span><span class="op">)</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span><span class="op">(</span><span class="va">mids</span>,<span class="va">pars</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span>,<span class="va">pars</span><span class="op">[</span><span class="fl">4</span><span class="op">]</span><span class="op">)</span>   </span>
<span><span class="va">parsb</span> <span class="op">&lt;-</span> <span class="va">bestmodb</span><span class="op">$</span><span class="va">estimate</span> <span class="co"># best estimate with bounds  </span></span>
<span><span class="va">nedge</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="va">mids</span><span class="op">)</span> <span class="op">+</span> <span class="fl">1</span>  <span class="co"># one extra estimate  </span></span>
<span><span class="va">cump1</span> <span class="op">&lt;-</span> <span class="op">(</span><span class="va">n</span><span class="op">*</span><span class="va">pars</span><span class="op">[</span><span class="fl">5</span><span class="op">]</span><span class="op">)</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">pnorm</a></span><span class="op">(</span><span class="va">X</span>,<span class="va">pars</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>,<span class="va">pars</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span><span class="op">)</span><span class="co">#no need to rescale  </span></span>
<span><span class="va">cohort1b</span> <span class="op">&lt;-</span> <span class="op">(</span><span class="va">cump1</span><span class="op">[</span><span class="fl">2</span><span class="op">:</span><span class="va">nedge</span><span class="op">]</span> <span class="op">-</span> <span class="va">cump1</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="op">(</span><span class="va">nedge</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">]</span><span class="op">)</span>   </span>
<span><span class="va">cump2</span> <span class="op">&lt;-</span> <span class="op">(</span><span class="va">n</span><span class="op">*</span><span class="op">(</span><span class="fl">1</span><span class="op">-</span><span class="va">pars</span><span class="op">[</span><span class="fl">5</span><span class="op">]</span><span class="op">)</span><span class="op">)</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">pnorm</a></span><span class="op">(</span><span class="va">X</span>,<span class="va">pars</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span>,<span class="va">pars</span><span class="op">[</span><span class="fl">4</span><span class="op">]</span><span class="op">)</span>  <span class="co"># cohort 2  </span></span>
<span><span class="va">cohort2b</span> <span class="op">&lt;-</span> <span class="op">(</span><span class="va">cump2</span><span class="op">[</span><span class="fl">2</span><span class="op">:</span><span class="va">nedge</span><span class="op">]</span> <span class="op">-</span> <span class="va">cump2</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="op">(</span><span class="va">nedge</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">]</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb95"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#plot the alternate model fits to cohorts  Fig 4.21  </span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/parset.html">parset</a></span><span class="op">(</span><span class="op">)</span>  <span class="co"># set up required par declaration; then plot curves  </span></span>
<span><span class="va">pick</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/which.html">which</a></span><span class="op">(</span><span class="va">mids</span> <span class="op">&lt;</span> <span class="fl">28</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/inthist.html">inthist</a></span><span class="op">(</span><span class="va">dat</span><span class="op">[</span><span class="va">pick</span>,<span class="op">]</span>,col<span class="op">=</span><span class="fl">0</span>,border<span class="op">=</span><span class="fl">8</span>,width<span class="op">=</span><span class="fl">1.8</span>,xmin<span class="op">=</span><span class="fl">5</span>,xmax<span class="op">=</span><span class="fl">28</span>,  </span>
<span>        xlabel<span class="op">=</span><span class="st">"Shell Length mm"</span>,ylabel<span class="op">=</span><span class="st">"Frequency"</span>,lwd<span class="op">=</span><span class="fl">3</span><span class="op">)</span>   </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">mids</span>,<span class="va">cohort1</span>,lwd<span class="op">=</span><span class="fl">3</span>,col<span class="op">=</span><span class="fl">1</span>,lty<span class="op">=</span><span class="fl">2</span><span class="op">)</span> <span class="co"># have used setpalette("R4")  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">mids</span>,<span class="va">cohort1b</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">4</span><span class="op">)</span>      <span class="co"># add the bounded results  </span></span>
<span><span class="va">label</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"midpoints"</span>,<span class="st">"bounds"</span><span class="op">)</span>      <span class="co"># very minor differences </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/legend.html">legend</a></span><span class="op">(</span><span class="st">"topleft"</span>,legend<span class="op">=</span><span class="va">label</span>,lwd<span class="op">=</span><span class="fl">3</span>,col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">4</span><span class="op">)</span>,bty<span class="op">=</span><span class="st">"n"</span>,  </span>
<span>       cex<span class="op">=</span><span class="fl">1.2</span>,lty<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">)</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-4-21" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-4-21-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="04-application_files/figure-html/fig-4-21-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-4-21-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;4.21: 长度-频率信息左侧模式的最佳拟合。使用长度分组中值或边界值的参数值差异出现在小数点后第四位。右侧模式的差异很小，无法辨别。The optimum fit to the left-hand mode of the length-frequency information. The differences in parameter values between using size-class midpts or bounds occurs at the fourth decimal place. The difference in the right-hand mode was so small as not to be discernible.
</figcaption></figure>
</div>
</div>
</div>
<p>在这种情况下，使用不同长度组的中点所得到的参数与使用每个长度组的上限和下限所得到的参数几乎没有差别，所得到的正态曲线几乎完全重合。我们可以通过列出每种情况下的观测计数和预测计数，以及每个长度组中预测数和观测数之间的差异来了解这些拟合的细节。如 <a href="#fig-4-21" class="quarto-xref">图&nbsp;<span>4.21</span></a> 所示， <a href="#tbl-4-4" class="quarto-xref">表&nbsp;<span>4.4</span></a> 中的数字本身更清楚地说明了两种方法的接近性。从严格意义上讲，使用上下限更为正确，但在实践中往往差别不大。</p>
<p>Venebles 和 Ripley（2002，p 436）采用不同的策略将模态分布拟合为混合分布。他们的方法更为复杂和优雅，因为他们使用了分析梯度来辅助模型拟合过程。希望大家都能清楚地认识到，几乎所有分析问题都有不止一种解决方法。使用数值方法往往需要探索其他方法来寻找解决方案。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb96"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co"># setup table of results for comparison of fitting strategies  </span></span>
<span><span class="va">predmid</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/colSums.html">rowSums</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span><span class="va">cohort1</span>,<span class="va">cohort2</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="va">predbnd</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/colSums.html">rowSums</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span><span class="va">cohort1b</span>,<span class="va">cohort2b</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="va">result</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">as.matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span><span class="va">mids</span>,<span class="va">obs</span>,<span class="va">predmid</span>,<span class="va">predbnd</span>,<span class="va">predbnd</span><span class="op">-</span><span class="va">predmid</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html">colnames</a></span><span class="op">(</span><span class="va">result</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"mids"</span>,<span class="st">"Obs"</span>,<span class="st">"Predmid"</span>,<span class="st">"Predbnd"</span>,<span class="st">"Difference"</span><span class="op">)</span>  </span>
<span><span class="va">result</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span><span class="op">(</span><span class="va">result</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="cn">NA</span>,<span class="fu"><a href="https://rdrr.io/r/base/colSums.html">colSums</a></span><span class="op">(</span><span class="va">result</span>,na.rm<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span><span class="op">[</span><span class="fl">2</span><span class="op">:</span><span class="fl">5</span><span class="op">]</span><span class="op">)</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb97"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">knitr</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/knitr/man/kable.html">kable</a></span><span class="op">(</span><span class="va">result</span><span class="op">)</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div id="tbl-4-4" class="cell quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-4-4-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
表&nbsp;4.4: A tabulation of the predicted counts for the two normal distributions from the optimum model fit. The original sample had 262 observations.
</figcaption><div aria-describedby="tbl-4-4-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell-output-display">
<table class="do-not-create-environment cell table table-sm table-striped small">
<thead><tr class="header">
<th style="text-align: right;">mids</th>
<th style="text-align: right;">Obs</th>
<th style="text-align: right;">Predmid</th>
<th style="text-align: right;">Predbnd</th>
<th style="text-align: right;">Difference</th>
</tr></thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">8</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">0.1243773</td>
<td style="text-align: right;">0.1487018</td>
<td style="text-align: right;">0.0243245</td>
</tr>
<tr class="even">
<td style="text-align: right;">10</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">0.9323332</td>
<td style="text-align: right;">1.0428918</td>
<td style="text-align: right;">0.1105586</td>
</tr>
<tr class="odd">
<td style="text-align: right;">12</td>
<td style="text-align: right;">6</td>
<td style="text-align: right;">4.5513306</td>
<td style="text-align: right;">4.8235655</td>
<td style="text-align: right;">0.2722349</td>
</tr>
<tr class="even">
<td style="text-align: right;">14</td>
<td style="text-align: right;">12</td>
<td style="text-align: right;">14.4343959</td>
<td style="text-align: right;">14.6974970</td>
<td style="text-align: right;">0.2631010</td>
</tr>
<tr class="odd">
<td style="text-align: right;">16</td>
<td style="text-align: right;">35</td>
<td style="text-align: right;">29.7390161</td>
<td style="text-align: right;">29.5254720</td>
<td style="text-align: right;">-0.2135441</td>
</tr>
<tr class="even">
<td style="text-align: right;">18</td>
<td style="text-align: right;">40</td>
<td style="text-align: right;">39.8898972</td>
<td style="text-align: right;">39.2109794</td>
<td style="text-align: right;">-0.6789178</td>
</tr>
<tr class="odd">
<td style="text-align: right;">20</td>
<td style="text-align: right;">29</td>
<td style="text-align: right;">35.1655925</td>
<td style="text-align: right;">34.7612096</td>
<td style="text-align: right;">-0.4043829</td>
</tr>
<tr class="even">
<td style="text-align: right;">22</td>
<td style="text-align: right;">23</td>
<td style="text-align: right;">21.2937759</td>
<td style="text-align: right;">21.4732877</td>
<td style="text-align: right;">0.1795118</td>
</tr>
<tr class="odd">
<td style="text-align: right;">24</td>
<td style="text-align: right;">13</td>
<td style="text-align: right;">10.8867799</td>
<td style="text-align: right;">11.2235972</td>
<td style="text-align: right;">0.3368173</td>
</tr>
<tr class="even">
<td style="text-align: right;">26</td>
<td style="text-align: right;">7</td>
<td style="text-align: right;">8.0156286</td>
<td style="text-align: right;">8.1948201</td>
<td style="text-align: right;">0.1791915</td>
</tr>
<tr class="odd">
<td style="text-align: right;">28</td>
<td style="text-align: right;">10</td>
<td style="text-align: right;">9.5119745</td>
<td style="text-align: right;">9.5509907</td>
<td style="text-align: right;">0.0390161</td>
</tr>
<tr class="even">
<td style="text-align: right;">30</td>
<td style="text-align: right;">14</td>
<td style="text-align: right;">12.0773614</td>
<td style="text-align: right;">12.0505122</td>
<td style="text-align: right;">-0.0268492</td>
</tr>
<tr class="odd">
<td style="text-align: right;">32</td>
<td style="text-align: right;">11</td>
<td style="text-align: right;">14.0532683</td>
<td style="text-align: right;">13.9953724</td>
<td style="text-align: right;">-0.0578959</td>
</tr>
<tr class="even">
<td style="text-align: right;">34</td>
<td style="text-align: right;">16</td>
<td style="text-align: right;">14.6762590</td>
<td style="text-align: right;">14.6093929</td>
<td style="text-align: right;">-0.0668661</td>
</tr>
<tr class="odd">
<td style="text-align: right;">36</td>
<td style="text-align: right;">11</td>
<td style="text-align: right;">13.7319605</td>
<td style="text-align: right;">13.6776679</td>
<td style="text-align: right;">-0.0542926</td>
</tr>
<tr class="even">
<td style="text-align: right;">38</td>
<td style="text-align: right;">11</td>
<td style="text-align: right;">11.5102599</td>
<td style="text-align: right;">11.4832323</td>
<td style="text-align: right;">-0.0270277</td>
</tr>
<tr class="odd">
<td style="text-align: right;">40</td>
<td style="text-align: right;">9</td>
<td style="text-align: right;">8.6431354</td>
<td style="text-align: right;">8.6453958</td>
<td style="text-align: right;">0.0022604</td>
</tr>
<tr class="even">
<td style="text-align: right;">42</td>
<td style="text-align: right;">8</td>
<td style="text-align: right;">5.8142145</td>
<td style="text-align: right;">5.8367730</td>
<td style="text-align: right;">0.0225585</td>
</tr>
<tr class="odd">
<td style="text-align: right;">44</td>
<td style="text-align: right;">5</td>
<td style="text-align: right;">3.5038405</td>
<td style="text-align: right;">3.5336705</td>
<td style="text-align: right;">0.0298300</td>
</tr>
<tr class="even">
<td style="text-align: right;">46</td>
<td style="text-align: right;">2</td>
<td style="text-align: right;">1.8916081</td>
<td style="text-align: right;">1.9184137</td>
<td style="text-align: right;">0.0268057</td>
</tr>
<tr class="odd">
<td style="text-align: right;">48</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">0.9148534</td>
<td style="text-align: right;">0.9339392</td>
<td style="text-align: right;">0.0190857</td>
</tr>
<tr class="even">
<td style="text-align: right;">50</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">0.3963743</td>
<td style="text-align: right;">0.4077103</td>
<td style="text-align: right;">0.0113361</td>
</tr>
<tr class="odd">
<td style="text-align: right;">52</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">0.1538484</td>
<td style="text-align: right;">0.1596018</td>
<td style="text-align: right;">0.0057535</td>
</tr>
<tr class="even">
<td style="text-align: right;">54</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">0.0534951</td>
<td style="text-align: right;">0.0560238</td>
<td style="text-align: right;">0.0025287</td>
</tr>
<tr class="odd">
<td style="text-align: right;">NA</td>
<td style="text-align: right;">262</td>
<td style="text-align: right;">261.9655804</td>
<td style="text-align: right;">261.9607187</td>
<td style="text-align: right;">-0.0048617</td>
</tr>
</tbody>
</table>
</div>
</div>
</figure>
</div>
</div>
</section></section><section id="gamma-分布的似然" class="level2" data-number="4.11"><h2 data-number="4.11" class="anchored" data-anchor-id="gamma-分布的似然">
<span class="header-section-number">4.11</span> Gamma 分布的似然</h2>
<p>与我们在前几节中所考虑的统计分布相比，Gamma 分布通常不太为人所知。然而，Gamma 分布在渔业建模和模拟中越来越常用；在基于长度的种群模型中可以找到实际的例子(Sullivan等，1990；Sullivan,1992)。Gamma分布的概率密度函数有两个参数，一个尺度参数 <span class="math inline">\(b\)</span> （ <span class="math inline">\(b &lt; 0\)</span>；有时使用的替代方式是 <span class="math inline">\(\lambda\)</span>，其中 <span class="math inline">\(\lambda &lt; 1/b\)</span>），以及一个形状参数 <span class="math inline">\(c\)</span> （<span class="math inline">\(c&gt;0\)</span>）。分布范围是 <span class="math inline">\(0 \leq{x} \leq{\infty}\)</span> （即无负值）。分布的期望或均值 <span class="math inline">\(E(x)\)</span> 与两个参数（尺度参数 <span class="math inline">\(b\)</span> 和形状参数 <span class="math inline">\(c\)</span>）有关。因此：</p>
<p><span id="eq-4_40"><span class="math display">\[
E{( x )}=bc \;\;\;\ \text{or} \;\;\;\ c=\frac{E{( x )}}{b}   
\qquad(4.40)\]</span></span></p>
<p>计算 Gamma 分布的单个似然的概率密度函数为（Forbes et al, 2011）：</p>
<p><span id="eq-4_41"><span class="math display">\[
L\left\{ x \vert b,c \right\}=\frac{{{\left( \frac{x}{b} \right)}^{( c-1 )}}{{e}^{\frac{-x}{b}}}}{b\Gamma (c)}  
\qquad(4.41)\]</span></span></p>
<p>其中 <span class="math inline">\(x\)</span> 是变量值 ，<span class="math inline">\(b\)</span> 是尺度参数， <span class="math inline">\(c\)</span> 是形状参数， <span class="math inline">\(\Gamma(c)\)</span> 是 <span class="math inline">\(c\)</span> 参数的 gamma 函数。<span class="math inline">\(c\)</span> 取整数值的情况下，分布还被称为 Erlang 分布，此时 gamma 函数（<span class="math inline">\(\Gamma(c)\)</span>）替代为阶乘 <span class="math inline">\((c-1)!\)</span> (Forbes 等，2011)：</p>
<p><span id="eq-4_42"><span class="math display">\[
L\left\{ x|b,c \right\}=\frac{{{\left( \frac{x}{b} \right)}^{\left( c-1 \right)}}{{e}^{\frac{-x}{b}}}}{b\left( c-1 \right)!}    
\qquad(4.42)\]</span></span></p>
<p>与通常的似然计算一样，为了避免过流和欠流的计算问题，标准的做法是计算对数似然，更具体地说是负对数似然。使用对数似然总是更能规避风险：</p>
<p><span id="eq-4_43"><span class="math display">\[
-LL\{x|b,c\}= -\left[ \left( (c-1)\log\left( \frac{x}{b} \right)-\frac{x}{b} \right)   
-\{\log{(b)}+ \log{\left( \Gamma \left( c \right) \right)} \} \right]  
\qquad(4.43)\]</span></span></p>
<p>对于多个观测值，这可以将它们相加而不是相乘，但仍需要计算对数 gamma 函数 <span class="math inline">\(\log(\Gamma (c))\)</span>。幸运的是在 R 语言中可以使用 <code><a href="https://rdrr.io/r/base/Special.html">gamma()</a></code> 和 <code><a href="https://rdrr.io/r/base/Special.html">lgamma()</a></code> 两个函数。</p>
<p>Gamma 分布（不要与 gamma 函数 <span class="math inline">\(\Gamma\)</span> 混淆）非常灵活，形状的范围从实际上的反向曲线，到右偏曲线，再到近似正态曲线。它的灵活性使其成为一个非常有用的模拟函数，<a href="#fig-4-22" class="quarto-xref">图&nbsp;<span>4.22</span></a>。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb98"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#Illustrate different Gamma function curves  Figure 4.22  </span></span>
<span><span class="va">X</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fl">0.0</span>,<span class="fl">10</span>,<span class="fl">0.1</span><span class="op">)</span> <span class="co">#now try different shapes and scale values  </span></span>
<span><span class="va">dg</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/GammaDist.html">dgamma</a></span><span class="op">(</span><span class="va">X</span>,shape<span class="op">=</span><span class="fl">1</span>,scale<span class="op">=</span><span class="fl">1</span><span class="op">)</span>   </span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/plot1.html">plot1</a></span><span class="op">(</span><span class="va">X</span>,<span class="va">dg</span>,xlab <span class="op">=</span> <span class="st">"Quantile"</span>,<span class="st">"Probability Density"</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">X</span>,<span class="fu"><a href="https://rdrr.io/r/stats/GammaDist.html">dgamma</a></span><span class="op">(</span><span class="va">X</span>,shape<span class="op">=</span><span class="fl">1.5</span>,scale<span class="op">=</span><span class="fl">1</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">2</span>,lty<span class="op">=</span><span class="fl">2</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">X</span>,<span class="fu"><a href="https://rdrr.io/r/stats/GammaDist.html">dgamma</a></span><span class="op">(</span><span class="va">X</span>,shape<span class="op">=</span><span class="fl">2</span>,scale<span class="op">=</span><span class="fl">1</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">3</span>,lty<span class="op">=</span><span class="fl">3</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">X</span>,<span class="fu"><a href="https://rdrr.io/r/stats/GammaDist.html">dgamma</a></span><span class="op">(</span><span class="va">X</span>,shape<span class="op">=</span><span class="fl">4</span>,scale<span class="op">=</span><span class="fl">1</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">4</span>,lty<span class="op">=</span><span class="fl">4</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/legend.html">legend</a></span><span class="op">(</span><span class="st">"topright"</span>,legend<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Shape 1"</span>,<span class="st">"Shape 1.5"</span>,<span class="st">"Shape 2"</span>,  </span>
<span>       <span class="st">"Shape 4"</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">3</span>,col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">3</span>,<span class="fl">4</span><span class="op">)</span>,bty<span class="op">=</span><span class="st">"n"</span>,cex<span class="op">=</span><span class="fl">1.25</span>,lty<span class="op">=</span><span class="fl">1</span><span class="op">:</span><span class="fl">4</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/mtext.html">mtext</a></span><span class="op">(</span><span class="st">"Scale c = 1"</span>,side<span class="op">=</span><span class="fl">3</span>,outer<span class="op">=</span><span class="cn">FALSE</span>,line<span class="op">=</span><span class="op">-</span><span class="fl">1.1</span>,cex<span class="op">=</span><span class="fl">1.0</span>,font<span class="op">=</span><span class="fl">7</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-4-22" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-4-22-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="04-application_files/figure-html/fig-4-22-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-4-22-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;4.22: Different Gamma distributions all with a scale c = 1.0.
</figcaption></figure>
</div>
</div>
</div>
<p>在 “多项式分布”一节中，我们使用正态分布来描述一个世代中长度的预期分布。也有可能使用 Gamma 分布来更好地描述物种的生长模式。</p>
</section><section id="beta-分布的似然" class="level2" data-number="4.12"><h2 data-number="4.12" class="anchored" data-anchor-id="beta-分布的似然">
<span class="header-section-number">4.12</span> Beta 分布的似然</h2>
<p>Beta 分布只适用于 0.0 到 1.0 之间的变量值。这使它成为模拟中另一个非常有用的分布，因为从 0 到 1 之间的分布中采样是比较常见的，而不可能获得超出这些限制的值，如 <a href="#fig-4-23" class="quarto-xref">图&nbsp;<span>4.23</span></a> 。在 “不确定性”一章中，我们将使用多变量正态分布，这需要使用一个额外的 R 软件包。可用于分析和模拟的分布阵列非常庞大。探索是发现其特性的最佳途径。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb99"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#Illustrate different Beta function curves. Figure 4.23  </span></span>
<span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">1</span>, length <span class="op">=</span> <span class="fl">1000</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/parset.html">parset</a></span><span class="op">(</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">x</span>,<span class="fu"><a href="https://rdrr.io/r/stats/Beta.html">dbeta</a></span><span class="op">(</span><span class="va">x</span>,shape1<span class="op">=</span><span class="fl">3</span>,shape2<span class="op">=</span><span class="fl">1</span><span class="op">)</span>,type<span class="op">=</span><span class="st">"l"</span>,lwd<span class="op">=</span><span class="fl">2</span>,ylim<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">4</span><span class="op">)</span>,  </span>
<span>     yaxs<span class="op">=</span><span class="st">"i"</span>,panel.first<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/graphics/grid.html">grid</a></span><span class="op">(</span><span class="op">)</span>, xlab<span class="op">=</span><span class="st">"Variable 0 - 1"</span>,   </span>
<span>     ylab<span class="op">=</span><span class="st">"Beta Probability Density - Scale1 = 3"</span><span class="op">)</span>  </span>
<span><span class="va">bval</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1.25</span>,<span class="fl">2</span>,<span class="fl">4</span>,<span class="fl">10</span><span class="op">)</span>  </span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="va">bval</span><span class="op">)</span><span class="op">)</span>   </span>
<span>  <span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">x</span>,<span class="fu"><a href="https://rdrr.io/r/stats/Beta.html">dbeta</a></span><span class="op">(</span><span class="va">x</span>,shape1<span class="op">=</span><span class="fl">3</span>,shape2<span class="op">=</span><span class="va">bval</span><span class="op">[</span><span class="va">i</span><span class="op">]</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="op">(</span><span class="va">i</span><span class="op">+</span><span class="fl">1</span><span class="op">)</span>,lty<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">i</span><span class="op">+</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/legend.html">legend</a></span><span class="op">(</span><span class="fl">0.5</span>,<span class="fl">3.95</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1.0</span>,<span class="va">bval</span><span class="op">)</span>,col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">7</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">2</span>,bty<span class="op">=</span><span class="st">"n"</span>,lty<span class="op">=</span><span class="fl">1</span><span class="op">:</span><span class="fl">5</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-4-23" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-4-23-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="04-application_files/figure-html/fig-4-23-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-4-23-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;4.23: Different Beta probability density distributions all with a shape1 value = 3.0, and with values of shape2 ranging from 1 to 10.
</figcaption></figure>
</div>
</div>
</div>
</section><section id="贝叶斯定理" class="level2" data-number="4.13"><h2 data-number="4.13" class="anchored" data-anchor-id="贝叶斯定理">
<span class="header-section-number">4.13</span> 贝叶斯定理</h2>
<section id="简介" class="level3" data-number="4.13.1"><h3 data-number="4.13.1" class="anchored" data-anchor-id="简介">
<span class="header-section-number">4.13.1</span> 简介</h3>
<p>贝叶斯统计在渔业科学中的应用不断扩大（McAllister 等，1994；McAllister 和 Ianelli，1997；Punt 和 Hilborn，1997；反对意见见 Dennis，1996；最近见 Winker 等，2018）。Gelman 等（2014）出版了一本与这些方法的使用相关的优秀书籍。在此，我们不打算对渔业中使用的方法进行回顾；Punt 和 Hilborn（1997）中有很好的介绍，而且还有许多更近期的例子。相反，我们将集中讨论渔业中使用的贝叶斯方法的基础，并与最大似然法进行一些比较。关于如何使用这些方法的详情，请参阅 “不确定性”一章。</p>
<p>条件概率用于描述人们对特定事件发生的概率感兴趣的情况，比如在事件 <span class="math inline">\(A\)</span> 已经发生的情况下，事件 <span class="math inline">\(B_i\)</span> 发生的概率。这个表达式的符号是 <span class="math inline">\(P (B_i | A)\)</span>，其中垂直线“|” 表示“给定（given）”的意思。</p>
<p>贝叶斯定理就是基于对这种条件概率的操纵。因此，如果一组 <span class="math inline">\(n\)</span> 个事件，标记为 <span class="math inline">\(B_i\)</span>，在事件 <span class="math inline">\(A\)</span> 发生的情况下发生，那么我们可以正式地发展贝叶斯定理。首先，我们考虑在 <span class="math inline">\(A\)</span> 发生的情况下观察到特定 <span class="math inline">\(B_i\)</span> 的概率:</p>
<p><span id="eq-4_44"><span class="math display">\[
P\left( {{B}_{i}}|A \right)=\frac{P\left( A \&amp; B_i \right)}{P\left( A \right)}   
\qquad(4.44)\]</span></span></p>
<p>也就是说，在 <span class="math inline">\(A\)</span> 已经发生的情况下，<span class="math inline">\(B_i\)</span> 发生的概率等于 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B_i\)</span> 同时发生的概率除以 <span class="math inline">\(A\)</span> 发生的概率。以同样的方式，我们可以考虑给定事件 <span class="math inline">\(B_i\)</span> 发生的情况下事件 <span class="math inline">\(A\)</span> 的条件概率。</p>
<p><span id="eq-4_45"><span class="math display">\[
P\left( {A}|{B_i} \right)=\frac{P\left( {A} \&amp; {B}_{i} \right)}{P\left( {B}_{i} \right)}  
\qquad(4.45)\]</span></span></p>
<p>这两种条件概率可以重新排列，得到:</p>
<p><span id="eq-4_46"><span class="math display">\[
P\left( A|{B_i} \right)P\left( {B}_{i} \right)=P\left( A \&amp; {B}_{i} \right)  
\qquad(4.46)\]</span></span></p>
<p>我们使用这个代替 <a href="#eq-4_44" class="quarto-xref">公式&nbsp;<span>4.44</span></a> 中的 <span class="math inline">\(P(A \&amp; B_i)\)</span> 项可得到 传统的贝叶斯定理：</p>
<p><span id="eq-4_47"><span class="math display">\[
P\left({B_i}|A\right)=\frac{P\left(A|{B_i}\right)P\left({B_i}\right)}{P\left(A\right)}    
\qquad(4.47)\]</span></span></p>
<p>如果我们把这个看似晦涩的定理翻译成这样，即 <span class="math inline">\(A\)</span> 代表从自然界获得的数据，而各种 <span class="math inline">\(B_i\)</span> 作为可以用来解释数据的单独假设（假设是模型加上参数向量 <span class="math inline">\(\theta\)</span>），那么我们就可以推导出渔业中使用的贝叶斯定理的形式。因此，<span class="math inline">\(P(A | B_i)\)</span> 就是给定模型加上参数 <span class="math inline">\(B_i\)</span> （假设）的数据 <span class="math inline">\(A\)</span> 的似然;我们已经从极大似然理论和实践中熟悉了这一点。新内容是 <span class="math inline">\(P(B_i)\)</span>，它是在对数据 <span class="math inline">\(A\)</span> 进行任何分析或考虑之前假设的概率。这就是假设 <span class="math inline">\(B_i\)</span> 的<strong>先验</strong>概率。 <a href="#eq-4_47" class="quarto-xref">公式&nbsp;<span>4.47</span></a> 中的 <span class="math inline">\(P(A)\)</span> 是所有可能的数据和假设组合的组合概率。“所有”这个词的使用需要强调，因为它实际上意味着考虑所有可能的结果。这种完备性就是为什么贝叶斯统计在纸牌游戏和其他受限制的机会游戏等封闭系统中如此有效的原因。然而，在开放世界中，所有的可能性都被考虑过是一个强有力的假设。最好的解释是，所考虑的一系列备选假设（模型加特定参数）构成了正在进行的分析的适用范围。b也就是对于所有 <span class="math inline">\(B_i\)</span>， <span class="math inline">\(\sum P(B_i|A)=0\)</span>，因此得到了 <a href="#eq-4_48" class="quarto-xref">公式&nbsp;<span>4.48</span></a>。</p>
<p><span id="eq-4_48"><span class="math display">\[
P\left(A\right)=\sum\limits_{i=1}^{n}{P\left( A|{B_i}\right)}P\left({B_i}\right)  
\qquad(4.48)\]</span></span></p>
</section><section id="贝叶斯方法" class="level3" data-number="4.13.2"><h3 data-number="4.13.2" class="anchored" data-anchor-id="贝叶斯方法">
<span class="header-section-number">4.13.2</span> 贝叶斯方法</h3>
<p>如前所述，贝叶斯定理与条件概率有关(Gelman et al, 2014)，因此，当我们试图确定一系列 <span class="math inline">\(n\)</span> 个离散假设（ <span class="math inline">\(H_i = model + \theta_i\)</span> ）中哪个是最可能的时，我们使用:</p>
<p><span id="eq-4_49"><span class="math display">\[
P\left\{ {H_i}|data \right\}=\frac{L\left\{data|{H_i}\right\}P\left\{{H_i} \right\}}{\sum\limits_{i=1}^{n}{\left[ L\left\{ data|{H_i} \right\}P\left\{{H_i}\right\} \right]}}  
\qquad(4.49)\]</span></span></p>
<p>其中 <span class="math inline">\(H_i\)</span> 指的是被考虑的 <span class="math inline">\(n\)</span> 个假设中的 <span class="math inline">\(i\)</span> （假设是具有特定参数值集的特定模型），而数据只是模型拟合的数据。重要的是，<span class="math inline">\(P \{H_i | data\}\)</span> 是假设 <span class="math inline">\(H_i\)</span> 的<strong>后验</strong>概率(即 0 到 1 之间的严格概率)。这定义了除数 <span class="math inline">\(\sum\limits_{i=1}^{n}{\left[ L\left\{ data|{H_i} \right\}P\left\{{H_i}\right\} \right]}\)</span>，重新调整后的概率总和为 1.0。在考虑观察数据之前，<span class="math inline">\(P\{H_i \}\)</span> 是假设的先验概率（模型加上特定的参数值）。同样，这是一个严格的概率，所有假设的先验值之和必须为 1。最后，<span class="math inline">\(L\left\{data|H_i\right\}\)</span> 是给定假设 <span class="math inline">\(i\)</span> 时数据的似然，正如之前在最大似然法部分所讨论的那样。</p>
<p>如果参数是连续变量（如von Bertalanffy 曲线中 <span class="math inline">\(L_\infty\)</span> 和 <span class="math inline">\(K\)</span>），替代假设必须使用连续参数的向量来描述，而不是使用离散参数集的列表，这样贝叶斯条件概率就变成了连续的:</p>
<p><span id="eq-4_50"><span class="math display">\[
P\left\{ {H_i}|data \right\}=\frac{L\left\{ data|{H_i} \right\}P\left({H_i} \right)}{\int\limits_{i=1}^{n}{L\left[ \left\{data|{H_i}\right\}P\left\{{H_i}\right\} \right]d{H_i}}}  
\qquad(4.50)\]</span></span></p>
<p>在渔业和生态学中，要使用贝叶斯定理生成所需的后验分布，我们需要三样东西：</p>
<ol type="1">
<li>要考虑的模型假设列表（即我们要尝试的参数和模型的组合（或范围））；</li>
<li>计算每个假设 <span class="math inline">\(i\)</span> 下观测数据的概率密度所需的似然函数, <span class="math inline">\(L\left\{data|H_i\right\}\)</span> ；</li>
<li>每个假设 <span class="math inline">\(i\)</span> 的先验概率，标准化后所有先验概率之和等于 1.0。</li>
</ol>
<p>除了对一组先验概率的要求之外，这与确定最大似然的要求完全相同。然而，先验概率的引入是一个很大的区别，也是我们将重点讨论的内容。这种方法的本质是利用数据信息更新先验概率。</p>
<p>如果模型中有许多参数需要估计，那么确定特定问题中的后验概率所涉及的整合工作就会耗费大量的计算机时间。用于确定贝叶斯后验分布的技术有很多，Gelman 等（2014）介绍了比较常用的方法。我们将介绍和讨论一种估算贝叶斯后验概率的灵活方法（MCMC），我们将在讨论不确定性特征的章节中使用这种方法。这实际上是一种新的模型拟合方法，但为了方便起见，我们将把它包含在有关不确定性的章节中。贝叶斯分析法的明确目标不仅仅是发现后验分布的模式，从最大似然的角度看，后验分布可能被认为代表了最优模型。相反，其目的是明确描述分析得出的不同可能结果的相对概率，即描述每个参数和模型输出的不确定性。可能会有一个最可能的结果，但它是在所有其他可能性的概率分布的背景下提出的。</p>
</section><section id="先验概率" class="level3" data-number="4.13.3"><h3 data-number="4.13.3" class="anchored" data-anchor-id="先验概率">
<span class="header-section-number">4.13.3</span> 先验概率</h3>
<p>对于如何确定先验概率没有任何限制。人们可能已经从以前对同一物种的同一种群或不同种群的研究中对模型的参数有了很好的估计，或者至少对参数有了有用的限制（如不可能出现负增长或存活率 &gt;1）。如果没有足够的信息来产生有参考价值的先验概率，通常会采用一组均匀或无信息的先验概率，即所有被考虑的假设都被赋予相等的先验概率。这样做的效果是在分析前给每个假设赋予相同的权重。当然，如果在分析中不考虑某一假设，这就等于给该假设（模型加上特定参数）分配了一个零权重或先验概率。</p>
<p>使用先验概率的想法之所以如此吸引人，原因之一是认为所有可能的参数值都具有同等可能性的想法有违直觉。渔业和生物学方面的任何经验都会让人对生物体的自然制约因素有先验知识。因此，举例来说，即使在彻底取样之前，就应该预料到深水（大于 800 米水深）鱼类物种，如橙连鳍鲑（<em>Hoplostethus atlanticus</em>），很可能寿命长、生长慢。这一特征反映了生活在低温和低生产力环境中的影响。贝叶斯方法的一大优势是，它允许人们摆脱所有可能性都具有同等可能性的反直觉假设。我们可以尝试在先验分布中捕捉模型中不同参数值的相对可能性。这样，先验知识就可以直接纳入分析。</p>
<p>使用先前信息可能引起争议的地方是在纳入意见时。例如，可以召集渔业利益相关者，了解他们对当前生物量等参数状况的看法（也许是相对于五年前的看法）。这种以委员会为基础的参数先验概率分布可以很容易地纳入贝叶斯分析，就像单独评估的结果一样（不是以前的评估，人们会认为以前的评估使用了大部分相同的数据，而是使用了独立的数据）。在正式分析中，是否应同样接受来自这些不同来源的先验数据，经常引起争论。Punt 和 Hilborn（1997，第 43 页）在一篇可读性很强的文章中讨论了先验来源的合理性问题：</p>
<p><em>因此，我们强烈建议，无论何时进行贝叶斯评估，都应非常谨慎地充分记录各种先验分布的依据….。在选择先验函数形式时应小心谨慎，因为选择不当会导致不正确的推论。我们还注意到一种低估不确定性的倾向，即指定不切实际的先验信息–这种倾向应得到明确承认并加以避免。</em></p>
<p>辩论的有效性的使用丰富的案底已经这样，walters 和 Ludwig （1994）建议非翔实的先验被用来作为一个默认在贝股的评估。 然而，除了不同意沃尔特斯和路德维希，平底船和Hilborn(1997年)突出强调的一个问题与我们的能力产生非翔实的前科(Box 和 Tiao,1973). 一个问题产生非翔实的先验是，他们感到特别测量系统( <a href="#fig-4-24" class="quarto-xref">图&nbsp;<span>4.24</span></a>). 因此，现有概率密度，是统一的线性规模将不代表一个统一的密度在一个日志的规模。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb100"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co"># can prior probabilities ever be uniniformative?  Figure 4.24  </span></span>
<span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fl">1</span><span class="op">:</span><span class="fl">1000</span>  </span>
<span><span class="va">y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fl">1</span><span class="op">/</span><span class="fl">1000</span>,<span class="fl">1000</span><span class="op">)</span>  </span>
<span><span class="va">cumy</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cumsum.html">cumsum</a></span><span class="op">(</span><span class="va">y</span><span class="op">)</span>  </span>
<span><span class="va">group</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sort.html">sort</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">50</span><span class="op">)</span>,<span class="fl">20</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="va">xlab</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fl">10</span>,<span class="fl">990</span>,<span class="fl">20</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html">par</a></span><span class="op">(</span>mfrow<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">)</span>,mai<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.45</span>,<span class="fl">0.3</span>,<span class="fl">0.05</span>,<span class="fl">0.05</span><span class="op">)</span>,oma<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.0</span>,<span class="fl">1.0</span>,<span class="fl">0.0</span>,<span class="fl">0.0</span><span class="op">)</span><span class="op">)</span>   </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html">par</a></span><span class="op">(</span>cex<span class="op">=</span><span class="fl">0.75</span>, mgp<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1.35</span>,<span class="fl">0.35</span>,<span class="fl">0</span><span class="op">)</span>, font.axis<span class="op">=</span><span class="fl">7</span>,font<span class="op">=</span><span class="fl">7</span>,font.lab<span class="op">=</span><span class="fl">7</span><span class="op">)</span>    </span>
<span><span class="va">yval</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/tapply.html">tapply</a></span><span class="op">(</span><span class="va">y</span>,<span class="va">group</span>,<span class="va">sum</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">x</span>,<span class="va">cumy</span>,type<span class="op">=</span><span class="st">"p"</span>,pch<span class="op">=</span><span class="fl">16</span>,cex<span class="op">=</span><span class="fl">0.5</span>,panel.first<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/graphics/grid.html">grid</a></span><span class="op">(</span><span class="op">)</span>,  </span>
<span>     xlim<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">1000</span><span class="op">)</span>,ylim<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">1</span><span class="op">)</span>,ylab<span class="op">=</span><span class="st">""</span>,xlab<span class="op">=</span><span class="st">"Linear Scale"</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span>,<span class="va">cumy</span>,type<span class="op">=</span><span class="st">"p"</span>,pch<span class="op">=</span><span class="fl">16</span>,cex<span class="op">=</span><span class="fl">0.5</span>,panel.first<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/graphics/grid.html">grid</a></span><span class="op">(</span><span class="op">)</span>,  </span>
<span>     xlim<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">7</span><span class="op">)</span>,xlab<span class="op">=</span><span class="st">"Logarithmic Scale"</span>,ylab<span class="op">=</span><span class="st">""</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/mtext.html">mtext</a></span><span class="op">(</span><span class="st">"Cumulative Probability"</span>,side<span class="op">=</span><span class="fl">2</span>,outer<span class="op">=</span><span class="cn">TRUE</span>,cex<span class="op">=</span><span class="fl">0.9</span>,font<span class="op">=</span><span class="fl">7</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-4-24" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-4-24-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="04-application_files/figure-html/fig-4-24-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-4-24-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;4.24: A constant set of prior probabilities accumulated on a linear scale and on a log scale.
</figcaption></figure>
</div>
</div>
</div>
<p>由于渔业模型往往充满非线性关系，使用非信息先验是有争议的，因为对某些参 数非信息先验很可能对其他参数有信息影响。虽然这种影响可能是无意的，但却不容忽视。这意味着信息可能以完全无意的方式被纳入模型，这也是讨论先验概率时争议的一个来源。如果要使用先验概率，那么 Punt 和 Hilborn（1997 年）关于充分记录先验概率的起源和属性的建议是非常明智的。我们将在 “不确定性”一章中更详细地探讨贝叶斯方法的使用。</p>
</section></section><section id="结语" class="level2" data-number="4.14"><h2 data-number="4.14" class="anchored" data-anchor-id="结语">
<span class="header-section-number">4.14</span> 结语</h2>
<p>在任何分析情况下，使用哪种方法最合适在很大程度上取决于分析的目标。如果只想找到模型的最佳拟合方法，那么使用最小二乘法、最大似然法还是贝叶斯法其实并不重要。有时，先用最小二乘法拟合模型，然后再用似然法或贝叶斯法建立置信区间和进行风险评估，可能会更容易一些。</p>
<p>模型参数和输出的置信区间可以用传统的渐近方法（保证对称，对于强非线性模型，只能大致近似）、似然法或贝叶斯后验积分法（两者显然密切相关）来生成，也可以用引导法或蒙特卡洛技术。</p>
<p>并不是说只有使用贝叶斯方法才能更详细地评估备选管理方案的相对风险。Bootstrapping 和 Monte Carlo 方法为开展此类工作提供了必要的工具。首要问题是确定分析目标。然而，如果在拟合模型时，不对每个参数的不确定性以及模型对各种输入参数动态的敏感性有一定的了解，那将是一种糟糕的做法。由于各种方法之间没有明显的优胜者，如果有时间，使用一种以上的方法（特别是比较似然概 念、贝叶斯后验和引导法）是一个合理的想法。至于是否有足够的资源让资源建模者有时间进行这一系列分析，则是一个不同但同样现实的问题。如果发现存在重大差异，那么最好对其背后的原因进行调查。如果不同的程序得出的答案大相径庭，则可能是对现有数据的要求过高，需要进行不同的分析。</p>


<!-- -->

<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-birkes1993" class="csl-entry" role="listitem">
Birkes, David, 和 Yadolah Dodge. 1993. <span>《Alternative Methods of Regression》</span>. <em>Wiley Series in Probability and Statistics</em>, 六月. <a href="https://doi.org/10.1002/9781118150238">https://doi.org/10.1002/9781118150238</a>.
</div>
<div id="ref-modelse2004" class="csl-entry" role="listitem">
Burnham, Kenneth P., 和 David R. Anderson, 编. 2004. <em>Model Selection and Multimodel Inference</em>. Springer New York. <a href="https://doi.org/10.1007/b97636">https://doi.org/10.1007/b97636</a>.
</div>
<div id="ref-fournier1998" class="csl-entry" role="listitem">
Fournier, Daid A, John Hampton, 和 John R Sibert. 1998. <span>《MULTIFAN-CL: A Length-Based, Age-Structured Model for Fisheries Stock Assessment, with Application to South Pacific Albacore, <span><em>Thunnus Alalunga</em></span>》</span>. <em>Canadian Journal of Fisheries and Aquatic Sciences</em> 55 (9): 2105–16. <a href="https://doi.org/10.1139/f98-100">https://doi.org/10.1139/f98-100</a>.
</div>
<div id="ref-fournier2012" class="csl-entry" role="listitem">
Fournier, David A., Hans J. Skaug, Johnoel Ancheta, James Ianelli, Arni Magnusson, Mark N. Maunder, Anders Nielsen, 和 John Sibert. 2012. <span>《AD Model Builder: Using Automatic Differentiation for Statistical Inference of Highly Parameterized Complex Nonlinear Models》</span>. <em>Optimization Methods and Software</em> 27 (2): 233–49. <a href="https://doi.org/10.1080/10556788.2011.597854">https://doi.org/10.1080/10556788.2011.597854</a>.
</div>
<div id="ref-helidoniotis2013" class="csl-entry" role="listitem">
Helidoniotis, Fay, 和 Malcolm Haddon. 2013. <span>《Growth Models for Fisheries: The Effect of Unbalanced Sampling Error On Model Selection, Parameter Estimation, and Biological Predictions》</span>. <em>Journal of Shellfish Research</em> 32 (1): 223–35. <a href="https://doi.org/10.2983/035.032.0129">https://doi.org/10.2983/035.032.0129</a>.
</div>
<div id="ref-kristensen2016" class="csl-entry" role="listitem">
Kristensen, Kasper, Anders Nielsen, Casper W. Berg, Hans Skaug, 和 Bradley M. Bell. 2016. <span>《<span><strong>TMB</strong></span>: Automatic Differentiation and Laplace Approximation》</span>. <em>Journal of Statistical Software</em> 70 (5). <a href="https://doi.org/10.18637/jss.v070.i05">https://doi.org/10.18637/jss.v070.i05</a>.
</div>
</div>
</section></main><!-- /main --><script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "已复制");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "已复制");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><nav class="page-navigation"><div class="nav-page nav-page-previous">
      <a href="./03-simpopmodel.html" class="pagination-link  aria-label=">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">简单种群模型</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./05-staticModel.html" class="pagination-link" aria-label="<span class='chapter-number'>5</span>&nbsp; <span class='chapter-title'>静态模型</span>">
        <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">静态模型</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">源代码</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb101" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="fu"># 模型参数估算 {#sec-paraestimat}</span></span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a><span class="fu">## 引言</span></span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a>生态学和渔业学学建模的一个更重要的方面涉及到模型与数据的拟合。这种模型拟合需要:</span>
<span id="cb101-6"><a href="#cb101-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-7"><a href="#cb101-7" aria-hidden="true" tabindex="-1"></a><span class="ss">-   </span>从对自然感兴趣的过程中获得的数据（样本、观测），</span>
<span id="cb101-8"><a href="#cb101-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-9"><a href="#cb101-9" aria-hidden="true" tabindex="-1"></a><span class="ss">-   </span>明确地选择一个适合手头任务的模型结构（模型设计，然后选择------大的主题本身），</span>
<span id="cb101-10"><a href="#cb101-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-11"><a href="#cb101-11" aria-hidden="true" tabindex="-1"></a><span class="ss">-   </span>明确地选择概率密度函数来表示当比较时，模拟过程的预测将如何不同于自然观测的预期分布(选择残差结构) ，最后,</span>
<span id="cb101-12"><a href="#cb101-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-13"><a href="#cb101-13" aria-hidden="true" tabindex="-1"></a><span class="ss">-   </span>寻找模型参数，优化之间的预测模型和任何观测数据(模型拟合的准则)匹配。</span>
<span id="cb101-14"><a href="#cb101-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-15"><a href="#cb101-15" aria-hidden="true" tabindex="-1"></a>在上面的最后一个需求中，将模型与数据相匹配时所涉及的许多技巧/诡计/魔术都集中在那个看起来无害的单词或概念上进行**优化**。这是一个几乎是恶作剧的想法，有时会导致一个人陷入麻烦，虽然它也是一个挑战，往往是有趣的。生成所谓*最佳拟合*模型的不同方法是本章的重点。它围绕着在描述模型的质量拟合可用数据时使用什么标准的想法，以及如何实现明确选择的标准。</span>
<span id="cb101-16"><a href="#cb101-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-17"><a href="#cb101-17" aria-hidden="true" tabindex="-1"></a>我一直使用"显式"这个词，并且有很好的理由，但是需要一些解释。很多人都有过对数据进行线性回归拟合的经验，但是，根据我的经验，很少有人意识到，当他们拟合这样一个模型时，他们假设使用了加性正态随机残差(正态误差) ，并且他们正在最小化这些残差的平方和。根据上述四个要求，当将一个线性回归应用到一个数据集时，线性关系的假设回答了第二个要求，正态误差的使用(附加常数方差的假设)回答了第三个要求，平方和的最小化是满足第四个要求的选择。通常情况下，最好是明确地了解自己在做什么，而不是仅仅出于习惯或模仿他人。为了对这些模型拟合需求做出最合适的选择(即做出可以辩护的选择) ，分析师还需要了解被建模的自然过程。一个人可以假设和断言几乎任何事情，但只有这样的选择可以得到有效的辩护。作为一个更一般的陈述，如果一个人不能为一组选择辩护，那么他就不应该做出这些选择。</span>
<span id="cb101-18"><a href="#cb101-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-19"><a href="#cb101-19" aria-hidden="true" tabindex="-1"></a><span class="fu">### 最优化</span></span>
<span id="cb101-20"><a href="#cb101-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-21"><a href="#cb101-21" aria-hidden="true" tabindex="-1"></a>在 Microsoft Excel 中，当对数据进行模型拟合时，使用内置的Excel解算器找到最佳模型参数。这包括设置电子表格，使最佳拟合标准（平方和、最大似然等，见下文）由一个单元格的内容表示，而模型参数和使用的数据则包含在其他相互关联的单元格中。改变一个模型的参数会改变产生的预测值，这反过来又会改变最佳拟合的标准值。一个 "最佳"参数集可以通过寻找能优化观察值和预测值之间的匹配的参数来找到。这听起来很简单，但实际上是一门艺术，其中要做许多假设和决定。在 Excel 求解器中，人们确定了包含模型参数的单元格，然后求解器的内部代码将修改这些值，同时监测 "最佳拟合标准"单元格，直到找到一个最小（或最大）值（或遇到一个例外）。实际上，这样的电子表格设置构成了在Excel中使用求解器的语法。我们将在 R 中使用求解器或优化函数，它们也有一个必要的语法，但它并不比设置电子表格更复杂，只是更抽象而已。</span>
<span id="cb101-22"><a href="#cb101-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-23"><a href="#cb101-23" aria-hidden="true" tabindex="-1"></a>当对单一数据集（如年龄-长度）用2至6个参数进行非动态过程建模时，模型拟合通常是相对简单的。然而，当处理一个种群的动态过程时，可能会变得更加复杂，涉及到补充、个体生长、自然死亡和多个捕鱼船队的捕捞死亡。可能有许多类型的数据，可能有多于几十个甚至几百个参数。在这种情况下，为了调整预测值与观测值的拟合质量，必须使用某种形式的自动优化或非线性求解器。</span>
<span id="cb101-24"><a href="#cb101-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-25"><a href="#cb101-25" aria-hidden="true" tabindex="-1"></a>优化是一个非常大的研究课题，在CRAN任务视图中详细讨论了许多可用的选项。在 CRAN 任务视图：优化和数学编程中可以找到详细的讨论，网址是<span class="ot">&lt;https://cran.r-project.org/&gt;</span>。在本章的学习中，我们将主要使用内置的函数 <span class="in">`nlm()`</span>(尝试 <span class="in">`?nlm`</span>)，但也有许多替代方法（包括 <span class="in">`nlminb()`</span>、<span class="in">`optim()`</span>等）。如果你要参与模型拟合，那么真的值得阅读 R-CRAN 上关于优化的任务视图，并且作为第一步，探索 <span class="in">`nlm()`</span> 和 <span class="in">`optim()`</span> 函数的帮助和例子。</span>
<span id="cb101-26"><a href="#cb101-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-27"><a href="#cb101-27" aria-hidden="true" tabindex="-1"></a>有时有可能猜测出一组参数，产生看似合理的可视拟合，至少对简单的静态模型来说是如此。然而，虽然这种通过*目测拟合*（fitting-by-eye）可以为估计模型的参数提供可用的起点，但它并不构成将模型与数据拟合的可辩护的标准。这是因为我的 "目测拟合"（或称 "黑暗中的狂刺"）很可能与你的 "目测拟合"（或称 "有根据的猜测"）不同。与其使用这样的观点，不如使用一些更正式定义的模型与数据拟合质量的标准。</span>
<span id="cb101-28"><a href="#cb101-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-29"><a href="#cb101-29" aria-hidden="true" tabindex="-1"></a>这里的重点是如何设置 R 代码，以便使用最小二乘法或最大似然法进行模型参数估计，特别是后者。我们以后对贝叶斯方法的考虑将主要集中在对不确定性的描述上。我们将通过重复的例子和相关的解释来说明模型的拟合过程。目的是阅读本节应该使读者能够建立自己的模型来解决参数值。我们将尝试以一种一般的方式来做这件事，它应该适合于许多问题的调整。</span>
<span id="cb101-30"><a href="#cb101-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-31"><a href="#cb101-31" aria-hidden="true" tabindex="-1"></a><span class="fu">## 最佳拟合标准</span></span>
<span id="cb101-32"><a href="#cb101-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-33"><a href="#cb101-33" aria-hidden="true" tabindex="-1"></a>确定什么是数据的最佳模型拟合通常有三种方法。</span>
<span id="cb101-34"><a href="#cb101-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-35"><a href="#cb101-35" aria-hidden="true" tabindex="-1"></a>一般来讲，模型拟合包括观测变量 $x$ 与为描述建模过程而提出候选模型所预测值 $\hat x$ 之间残差平方的最小化（<span class="in">`ssq()`</span>）：</span>
<span id="cb101-36"><a href="#cb101-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-37"><a href="#cb101-37" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-38"><a href="#cb101-38" aria-hidden="true" tabindex="-1"></a>ssq = \sum_{i=1}^n (x_i- \hat x_i)^2 </span>
<span id="cb101-39"><a href="#cb101-39" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_1}</span>
<span id="cb101-40"><a href="#cb101-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-41"><a href="#cb101-41" aria-hidden="true" tabindex="-1"></a>其中 $x_i$ 是 $n$ 个观测中的第 $i$ 个观测值，$\hat x_i$ 是给定观测值 $i$ 的模型预测值（例如，如果 $x_i$ 为鱼 $i$ 的年龄-体长，则 $\hat x_i$ 为一些候选生长模型中得到的鱼 $i$ 的年龄-体长预测值）。$\hat x$ 中的 $\hat{}$ 表示 $x$ 的预测值。</span>
<span id="cb101-42"><a href="#cb101-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-43"><a href="#cb101-43" aria-hidden="true" tabindex="-1"></a>或者，模型拟合可以涉及最小化负对数似然（在本书中为<span class="in">`-veLL`</span> 或 <span class="in">`negLL`</span>），这需要确定1）定义的模型结构，2）一组模型参数和 3）残差的期望概率分布的情况下，每个观测数据点的似然有多大。最小化负对数似然相当于最大化所有似然的乘积或所有数据点的对数似然总和。给定一个观测值 $x$ 的集合，一个可以预测 $\hat x$ 的模型结构，以及一组模型参数 $\theta$ ，那么这些观测值的总似然定义为：</span>
<span id="cb101-44"><a href="#cb101-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-45"><a href="#cb101-45" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-46"><a href="#cb101-46" aria-hidden="true" tabindex="-1"></a>\begin{aligned}  </span>
<span id="cb101-47"><a href="#cb101-47" aria-hidden="true" tabindex="-1"></a>{L} &amp;= \prod\limits_{i=1}^{n}{{L}\left( {x_i|\theta}\right )}  <span class="sc">\\</span>  </span>
<span id="cb101-48"><a href="#cb101-48" aria-hidden="true" tabindex="-1"></a>{-veLL} &amp;= -\sum\limits_{i=1}^{n}{ \log{({L}\left( {x_i|\theta}\right )})}  </span>
<span id="cb101-49"><a href="#cb101-49" aria-hidden="true" tabindex="-1"></a>\end{aligned}  </span>
<span id="cb101-50"><a href="#cb101-50" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_2}</span>
<span id="cb101-51"><a href="#cb101-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-52"><a href="#cb101-52" aria-hidden="true" tabindex="-1"></a>其中 $L$ 为总似然，等于$\prod L(x|\theta)$ 或给定参数值 $\theta$ 每个观测值 $x$ 的概率密度（似然）积（在每种情况下，离期望值 $\hat x$ 越远，似然越低）。*-veLL* 是给定候选模型参数 $\theta$ 时观测值 $x$ 的总负对数似然，每个观测点 $x$ 的 $n$ 对数似然的负数和。 我们使用对数似然，因为大多数似然是非常小的数值，当与许多其他非常小的数字相乘时，会变得非常小，以至于有可能导致浮点溢出的计算机错误。对数变换将乘法变为加法，避免了这种风险( $\prod$ 转变为 $\Sigma$ ）。</span>
<span id="cb101-53"><a href="#cb101-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-54"><a href="#cb101-54" aria-hidden="true" tabindex="-1"></a>第三种方法是使用贝叶斯方法，该方法使用先验概率，即在模型拟合中给予每个备选参数向量的初始相对权重。贝叶斯方法结合并更新任何关于最可能的模型参数的先验知识（先验概率），以及在不同的候选参数向量 $\theta$ 下任何新数据的似然。就我们的目的而言，贝叶斯方法和最大似然法之间的两个关键区别是包含先验似然和重新缩放数值，以便使后验概率的总和达到1.0。重要的一点是，将给定一组参数的数据似然转换为给定数据参数的真实概率。给定数据 $x$ 的特定参数集 $\theta$ 的后验概率定义为：</span>
<span id="cb101-55"><a href="#cb101-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-56"><a href="#cb101-56" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-57"><a href="#cb101-57" aria-hidden="true" tabindex="-1"></a>P(\theta|x)=\frac{L(x|\theta)P(\theta)}{\sum\limits_{i=1}^{n}{\left<span class="co">[</span><span class="ot"> L(x_i|\theta)P(\theta)\right</span><span class="co">]</span>}}</span>
<span id="cb101-58"><a href="#cb101-58" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_3}</span>
<span id="cb101-59"><a href="#cb101-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-60"><a href="#cb101-60" aria-hidden="true" tabindex="-1"></a>其中 $P(\theta)$ 为参数集 $\theta$ 的先验概率，通过给定参数 $\theta$ 的数据 $x$ 似然、$L(x|\theta)p(\theta)$ 进行更新，除数 $\sum_{i=1}^n<span class="co">[</span><span class="ot">L(x_i|\theta)P(\theta)</span><span class="co">]</span>$ 对结果重新缩放或归一化，因此在给定数据的情况下，所有参数向量 $\sum P(\theta|x)$ 的后验概率之和为 1.0。最终 <span class="co">[</span><span class="ot">@eq-4_3</span><span class="co">]</span> 是一个近似值，因为除数中的总和实际上应该是一个连续分布的积分，但在实践中，近似值就足够了，而且是处理复杂渔业模型参数时的唯一实际选择，其后验分布没有简单的分析解。</span>
<span id="cb101-61"><a href="#cb101-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-62"><a href="#cb101-62" aria-hidden="true" tabindex="-1"></a>这里我们将主要关注负对数似然的最小化（相当于最大似然）。尽管其他方法也会得到一些关注。当我们探讨不确定性的特征时，贝叶斯方法将得到更多的关注。</span>
<span id="cb101-63"><a href="#cb101-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-64"><a href="#cb101-64" aria-hidden="true" tabindex="-1"></a>微软的Excel在很多方面都是很好的软件，但是实现最大似然法，特别是贝叶斯法往往是缓慢和笨拙的，它们更适合于在R中实现。</span>
<span id="cb101-65"><a href="#cb101-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-66"><a href="#cb101-66" aria-hidden="true" tabindex="-1"></a>识别平方残差之和、最大似然法和贝叶斯法并不是一个详尽的清单，它是在对数据进行模型拟合时可能使用的标准。例如，可以使用 "绝对残差之和"（sum of absolute residuals, SAR），它通过使用残差的绝对值而不是将其平方化来避免合并正负残差的问题 <span class="co">[</span><span class="ot">@birkes1993</span><span class="co">]</span>。尽管存在这种最佳模型拟合的替代标准，我们将只关注上述三种。其他更常用的替代方法包括所谓的稳健方法，这些方法致力于减少现有数据中的离群值，或极端的、被认为是不典型的值的影响。如前所述，优化是一个庞大而详细的研究领域，我向你推荐它的研究，并祝你好运。</span>
<span id="cb101-67"><a href="#cb101-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-68"><a href="#cb101-68" aria-hidden="true" tabindex="-1"></a><span class="fu">## R语言中的模型拟合</span></span>
<span id="cb101-69"><a href="#cb101-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-70"><a href="#cb101-70" aria-hidden="true" tabindex="-1"></a>虽然覆盖参数空间的网格搜索可能是寻找最佳参数集的一种可能的方法，但随着参数数量增加到两个以上，它将变得越来越难操作，直到最后变得不可行。我们将不再考虑这种可能性。相反，为了便于寻找最佳参数集，我们需要一个用软件实现的非线性优化器。</span>
<span id="cb101-71"><a href="#cb101-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-72"><a href="#cb101-72" aria-hidden="true" tabindex="-1"></a>R系统有一系列不同的优化函数，每个函数都使用不同的算法（请参见CRAN任务中关于优化的内容）。解算函数（<span class="in">`nlm()`</span>）和其他函数一样，需要给出一个参数值的初始猜测，然后这些初始参数值由优化函数改变，在每次改变时，预测值会像<span class="in">`ssq()`</span> 或<span class="in">`negLL()`</span> 一样重新计算。优化函数，如<span class="in">`nlm()`</span>，继续改变参数值（它们如何做到这一点是算法不同的地方），直到找到一个组合，根据所选择的任何标准被定义为 "最适合"（或无法找到进一步的改进）。渔业种群评估模型通常有许多参数，数量在10或100个左右（一些有更多的参数，需要更多的专业软件，例如 @fournier1998; @fournier2012; @kristensen2016 ）。在本书中，我们不会估计大量的参数，但无论数量多少，其原理都是相似的。</span>
<span id="cb101-73"><a href="#cb101-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-74"><a href="#cb101-74" aria-hidden="true" tabindex="-1"></a><span class="fu">### 模型需求</span></span>
<span id="cb101-75"><a href="#cb101-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-76"><a href="#cb101-76" aria-hidden="true" tabindex="-1"></a>讨论模型拟合的理论是有帮助的，但并没有阐明如何在 R 中实现在实践中拟合模型。优化软件用于改变参数向量内的值，但我们需要为其提供重复计算预测值的方法，该预测值将用于与观测值进行多次比较以找到最佳解决方案（如果成功的）。我们需要开发可以重复调用的代码块，这正是设计 R 语言函数的目的。为了在 R语言 中实现对现实世界问题的模型拟合，我们需要考虑四个形式要求：</span>
<span id="cb101-77"><a href="#cb101-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-78"><a href="#cb101-78" aria-hidden="true" tabindex="-1"></a><span class="ss">-   </span>来自所研究系统的观测（数据）。这可能是渔业中一个具有观测到的渔获量、cpue、渔获量的年龄和长度组成等，或者它可能是更简单的东西，例如鱼样本的观测到的长度和相关的年龄（但是如何将其放入 R ?),</span>
<span id="cb101-79"><a href="#cb101-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-80"><a href="#cb101-80" aria-hidden="true" tabindex="-1"></a><span class="ss">-   </span>第一个 R语言函数，表示系统的候选模型，当提供参数向量时，该函数用于计算预测值，以便与任何可用的观测值进行比较，</span>
<span id="cb101-81"><a href="#cb101-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-82"><a href="#cb101-82" aria-hidden="true" tabindex="-1"></a><span class="ss">-   </span>第二个 R语言 函数，计算选定的最佳拟合标准、最小化最小二乘或最小化负对数似然，以便将观测值与预测值进行比较。这需要能够返回单个值，反映输入参数和数据，然后可以通过最终所需的函数最小化，即</span>
<span id="cb101-83"><a href="#cb101-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-84"><a href="#cb101-84" aria-hidden="true" tabindex="-1"></a><span class="ss">-   </span>第三个R 语言函数（我们将倾向于使用 <span class="in">`nlm()`</span>）来自动优化所选最佳拟合标准的值。</span>
<span id="cb101-85"><a href="#cb101-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-86"><a href="#cb101-86" aria-hidden="true" tabindex="-1"></a>因此，需要输入数据和三个函数（ @fig-4-1 ）但是，因为我们可以使用内置函数来进行优化，模型拟合通常需要编写最多两个函数，一个用于从使用的任何模型计算预测值另一个用于计算拟合标准（有时，在更简单的练习中，这两个可以组合成一个函数）。</span>
<span id="cb101-87"><a href="#cb101-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-88"><a href="#cb101-88" aria-hidden="true" tabindex="-1"></a>我们在本书中假设读者至少熟悉模型拟合背后的概念，如拟合线性回归，因此我们将直接转向非线性模型拟合。这些相对简单的示例的主要目的是介绍 R 中可用求解器的使用和语法。</span>
<span id="cb101-89"><a href="#cb101-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-90"><a href="#cb101-90" aria-hidden="true" tabindex="-1"></a><span class="in">```{r }</span></span>
<span id="cb101-91"><a href="#cb101-91" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: fig-4-1</span></span>
<span id="cb101-92"><a href="#cb101-92" aria-hidden="true" tabindex="-1"></a><span class="in">#| echo: FALSE</span></span>
<span id="cb101-93"><a href="#cb101-93" aria-hidden="true" tabindex="-1"></a><span class="in">#| out-width: 50%</span></span>
<span id="cb101-94"><a href="#cb101-94" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-align: "center"</span></span>
<span id="cb101-95"><a href="#cb101-95" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-cap: "将模型拟合到数据时的输入、功能需求和输出。优化函数（此处为 `nlm()` ）最小化负对数似然（或平方和）并需要一个初始参数向量开始。此外，优化器需要一个函数（可能是 `negLL()` ）来计算它在搜索最小值时产生的每个参数向量的对应负对数似然。  要计算负对数似然需要一个函数（可能是 `vB()` ）来生成预测值，以便与输入的观测值进行比较。"</span></span>
<span id="cb101-96"><a href="#cb101-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-97"><a href="#cb101-97" aria-hidden="true" tabindex="-1"></a><span class="in">knitr::include_graphics('f401-1.png')</span></span>
<span id="cb101-98"><a href="#cb101-98" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-99"><a href="#cb101-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-100"><a href="#cb101-100" aria-hidden="true" tabindex="-1"></a><span class="fu">### 年龄-体长示例</span></span>
<span id="cb101-101"><a href="#cb101-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-102"><a href="#cb101-102" aria-hidden="true" tabindex="-1"></a>将模型拟合到数据仅仅意味着估计模型的参数，以便其预测与观测结果相匹配，以及根据选择的最佳拟合标准。作为在 R 中将模型拟合到数据的第一个说明，我们将使用一个简单的示例用著名的 von Bertalanffy 生长曲线 (von Bertalanffy, 1938) 拟合一组年龄-长度数据。这样的数据集包含在 R 包 **MQMF**（尝试 <span class="in">`?LatA`</span>）中。要使用您自己的数据，一种选择是生成一个逗号分隔的变量 (csv) 文件，其中包含最少的年龄和长度列，每个列都有一个列名（LatA 仅有年龄和长度列；请参阅其帮助页面）。可以使用 <span class="in">`laa &lt;- read.csv(file="filename.csv", header=TRUE)`</span> 将此 csv 文件读入 R中。</span>
<span id="cb101-103"><a href="#cb101-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-104"><a href="#cb101-104" aria-hidden="true" tabindex="-1"></a>von Bertalanffy 长度-年龄生长曲线表示为：</span>
<span id="cb101-105"><a href="#cb101-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-106"><a href="#cb101-106" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-107"><a href="#cb101-107" aria-hidden="true" tabindex="-1"></a>\begin{aligned}    </span>
<span id="cb101-108"><a href="#cb101-108" aria-hidden="true" tabindex="-1"></a>&amp; {{\hat{L}}_t}={L_{\infty}}\left( 1-{e^{\left( -K\left( t-{t_0} \right) \right)}} \right) <span class="sc">\\</span>    </span>
<span id="cb101-109"><a href="#cb101-109" aria-hidden="true" tabindex="-1"></a>&amp; {L_t}={L_{\infty}}\left( 1-{e^{\left( -K\left( t-{t_0} \right) \right)}} \right)+\varepsilon  <span class="sc">\\</span>    </span>
<span id="cb101-110"><a href="#cb101-110" aria-hidden="true" tabindex="-1"></a>&amp; {L_t}= {\hat{L}}_t + \varepsilon    </span>
<span id="cb101-111"><a href="#cb101-111" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb101-112"><a href="#cb101-112" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_4}</span>
<span id="cb101-113"><a href="#cb101-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-114"><a href="#cb101-114" aria-hidden="true" tabindex="-1"></a>其中 $\hat L_t$ 为年龄 $t$ 的期望或预测长度，$L_{\infty}$ 为渐近平均最大长度，$K$ 为是决定达到最大值的增长率系数，$t_0$ 为物种长度0时的假设年龄（von Bertalanffy, 1938），一旦我们有了$L_{\infty}$，$K$ ，$t_0$ 的估算值（或假设值），该非线性方程就提供了一种预测不同年龄的年龄-长度的方法。在拟合数据模型时，使用 <span class="co">[</span><span class="ot">@eq-4_4</span><span class="co">]</span> 中的下面两个方程，其中$L_t$ 为观测值，等于预测值加上正态随机离差$\varepsilon = N(0, \sigma^2)$ ，其中的每个值可能是正的或负的（某一年龄的观测值可能大于或小于期望长度）。最下面的方程实际上是关于决定使用什么剩余误差结构。在本章中，我们将描述生态学和渔业中使用的一系列可供选择的误差结构。它们并非都是可加的，有些是用函数关系而不是常数定义的（如$\sigma$）。</span>
<span id="cb101-115"><a href="#cb101-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-116"><a href="#cb101-116" aria-hidden="true" tabindex="-1"></a>关于 @eq-4_4 是非线性的表述是明确的，因为早期估计 von Bertalanffy （ <span class="in">`vB()`</span> ）生长曲线参数值的方法涉及各种旨在近似线性化曲线的变换（例如 Beverton和Holt, 1957）。在20世纪50年代末和60年代，拟合 von Bertalanffy 曲线不是一件小事。令人高兴的是，不再需要这样的转换，这样的曲线拟合也变得很简单。</span>
<span id="cb101-117"><a href="#cb101-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-118"><a href="#cb101-118" aria-hidden="true" tabindex="-1"></a><span class="fu">### 其它的生长模型</span></span>
<span id="cb101-119"><a href="#cb101-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-120"><a href="#cb101-120" aria-hidden="true" tabindex="-1"></a>个体生长的研究文献很多，描述生物体生长的模型多种多样（Schnute and Richards, 1990）。自Beverton和Holt (1957)引入以来，von Bertalanffy （<span class="in">`vB()`</span> ）曲线一直是主要的渔业模型，已被渔业科学家广泛应用。然而，只是因为该模型非常普遍命令使用，对于所有物种来说，并不一定意味着该模型总是提供生长的最佳描述。模型选择是渔业建模中一个至关重要但经常被忽视的方面 <span class="co">[</span><span class="ot">@modelse2004; @helidoniotis2013</span><span class="co">]</span>。这里两种替代 <span class="in">`vB()`</span>的两种模型可能是 Gompertz 生长曲线 （Gompertz, 1925）:</span>
<span id="cb101-121"><a href="#cb101-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-122"><a href="#cb101-122" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-123"><a href="#cb101-123" aria-hidden="true" tabindex="-1"></a>\hat{L_t} =ae^{-be^{ct}} \text{ or } \hat{L_t}=a \exp(-b \exp(ct)) </span>
<span id="cb101-124"><a href="#cb101-124" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_5}</span>
<span id="cb101-125"><a href="#cb101-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-126"><a href="#cb101-126" aria-hidden="true" tabindex="-1"></a>以及广义Michaelis-Menten 方程（Maynard Smith and Slatkin, 1973; Legendre and Legendre, 1998):</span>
<span id="cb101-127"><a href="#cb101-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-128"><a href="#cb101-128" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-129"><a href="#cb101-129" aria-hidden="true" tabindex="-1"></a>{{\hat{L}}_{t}}=\frac{at}{b+{{t}^{c}}}  </span>
<span id="cb101-130"><a href="#cb101-130" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_6}</span>
<span id="cb101-131"><a href="#cb101-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-132"><a href="#cb101-132" aria-hidden="true" tabindex="-1"></a>每个模型也有 a、b 和 c 三个参数，每个模型都能对生长过程的经验数据作出令人信服的描述。可以对某些参数进行生物学解释（如最大平均长度），但这些模型最终只提供了对生长过程的经验描述。如果把模型解释为反映了现实，就会导致完全不可信的预测，如不存在一米长的鱼（Knight，1968 ）。在文献中，参数可以有不同的符号（例如，Maynard Smith 和 Slatkin（1973）用 $R_0$ 代替 $a$ 表示 Michaelis-Menton），但基本结构形式是相同的。在对 **MQM**F 的年龄-长度数据集 $LatA$ 中的鱼类进行 von Bertalanffy 生长曲线拟合后，我们可以利用不同模型来说明尝试这些替代模型的价值，并对应该使用哪种模型保持开放的心态。这个问题在我们讨论不确定性时会再次出现，因为我们可以从不同的模型中得到不同的结果。在对任何自然过程建模时，模型选择都是需要做出的重大决定之一。重要的是，通过这种方式尝试不同的模型，还能强化模型与数据拟合的过程。</span>
<span id="cb101-133"><a href="#cb101-133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-134"><a href="#cb101-134" aria-hidden="true" tabindex="-1"></a><span class="fu">## 残差平方和</span></span>
<span id="cb101-135"><a href="#cb101-135" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-136"><a href="#cb101-136" aria-hidden="true" tabindex="-1"></a>数据拟合模型的经典方法称为 "最小残差平方和"（见 @eq-4_1 和 @eq-4_7 ），或更常称为 "最小二乘法"。这种方法被认为是高斯提出的（Nievergelt, 2000, 引用了高斯 1823 年用拉丁文撰写的一本书的译文：*Theoria combinationis observationum erroribus minimis obnoxiae*）。无论如何，最小二乘法符合两个多世纪以来用于确定一组预测值与观测值最佳拟合的策略。这种策略就是确定一个所谓的目标函数（最佳拟合标准），根据函数结构，可以将其最小化或最大化。就残差平方和而言，我们需要从相关的观测值中减去每个预测值，将不同的结果平方（以避免出现负值），然后将所有值相加，并使用数学（解析解）或其他方法将该相加值最小化：</span>
<span id="cb101-137"><a href="#cb101-137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-138"><a href="#cb101-138" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-139"><a href="#cb101-139" aria-hidden="true" tabindex="-1"></a>ssq=\sum\limits_{i=1}^{n}{{{\left( {{O}_{i}}-{\hat{E}_{i}} \right)}^{2}}}  </span>
<span id="cb101-140"><a href="#cb101-140" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_7}</span>
<span id="cb101-141"><a href="#cb101-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-142"><a href="#cb101-142" aria-hidden="true" tabindex="-1"></a>其中，$sqq$ 为 *n* 个观测值的残差平方和，$O_i$ 为第$i$ 个观测值，$E_i$为第第$i$ 个观测值的期望值或预测值。**MQMF** 包中的<span class="in">`ssq`</span> 函数仅仅是一个封装器，它调用了用于生成预测值的任何函数，然后计算并返回平方差和。根据不同问题的复杂程度和数据输入，我们通常需要创建新的函数作为封装。<span class="in">`ssq()`</span> 很好地说明了这样一个事实，即在一个传递给函数的参数中，也可以传递其他函数（在本例中，在 <span class="in">`ssq()`</span>内我们调用了传递给 <span class="in">`funk`</span> 的函数，当然在使用<span class="in">`ssq()`</span>时，我们输入的是与当前问题相关的实际函数，也许是<span class="in">`vB`</span>，注意在用作函数参数时没有括号）。</span>
<span id="cb101-143"><a href="#cb101-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-144"><a href="#cb101-144" aria-hidden="true" tabindex="-1"></a><span class="fu">### 最小二乘法的假设</span></span>
<span id="cb101-145"><a href="#cb101-145" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-146"><a href="#cb101-146" aria-hidden="true" tabindex="-1"></a>最小二乘方法的一个主要假设是，残差项呈正态分布，所有观测变量值具有相等的方差；即在$\varepsilon = N(0, \sigma^2)$ 中，$\sigma^2$ 是常数。如果以任何方式对数据进行变换，则变换对残差的影响可能违反这一假设。相反，如果残差以系统的方式变化，则转换可以标准化残差方差。因此，如果数据是对数正态分布，那么对数变换将使数据标准化，然后可以有效地使用最小二乘。与往常一样，考虑或可视化数据和残差的形式(由拟合模型产生)是一种很好的做法。</span>
<span id="cb101-147"><a href="#cb101-147" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-148"><a href="#cb101-148" aria-hidden="true" tabindex="-1"></a><span class="fu">### 数值求解</span></span>
<span id="cb101-149"><a href="#cb101-149" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-150"><a href="#cb101-150" aria-hidden="true" tabindex="-1"></a>渔业科学中大多数有趣的问题都没有解析解（如线性回归），有必要使用数值方法通过定义的"最佳拟合"标准（如最小残差平方和(最小二乘)）来寻找最佳拟合模型。这显然会涉及到一点R编程，但是R的一个很大的优势是，一旦你开发了一套分析方法，就可以直接地将其应用到新的数据集。</span>
<span id="cb101-151"><a href="#cb101-151" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-152"><a href="#cb101-152" aria-hidden="true" tabindex="-1"></a>在下面的示例中，我们用 **MQMF** 中的一些实用函数来辅助描述。我们需要 5 个函数拟合和比较上文定义的3种不同的生长模型，其中4个需要编写。前3个函数用于估计与观测数据进行比较的各年龄长度预测值。本例有3个候选模型函数分别对应3种不同的生长曲线：`vB()`、 `Gz()`和 `mm()`。第4个函数用作计算预测值及其相关观测值的平方和残差。这里将使用 **MQMF** 中的函数 <span class="in">`ssq()`</span>（你应该检查并理解其代码）。该函数返回单一数值，该值将由最后一个函数 <span class="in">`nlm()`</span>最小化，该函数需要自动最小化求解。R 函数 <span class="in">`nlm()`</span>使用用户定义的广义函数，用 $f$ 表示 (尝试 <span class="in">`args(nlm)`</span>，或<span class="in">`formals(nlm)`</span>以查看完整的参数列表），用于计算最小值（在本例中为 <span class="in">`ssq()`</span>），而<span class="in">`ssq()`</span>又使用预测生长曲线中各年龄长度的函数（例如<span class="in">`vB()`</span>）。如果我们使用不同的生长曲线函数（例如<span class="in">`Gz()`</span>），只需将<span class="in">`nlm()`</span>调用代码中指向<span class="in">`vB()`</span> 的地方改为 <span class="in">`Gz()`</span> ，并修改参数值以适应 <span class="in">`Gz()`</span>函数，以便代码产生可用的结果。从根本上说，<span class="in">`nlm()`</span>通过改变输入参数(称作 *p* )来最小化<span class="in">`ssq()`</span>，无论选择哪个参数，都会改变生长函数<span class="in">`vB()`</span>、<span class="in">`Gz()`</span>或<span class="in">`mm()`</span>的结果，。</span>
<span id="cb101-153"><a href="#cb101-153" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-154"><a href="#cb101-154" aria-hidden="true" tabindex="-1"></a><span class="in">`nlm()`</span>只是 **R** 中用于非线性优化的函数之一，候选函数包括 <span class="in">`optim()`</span>和 <span class="in">`nlminb()`</span>（请阅读 <span class="in">`nlm`</span>中的文档，CRAN 上关于优化的任务视图列出了旨在解决优化问题的包）。</span>
<span id="cb101-155"><a href="#cb101-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-158"><a href="#cb101-158" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-159"><a href="#cb101-159" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(MQMF)</span>
<span id="cb101-160"><a href="#cb101-160" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb101-161"><a href="#cb101-161" aria-hidden="true" tabindex="-1"></a> <span class="co">#setup optimization using growth and ssq  </span></span>
<span id="cb101-162"><a href="#cb101-162" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(LatA)      <span class="co"># try ?LatA   assumes library(MQMF) already run  </span></span>
<span id="cb101-163"><a href="#cb101-163" aria-hidden="true" tabindex="-1"></a> <span class="co">#convert equations 4.4 to 4.6 into vectorized R functions  </span></span>
<span id="cb101-164"><a href="#cb101-164" aria-hidden="true" tabindex="-1"></a> <span class="co">#These will over-write the same functions in the MQMF package  </span></span>
<span id="cb101-165"><a href="#cb101-165" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-166"><a href="#cb101-166" aria-hidden="true" tabindex="-1"></a>vB <span class="ot">&lt;-</span> <span class="cf">function</span>(p, ages) <span class="fu">return</span>(p[<span class="dv">1</span>]<span class="sc">*</span>(<span class="dv">1</span><span class="sc">-</span><span class="fu">exp</span>(<span class="sc">-</span>p[<span class="dv">2</span>]<span class="sc">*</span>(ages<span class="sc">-</span>p[<span class="dv">3</span>]))))  </span>
<span id="cb101-167"><a href="#cb101-167" aria-hidden="true" tabindex="-1"></a>Gz <span class="ot">&lt;-</span> <span class="cf">function</span>(p, ages) <span class="fu">return</span>(p[<span class="dv">1</span>]<span class="sc">*</span><span class="fu">exp</span>(<span class="sc">-</span>p[<span class="dv">2</span>]<span class="sc">*</span><span class="fu">exp</span>(p[<span class="dv">3</span>]<span class="sc">*</span>ages)))  </span>
<span id="cb101-168"><a href="#cb101-168" aria-hidden="true" tabindex="-1"></a>mm <span class="ot">&lt;-</span> <span class="cf">function</span>(p, ages) <span class="fu">return</span>((p[<span class="dv">1</span>]<span class="sc">*</span>ages)<span class="sc">/</span>(p[<span class="dv">2</span>] <span class="sc">+</span> ages<span class="sc">^</span>p[<span class="dv">3</span>]))  </span>
<span id="cb101-169"><a href="#cb101-169" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-170"><a href="#cb101-170" aria-hidden="true" tabindex="-1"></a> <span class="co">#specific function to calc ssq. The ssq within MQMF is more  </span></span>
<span id="cb101-171"><a href="#cb101-171" aria-hidden="true" tabindex="-1"></a>ssq <span class="ot">&lt;-</span> <span class="cf">function</span>(p,funk,agedata,observed) {        <span class="co">#general and is  </span></span>
<span id="cb101-172"><a href="#cb101-172" aria-hidden="true" tabindex="-1"></a>  predval <span class="ot">&lt;-</span> <span class="fu">funk</span>(p,agedata)        <span class="co">#not limited to p and agedata  </span></span>
<span id="cb101-173"><a href="#cb101-173" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">sum</span>((observed <span class="sc">-</span> predval)<span class="sc">^</span><span class="dv">2</span>,<span class="at">na.rm=</span><span class="cn">TRUE</span>))  </span>
<span id="cb101-174"><a href="#cb101-174" aria-hidden="true" tabindex="-1"></a>} <span class="co">#end of ssq   </span></span>
<span id="cb101-175"><a href="#cb101-175" aria-hidden="true" tabindex="-1"></a> <span class="co"># guess starting values for Linf, K, and t0, names not needed  </span></span>
<span id="cb101-176"><a href="#cb101-176" aria-hidden="true" tabindex="-1"></a>pars <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"Linf"</span><span class="ot">=</span><span class="fl">27.0</span>,<span class="st">"K"</span><span class="ot">=</span><span class="fl">0.15</span>,<span class="st">"t0"</span><span class="ot">=</span><span class="sc">-</span><span class="fl">2.0</span>) <span class="co">#ssq should=1478.449  </span></span>
<span id="cb101-177"><a href="#cb101-177" aria-hidden="true" tabindex="-1"></a><span class="fu">ssq</span>(<span class="at">p=</span>pars, <span class="at">funk=</span>vB, <span class="at">agedata=</span>LatA<span class="sc">$</span>age, <span class="at">observed=</span>LatA<span class="sc">$</span>length)   </span>
<span id="cb101-178"><a href="#cb101-178" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-179"><a href="#cb101-179" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-180"><a href="#cb101-180" aria-hidden="true" tabindex="-1"></a><span class="in">`ssq()`</span>函数取代了全局环境中的 <span class="in">`MQMF::ssq()`</span>函数，但也返回一个数值，例如上面的 1478.449，它是 <span class="in">`nlm()`</span>函数的第一个输入，也是需要最小化的值。</span>
<span id="cb101-181"><a href="#cb101-181" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-182"><a href="#cb101-182" aria-hidden="true" tabindex="-1"></a><span class="fu">### 将函数作为参数传递给其它函数</span></span>
<span id="cb101-183"><a href="#cb101-183" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-184"><a href="#cb101-184" aria-hidden="true" tabindex="-1"></a>在上例中，我们定义了一些用于模型拟合数据所需的函数，确定了要比较的生长模型，也定义了计算平方和的函数。刚刚做的一个非常重要的方面是，为了计算平方和，我们将 <span class="in">`vB()`</span>函数作为参数传递给 <span class="in">`ssq()`</span>函数。这意味着我们传递了一个函数，它有参数，作为另一个函数的参数之一。你可以在这里看到潜在的混乱，所以有必要集中精力，保持清晰。目前，我们定义 <span class="in">`ssq()`</span>的方式似乎并没有那么引人注目，因为我们已经在对<span class="in">`ssq()`</span>的调用中显式地定义了两个函数的参数。但是 R 有一些妙招，我们可以用它来泛化包含其他函数作为参数的函数，主要的一个使用了神奇的省略号<span class="in">`…`</span>，对于任何R函数，除非实参在其定义中设置了默认值，否则每个实参都必须给定一个值。在上面的<span class="in">`ssq()`</span>函数中，我们包含了仅由 <span class="in">`ssq()`</span> 使用的参数（ *funk* 和 *observed* ），以及仅由函数 `funk`使用的参数（ *p* 和 *agedata*）。这在本例子中很有效，因为我们故意将生长函数定义为具有相同的输入参数，但如果我们想使用的 <span class="in">`funk`</span> 有不同的输入，可能是因为我们拟合的是选择性曲线而不是生长曲线，该怎么办？显然，我们需要编写一个不同的 <span class="in">`ssq()`</span> 函数。为了允许在更多情况下重用更通用的函数，R 的作者（R Core Team, 2019）包含了这个概念 <span class="in">`…`</span>，它将匹配其他方式不匹配的任何参数，因此可用于输入<span class="in">`funk`</span> 函数的参数。因此，我们可以这样重新定义 <span class="in">`ssq()`</span>:</span>
<span id="cb101-185"><a href="#cb101-185" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-188"><a href="#cb101-188" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-189"><a href="#cb101-189" aria-hidden="true" tabindex="-1"></a> <span class="co"># Illustrates use of names within function arguments  </span></span>
<span id="cb101-190"><a href="#cb101-190" aria-hidden="true" tabindex="-1"></a>vB <span class="ot">&lt;-</span> <span class="cf">function</span>(p,ages) <span class="fu">return</span>(p[<span class="dv">1</span>]<span class="sc">*</span>(<span class="dv">1</span><span class="sc">-</span><span class="fu">exp</span>(<span class="sc">-</span>p[<span class="dv">2</span>] <span class="sc">*</span>(ages<span class="sc">-</span>p[<span class="dv">3</span>]))))  </span>
<span id="cb101-191"><a href="#cb101-191" aria-hidden="true" tabindex="-1"></a>ssq <span class="ot">&lt;-</span> <span class="cf">function</span>(funk,observed,...) { <span class="co"># only define ssq arguments  </span></span>
<span id="cb101-192"><a href="#cb101-192" aria-hidden="true" tabindex="-1"></a>  predval <span class="ot">&lt;-</span> <span class="fu">funk</span>(...) <span class="co"># funks arguments are implicit  </span></span>
<span id="cb101-193"><a href="#cb101-193" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">sum</span>((observed <span class="sc">-</span> predval)<span class="sc">^</span><span class="dv">2</span>,<span class="at">na.rm=</span><span class="cn">TRUE</span>))  </span>
<span id="cb101-194"><a href="#cb101-194" aria-hidden="true" tabindex="-1"></a>} <span class="co"># end of ssq   </span></span>
<span id="cb101-195"><a href="#cb101-195" aria-hidden="true" tabindex="-1"></a>pars <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"Linf"</span><span class="ot">=</span><span class="fl">27.0</span>,<span class="st">"K"</span><span class="ot">=</span><span class="fl">0.15</span>,<span class="st">"t0"</span><span class="ot">=</span><span class="sc">-</span><span class="fl">2.0</span>) <span class="co"># ssq should = 1478.449  </span></span>
<span id="cb101-196"><a href="#cb101-196" aria-hidden="true" tabindex="-1"></a><span class="fu">ssq</span>(<span class="at">p=</span>pars, <span class="at">funk=</span>vB, <span class="at">ages=</span>LatA<span class="sc">$</span>age, <span class="at">observed=</span>LatA<span class="sc">$</span>length) <span class="co">#if no  </span></span>
<span id="cb101-197"><a href="#cb101-197" aria-hidden="true" tabindex="-1"></a><span class="fu">ssq</span>(vB,LatA<span class="sc">$</span>length,pars,LatA<span class="sc">$</span>age) <span class="co"># name order is now vital!  </span></span>
<span id="cb101-198"><a href="#cb101-198" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-199"><a href="#cb101-199" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-200"><a href="#cb101-200" aria-hidden="true" tabindex="-1"></a>这意味着 <span class="in">`ssq()`</span> 函数现在更加通用，可以与任何输入函数一起使用，这些输入函数可用于生成一组预测值，以便与一组观测值进行比较。**MQMF** 中的 <span class="in">`ssq()`</span> 函数就是这样实现的；查阅帮助 <span class="in">`?ssq`</span>。一般的想法是，您必须定义主函数中使用的所有参数，但任何仅在被调用函数（此处称为 *funk* ）中使用的参数都可以在 `…`中传递。最好是显式地命名参数，这样它们的顺序就无关紧要了，并且您需要非常小心地键入，如果您拼错了通过`…`传递的参数的名称，并不一定会出错！例如，使用大写的 *LatA\$Age* 而不是 *LatA\$age* 不会出错，但会导致结果为 0 而不是 1478.440。这是因为 *LatA\$Age = NULL*，即使输入不正确也是有效的。很明显，<span class="in">`…`</span> 可能非常有用，但如果你像我一样输入错误，其本身也是有风险的。</span>
<span id="cb101-201"><a href="#cb101-201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-204"><a href="#cb101-204" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-205"><a href="#cb101-205" aria-hidden="true" tabindex="-1"></a> <span class="co"># Illustrate a problem with calling a function in a function  </span></span>
<span id="cb101-206"><a href="#cb101-206" aria-hidden="true" tabindex="-1"></a> <span class="co"># LatA$age is typed as LatA$Age but no error, and result = 0  </span></span>
<span id="cb101-207"><a href="#cb101-207" aria-hidden="true" tabindex="-1"></a><span class="fu">ssq</span>(<span class="at">funk=</span>vB, <span class="at">observed=</span>LatA<span class="sc">$</span>length, <span class="at">p=</span>pars, <span class="at">ages=</span>LatA<span class="sc">$</span>Age) <span class="co"># !!!  </span></span>
<span id="cb101-208"><a href="#cb101-208" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-209"><a href="#cb101-209" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-210"><a href="#cb101-210" aria-hidden="true" tabindex="-1"></a>如果你匆忙行事，没有给参数命名，那么如果你弄错了参数顺序，也会失败。例如，如果你要输入的是<span class="in">`ssq(LatA$length, vB, pars, LatA$age)`</span>而不是<span class="in">`ssq(vB, LatA$length, pars, LatA$age)`</span>，就会出现错误：*Error in funk(...): could not find function " funk "*。为了以防万一，你可以自己试试。对你的代码进行试验几乎没什么坏处，不会弄坏你的电脑，而你可能会学到一些东西。</span>
<span id="cb101-211"><a href="#cb101-211" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-212"><a href="#cb101-212" aria-hidden="true" tabindex="-1"></a><span class="fu">### 模型拟合</span></span>
<span id="cb101-213"><a href="#cb101-213" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-214"><a href="#cb101-214" aria-hidden="true" tabindex="-1"></a>如果我们绘制 *LatA* 数据集图（ @fig-4-2 ），可以看到一些典型的年龄-长度数据。图中有 358 个点（试试 <span class="in">`dim(LatA)`</span>），许多点彼此重叠，但是当我们使用 <span class="in">`plot()`</span>函数中 <span class="in">`rgb()`</span>选项来改变图中颜色的透明度时，较高年龄组鱼类的颜色相对稀疏性就会显现出来。另外，我们可以使用 <span class="in">`jitter()`</span>为每个绘制点的位置添加噪声，以查看数据点的相对密度。每当你处理经验数据时，总是值得你花时间至少将其绘制成画并探索其属性。</span>
<span id="cb101-215"><a href="#cb101-215" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-218"><a href="#cb101-218" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-219"><a href="#cb101-219" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-4-2</span></span>
<span id="cb101-220"><a href="#cb101-220" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "基于澳大利亚东部样本模拟的 358 条红鱼（*Centroberyx affinis*）的雌性年龄长度数据。全强度颜色表示 &gt;= 5 个点。"</span></span>
<span id="cb101-221"><a href="#cb101-221" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-222"><a href="#cb101-222" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-223"><a href="#cb101-223" aria-hidden="true" tabindex="-1"></a> <span class="co">#plot the LatA data set   Figure 4.2  </span></span>
<span id="cb101-224"><a href="#cb101-224" aria-hidden="true" tabindex="-1"></a><span class="fu">parset</span>()        <span class="co"># parset and getmax are two MQMF functions   </span></span>
<span id="cb101-225"><a href="#cb101-225" aria-hidden="true" tabindex="-1"></a>ymax <span class="ot">&lt;-</span> <span class="fu">getmax</span>(LatA<span class="sc">$</span>length) <span class="co"># simplifies use of base graphics. For  </span></span>
<span id="cb101-226"><a href="#cb101-226" aria-hidden="true" tabindex="-1"></a> <span class="co"># full colour, with the rgb as set-up below, there must be &gt;= 5 obs  </span></span>
<span id="cb101-227"><a href="#cb101-227" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(LatA<span class="sc">$</span>age,LatA<span class="sc">$</span>length,<span class="at">type=</span><span class="st">"p"</span>,<span class="at">pch=</span><span class="dv">16</span>,<span class="at">cex=</span><span class="fl">1.2</span>,<span class="at">xlab=</span><span class="st">"Age Years"</span>,   </span>
<span id="cb101-228"><a href="#cb101-228" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylab=</span><span class="st">"Length cm"</span>,<span class="at">col=</span><span class="fu">rgb</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span><span class="sc">/</span><span class="dv">5</span>),<span class="at">ylim=</span><span class="fu">c</span>(<span class="dv">0</span>,ymax),<span class="at">yaxs=</span><span class="st">"i"</span>,  </span>
<span id="cb101-229"><a href="#cb101-229" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlim=</span><span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">44</span>),<span class="at">panel.first=</span><span class="fu">grid</span>())  </span>
<span id="cb101-230"><a href="#cb101-230" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-231"><a href="#cb101-231" aria-hidden="true" tabindex="-1"></a><span class="co"># ggplot(data = LatA, aes(x = age, y = length)) +</span></span>
<span id="cb101-232"><a href="#cb101-232" aria-hidden="true" tabindex="-1"></a><span class="co">#   geom_point(size = 3, color = "red", alpha = 0.2) +</span></span>
<span id="cb101-233"><a href="#cb101-233" aria-hidden="true" tabindex="-1"></a><span class="co">#   labs(x = "Age Years", </span></span>
<span id="cb101-234"><a href="#cb101-234" aria-hidden="true" tabindex="-1"></a><span class="co">#        y = "Length cm") +</span></span>
<span id="cb101-235"><a href="#cb101-235" aria-hidden="true" tabindex="-1"></a><span class="co">#   theme_bw() </span></span>
<span id="cb101-236"><a href="#cb101-236" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-237"><a href="#cb101-237" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-238"><a href="#cb101-238" aria-hidden="true" tabindex="-1"></a>与其继续推测参数值并手动修改它们，我们可以使用 <span class="in">`nlm()`</span> 或 <span class="in">`optim()`</span>或 <span class="in">`nlminb()`</span>，它们的语法不同)来拟合所选的 *LatA* 数据的生长模型或曲线。这不仅说明了`nlm()`的语法，还说明了另外两个 **MQMF** 实用R函数 <span class="in">`magnitude()`</span>和 <span class="in">`outfit()`</span>的使用(请查阅<span class="in">`?nlm`</span>、<span class="in">`?magnitude`</span>和 <span class="in">`?outfit`</span>)。还可以查看每个函数中的代码（在控制台中输入每个函数的名称，不带参数或括号）。从现在起，我将减少提示你查看所使用函数细节的次数，但是如果看到一个新的函数，希望现查看其帮助、语法，尤其是代码是有意义的，就像查看每个所用变量的内容一样。</span>
<span id="cb101-239"><a href="#cb101-239" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-240"><a href="#cb101-240" aria-hidden="true" tabindex="-1"></a>3 个生长模型中的每一个都需要估计 3 个参数，我们需要对每个参数进行初始猜测，以启动 <span class="in">`nlm()`</span>求解。我们所做的就是为 <span class="in">`nlm()`</span>函数的每个形参/实参提供值。此外，我们还使用了 2 个额外的参数，*typsize* 和 *iterlim*。*typesize* 在 `nlm()`帮助中定义为"每个参数最小值的估计"。加入这 2 个参数一般有助于稳定搜索算法，因为它可以确保对每个参数值迭代变化尺度大致相同。一种非常常见的替代方法（我们将在更复杂的模型中使用）是在输入 `nlm()`时对每个参数进行对数变换，然后在调用的函数中对它们进行反变换，以计算预测值。但是，这只能在保证参数始终为正值情况下才可行。例如，对于 von Bertalanffy 曲线，$t_0$ 参数通常是负值，因此应使用 `magnitude()`而不是对数变换方法。默认的 `iterlim=100`意味着最多迭代 100 次，这有时是不够的，所以如果迭代达到 100 次，您应该将该数值增加到 1000 。你很快就会发现，在每次模型拟合过程中，唯一改变的是`ssq()`中的 *funk* 所指向的函数和初始参数值。这可以通过有意识地构建生长函数，使其使用完全相同的参数（通过`…`传递）。您也可以尝试在不设置 *typsize* 和 *interlim* 选项的情况下运行其中的一个或两个函数。还请注意，我们运行 Michaelis-Menton 曲线时使用了两个略有不同的初始点。</span>
<span id="cb101-241"><a href="#cb101-241" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-244"><a href="#cb101-244" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-245"><a href="#cb101-245" aria-hidden="true" tabindex="-1"></a> <span class="co"># use nlm to fit 3 growth curves to LatA, only p and funk change </span></span>
<span id="cb101-246"><a href="#cb101-246" aria-hidden="true" tabindex="-1"></a>ages <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">max</span>(LatA<span class="sc">$</span>age) <span class="co"># used in comparisons   </span></span>
<span id="cb101-247"><a href="#cb101-247" aria-hidden="true" tabindex="-1"></a>pars <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">27.0</span>,<span class="fl">0.15</span>,<span class="sc">-</span><span class="fl">2.0</span>) <span class="co"># von Bertalanffy  </span></span>
<span id="cb101-248"><a href="#cb101-248" aria-hidden="true" tabindex="-1"></a>bestvB <span class="ot">&lt;-</span> <span class="fu">nlm</span>(<span class="at">f=</span>ssq,<span class="at">funk=</span>vB,<span class="at">observed=</span>LatA<span class="sc">$</span>length,<span class="at">p=</span>pars,  </span>
<span id="cb101-249"><a href="#cb101-249" aria-hidden="true" tabindex="-1"></a>             <span class="at">ages=</span>LatA<span class="sc">$</span>age,<span class="at">typsize=</span><span class="fu">magnitude</span>(pars))  </span>
<span id="cb101-250"><a href="#cb101-250" aria-hidden="true" tabindex="-1"></a><span class="fu">outfit</span>(bestvB,<span class="at">backtran=</span><span class="cn">FALSE</span>,<span class="at">title=</span><span class="st">"vB"</span>); <span class="fu">cat</span>(<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)   </span>
<span id="cb101-251"><a href="#cb101-251" aria-hidden="true" tabindex="-1"></a>pars <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">26.0</span>,<span class="fl">0.7</span>,<span class="sc">-</span><span class="fl">0.5</span>) <span class="co"># Gompertz  </span></span>
<span id="cb101-252"><a href="#cb101-252" aria-hidden="true" tabindex="-1"></a>bestGz <span class="ot">&lt;-</span> <span class="fu">nlm</span>(<span class="at">f=</span>ssq,<span class="at">funk=</span>Gz,<span class="at">observed=</span>LatA<span class="sc">$</span>length,<span class="at">p=</span>pars,  </span>
<span id="cb101-253"><a href="#cb101-253" aria-hidden="true" tabindex="-1"></a>             <span class="at">ages=</span>LatA<span class="sc">$</span>age,<span class="at">typsize=</span><span class="fu">magnitude</span>(pars))  </span>
<span id="cb101-254"><a href="#cb101-254" aria-hidden="true" tabindex="-1"></a><span class="fu">outfit</span>(bestGz,<span class="at">backtran=</span><span class="cn">FALSE</span>,<span class="at">title=</span><span class="st">"Gz"</span>); <span class="fu">cat</span>(<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)   </span>
<span id="cb101-255"><a href="#cb101-255" aria-hidden="true" tabindex="-1"></a>pars <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">26.2</span>,<span class="fl">1.0</span>,<span class="fl">1.0</span>) <span class="co"># Michaelis-Menton - first start point  </span></span>
<span id="cb101-256"><a href="#cb101-256" aria-hidden="true" tabindex="-1"></a>bestMM1 <span class="ot">&lt;-</span> <span class="fu">nlm</span>(<span class="at">f=</span>ssq,<span class="at">funk=</span>mm,<span class="at">observed=</span>LatA<span class="sc">$</span>length,<span class="at">p=</span>pars,  </span>
<span id="cb101-257"><a href="#cb101-257" aria-hidden="true" tabindex="-1"></a>             <span class="at">ages=</span>LatA<span class="sc">$</span>age,<span class="at">typsize=</span><span class="fu">magnitude</span>(pars))  </span>
<span id="cb101-258"><a href="#cb101-258" aria-hidden="true" tabindex="-1"></a><span class="fu">outfit</span>(bestMM1,<span class="at">backtran=</span><span class="cn">FALSE</span>,<span class="at">title=</span><span class="st">"MM"</span>); <span class="fu">cat</span>(<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)  </span>
<span id="cb101-259"><a href="#cb101-259" aria-hidden="true" tabindex="-1"></a>pars <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">23.0</span>,<span class="fl">1.0</span>,<span class="fl">1.0</span>) <span class="co"># Michaelis-Menton - second start point  </span></span>
<span id="cb101-260"><a href="#cb101-260" aria-hidden="true" tabindex="-1"></a>bestMM2 <span class="ot">&lt;-</span> <span class="fu">nlm</span>(<span class="at">f=</span>ssq,<span class="at">funk=</span>mm,<span class="at">observed=</span>LatA<span class="sc">$</span>length,<span class="at">p=</span>pars,  </span>
<span id="cb101-261"><a href="#cb101-261" aria-hidden="true" tabindex="-1"></a>             <span class="at">ages=</span>LatA<span class="sc">$</span>age,<span class="at">typsize=</span><span class="fu">magnitude</span>(pars))  </span>
<span id="cb101-262"><a href="#cb101-262" aria-hidden="true" tabindex="-1"></a><span class="fu">outfit</span>(bestMM2,<span class="at">backtran=</span><span class="cn">FALSE</span>,<span class="at">title=</span><span class="st">"MM2"</span>); <span class="fu">cat</span>(<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)   </span>
<span id="cb101-263"><a href="#cb101-263" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-264"><a href="#cb101-264" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-265"><a href="#cb101-265" aria-hidden="true" tabindex="-1"></a>这些都是数值解，它们不能保证是正确的解。请注意，第一个 Michaelis-Menton 解（从 26.2,1,1 开始）的梯度相对较大，但它的 SSQ(1335.96) 非常接近第二个 Michaelis-Menton 模型拟合，而且比 <span class="in">`vB`</span> 或 <span class="in">`Gz`</span> 曲线更小（更好）。然而，梯度值表明该模型的拟合可以而且应该得到改进。如果您将参数 *a*（首个 MM 参数）的初始参数估计值从上次模型拟合中的 26.2 降到了 23，我们就会得到稍有不同的参数值、稍小的 SSQ 以及更小的梯度，从而更有把握地认为结果是个真正的最小值。实际上，如果要运行`cbind(mm(bestMM1$estimate,ages)， mm(bestMM2$estimate,ages))`，可以计算出预测值的差异从 -0.018 到 0.21%，而如果将 vB 预测值包括在内，MM2 与 vB 预测的差异从 -6.15 到 9.88% (忽略 40.6% 的最大偏差)。你也可以尝试从 vB 模型的估计中省略*typsize* 参数，这样仍然会得到最佳结果，但可查看梯度以了解为什么使用 *typsize* 有助于优化。在设置这些示例时，偶尔运行 `Gz()`模型会出现 *steptol* 可能太小的注释，将其从默认的 1e-06 改为 1e-05 可以很快解决这个问题。如果您遇到了这种情况，请在<span class="in">`nlm()`</span>命令中添加一条语句 <span class="in">`steptol=1e-05`</span>，看看诊断是否有所改善。</span>
<span id="cb101-266"><a href="#cb101-266" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-267"><a href="#cb101-267" aria-hidden="true" tabindex="-1"></a>显而易见的结论是，我们应该经常查阅 <span class="in">`nlm()`</span>的诊断注释，考虑得到的解的方案的梯度，并且使用多组初始参数猜测，以确保得到稳定的解。数值求解以软件实现为基础，用于决定何时停止迭代的规则有时会被次优解所欺骗。我们的目标是找到全局最小值，而不是局部最小值。任何非线性模型都可能产生此类次优解，因此自动拟合此类模型并非易事。在这种情况下，永远不要假设在这种情况下你得到的第一个答案一定是你正在寻找的最佳答案，即使描绘的模型拟合看起来是可以接受的。</span>
<span id="cb101-268"><a href="#cb101-268" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-269"><a href="#cb101-269" aria-hidden="true" tabindex="-1"></a>在函数调用中，如果你为每个参数命名，那么严格来讲，顺序并不重要，但我发现一致的用法可以简化代码的阅读，因此即使使用显式名称，也建议使用标准顺序。如果我们不使用显式名称，则 <span class="in">`nlm()`</span>的语法要求首先定义函数最小化（*f*）。此外，它还要求 *f* 函数，无论它是什么，在 *p* 参数中使用初始参数猜测，如果未命名，则必须排在第二位。如果你在控制台中输入 <span class="in">`formals(nlm)`</span>或 <span class="in">`args(nlm)`</span>，就可得到可以输入到函数的可能参数以及它们的默认值（如果存在）:</span>
<span id="cb101-270"><a href="#cb101-270" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-273"><a href="#cb101-273" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-274"><a href="#cb101-274" aria-hidden="true" tabindex="-1"></a> <span class="co">#The use of args() and formals()   </span></span>
<span id="cb101-275"><a href="#cb101-275" aria-hidden="true" tabindex="-1"></a><span class="fu">args</span>(nlm) <span class="co"># formals(nlm) uses more screen space. Try yourself.  </span></span>
<span id="cb101-276"><a href="#cb101-276" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-277"><a href="#cb101-277" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-278"><a href="#cb101-278" aria-hidden="true" tabindex="-1"></a>正如所见，首先要最小化函数 *f* （在本例中是 `ssq()` ），然后是初始参数 *p*，它必须是*f*所指向的任何函数所需的第一个参数。接着是省略号(三个点)，它概括了任何函数*f*的 `nlm()`代码，其后是可能的参数集，所有这些参数都具有默认值。我们修改了 *typsize* 和 *iterm* (有时也修改了`Gz()` 中的 *steptol*）；请参阅 <span class="in">`nlm()`</span>帮助以获得对每种方法的解释。</span>
<span id="cb101-279"><a href="#cb101-279" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-280"><a href="#cb101-280" aria-hidden="true" tabindex="-1"></a>在R中，”...“ 实际上指的是所需的任何其他输入，例如函数*f*指向的任何参数（本例中为`ssq`）。如果 Et `?ssq`查看参数或代码或帮助，将会看到所需函数 *funk*，该函数将用于计算相对于`ssq()`的下一个所需输入的期望值，为观测值的向量（如$O_i-E_i$）。请注意，这里没有明确提到 *funk* 使用的参数，这些参数假定是通过 .... 传递的。在对 `ssq()`的每次调用中，我们都显式地填充了这些参数，例如`nlm(f=ssq,funk=Gz, observed=LatA$length, p=pars, ages=LatA$age，)`。这样，所有要求都已满足，`ssq()`就可以开始工作。如果不小心忽略了`ages=LatA$age`参数，那么在这种情况下，R 会出现如下揭示：*Error in funk(par, independent) : argument "ages" is missing, with no default*（我相信你会相信我的，但你自己试试也无妨!)。</span>
<span id="cb101-281"><a href="#cb101-281" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-282"><a href="#cb101-282" aria-hidden="true" tabindex="-1"></a>就生长曲线模型拟合而言，绘制结果提供了一个直观的比较，说明了三条生长曲线之间的差异（Murrell, 2011）。</span>
<span id="cb101-283"><a href="#cb101-283" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-286"><a href="#cb101-286" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-287"><a href="#cb101-287" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-4-3</span></span>
<span id="cb101-288"><a href="#cb101-288" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "来自 358 个模拟的雌性红鱼年龄-长度数据，顶部绘制了三条最佳拟合生长曲线。Female Length-at-Age data from 358 simulated female redfish with three optimally fitted growth curves drawn on top."</span></span>
<span id="cb101-289"><a href="#cb101-289" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-290"><a href="#cb101-290" aria-hidden="true" tabindex="-1"></a> <span class="co">#Female length-at-age + 3 growth fitted curves Figure 4.3  </span></span>
<span id="cb101-291"><a href="#cb101-291" aria-hidden="true" tabindex="-1"></a>predvB <span class="ot">&lt;-</span> <span class="fu">vB</span>(bestvB<span class="sc">$</span>estimate,ages) <span class="co">#get optimumpredicted lengths  </span></span>
<span id="cb101-292"><a href="#cb101-292" aria-hidden="true" tabindex="-1"></a>predGz <span class="ot">&lt;-</span> <span class="fu">Gz</span>(bestGz<span class="sc">$</span>estimate,ages) <span class="co"># using the outputs  </span></span>
<span id="cb101-293"><a href="#cb101-293" aria-hidden="true" tabindex="-1"></a>predmm <span class="ot">&lt;-</span> <span class="fu">mm</span>(bestMM2<span class="sc">$</span>estimate,ages) <span class="co">#from the nlm analysis above  </span></span>
<span id="cb101-294"><a href="#cb101-294" aria-hidden="true" tabindex="-1"></a>ymax <span class="ot">&lt;-</span> <span class="fu">getmax</span>(LatA<span class="sc">$</span>length) <span class="co">#try ?getmax or getmax [no brackets]  </span></span>
<span id="cb101-295"><a href="#cb101-295" aria-hidden="true" tabindex="-1"></a>xmax <span class="ot">&lt;-</span> <span class="fu">getmax</span>(LatA<span class="sc">$</span>age)  <span class="co">#there is also a getmin, not used here  </span></span>
<span id="cb101-296"><a href="#cb101-296" aria-hidden="true" tabindex="-1"></a><span class="fu">parset</span>(<span class="at">font=</span><span class="dv">7</span>)   <span class="co"># or use parsyn() to prompt for the par syntax  </span></span>
<span id="cb101-297"><a href="#cb101-297" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(LatA<span class="sc">$</span>age,LatA<span class="sc">$</span>length,<span class="at">type=</span><span class="st">"p"</span>,<span class="at">pch=</span><span class="dv">16</span>, <span class="at">col=</span><span class="fu">rgb</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span><span class="sc">/</span><span class="dv">5</span>),  </span>
<span id="cb101-298"><a href="#cb101-298" aria-hidden="true" tabindex="-1"></a>     <span class="at">cex=</span><span class="fl">1.2</span>,<span class="at">xlim=</span><span class="fu">c</span>(<span class="dv">0</span>,xmax),<span class="at">ylim=</span><span class="fu">c</span>(<span class="dv">0</span>,ymax),<span class="at">yaxs=</span><span class="st">"i"</span>,<span class="at">xlab=</span><span class="st">"Age"</span>,  </span>
<span id="cb101-299"><a href="#cb101-299" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylab=</span><span class="st">"Length (cm)"</span>,<span class="at">panel.first=</span><span class="fu">grid</span>())  </span>
<span id="cb101-300"><a href="#cb101-300" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(ages,predvB,<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">4</span>)        <span class="co"># vB    col=4=blue  </span></span>
<span id="cb101-301"><a href="#cb101-301" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(ages,predGz,<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">1</span>,<span class="at">lty=</span><span class="dv">2</span>)  <span class="co"># Gompertz  1=black  </span></span>
<span id="cb101-302"><a href="#cb101-302" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(ages,predmm,<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">3</span>,<span class="at">lty=</span><span class="dv">3</span>)  <span class="co"># MM        3=green  </span></span>
<span id="cb101-303"><a href="#cb101-303" aria-hidden="true" tabindex="-1"></a> <span class="co">#notice the legend function and its syntax.  </span></span>
<span id="cb101-304"><a href="#cb101-304" aria-hidden="true" tabindex="-1"></a><span class="fu">legend</span>(<span class="st">"bottomright"</span>,<span class="at">cex=</span><span class="fl">1.2</span>,<span class="fu">c</span>(<span class="st">"von Bertalanffy"</span>,<span class="st">"Gompertz"</span>,  </span>
<span id="cb101-305"><a href="#cb101-305" aria-hidden="true" tabindex="-1"></a>       <span class="st">"Michaelis-Menton"</span>),<span class="at">col=</span><span class="fu">c</span>(<span class="dv">4</span>,<span class="dv">1</span>,<span class="dv">3</span>),<span class="at">lty=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>),<span class="at">lwd=</span><span class="dv">3</span>,<span class="at">bty=</span><span class="st">"n"</span>)  </span>
<span id="cb101-306"><a href="#cb101-306" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-307"><a href="#cb101-307" aria-hidden="true" tabindex="-1"></a><span class="co"># ggplot() +</span></span>
<span id="cb101-308"><a href="#cb101-308" aria-hidden="true" tabindex="-1"></a><span class="co">#   geom_point(data = LatA, aes(x = age, y = length), </span></span>
<span id="cb101-309"><a href="#cb101-309" aria-hidden="true" tabindex="-1"></a><span class="co">#              color = "red", alpha = 0.2) +</span></span>
<span id="cb101-310"><a href="#cb101-310" aria-hidden="true" tabindex="-1"></a><span class="co">#   geom_line(aes(x = ages, y = predvB), color = "blue") +</span></span>
<span id="cb101-311"><a href="#cb101-311" aria-hidden="true" tabindex="-1"></a><span class="co">#   geom_line(aes(x = ages, y = predGz), color = "black") +</span></span>
<span id="cb101-312"><a href="#cb101-312" aria-hidden="true" tabindex="-1"></a><span class="co">#   geom_line(aes(x = ages, y = predmm), color = "green") +</span></span>
<span id="cb101-313"><a href="#cb101-313" aria-hidden="true" tabindex="-1"></a><span class="co">#   theme_bw()</span></span>
<span id="cb101-314"><a href="#cb101-314" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-315"><a href="#cb101-315" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-316"><a href="#cb101-316" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-317"><a href="#cb101-317" aria-hidden="true" tabindex="-1"></a>在图中使用的 <span class="in">`rgb()`</span> 函数意味着颜色强度代表观测数量，最强烈的颜色至少表示有五个观测值。很明显，在这份数据中， <span class="in">`vB()`</span> 和 <span class="in">`Gz()`</span> 曲线在大部分观测范围内几乎重合，而 <span class="in">`mm()`</span> 曲线与其他两条曲线偏离，但主要是在极端值处。Michaelis-Menton 曲线被强制通过原点，而另外两条曲线则不受这种限制（尽管这个想法可能更接近现实）。可以包括幼鱼长度来将高姆珀茨曲线和 von Bertalanffy 曲线向下拉。但生物生长过程很复杂。许多鲨鱼和鳐鱼是胎生，确实在发育后期开始生活时体型显著大于零。始终要记住，这些曲线只是数据的经验性描述，反映现实的能力有限。</span>
<span id="cb101-318"><a href="#cb101-318" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-319"><a href="#cb101-319" aria-hidden="true" tabindex="-1"></a>大部分可用数据集中在 3 至 12 龄之间（尝试 <span class="in">`table(LatA$age)`</span> ），然后只有 24 龄以上单次出现。在 3 至 24 龄之间，Gompertz 曲线和 von Bertalanffy 曲线基本上遵循相同轨迹，而 Michaelis-Menton 曲线差异很小（你可以尝试以下代码查看实际差异 <span class="in">`cbind(ages, predvB, predGz, predmm)`</span> ）。超出这个年龄范围，差异更大，尽管缺乏年轻动物表明捕捞样本的渔具选择性可能无法充分代表 3 龄以下的鱼类。在拟合相对质量（残差平方和）方面，最终的 Michaelis-Menton 曲线最小&nbsp;<span class="in">`ssq()`</span>&nbsp;，其次是 von Bertalanffy 曲线，然后是 Gompertz 曲线。但每种模型都为 3 至 24 龄（数据最密集范围）之间的生长提供了合理的平均描述。当老年年龄组的数据如此稀疏时，也存在该样本是否代表这些年龄组种群的问题。质疑数据、所用模型及由此产生的解释，是构建自然过程有用模型的重要方面。</span>
<span id="cb101-320"><a href="#cb101-320" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-321"><a href="#cb101-321" aria-hidden="true" tabindex="-1"></a><span class="fu">### 目标模型选择</span></span>
<span id="cb101-322"><a href="#cb101-322" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-323"><a href="#cb101-323" aria-hidden="true" tabindex="-1"></a>在上述三种生长模型中，最优模型拟合定义为使预测值与实测值之间的平方和残差最小。根据这一标准，第二个生长模型 Michaelis-Menton 曲线比 von Bertalanffy 曲线和 Gompertz 曲线更适合。但我们真的能说第二条 Michaelis-Menton 曲线比第一条曲线"更好"拟合吗?就最终溶液的梯度而言，第二条曲线显然更好，但严格的拟合标准只是最小 SSQ，差异小于 0.01 个单位。模型选择通常是使用参数的数量和根据所选标准的拟合质量之间的权衡。如果我们设计一个具有更多参数的模型，这通常会导致更大的灵活性和更接近观测数据的改进能力。在极端情况下，如果我们有和观测值一样多的参数，我们可以有一个完美的模型拟合，但是，当然，我们对我们正在建模的系统一无所知。LatA 数据集有 358 个参数，这显然是过度参数化的情况，但如果我们只将参数数量增加到10个呢？毫无疑问，曲线的形状会很奇怪，但 SSQ 可能会更低。Burnham 和 Anderson(2002) 详细讨论了参数数量和模型与数据的拟合质量之间的权衡关系。在 20 世纪 70 年代，人们开始使用信息论来开发一种量化模型参数和模型拟合质量之间权衡的方法。Akaike(1974) 描述了他的Akaike信息标准（AIC），该标准基于最大似然和信息理论原理（稍后会详细介绍），但幸运的是，Burnham 和 Anderson(2002) 在使用最小平方和残差时提供了另一种选择，这是Atkinson（1980）中包含的一种变体:</span>
<span id="cb101-324"><a href="#cb101-324" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-325"><a href="#cb101-325" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-326"><a href="#cb101-326" aria-hidden="true" tabindex="-1"></a>AIC=N \left(\log\left(\hat\sigma^2 \right) \right)+2p  </span>
<span id="cb101-327"><a href="#cb101-327" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_8}</span>
<span id="cb101-328"><a href="#cb101-328" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-329"><a href="#cb101-329" aria-hidden="true" tabindex="-1"></a>其中$N$ 为观测数，$p$ 为"模型内独立调整参数数量"（Akaike，1974，p716），$\hat{\sigma}^2$ 为方差的最大似然估计，仅表示残差平方和除以$N$ 而非 $N-1$ ：</span>
<span id="cb101-330"><a href="#cb101-330" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-331"><a href="#cb101-331" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-332"><a href="#cb101-332" aria-hidden="true" tabindex="-1"></a>\hat\sigma^2 = \frac{\Sigma\varepsilon^2}{N} = \frac{ssq}{N}</span>
<span id="cb101-333"><a href="#cb101-333" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_9}</span>
<span id="cb101-334"><a href="#cb101-334" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-335"><a href="#cb101-335" aria-hidden="true" tabindex="-1"></a>即使有了*AIC*，也很难确定，当使用最小二乘时，差异是否可以被认为是统计上显著的差异。有与方差分析相关的方法，但当使用最大似然时，这些问题能够得到更可靠的回答，所以我们将在后面的部分中解决这个问题。</span>
<span id="cb101-336"><a href="#cb101-336" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-337"><a href="#cb101-337" aria-hidden="true" tabindex="-1"></a>如果想在拟合模型时获得生物学上合理的或可站得住脚的解释，那么模型选择不能仅仅依赖于统计拟合的质量。相反，它应该反映理论预期（例如，种群中的平均生长是否包括随着时间的推移个体大小的平稳增长，等等）。除了数据的统计拟合之外，这些考虑因素似乎没有得到足够的重视，但只有在出现生物学上不可信的模型结果或提出不可信的模型结构时才变得重要。它显然有助于理解正在建模的过程的生物学期望。</span>
<span id="cb101-338"><a href="#cb101-338" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-339"><a href="#cb101-339" aria-hidden="true" tabindex="-1"></a><span class="fu">### 残差选择对模型拟合的影响</span></span>
<span id="cb101-340"><a href="#cb101-340" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-341"><a href="#cb101-341" aria-hidden="true" tabindex="-1"></a>在生长模型例子中，我们使用了正态随机偏差，但我们可以问，如果我们使用，例如对数正态偏差，我们是否会得到相同的答案？在这种情况下，我们所需要做的就是在计算残差平方和之前对观测值和预测值进行对数变换（参见下面关于对数正态残差的内容）。</span>
<span id="cb101-342"><a href="#cb101-342" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-343"><a href="#cb101-343" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-344"><a href="#cb101-344" aria-hidden="true" tabindex="-1"></a>ssq=\sum\limits_{i=1}^{n}{{{\left( \log({O_i})- \log({\hat{E_i}}) \right)}^{2}}}</span>
<span id="cb101-345"><a href="#cb101-345" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_10}</span>
<span id="cb101-346"><a href="#cb101-346" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-347"><a href="#cb101-347" aria-hidden="true" tabindex="-1"></a>这里我们继续在 <span class="in">`outfit()`</span>中使用 *backtran=FALSE* 选项，因为我们是对数据进行对数转换，而不是对参数进行对数转换，因此不需要进行反向转换。</span>
<span id="cb101-348"><a href="#cb101-348" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-351"><a href="#cb101-351" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-352"><a href="#cb101-352" aria-hidden="true" tabindex="-1"></a> <span class="co"># von Bertalanffy   </span></span>
<span id="cb101-353"><a href="#cb101-353" aria-hidden="true" tabindex="-1"></a>pars <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">27.25</span>,<span class="fl">0.15</span>,<span class="sc">-</span><span class="fl">3.0</span>)  </span>
<span id="cb101-354"><a href="#cb101-354" aria-hidden="true" tabindex="-1"></a>bestvBN <span class="ot">&lt;-</span> <span class="fu">nlm</span>(<span class="at">f=</span>ssq,<span class="at">funk=</span>vB,<span class="at">observed=</span>LatA<span class="sc">$</span>length,<span class="at">p=</span>pars,  </span>
<span id="cb101-355"><a href="#cb101-355" aria-hidden="true" tabindex="-1"></a>             <span class="at">ages=</span>LatA<span class="sc">$</span>age,<span class="at">typsize=</span><span class="fu">magnitude</span>(pars),<span class="at">iterlim=</span><span class="dv">1000</span>)  </span>
<span id="cb101-356"><a href="#cb101-356" aria-hidden="true" tabindex="-1"></a><span class="fu">outfit</span>(bestvBN,<span class="at">backtran=</span><span class="cn">FALSE</span>,<span class="at">title=</span><span class="st">"Normal errors"</span>); <span class="fu">cat</span>(<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)   </span>
<span id="cb101-357"><a href="#cb101-357" aria-hidden="true" tabindex="-1"></a> <span class="co"># modify ssq to account for log-normal errors in ssqL  </span></span>
<span id="cb101-358"><a href="#cb101-358" aria-hidden="true" tabindex="-1"></a>ssqL <span class="ot">&lt;-</span> <span class="cf">function</span>(funk,observed,...) {  </span>
<span id="cb101-359"><a href="#cb101-359" aria-hidden="true" tabindex="-1"></a>  predval <span class="ot">&lt;-</span> <span class="fu">funk</span>(...)  </span>
<span id="cb101-360"><a href="#cb101-360" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">sum</span>((<span class="fu">log</span>(observed) <span class="sc">-</span> <span class="fu">log</span>(predval))<span class="sc">^</span><span class="dv">2</span>,<span class="at">na.rm=</span><span class="cn">TRUE</span>))  </span>
<span id="cb101-361"><a href="#cb101-361" aria-hidden="true" tabindex="-1"></a>} <span class="co"># end of ssqL  </span></span>
<span id="cb101-362"><a href="#cb101-362" aria-hidden="true" tabindex="-1"></a>bestvBLN <span class="ot">&lt;-</span> <span class="fu">nlm</span>(<span class="at">f=</span>ssqL,<span class="at">funk=</span>vB,<span class="at">observed=</span>LatA<span class="sc">$</span>length,<span class="at">p=</span>pars,  </span>
<span id="cb101-363"><a href="#cb101-363" aria-hidden="true" tabindex="-1"></a>             <span class="at">ages=</span>LatA<span class="sc">$</span>age,<span class="at">typsize=</span><span class="fu">magnitude</span>(pars),<span class="at">iterlim=</span><span class="dv">1000</span>)  </span>
<span id="cb101-364"><a href="#cb101-364" aria-hidden="true" tabindex="-1"></a><span class="fu">outfit</span>(bestvBLN,<span class="at">backtran=</span><span class="cn">FALSE</span>,<span class="at">title=</span><span class="st">"Log-Normal errors"</span>)  </span>
<span id="cb101-365"><a href="#cb101-365" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-366"><a href="#cb101-366" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-367"><a href="#cb101-367" aria-hidden="true" tabindex="-1"></a>在这种情况下，使用正态和对数正态残差产生的曲线几乎没有区别（ @fig-4-4 ）。尽管它们的参数不同（使用 <span class="in">`ylim=c(10,ymax)`</span> 使差异更明显）。除了视觉上的不同，不同的模型甚至没有可比性。如果我们比较它们各自的平方和残差，一个是 1361.0，另一个只有 3.153。当我们考虑到平方和计算中对数变换的影响时，这并不奇怪。但这意味着我们不能只看表格输出，然后决定哪个版本比另一个更适合数据。它们是严格不相称的，尽管它们使用的是完全相同的模型。不同残差结构的使用需要在考虑相对模型拟合以外的方式进行辩护。这个例子强调，虽然模型的选择显然很重要，但残差结构的选择也是模型结构的一部分，同样重要。</span>
<span id="cb101-368"><a href="#cb101-368" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-371"><a href="#cb101-371" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-372"><a href="#cb101-372" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-4-4</span></span>
<span id="cb101-373"><a href="#cb101-373" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Female Length-at-Age data from 358 female redfish, Centroberyx affinis, with two von Bertalanffy growth curves fitted using Normal and Log-Normal residuals."</span></span>
<span id="cb101-374"><a href="#cb101-374" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-375"><a href="#cb101-375" aria-hidden="true" tabindex="-1"></a> <span class="co"># Now plot the resultibng two curves and the data Fig 4.4  </span></span>
<span id="cb101-376"><a href="#cb101-376" aria-hidden="true" tabindex="-1"></a>predvBN <span class="ot">&lt;-</span> <span class="fu">vB</span>(bestvBN<span class="sc">$</span>estimate,ages)   </span>
<span id="cb101-377"><a href="#cb101-377" aria-hidden="true" tabindex="-1"></a>predvBLN <span class="ot">&lt;-</span> <span class="fu">vB</span>(bestvBLN<span class="sc">$</span>estimate,ages)   </span>
<span id="cb101-378"><a href="#cb101-378" aria-hidden="true" tabindex="-1"></a>ymax <span class="ot">&lt;-</span> <span class="fu">getmax</span>(LatA<span class="sc">$</span>length)   </span>
<span id="cb101-379"><a href="#cb101-379" aria-hidden="true" tabindex="-1"></a>xmax <span class="ot">&lt;-</span> <span class="fu">getmax</span>(LatA<span class="sc">$</span>age)      </span>
<span id="cb101-380"><a href="#cb101-380" aria-hidden="true" tabindex="-1"></a><span class="fu">parset</span>()                </span>
<span id="cb101-381"><a href="#cb101-381" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(LatA<span class="sc">$</span>age,LatA<span class="sc">$</span>length,<span class="at">type=</span><span class="st">"p"</span>,<span class="at">pch=</span><span class="dv">16</span>, <span class="at">col=</span><span class="fu">rgb</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span><span class="sc">/</span><span class="dv">5</span>),  </span>
<span id="cb101-382"><a href="#cb101-382" aria-hidden="true" tabindex="-1"></a>     <span class="at">cex=</span><span class="fl">1.2</span>,<span class="at">xlim=</span><span class="fu">c</span>(<span class="dv">0</span>,xmax),<span class="at">ylim=</span><span class="fu">c</span>(<span class="dv">0</span>,ymax),<span class="at">yaxs=</span><span class="st">"i"</span>,<span class="at">xlab=</span><span class="st">"Age"</span>,  </span>
<span id="cb101-383"><a href="#cb101-383" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylab=</span><span class="st">"Length (cm)"</span>,<span class="at">panel.first=</span><span class="fu">grid</span>())  </span>
<span id="cb101-384"><a href="#cb101-384" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(ages,predvBN,<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">4</span>,<span class="at">lty=</span><span class="dv">2</span>)   <span class="co"># add Normal dashed  </span></span>
<span id="cb101-385"><a href="#cb101-385" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(ages,predvBLN,<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">1</span>)        <span class="co"># add Log-Normal solid  </span></span>
<span id="cb101-386"><a href="#cb101-386" aria-hidden="true" tabindex="-1"></a><span class="fu">legend</span>(<span class="st">"bottomright"</span>,<span class="fu">c</span>(<span class="st">"Normal Errors"</span>,<span class="st">"Log-Normal Errors"</span>),  </span>
<span id="cb101-387"><a href="#cb101-387" aria-hidden="true" tabindex="-1"></a>       <span class="at">col=</span><span class="fu">c</span>(<span class="dv">4</span>,<span class="dv">1</span>),<span class="at">lty=</span><span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">1</span>),<span class="at">lwd=</span><span class="dv">3</span>,<span class="at">bty=</span><span class="st">"n"</span>,<span class="at">cex=</span><span class="fl">1.2</span>)  </span>
<span id="cb101-388"><a href="#cb101-388" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-389"><a href="#cb101-389" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-390"><a href="#cb101-390" aria-hidden="true" tabindex="-1"></a><span class="fu">### 关于初始模型拟合的说明</span></span>
<span id="cb101-391"><a href="#cb101-391" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-392"><a href="#cb101-392" aria-hidden="true" tabindex="-1"></a>上面例子中的曲线比较本身就很有趣，不过，我们还说明了 <span class="in">`nlm()`</span> 的语法以及如何将模型拟合到数据中。将函数作为参数传递给另一个函数的能力（就像这里我们将 <span class="in">`ssq`</span> 作为 *f* 传递给 `nlm()`，将 `vB`、`Gz` 和 `mm` 作为 *funk* 传递给 <span class="in">`ssq()`</span>）是 R 的优势之一，但也是其复杂性所在。它简化了<span class="in">`ssq()`</span>等函数的重用，在这些函数中，我们只需改变输入函数，就能从本质上相同的代码中得到完全不同的答案。熟悉这些方法的最佳途径是使用自己的数据集。绘制您的数据和任何模型拟合图，因为如果模型拟合图看起来不寻常，那么很可能就是不寻常的，需要再三审视。</span>
<span id="cb101-393"><a href="#cb101-393" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-394"><a href="#cb101-394" aria-hidden="true" tabindex="-1"></a>使用平方和法可以取得很好的效果，但在处理现实世界的多样性时，要求在期望值附近的残差呈正态分布以及方差恒定的假设是有限制的。为了使用正态分布以外的概率密度分布和非恒定方差，我们应该转而使用最大似然法。</span>
<span id="cb101-395"><a href="#cb101-395" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-396"><a href="#cb101-396" aria-hidden="true" tabindex="-1"></a><span class="fu">## 最大似然</span></span>
<span id="cb101-397"><a href="#cb101-397" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-398"><a href="#cb101-398" aria-hidden="true" tabindex="-1"></a>在 R 中使用似然比较简单，因为有许多概率密度函数（PDF）的内置函数以及一系列定义其他 PDF 的软件包。再重复一遍，最大似然法的目的是使用软件搜索模型参数集，使观测数据的总似然最大化。要使用这一最优模型拟合标准，需要对模型进行定义，以便将每个观测值（可用数据）的概率或似然值指定为模型中参数值和其他变量的函数（ @eq-4_2 和 @eq-4_11 ）。重要的是，这种规范包括对所选 PDF 的变异性或扩散性的估计（正态分布中的 $\sigma$ 只是最小二乘法的副产品）。使用最大似然法的一个主要优点是，残差结构或关于数据预期中心倾向的观测值的预期分布不一定是正态分布。如果可以定义概率密度函数 (PDF)，则可以在最大似然法框架中使用；有关许多有用概率密度函数的定义，请参见 Forbes et al, (2011)。</span>
<span id="cb101-399"><a href="#cb101-399" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-400"><a href="#cb101-400" aria-hidden="true" tabindex="-1"></a><span class="fu">### 简要示例</span></span>
<span id="cb101-401"><a href="#cb101-401" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-402"><a href="#cb101-402" aria-hidden="true" tabindex="-1"></a>我们将使用众所周知的正态分布来说明这些方法，然后扩展该方法以包含一系列可选的 PDF。对于数据模型拟合而言，每个PDF的主要意义在于定义单个观测值的概率密度或似然值。对于平均期望值为 $\bar x$ 或 $\mu$ 的正态分布，给定单个值 $x_i$ 的概率密度或似然定义为:</span>
<span id="cb101-403"><a href="#cb101-403" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-404"><a href="#cb101-404" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-405"><a href="#cb101-405" aria-hidden="true" tabindex="-1"></a>L\left( {x_i}|\mu_{i} ,\sigma  \right)=\frac{1}{\sigma \sqrt{2\pi }}{{e}^{\left( \frac{-{{\left( {x_i}-\mu_{i}  \right)}^{2}}}{2\sigma^2 } \right)}}  </span>
<span id="cb101-406"><a href="#cb101-406" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_11}</span>
<span id="cb101-407"><a href="#cb101-407" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-408"><a href="#cb101-408" aria-hidden="true" tabindex="-1"></a>其中 $\sigma$ 为与 $\mu_i$ 相关的标准差。这确定了最小二乘法和最大似然方法之间的直接区别，在后者中，需要一个 PDF 的完整定义，在正态分布的情况下，它包括对均值估计 $\mu$ 周围残差的标准偏差的显式估计。这样的估计不需要最小二乘，虽然很容易从 SSQ 值中得到。</span>
<span id="cb101-409"><a href="#cb101-409" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-410"><a href="#cb101-410" aria-hidden="true" tabindex="-1"></a>例如，我们可以从正态分布中生成一个观测样本(参见<span class="in">`?rnorm`</span>)，然后计算该样本的均值和标准差，并比较给定的样本值与 *rnorm* 函数中使用的原始均值和标准差的参数估计值的可能性有多大（ @tbl-4-1 ）：</span>
<span id="cb101-411"><a href="#cb101-411" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-414"><a href="#cb101-414" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-415"><a href="#cb101-415" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-4-1</span></span>
<span id="cb101-416"><a href="#cb101-416" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: "使用正态随机值及相关正态似然函数的示例。估计列具有更大的总似然值。1=真，0=假。"</span></span>
<span id="cb101-417"><a href="#cb101-417" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-418"><a href="#cb101-418" aria-hidden="true" tabindex="-1"></a> <span class="co"># Illustrate Normal random likelihoods. see Table 4.1  </span></span>
<span id="cb101-419"><a href="#cb101-419" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">12345</span>)       <span class="co"># make the use of random numbers repeatable  </span></span>
<span id="cb101-420"><a href="#cb101-420" aria-hidden="true" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="dv">10</span>,<span class="at">mean=</span><span class="fl">5.0</span>,<span class="at">sd=</span><span class="fl">1.0</span>)      <span class="co"># pseudo-randomly generate 10   </span></span>
<span id="cb101-421"><a href="#cb101-421" aria-hidden="true" tabindex="-1"></a>avx <span class="ot">&lt;-</span> <span class="fu">mean</span>(x)                      <span class="co"># normally distributed values  </span></span>
<span id="cb101-422"><a href="#cb101-422" aria-hidden="true" tabindex="-1"></a>sdx <span class="ot">&lt;-</span> <span class="fu">sd</span>(x)          <span class="co"># estimate the mean and stdev of the sample            </span></span>
<span id="cb101-423"><a href="#cb101-423" aria-hidden="true" tabindex="-1"></a>L1 <span class="ot">&lt;-</span> <span class="fu">dnorm</span>(x,<span class="at">mean=</span><span class="fl">5.0</span>,<span class="at">sd=</span><span class="fl">1.0</span>)   <span class="co"># obtain likelihoods, L1, L2 for   </span></span>
<span id="cb101-424"><a href="#cb101-424" aria-hidden="true" tabindex="-1"></a>L2 <span class="ot">&lt;-</span> <span class="fu">dnorm</span>(x,<span class="at">mean=</span>avx,<span class="at">sd=</span>sdx)    <span class="co"># each data point for both sets  </span></span>
<span id="cb101-425"><a href="#cb101-425" aria-hidden="true" tabindex="-1"></a>result <span class="ot">&lt;-</span> <span class="fu">cbind</span>(x,L1,L2,<span class="st">"L2gtL1"</span><span class="ot">=</span>(L2<span class="sc">&gt;</span>L1))      <span class="co"># which is larger?  </span></span>
<span id="cb101-426"><a href="#cb101-426" aria-hidden="true" tabindex="-1"></a>result <span class="ot">&lt;-</span> <span class="fu">rbind</span>(result,<span class="fu">c</span>(<span class="cn">NA</span>,<span class="fu">prod</span>(L1),<span class="fu">prod</span>(L2),<span class="dv">1</span>)) <span class="co"># result+totals  </span></span>
<span id="cb101-427"><a href="#cb101-427" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(result) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>,<span class="st">"product"</span>)  </span>
<span id="cb101-428"><a href="#cb101-428" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(result) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"x"</span>,<span class="st">"original"</span>,<span class="st">"estimated"</span>,<span class="st">"est &gt; orig"</span>)  </span>
<span id="cb101-429"><a href="#cb101-429" aria-hidden="true" tabindex="-1"></a>knitr<span class="sc">::</span><span class="fu">kable</span>(result) </span>
<span id="cb101-430"><a href="#cb101-430" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-431"><a href="#cb101-431" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-432"><a href="#cb101-432" aria-hidden="true" tabindex="-1"></a>@tbl-4-1 的最下面一行包含每列似然值的乘积(使用R函数 <span class="in">`prod()`</span> 求得)。毫不奇怪，当我们使用样本的均值和标准差估计(估计，L2)而不是原始值的 *mean=5* 和 *sd=1.0* (原始，L1)时，求得最大似然，即 $8.9201095^{-6} &gt; 4.7521457 ^{-6}$。在本例中，我可以确定这些值，因为在代码开始时使用了R函数 <span class="in">`set.seed()`</span> ，以便在特定位置启动伪随机数生成器。如果你通常使用 <span class="in">`set.seed()`</span>，不会重复使用相同的旧序列，例如 $12345$，因为您可能会破坏伪随机数是随机数序列的良好近似值的想法，也许可以使用 <span class="in">`getseed()`</span>来提供合适的种子数。</span>
<span id="cb101-433"><a href="#cb101-433" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-434"><a href="#cb101-434" aria-hidden="true" tabindex="-1"></a>因此，<span class="in">`rnorm()`</span> 函数提供了由均值和标准差确定分布中的伪随机数，<span class="in">`dnorm()`</span> 函数提供了观测值在均值和标准差条件下的概率密度或似然（相当于 @eq-4_11 ）。累积概率密度函数（cdf）由函数 <span class="in">`pnorm()`</span> 提供，量化值由 <span class="in">`qnorm()`</span> 确定。平均值自然具有最大的似然。还要注意的是，正态曲线是围绕均值对称的。</span>
<span id="cb101-435"><a href="#cb101-435" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-438"><a href="#cb101-438" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-439"><a href="#cb101-439" aria-hidden="true" tabindex="-1"></a> <span class="co"># some examples of pnorm, dnorm, and qnorm, all mean = 0  </span></span>
<span id="cb101-440"><a href="#cb101-440" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"x = 0.0        Likelihood ="</span>,<span class="fu">dnorm</span>(<span class="fl">0.0</span>,<span class="at">mean=</span><span class="dv">0</span>,<span class="at">sd=</span><span class="dv">1</span>),<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)   </span>
<span id="cb101-441"><a href="#cb101-441" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"x = 1.95996395 Likelihood ="</span>,<span class="fu">dnorm</span>(<span class="fl">1.95996395</span>,<span class="at">mean=</span><span class="dv">0</span>,<span class="at">sd=</span><span class="dv">1</span>),<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)   </span>
<span id="cb101-442"><a href="#cb101-442" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"x =-1.95996395 Likelihood ="</span>,<span class="fu">dnorm</span>(<span class="sc">-</span><span class="fl">1.95996395</span>,<span class="at">mean=</span><span class="dv">0</span>,<span class="at">sd=</span><span class="dv">1</span>),<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)   </span>
<span id="cb101-443"><a href="#cb101-443" aria-hidden="true" tabindex="-1"></a> <span class="co"># 0.5 = half cumulative distribution  </span></span>
<span id="cb101-444"><a href="#cb101-444" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"x = 0.0        cdf = "</span>,<span class="fu">pnorm</span>(<span class="dv">0</span>,<span class="at">mean=</span><span class="dv">0</span>,<span class="at">sd=</span><span class="dv">1</span>),<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)   </span>
<span id="cb101-445"><a href="#cb101-445" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"x = 0.6744899  cdf = "</span>,<span class="fu">pnorm</span>(<span class="fl">0.6744899</span>,<span class="at">mean=</span><span class="dv">0</span>,<span class="at">sd=</span><span class="dv">1</span>),<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)  </span>
<span id="cb101-446"><a href="#cb101-446" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"x = 0.75       Quantile ="</span>,<span class="fu">qnorm</span>(<span class="fl">0.75</span>),<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>) <span class="co"># reverse pnorm  </span></span>
<span id="cb101-447"><a href="#cb101-447" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"x = 1.95996395 cdf = "</span>,<span class="fu">pnorm</span>(<span class="fl">1.95996395</span>,<span class="at">mean=</span><span class="dv">0</span>,<span class="at">sd=</span><span class="dv">1</span>),<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)  </span>
<span id="cb101-448"><a href="#cb101-448" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"x =-1.95996395 cdf = "</span>,<span class="fu">pnorm</span>(<span class="sc">-</span><span class="fl">1.95996395</span>,<span class="at">mean=</span><span class="dv">0</span>,<span class="at">sd=</span><span class="dv">1</span>),<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)  </span>
<span id="cb101-449"><a href="#cb101-449" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"x = 0.975      Quantile ="</span>,<span class="fu">qnorm</span>(<span class="fl">0.975</span>),<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>) <span class="co"># expect ~1.96  </span></span>
<span id="cb101-450"><a href="#cb101-450" aria-hidden="true" tabindex="-1"></a> <span class="co"># try x &lt;- seq(-5,5,0.2); round(dnorm(x,mean=0.0,sd=1.0),5)  </span></span>
<span id="cb101-451"><a href="#cb101-451" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-452"><a href="#cb101-452" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-453"><a href="#cb101-453" aria-hidden="true" tabindex="-1"></a>我们可以看到，单个似然值可能是相对较大的数字，但当它们相乘时，很快就会变成相对较小的数字。当观测数据的数量增加时，就会出现误差。即使只有十个数字，当我们将所有单个似然值相乘（使用 <span class="in">`prod()`</span>）时，结果也会很快变得非常小。如果使用与 @tbl-4-1 中的十个数字类似的另外十个数字，总似然很容易降到 $1e-11$ 或 $1e-12$。随着观察次数的增加，出现四舍五入错误的几率（即使在 64 位计算机上）也开始增加。与其将许多小数相乘得到一个极小的数，不如将这些小数相乘的标准解决方案是对似然值进行自然对数变换，然后相加。最大化对数变换似然值之和与最大化单个似然值之积一样，都能获得最佳参数。此外，许多软件中的优化器似乎都是为了最有效地最小化某个函数而设计的。简单的解决方案是，我们不最大化单个似然的乘积，而是最小化负对数似然的总和（*-veLL* 或 <span class="in">`negLL()`</span>）。</span>
<span id="cb101-454"><a href="#cb101-454" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-455"><a href="#cb101-455" aria-hidden="true" tabindex="-1"></a><span class="fu">## 正态分布的似然</span></span>
<span id="cb101-456"><a href="#cb101-456" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-457"><a href="#cb101-457" aria-hidden="true" tabindex="-1"></a>概率似乎是一种相当奇怪的生物。当它们来自连续的概率密度函数（PDFs）时，尽管它们具有许多相同的属性，但严格来说它们并不是概率（Edwards，1972 ）。严格来讲，它们与概率密度函数下某一点的概率密度有关。根据概率的定义，整条曲线下的面积总和必须为 1.0，但连续概率密度函数任何一点下的面积都会变得无穷小。正态似然的定义使用 @eq-4_11 ），而累积密度函数为:</span>
<span id="cb101-458"><a href="#cb101-458" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-459"><a href="#cb101-459" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-460"><a href="#cb101-460" aria-hidden="true" tabindex="-1"></a>{cdf}=1=\int\limits_{x=-\infty }^{\infty }{\frac{1}{\sigma \sqrt{2\pi }}}{{e}^{\left( \frac{-{{\left( x-\mu  \right)}^{2}}}{2{{\sigma }^{2}}} \right)}} </span>
<span id="cb101-461"><a href="#cb101-461" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_12}</span>
<span id="cb101-462"><a href="#cb101-462" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-463"><a href="#cb101-463" aria-hidden="true" tabindex="-1"></a>我们可以使用 <span class="in">`dnorm()`</span> 和 <span class="in">`pnorm()`</span> 计算似然和累积密度函数（cdf）（ @fig-4-5 ）。</span>
<span id="cb101-464"><a href="#cb101-464" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-467"><a href="#cb101-467" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-468"><a href="#cb101-468" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-4-5</span></span>
<span id="cb101-469"><a href="#cb101-469" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "一条虚线红色曲线描绘了均值为 0 和标准差为 1.0 的预期正态似然，以及作为黑色线的相同正态似然的累积密度。蓝线标识了累积概率为 0.5。"</span></span>
<span id="cb101-470"><a href="#cb101-470" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-471"><a href="#cb101-471" aria-hidden="true" tabindex="-1"></a> <span class="co"># Density plot and cumulative distribution for Normal   Fig 4.5  </span></span>
<span id="cb101-472"><a href="#cb101-472" aria-hidden="true" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="sc">-</span><span class="dv">5</span>,<span class="dv">5</span>,<span class="fl">0.1</span>)  <span class="co"># a sequence of values around a mean of 0.0  </span></span>
<span id="cb101-473"><a href="#cb101-473" aria-hidden="true" tabindex="-1"></a>NL <span class="ot">&lt;-</span> <span class="fu">dnorm</span>(x,<span class="at">mean=</span><span class="dv">0</span>,<span class="at">sd=</span><span class="fl">1.0</span>)   <span class="co"># normal likelihoods for each X  </span></span>
<span id="cb101-474"><a href="#cb101-474" aria-hidden="true" tabindex="-1"></a>CD <span class="ot">&lt;-</span> <span class="fu">pnorm</span>(x,<span class="at">mean=</span><span class="dv">0</span>,<span class="at">sd=</span><span class="fl">1.0</span>)   <span class="co"># cumulative density vs X  </span></span>
<span id="cb101-475"><a href="#cb101-475" aria-hidden="true" tabindex="-1"></a><span class="fu">plot1</span>(x,CD,<span class="at">xlab=</span><span class="st">"x = StDev from Mean"</span>,<span class="at">ylab=</span><span class="st">"Likelihood and CDF"</span>)  </span>
<span id="cb101-476"><a href="#cb101-476" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(x,NL,<span class="at">lwd=</span><span class="dv">3</span>,<span class="at">col=</span><span class="dv">2</span>,<span class="at">lty=</span><span class="dv">3</span>) <span class="co"># dashed line as these are points  </span></span>
<span id="cb101-477"><a href="#cb101-477" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">h=</span><span class="fl">0.5</span>,<span class="at">col=</span><span class="dv">4</span>,<span class="at">lwd=</span><span class="dv">1</span>)  </span>
<span id="cb101-478"><a href="#cb101-478" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-479"><a href="#cb101-479" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-480"><a href="#cb101-480" aria-hidden="true" tabindex="-1"></a>这听起来不错，但在这样的曲线下， $x$ 变量的特定值来说，确定这样一条曲线下的特定值意味着什么呢？在 @fig-4-5 中，我们用虚线表示图中的似然是局部估计，不构成连续的线。每个都表示在给定 $x$ 值处的似然。如前所述，对于 $mean= 0.0$ 和 $stdev = 1.0$ 的分布，在 $0.0$ 值处的概率密度为 $0.3989423$。让我们简单地查看一下似然和概率之间可能存在的混淆。如果我们考虑概率密度函数的一小部分，在 $x = 3.4$ 到 $3.6$的值之间 $mean= 5.0$，$st.dev = 1.0$ 的概率密度函数，我们可能会看到类似 @fig-4-6 的情况:</span>
<span id="cb101-481"><a href="#cb101-481" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-484"><a href="#cb101-484" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-485"><a href="#cb101-485" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-4-6</span></span>
<span id="cb101-486"><a href="#cb101-486" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "正态分布变量 X 的概率密度，均值为 5.0，标准差为 1.0。在 x = 3.5 处的 PDF 值为 0.129518，因此红色框线所围成的矩形的面积是 0.0129518，这近似于 3.45 到 3.55 之间的总概率，实际上应该是曲线下的面积。"</span></span>
<span id="cb101-487"><a href="#cb101-487" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-488"><a href="#cb101-488" aria-hidden="true" tabindex="-1"></a> <span class="co">#function facilitates exploring different polygons Fig 4.6  </span></span>
<span id="cb101-489"><a href="#cb101-489" aria-hidden="true" tabindex="-1"></a>plotpoly <span class="ot">&lt;-</span> <span class="cf">function</span>(mid,delta,<span class="at">av=</span><span class="fl">5.0</span>,<span class="at">stdev=</span><span class="fl">1.0</span>) {  </span>
<span id="cb101-490"><a href="#cb101-490" aria-hidden="true" tabindex="-1"></a>   neg <span class="ot">&lt;-</span> mid<span class="sc">-</span>delta;  pos <span class="ot">&lt;-</span> mid<span class="sc">+</span>delta  </span>
<span id="cb101-491"><a href="#cb101-491" aria-hidden="true" tabindex="-1"></a>   pdval <span class="ot">&lt;-</span> <span class="fu">dnorm</span>(<span class="fu">c</span>(mid,neg,pos),<span class="at">mean=</span>av,<span class="at">sd=</span>stdev)  </span>
<span id="cb101-492"><a href="#cb101-492" aria-hidden="true" tabindex="-1"></a>   <span class="fu">polygon</span>(<span class="fu">c</span>(neg,neg,mid,neg),<span class="fu">c</span>(pdval[<span class="dv">2</span>],pdval[<span class="dv">1</span>],pdval[<span class="dv">1</span>],  </span>
<span id="cb101-493"><a href="#cb101-493" aria-hidden="true" tabindex="-1"></a>                          pdval[<span class="dv">2</span>]),<span class="at">col=</span><span class="fu">rgb</span>(<span class="fl">0.25</span>,<span class="fl">0.25</span>,<span class="fl">0.25</span>,<span class="fl">0.5</span>))  </span>
<span id="cb101-494"><a href="#cb101-494" aria-hidden="true" tabindex="-1"></a>   <span class="fu">polygon</span>(<span class="fu">c</span>(pos,pos,mid,pos),<span class="fu">c</span>(pdval[<span class="dv">1</span>],pdval[<span class="dv">3</span>],pdval[<span class="dv">1</span>],  </span>
<span id="cb101-495"><a href="#cb101-495" aria-hidden="true" tabindex="-1"></a>                                pdval[<span class="dv">1</span>]),<span class="at">col=</span><span class="fu">rgb</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="fl">0.5</span>))     </span>
<span id="cb101-496"><a href="#cb101-496" aria-hidden="true" tabindex="-1"></a>   <span class="fu">polygon</span>(<span class="fu">c</span>(mid,neg,neg,mid,mid),  </span>
<span id="cb101-497"><a href="#cb101-497" aria-hidden="true" tabindex="-1"></a>        <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">0</span>,pdval[<span class="dv">1</span>],pdval[<span class="dv">1</span>],<span class="dv">0</span>),<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">lty=</span><span class="dv">1</span>,<span class="at">border=</span><span class="dv">2</span>)  </span>
<span id="cb101-498"><a href="#cb101-498" aria-hidden="true" tabindex="-1"></a>   <span class="fu">polygon</span>(<span class="fu">c</span>(mid,pos,pos,mid,mid),  </span>
<span id="cb101-499"><a href="#cb101-499" aria-hidden="true" tabindex="-1"></a>        <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">0</span>,pdval[<span class="dv">1</span>],pdval[<span class="dv">1</span>],<span class="dv">0</span>),<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">lty=</span><span class="dv">1</span>,<span class="at">border=</span><span class="dv">2</span>)   </span>
<span id="cb101-500"><a href="#cb101-500" aria-hidden="true" tabindex="-1"></a>   <span class="fu">text</span>(<span class="fl">3.395</span>,<span class="fl">0.025</span>,<span class="fu">paste0</span>(<span class="st">"~"</span>,<span class="fu">round</span>((<span class="dv">2</span><span class="sc">*</span>(delta<span class="sc">*</span>pdval[<span class="dv">1</span>])),<span class="dv">7</span>)),</span>
<span id="cb101-501"><a href="#cb101-501" aria-hidden="true" tabindex="-1"></a>        <span class="at">cex=</span><span class="fl">1.1</span>,<span class="at">pos=</span><span class="dv">4</span>)  </span>
<span id="cb101-502"><a href="#cb101-502" aria-hidden="true" tabindex="-1"></a>   <span class="fu">return</span>(<span class="dv">2</span><span class="sc">*</span>(delta<span class="sc">*</span>pdval[<span class="dv">1</span>])) <span class="co"># approx probability, see below  </span></span>
<span id="cb101-503"><a href="#cb101-503" aria-hidden="true" tabindex="-1"></a>} <span class="co"># end of plotpoly, a temporary function to enable flexibility  </span></span>
<span id="cb101-504"><a href="#cb101-504" aria-hidden="true" tabindex="-1"></a> <span class="co">#This code can be re-run with different values for delta  </span></span>
<span id="cb101-505"><a href="#cb101-505" aria-hidden="true" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="fl">3.4</span>,<span class="fl">3.6</span>,<span class="fl">0.05</span>) <span class="co"># where under the normal curve to examine  </span></span>
<span id="cb101-506"><a href="#cb101-506" aria-hidden="true" tabindex="-1"></a>pd <span class="ot">&lt;-</span> <span class="fu">dnorm</span>(x,<span class="at">mean=</span><span class="fl">5.0</span>,<span class="at">sd=</span><span class="fl">1.0</span>) <span class="co">#prob density for each X value  </span></span>
<span id="cb101-507"><a href="#cb101-507" aria-hidden="true" tabindex="-1"></a>mid <span class="ot">&lt;-</span> <span class="fu">mean</span>(x)      </span>
<span id="cb101-508"><a href="#cb101-508" aria-hidden="true" tabindex="-1"></a>delta <span class="ot">&lt;-</span> <span class="fl">0.05</span>  <span class="co"># how wide either side of the sample mean to go?   </span></span>
<span id="cb101-509"><a href="#cb101-509" aria-hidden="true" tabindex="-1"></a><span class="fu">parset</span>()       <span class="co"># a pre-defined MQMF base graphics set-up for par  </span></span>
<span id="cb101-510"><a href="#cb101-510" aria-hidden="true" tabindex="-1"></a>ymax <span class="ot">&lt;-</span> <span class="fu">getmax</span>(pd)    <span class="co"># find maximum y value for the plot  </span></span>
<span id="cb101-511"><a href="#cb101-511" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(x,pd,<span class="at">type=</span><span class="st">"l"</span>,<span class="at">xlab=</span><span class="st">"Variable x"</span>,<span class="at">ylab=</span><span class="st">"Probability Density"</span>,  </span>
<span id="cb101-512"><a href="#cb101-512" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylim=</span><span class="fu">c</span>(<span class="dv">0</span>,ymax),<span class="at">yaxs=</span><span class="st">"i"</span>,<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">panel.first=</span><span class="fu">grid</span>())  </span>
<span id="cb101-513"><a href="#cb101-513" aria-hidden="true" tabindex="-1"></a>approxprob <span class="ot">&lt;-</span> <span class="fu">plotpoly</span>(mid,delta)  <span class="co">#use function defined above  </span></span>
<span id="cb101-514"><a href="#cb101-514" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-515"><a href="#cb101-515" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-516"><a href="#cb101-516" aria-hidden="true" tabindex="-1"></a>完整概率密度函数（ PDF） 下的面积总和为 1.0，因此得到 @fig-4-6 中 $3.45$ 和 $3.55$ 之间值的概率是长方形面积减去左三角形面积再加上右三角形面积之和。三角形几乎是对称的，因此可以近似地相互抵消，所以近似解法就是将其中一个长方形的面积乘以 $2.0$。当 delta（长方形在 $x$ 轴上的宽度）为 $0.05$ 时，概率 $= 0.0129518$。如果将 delta 值改为 $0.01$，那么近似概率 $= 0.0025904$，随着 delta 值的减小，总概率也随之减小，尽管 $3.5$ 时的概率密度仍为 $0.1295176$。显然，似然值与连续 PDF 中的概率并不相同（见 Edwards, 1972）。曲线下面积概率的最佳估计值为 <span class="in">`pnorm(3.55,5,1) - pnorm(3.45,5,1)`</span>，即 = 0.0129585。</span>
<span id="cb101-517"><a href="#cb101-517" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-518"><a href="#cb101-518" aria-hidden="true" tabindex="-1"></a><span class="fu">### 与平方和等价性</span></span>
<span id="cb101-519"><a href="#cb101-519" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-520"><a href="#cb101-520" aria-hidden="true" tabindex="-1"></a>当使用正态似然来拟合数据模型时，我们实际做的是设置，使得每个可用观测值的负对数似然之和最小化。幸运的是，我们可以使用<span class="in">`dnorm()`</span>来估计似然。事实上，如果我们使用正态分布残差或对数变换的对数正态分布数据使用极大似然方法拟合模型，则得到的参数估计与使用最小二乘法得到的参数估计相同(参见下文 @eq-4_19 的推导和形式)。拟合模型需要生成一组预测值 $\hat x$ (x-hat)，为其他自变量 $\theta(x)$ 的函数，其中 $\theta$ 是函数关系中使用的参数列。$n$ 个观测值的对数似然定义为:</span>
<span id="cb101-521"><a href="#cb101-521" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-522"><a href="#cb101-522" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-523"><a href="#cb101-523" aria-hidden="true" tabindex="-1"></a>LL(x|\theta)=\sum\limits_{i=1}^{n}{log\left( \frac{1}{\hat{\sigma }\sqrt{2\pi }}{{e}^{\left( \frac{-{{\left( {x_i}-{{\hat{x}}_{i}} \right)}^{2}}}{2{{{\hat{\sigma }}}^{2}}} \right)}} \right)}  </span>
<span id="cb101-524"><a href="#cb101-524" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_13}</span>
<span id="cb101-525"><a href="#cb101-525" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-526"><a href="#cb101-526" aria-hidden="true" tabindex="-1"></a>$LL(x|\theta)$ 读作给定 $\theta$ 个参数（$\mu$ 和 $\hat \sigma$）时观测值 $x$ 的对数似然；符号"\|"读作"给定"。这个看似复杂的方程式其实可以大大简化。首先，我们可以将指数项之前的常数移到求和项之外，乘以 $n$ ，然后将剩余指数项的自然对数反变换为指数：</span>
<span id="cb101-527"><a href="#cb101-527" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-528"><a href="#cb101-528" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-529"><a href="#cb101-529" aria-hidden="true" tabindex="-1"></a>LL(x|\theta)=n \log\left( \frac{1}{\hat{\sigma }\sqrt{2\pi }} \right)+\frac{1}{2{\hat{\sigma }^{2}}}\sum\limits_{i=1}^{n}{\left( -{{\left( x_i-\hat{x}_i \right)}^{2}} \right)}  </span>
<span id="cb101-530"><a href="#cb101-530" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_14}</span>
<span id="cb101-531"><a href="#cb101-531" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-532"><a href="#cb101-532" aria-hidden="true" tabindex="-1"></a>$\hat \sigma^2$ 是数据方差的最大似然估计（记住是除以 $n$ 而非 $n-1$）：</span>
<span id="cb101-533"><a href="#cb101-533" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-534"><a href="#cb101-534" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-535"><a href="#cb101-535" aria-hidden="true" tabindex="-1"></a>{{\hat{\sigma }}^{2}}=\frac{\sum\limits_{i=1}^{n}{{{\left( x_i-\hat{x}_i \right)}^{2}}}}{n}</span>
<span id="cb101-536"><a href="#cb101-536" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_15}</span>
<span id="cb101-537"><a href="#cb101-537" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-538"><a href="#cb101-538" aria-hidden="true" tabindex="-1"></a>如果用 @eq-4_15 中 $\hat \sigma^2$ 代入 @eq-4_14 ，则 $(x_i-\hat x_i)^2$ 用 $-n/2$ 代替：</span>
<span id="cb101-539"><a href="#cb101-539" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-540"><a href="#cb101-540" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-541"><a href="#cb101-541" aria-hidden="true" tabindex="-1"></a>LL(x|\theta)=n{\log}\left( \left( {\hat{\sigma }\sqrt{2\pi }} \right)^{-1} \right) - \frac{n}{2}  </span>
<span id="cb101-542"><a href="#cb101-542" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_16}</span>
<span id="cb101-543"><a href="#cb101-543" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-544"><a href="#cb101-544" aria-hidden="true" tabindex="-1"></a>化简平方根意味着将 $- 1$ 移至对数项外面，$n$ 变成 $- n$，我们可以将平方根变成指数 $1/2$，然后将 $\log(\hat \sigma)$ 项加到 $\pi$ 项上：</span>
<span id="cb101-545"><a href="#cb101-545" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-546"><a href="#cb101-546" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-547"><a href="#cb101-547" aria-hidden="true" tabindex="-1"></a>LL(x|\theta)=-n\left( {\log}\left( {{\left( 2\pi  \right)}^{\frac{1}{2}}} \right)+{\log}\left( {\hat{\sigma }} \right) \right)-\frac{n}{2}  </span>
<span id="cb101-548"><a href="#cb101-548" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_17}</span>
<span id="cb101-549"><a href="#cb101-549" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-550"><a href="#cb101-550" aria-hidden="true" tabindex="-1"></a>将幂指数 $1/2$ 移到第1个 *log* 项外：</span>
<span id="cb101-551"><a href="#cb101-551" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-552"><a href="#cb101-552" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-553"><a href="#cb101-553" aria-hidden="true" tabindex="-1"></a>LL(x|\theta)=-\frac{n}{2}\left( {\log}\left( 2\pi  \right)+2{\log}\left( {\hat{\sigma }} \right) \right)-\frac{n}{2}    </span>
<span id="cb101-554"><a href="#cb101-554" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_18}</span>
<span id="cb101-555"><a href="#cb101-555" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-556"><a href="#cb101-556" aria-hidden="true" tabindex="-1"></a>然后将 $n/2$ 简化，并将整个方程两边乘以 $- 1$，以转换为负对数似然，从而得到正态分布值的负对数似然的最终简化:</span>
<span id="cb101-557"><a href="#cb101-557" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-558"><a href="#cb101-558" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-559"><a href="#cb101-559" aria-hidden="true" tabindex="-1"></a>-LL(x|\theta)=\frac{n}{2}\left( {\log}\left( 2\pi  \right) + 2{\log} \left( {\hat{\sigma }} \right) + 1 \right)  </span>
<span id="cb101-560"><a href="#cb101-560" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_19}</span>
<span id="cb101-561"><a href="#cb101-561" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-562"><a href="#cb101-562" aria-hidden="true" tabindex="-1"></a>其中唯一的非常数部分是 $\hat \sigma$ 的值，它是残差平方和除以 $n$ 的平方根，所以现在应该很清楚了，为什么使用最大似然时获得的参数，如果使用正态随机误差，与从最小二乘方法得到的参数相同。</span>
<span id="cb101-563"><a href="#cb101-563" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-564"><a href="#cb101-564" aria-hidden="true" tabindex="-1"></a><span class="fu">### 应用正态似然拟合数据模型</span></span>
<span id="cb101-565"><a href="#cb101-565" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-566"><a href="#cb101-566" aria-hidden="true" tabindex="-1"></a>我们可以使用数据集 *LatA* 中的模拟雌性红鱼数据重复这个例子，图，</span>
<span id="cb101-567"><a href="#cb101-567" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-568"><a href="#cb101-568" aria-hidden="true" tabindex="-1"></a>我们可以使用数据集 LatA中的模拟雌性红鱼数据来重复这个例子（ @fig-4-7 ），我们用它来说明平方残差之和的使用。理想情况下，我们应该得到相同的答案，但估计值为 $\sigma$ 的估计值。**MQMF** 函数 <span class="in">`plot1()`</span> 只是绘制单个图形（*type="l "*或 *type="p"*；请参阅 <span class="in">`?plot1`</span>）的一种快速方法，没有太多空白。如果你比我更喜欢空白，请编辑 <span class="in">`plot1()`</span>！</span>
<span id="cb101-569"><a href="#cb101-569" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-572"><a href="#cb101-572" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-573"><a href="#cb101-573" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-4-7</span></span>
<span id="cb101-574"><a href="#cb101-574" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "LatA 数据集中包含的雌性红鱼 Centroberyx affinis 的年龄-长度数据。全彩表示 &gt;= 5 个点。"</span></span>
<span id="cb101-575"><a href="#cb101-575" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-576"><a href="#cb101-576" aria-hidden="true" tabindex="-1"></a> <span class="co">#plot of length-at-age data  Fig 4.7  </span></span>
<span id="cb101-577"><a href="#cb101-577" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(LatA) <span class="co"># load the redfish data set into memory and plot it  </span></span>
<span id="cb101-578"><a href="#cb101-578" aria-hidden="true" tabindex="-1"></a>ages <span class="ot">&lt;-</span> LatA<span class="sc">$</span>age;  lengths <span class="ot">&lt;-</span> LatA<span class="sc">$</span>length  </span>
<span id="cb101-579"><a href="#cb101-579" aria-hidden="true" tabindex="-1"></a><span class="fu">plot1</span>(ages,lengths,<span class="at">xlab=</span><span class="st">"Age"</span>,<span class="at">ylab=</span><span class="st">"Length"</span>,<span class="at">type=</span><span class="st">"p"</span>,<span class="at">cex=</span><span class="fl">0.8</span>,  </span>
<span id="cb101-580"><a href="#cb101-580" aria-hidden="true" tabindex="-1"></a>      <span class="at">pch=</span><span class="dv">16</span>,<span class="at">col=</span><span class="fu">rgb</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span><span class="sc">/</span><span class="dv">5</span>))  </span>
<span id="cb101-581"><a href="#cb101-581" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-582"><a href="#cb101-582" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-583"><a href="#cb101-583" aria-hidden="true" tabindex="-1"></a>现在，我们可以使用 **MQMF** 函数 `negNLL()`（负正态对数似然值）以确定使用正态随机误差的负对数似然值之和（`negLL()`对对数正态分布数据也有同样的作用）。如果你查看一下 `negNLL()` 的代码，就会发现它与 `ssq()` 一样，都是将一个函数作为参数传递给它，然后用它来计算每个输入年龄的预测平均值（在本例中是使用 **MQMF** 函数 <span class="in">`vB()`</span>计算的年龄长度），然后使用 <span class="in">`dnorm()`</span> 以预测值作为平均值，并使用数据中的年龄-长度观测值来计算 <span class="in">`-veLL`</span> 之和。年龄数据是通过省略号（...）传递的，并没有在 <span class="in">`negNLL()`</span> 中明确声明为参数。该函数在结构上与 <span class="in">`ssq()`</span> 非常相似，输入要求完全相同，但 *pars* 是显式传递的，而不是在...中传递，因为 *pars* 的最后一个值必须是残差的 stdev，它将在 `negNLL()` 中使用，而不只是在 *funk* 中使用。因此，<span class="in">`negNLL()`</span>的运行方式与<span class="in">`ssq()`</span>非常相似，它是调用函数生成预测值的封装程序，然后使用 <span class="in">`dnorm()`</span> 在每次调用时返回一个数字。因此，<span class="in">`nlm()`</span> 会最小化 <span class="in">`negNLL()`</span>，而 <span class="in">`negNLL()`</span> 又会调用 <span class="in">`vB()`</span>。</span>
<span id="cb101-584"><a href="#cb101-584" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-587"><a href="#cb101-587" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-588"><a href="#cb101-588" aria-hidden="true" tabindex="-1"></a> <span class="co"># Fit the vB growth curve using maximum likelihood  </span></span>
<span id="cb101-589"><a href="#cb101-589" aria-hidden="true" tabindex="-1"></a>pars <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="at">Linf=</span><span class="fl">27.0</span>,<span class="at">K=</span><span class="fl">0.15</span>,<span class="at">t0=</span><span class="sc">-</span><span class="fl">3.0</span>,<span class="at">sigma=</span><span class="fl">2.5</span>) <span class="co"># starting values  </span></span>
<span id="cb101-590"><a href="#cb101-590" aria-hidden="true" tabindex="-1"></a> <span class="co"># note, estimate for sigma is required for maximum likelihood  </span></span>
<span id="cb101-591"><a href="#cb101-591" aria-hidden="true" tabindex="-1"></a>ansvB <span class="ot">&lt;-</span> <span class="fu">nlm</span>(<span class="at">f=</span>negNLL,<span class="at">p=</span>pars,<span class="at">funk=</span>vB,<span class="at">observed=</span>lengths,<span class="at">ages=</span>ages,  </span>
<span id="cb101-592"><a href="#cb101-592" aria-hidden="true" tabindex="-1"></a>             <span class="at">typsize=</span><span class="fu">magnitude</span>(pars))  </span>
<span id="cb101-593"><a href="#cb101-593" aria-hidden="true" tabindex="-1"></a><span class="fu">outfit</span>(ansvB,<span class="at">backtran=</span><span class="cn">FALSE</span>,<span class="at">title=</span><span class="st">"vB by minimum -veLL"</span>)  </span>
<span id="cb101-594"><a href="#cb101-594" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-595"><a href="#cb101-595" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-596"><a href="#cb101-596" aria-hidden="true" tabindex="-1"></a>如果回顾一下 von Bertalanffy 曲线的 <span class="in">`ssq()`</span> 例子，你会看到我们从358尾鱼的样本中得到SSQ值为 $1361.421$ （试试 <span class="in">`nrow(LatA)`</span>）。因此 <span class="in">`ssq()`</span> 方法对 $\sigma$ 的估计值为 $\sqrt{(1361.421/358)}=1.95009$，与预期的最大似然估计基本相同。</span>
<span id="cb101-597"><a href="#cb101-597" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-598"><a href="#cb101-598" aria-hidden="true" tabindex="-1"></a>和以前一样，我们所需要做的就是把一个不同的生长曲线函数代入 <span class="in">`negNLL()`</span> 就可得到结果。我们只需要记住在 $p$ 向量中包含第四个参数($\sigma$ )。同样，使用正态随机误差得到的数值解与使用 <span class="in">`ssq()`</span> 方法得到的数值解本质上是相同的。</span>
<span id="cb101-599"><a href="#cb101-599" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-602"><a href="#cb101-602" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-603"><a href="#cb101-603" aria-hidden="true" tabindex="-1"></a> <span class="co">#Now fit the Michaelis-Menton curve  </span></span>
<span id="cb101-604"><a href="#cb101-604" aria-hidden="true" tabindex="-1"></a>pars <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="at">a=</span><span class="fl">23.0</span>,<span class="at">b=</span><span class="fl">1.0</span>,<span class="at">c=</span><span class="fl">1.0</span>,<span class="at">sigma=</span><span class="fl">3.0</span>) <span class="co"># Michaelis-Menton</span></span>
<span id="cb101-605"><a href="#cb101-605" aria-hidden="true" tabindex="-1"></a>ansMM <span class="ot">&lt;-</span> <span class="fu">nlm</span>(<span class="at">f=</span>negNLL,<span class="at">p=</span>pars,<span class="at">funk=</span>mm,<span class="at">observed=</span>lengths,<span class="at">ages=</span>ages,  </span>
<span id="cb101-606"><a href="#cb101-606" aria-hidden="true" tabindex="-1"></a>             <span class="at">typsize=</span><span class="fu">magnitude</span>(pars))  </span>
<span id="cb101-607"><a href="#cb101-607" aria-hidden="true" tabindex="-1"></a><span class="fu">outfit</span>(ansMM,<span class="at">backtran=</span><span class="cn">FALSE</span>,<span class="at">title=</span><span class="st">"MM by minimum -veLL"</span>)  </span>
<span id="cb101-608"><a href="#cb101-608" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-609"><a href="#cb101-609" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-610"><a href="#cb101-610" aria-hidden="true" tabindex="-1"></a>同样，解决方案的梯度很小，这增加了解决方案不仅仅是局部最小值的信心，所以我们应该画出解决方案，看看它与数据的相对拟合。</span>
<span id="cb101-611"><a href="#cb101-611" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-612"><a href="#cb101-612" aria-hidden="true" tabindex="-1"></a>通过在数据点上绘制拟合曲线，数据不会遮挡线条。现在可以从该分析中产生的实际预测，也可以与残值一起制成表格。通过包含单个残差的平方，可以更清楚地看出哪些点(见记录3)可能具有最大的影响。</span>
<span id="cb101-613"><a href="#cb101-613" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-616"><a href="#cb101-616" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-617"><a href="#cb101-617" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-4-8</span></span>
<span id="cb101-618"><a href="#cb101-618" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "雌性 LatA 红鱼数据拟合的最优 von Bertalanffy 和 Michaelis-Menton 生长曲线。注意两条曲线在观测数据最集中的区域几乎重合。注意 y 轴从 10 开始。"</span></span>
<span id="cb101-619"><a href="#cb101-619" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-620"><a href="#cb101-620" aria-hidden="true" tabindex="-1"></a> <span class="co">#plot optimum solutions for vB and mm. Fig 4.8  </span></span>
<span id="cb101-621"><a href="#cb101-621" aria-hidden="true" tabindex="-1"></a>Age <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">max</span>(ages) <span class="co"># used in comparisons   </span></span>
<span id="cb101-622"><a href="#cb101-622" aria-hidden="true" tabindex="-1"></a>predvB <span class="ot">&lt;-</span> <span class="fu">vB</span>(ansvB<span class="sc">$</span>estimate,Age) <span class="co">#optimum solution  </span></span>
<span id="cb101-623"><a href="#cb101-623" aria-hidden="true" tabindex="-1"></a>predMM <span class="ot">&lt;-</span> <span class="fu">mm</span>(ansMM<span class="sc">$</span>estimate,Age) <span class="co">#optimum solution  </span></span>
<span id="cb101-624"><a href="#cb101-624" aria-hidden="true" tabindex="-1"></a><span class="fu">parset</span>()                       <span class="co"># plot the deata points first</span></span>
<span id="cb101-625"><a href="#cb101-625" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(ages,lengths,<span class="at">xlab=</span><span class="st">"Age"</span>,<span class="at">ylab=</span><span class="st">"Length"</span>,<span class="at">type=</span><span class="st">"p"</span>,<span class="at">pch=</span><span class="dv">16</span>,  </span>
<span id="cb101-626"><a href="#cb101-626" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylim=</span><span class="fu">c</span>(<span class="dv">10</span>,<span class="dv">33</span>),<span class="at">panel.first=</span><span class="fu">grid</span>(),<span class="at">col=</span><span class="fu">rgb</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span><span class="sc">/</span><span class="dv">3</span>))  </span>
<span id="cb101-627"><a href="#cb101-627" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(Age,predvB,<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">4</span>)     <span class="co"># then add the growth curves</span></span>
<span id="cb101-628"><a href="#cb101-628" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(Age,predMM,<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">1</span>,<span class="at">lty=</span><span class="dv">2</span>)  </span>
<span id="cb101-629"><a href="#cb101-629" aria-hidden="true" tabindex="-1"></a><span class="fu">legend</span>(<span class="st">"bottomright"</span>,<span class="fu">c</span>(<span class="st">"von Bertalanffy"</span>,<span class="st">"Michaelis-Menton"</span>),  </span>
<span id="cb101-630"><a href="#cb101-630" aria-hidden="true" tabindex="-1"></a>       <span class="at">col=</span><span class="fu">c</span>(<span class="dv">4</span>,<span class="dv">1</span>),<span class="at">lwd=</span><span class="dv">3</span>,<span class="at">bty=</span><span class="st">"n"</span>,<span class="at">cex=</span><span class="fl">1.2</span>,<span class="at">lty=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>))  </span>
<span id="cb101-631"><a href="#cb101-631" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-632"><a href="#cb101-632" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-633"><a href="#cb101-633" aria-hidden="true" tabindex="-1"></a>通常，我们会生成残差图来检查残差特征（ @fig-4-9 ）。</span>
<span id="cb101-634"><a href="#cb101-634" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-637"><a href="#cb101-637" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-638"><a href="#cb101-638" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-4-9</span></span>
<span id="cb101-639"><a href="#cb101-639" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "The residual values for von Bertalanffy curve fitted to the female LatA data. There is a clear pattern between the ages of 3 - 10, which reflects the nature of residuals when the mean expected length for a given age is constant and compared to these rounded length measurements"</span></span>
<span id="cb101-640"><a href="#cb101-640" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-641"><a href="#cb101-641" aria-hidden="true" tabindex="-1"></a> <span class="co"># residual plot for vB curve   Fig 4.9  </span></span>
<span id="cb101-642"><a href="#cb101-642" aria-hidden="true" tabindex="-1"></a>predvB <span class="ot">&lt;-</span> <span class="fu">vB</span>(ansvB<span class="sc">$</span>estimate,ages) <span class="co"># predicted values for age data  </span></span>
<span id="cb101-643"><a href="#cb101-643" aria-hidden="true" tabindex="-1"></a>resids <span class="ot">&lt;-</span> lengths <span class="sc">-</span> predvB               <span class="co"># calculate vB residuals   </span></span>
<span id="cb101-644"><a href="#cb101-644" aria-hidden="true" tabindex="-1"></a><span class="fu">plot1</span>(ages,resids,<span class="at">type=</span><span class="st">"p"</span>,<span class="at">col=</span><span class="fu">rgb</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span><span class="sc">/</span><span class="dv">3</span>),<span class="at">xlim=</span><span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">43</span>),  </span>
<span id="cb101-645"><a href="#cb101-645" aria-hidden="true" tabindex="-1"></a>      <span class="at">pch=</span><span class="dv">16</span>,<span class="at">xlab=</span><span class="st">"Ages Years"</span>,<span class="at">ylab=</span><span class="st">"Residuals"</span>)  </span>
<span id="cb101-646"><a href="#cb101-646" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">h=</span><span class="fl">0.0</span>,<span class="at">col=</span><span class="dv">1</span>,<span class="at">lty=</span><span class="dv">2</span>)    <span class="co"># emphasize the zero line</span></span>
<span id="cb101-647"><a href="#cb101-647" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-648"><a href="#cb101-648" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-649"><a href="#cb101-649" aria-hidden="true" tabindex="-1"></a>生长数据的图（@fig-4-8 和 @fig-4-9 ）中，数据的网格性质清楚地表明测量的长度精确到厘米，年龄四舍五入到最接近的整年。在 x 轴和 y 轴上的这种舍入与我们用经典的 y-on-x 方法拟合这些模型的问题相结合（Ricker, 1973），并且假设在 x 轴上的测量没有变化，但不幸的是，与年龄有关，这个假设是完全错误的。从本质上讲，我们将长度和年龄的变量视为离散的，而不是连续的，年龄数据是精确的，没有误差。这些特征值得进一步探索，但也有助于强调，当处理来自生活世界的数据时，很难收集，而且通常我们处理的信息并不完美。在渔业和现实世界的生态学中建立模型的真正诀窍是从那些不太完美的数据中获得有用和有趣的信息，并以一种站得住的方式这样做。</span>
<span id="cb101-650"><a href="#cb101-650" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-651"><a href="#cb101-651" aria-hidden="true" tabindex="-1"></a><span class="fu">## 对数正态似然</span></span>
<span id="cb101-652"><a href="#cb101-652" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-653"><a href="#cb101-653" aria-hidden="true" tabindex="-1"></a>正态分布具有高于或低于预期平均值的加性残差误差，这是众所周知的，其特性构成了许多有关自然的直觉的基础。然而，在开发种群中发现的许多变量（CPUE、渔获量、努力量......）都呈现出高度倾斜的分布，中心倾向并不位于分布的中心（正态分布就是这样）。对数正态分布（Log-Normal distribution）是用于描述此类数据的一种非常常见的 PDF 分布：</span>
<span id="cb101-654"><a href="#cb101-654" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-655"><a href="#cb101-655" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-656"><a href="#cb101-656" aria-hidden="true" tabindex="-1"></a>L\left( x_i|m_i ,\sigma  \right)=\frac{1}{{x_i}\sigma \sqrt{2\pi }}{{e}^{\left( \frac{-{{\left(\log{(x_{i})}-\log{(m_i)}  \right)}^{2}}}{2\sigma^2 } \right)}}  </span>
<span id="cb101-657"><a href="#cb101-657" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_20}</span>
<span id="cb101-658"><a href="#cb101-658" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-659"><a href="#cb101-659" aria-hidden="true" tabindex="-1"></a>其中， $L(x_i | m, \sigma$ 为数据点 $x_i$ 的似然，$m_i$ 为 $i$ 点变量实例的中位数，$m= e^{\mu}$ （ $\mu = \log(m)$ ）。用 $\log(x)$ 的均值估算 $\mu$，$\sigma$ 是 $\log(x)$ 的标准差。</span>
<span id="cb101-660"><a href="#cb101-660" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-661"><a href="#cb101-661" aria-hidden="true" tabindex="-1"></a>对数正态似然方程（@eq-4_20 ）在视觉上与正态分布相似，不同之处在于对数正态分布的残差是乘性的，而不是加性的。详细地说，每个似然乘以观测值的倒数，观测值和期望值进行对数变换。具体上讲，每个似然乘以观测值的倒数，观测值和期望值进行对数变换。对观测数据和期望值的对数变换意味着，我们不是使用 $x_i-m_i$ 的变量，而是使用等价的 $x_i/m_i$ 计算残差。这意味着观测值除以预期值，而不是从观测值中减去预期值。所有这些残差都将是正值，并将围绕 1.0 的值变化。残差为 1.0 意味着数据点完全符合该数据点的预期中值。</span>
<span id="cb101-662"><a href="#cb101-662" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-663"><a href="#cb101-663" aria-hidden="true" tabindex="-1"></a><span class="fu">### 对数正态似然的简化</span></span>
<span id="cb101-664"><a href="#cb101-664" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-665"><a href="#cb101-665" aria-hidden="true" tabindex="-1"></a>与正态似然一样，对数正态似然也可以简化，以方便后续计算：</span>
<span id="cb101-666"><a href="#cb101-666" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-667"><a href="#cb101-667" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-668"><a href="#cb101-668" aria-hidden="true" tabindex="-1"></a>-LL(x|\theta)=\frac{n}{2}\left( {\log}\left( 2\pi  \right)+2{\log}\left( {\hat{\sigma }} \right) + 1 \right)+\sum\limits_{i=1}^{n}{{\log}\left( {{x}_{i}} \right)}  </span>
<span id="cb101-669"><a href="#cb101-669" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_21}</span>
<span id="cb101-670"><a href="#cb101-670" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-671"><a href="#cb101-671" aria-hidden="true" tabindex="-1"></a>$\hat \sigma^2$ 的最大似然估计是：</span>
<span id="cb101-672"><a href="#cb101-672" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-673"><a href="#cb101-673" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-674"><a href="#cb101-674" aria-hidden="true" tabindex="-1"></a>{{\hat{\sigma }}^{2}}=\sum\limits_{i=1}^{n}{\frac{{{\left( log\left( {{x}_{i}} \right)-log\left( {{{\hat{x}}}_{i}} \right) \right)}^{2}}}{n}}  </span>
<span id="cb101-675"><a href="#cb101-675" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_22}</span>
<span id="cb101-676"><a href="#cb101-676" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-677"><a href="#cb101-677" aria-hidden="true" tabindex="-1"></a>再次注意方差的最大似然估计用 $n$ 而非 $n-1$。 @eq-4_21 末尾的 $\sum \log(x)$ 项是常量，在拟合模型时经常忽略掉。如上所述，假设我们忽略 $\sum \log(x)$ 项，那么 @eq-4_22 似乎与正态分布相同（ @eq-4_13 ）。然而，现在 $\sigma$ 需要将观测值和预测值进行对数转换（ @eq-4_22 ）。因此，只要在分析前对数据和预测值进行对数变换，我们就可以使用与正态似然相关的函数（如 <span class="in">`negNLL()`</span>）来拟合使用对数正态残差的模型。不过，一般情况下，我们会使用 <span class="in">`negLL()`</span>，它需要对数变换的观测值和一个生成预测值对数的函数（见 <span class="in">`?negLL`</span>）。</span>
<span id="cb101-678"><a href="#cb101-678" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-679"><a href="#cb101-679" aria-hidden="true" tabindex="-1"></a><span class="fu">### 对数正态分布的性质</span></span>
<span id="cb101-680"><a href="#cb101-680" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-681"><a href="#cb101-681" aria-hidden="true" tabindex="-1"></a>对于正态分布，我们知道分布的期望均值、中位数和模都是相同的，但对于对数正态分布，情况并非如此。给定一组连续变量 $x$ 的值，其中位数的估计值为</span>
<span id="cb101-682"><a href="#cb101-682" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-683"><a href="#cb101-683" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-684"><a href="#cb101-684" aria-hidden="true" tabindex="-1"></a>\text{median} =m = e^{\mu}</span>
<span id="cb101-685"><a href="#cb101-685" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_23}</span>
<span id="cb101-686"><a href="#cb101-686" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-687"><a href="#cb101-687" aria-hidden="true" tabindex="-1"></a>其中 $\mu$ 是 $\log(x)$ 的均值，对数正态分布的模定义为：</span>
<span id="cb101-688"><a href="#cb101-688" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-689"><a href="#cb101-689" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-690"><a href="#cb101-690" aria-hidden="true" tabindex="-1"></a>\text{mode} = \dfrac{m}{e^{\sigma^2}}=e^{(\mu-\sigma^2)}</span>
<span id="cb101-691"><a href="#cb101-691" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_24}</span>
<span id="cb101-692"><a href="#cb101-692" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-693"><a href="#cb101-693" aria-hidden="true" tabindex="-1"></a>其中 $\sigma$ 是 $\log(x)$ 的标准差。最终，对数正态分布的均值或期望值定义为：</span>
<span id="cb101-694"><a href="#cb101-694" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-695"><a href="#cb101-695" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-696"><a href="#cb101-696" aria-hidden="true" tabindex="-1"></a>\bar{x} = me^{(\sigma^2/2)} = e^{(\mu + \sigma^2/2)}</span>
<span id="cb101-697"><a href="#cb101-697" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_25}</span>
<span id="cb101-698"><a href="#cb101-698" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-699"><a href="#cb101-699" aria-hidden="true" tabindex="-1"></a>这些方程（ @eq-4_23 到 @eq-4_25 ） 表明对数正态分布总是右斜（在模的右侧有一长尾）。此外，与正态分布相比，对数正态分布仅定义了 $x$ 为正值的情形，见 @fig-4-10 。</span>
<span id="cb101-700"><a href="#cb101-700" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-703"><a href="#cb101-703" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-704"><a href="#cb101-704" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-4-10</span></span>
<span id="cb101-705"><a href="#cb101-705" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "两幅展示对数正态概率密度函数的图。左图是一组不同参数集的似然分布，右图是前四个对数正态分布的对数变换版本。\\ Two plots illustrating the Log-Normal probability density function. Left is a group of likelihood distributions for different parameter sets, while right is the log-transformed versions of these first four Log-Normal distributions."</span></span>
<span id="cb101-706"><a href="#cb101-706" aria-hidden="true" tabindex="-1"></a> <span class="co"># meanlog and sdlog affects on mode and spread of lognormal Fig 4.10   </span></span>
<span id="cb101-707"><a href="#cb101-707" aria-hidden="true" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="fl">0.05</span>,<span class="fl">5.0</span>,<span class="fl">0.01</span>)  <span class="co"># values must be greater than 0.0  </span></span>
<span id="cb101-708"><a href="#cb101-708" aria-hidden="true" tabindex="-1"></a>y <span class="ot">&lt;-</span> <span class="fu">dlnorm</span>(x,<span class="at">meanlog=</span><span class="dv">0</span>,<span class="at">sdlog=</span><span class="fl">1.2</span>,<span class="at">log=</span><span class="cn">FALSE</span>) <span class="co">#dlnorm=likelihoods  </span></span>
<span id="cb101-709"><a href="#cb101-709" aria-hidden="true" tabindex="-1"></a>y2 <span class="ot">&lt;-</span> <span class="fu">dlnorm</span>(x,<span class="at">meanlog=</span><span class="dv">0</span>,<span class="at">sdlog=</span><span class="fl">1.0</span>,<span class="at">log=</span><span class="cn">FALSE</span>)<span class="co">#from log-normal   </span></span>
<span id="cb101-710"><a href="#cb101-710" aria-hidden="true" tabindex="-1"></a>y3 <span class="ot">&lt;-</span> <span class="fu">dlnorm</span>(x,<span class="at">meanlog=</span><span class="dv">0</span>,<span class="at">sdlog=</span><span class="fl">0.6</span>,<span class="at">log=</span><span class="cn">FALSE</span>)<span class="co">#distribution   </span></span>
<span id="cb101-711"><a href="#cb101-711" aria-hidden="true" tabindex="-1"></a>y4 <span class="ot">&lt;-</span> <span class="fu">dlnorm</span>(x,<span class="fl">0.75</span>,<span class="fl">0.6</span>)         <span class="co">#log=TRUE = log-likelihoods  </span></span>
<span id="cb101-712"><a href="#cb101-712" aria-hidden="true" tabindex="-1"></a><span class="fu">parset</span>(<span class="at">plots=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>)) <span class="co">#MQMF shortcut plot formatting function  </span></span>
<span id="cb101-713"><a href="#cb101-713" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(x,y3,<span class="at">type=</span><span class="st">"l"</span>,<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">panel.first=</span><span class="fu">grid</span>(),  </span>
<span id="cb101-714"><a href="#cb101-714" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylab=</span><span class="st">"Log-Normal Likelihood"</span>)  </span>
<span id="cb101-715"><a href="#cb101-715" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(x,y,<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">2</span>,<span class="at">lty=</span><span class="dv">2</span>)  </span>
<span id="cb101-716"><a href="#cb101-716" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(x,y2,<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">3</span>,<span class="at">lty=</span><span class="dv">3</span>)  </span>
<span id="cb101-717"><a href="#cb101-717" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(x,y4,<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">4</span>,<span class="at">lty=</span><span class="dv">4</span>)  </span>
<span id="cb101-718"><a href="#cb101-718" aria-hidden="true" tabindex="-1"></a><span class="fu">legend</span>(<span class="st">"topright"</span>,<span class="fu">c</span>(<span class="st">"meanlog sdlog"</span>,<span class="st">"    0.0      0.6"</span>,  </span>
<span id="cb101-719"><a href="#cb101-719" aria-hidden="true" tabindex="-1"></a><span class="st">"    0.0      1.0"</span>,<span class="st">"    0.0      1.2"</span>,<span class="st">"    0.75    0.6"</span>),  </span>
<span id="cb101-720"><a href="#cb101-720" aria-hidden="true" tabindex="-1"></a>       <span class="at">col=</span><span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">4</span>),<span class="at">lwd=</span><span class="dv">3</span>,<span class="at">bty=</span><span class="st">"n"</span>,<span class="at">cex=</span><span class="fl">1.0</span>,<span class="at">lty=</span><span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">4</span>))  </span>
<span id="cb101-721"><a href="#cb101-721" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">log</span>(x),y3,<span class="at">type=</span><span class="st">"l"</span>,<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">panel.first=</span><span class="fu">grid</span>(),<span class="at">ylab=</span><span class="st">""</span>)  </span>
<span id="cb101-722"><a href="#cb101-722" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(<span class="fu">log</span>(x),y,<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">2</span>,<span class="at">lty=</span><span class="dv">2</span>)  </span>
<span id="cb101-723"><a href="#cb101-723" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(<span class="fu">log</span>(x),y2,<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">3</span>,<span class="at">lty=</span><span class="dv">3</span>)  </span>
<span id="cb101-724"><a href="#cb101-724" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(<span class="fu">log</span>(x),y4,<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">4</span>,<span class="at">lty=</span><span class="dv">4</span>)  </span>
<span id="cb101-725"><a href="#cb101-725" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-726"><a href="#cb101-726" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-727"><a href="#cb101-727" aria-hidden="true" tabindex="-1"></a>同样，可以从对数正态分布生成随机数，与之前一样，对数变换应生成正态分布, 如 @fig-4-11 所示。</span>
<span id="cb101-728"><a href="#cb101-728" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-731"><a href="#cb101-731" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-732"><a href="#cb101-732" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-4-11</span></span>
<span id="cb101-733"><a href="#cb101-733" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap:  "5000 个随机点的对数正态分布，meanlog=0.7，sdlog=0.5，显示偏差校正后的平均值、模式和中位数。右侧是拟合正态分布的对数变换版本。A Log-Normal distribution of 5000 random points with meanlog=0.7 and sdlog=0.5 showing the bias-corrected mean, the mode, and the median. On the right is the log-transformed version with a fitted normal distribution."</span></span>
<span id="cb101-734"><a href="#cb101-734" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-735"><a href="#cb101-735" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">12354</span>) <span class="co"># plot random log-normal numbers as Fig 4.11  </span></span>
<span id="cb101-736"><a href="#cb101-736" aria-hidden="true" tabindex="-1"></a>meanL <span class="ot">&lt;-</span> <span class="fl">0.7</span>;   sdL <span class="ot">&lt;-</span> <span class="fl">0.5</span>  <span class="co"># generate 5000 random log-normal   </span></span>
<span id="cb101-737"><a href="#cb101-737" aria-hidden="true" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">rlnorm</span>(<span class="dv">5000</span>,<span class="at">meanlog =</span> meanL,<span class="at">sdlog =</span> sdL) <span class="co"># values  </span></span>
<span id="cb101-738"><a href="#cb101-738" aria-hidden="true" tabindex="-1"></a><span class="fu">parset</span>(<span class="at">plots=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>)) <span class="co"># simplifies the plots par() definition  </span></span>
<span id="cb101-739"><a href="#cb101-739" aria-hidden="true" tabindex="-1"></a><span class="fu">hist</span>(x[x <span class="sc">&lt;</span> <span class="fl">8.0</span>],<span class="at">breaks=</span><span class="fu">seq</span>(<span class="dv">0</span>,<span class="dv">8</span>,<span class="fl">0.25</span>),<span class="at">col=</span><span class="dv">0</span>,<span class="at">main=</span><span class="st">""</span>)   </span>
<span id="cb101-740"><a href="#cb101-740" aria-hidden="true" tabindex="-1"></a>meanx <span class="ot">&lt;-</span> <span class="fu">mean</span>(<span class="fu">log</span>(x)); sdx <span class="ot">&lt;-</span> <span class="fu">sd</span>(<span class="fu">log</span>(x))  </span>
<span id="cb101-741"><a href="#cb101-741" aria-hidden="true" tabindex="-1"></a>outstat <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">exp</span>(meanx<span class="sc">-</span>(sdx<span class="sc">^</span><span class="dv">2</span>)),<span class="fu">exp</span>(meanx),<span class="fu">exp</span>(meanx<span class="sc">+</span>(sdx<span class="sc">^</span><span class="dv">2</span>)<span class="sc">/</span><span class="dv">2</span>))  </span>
<span id="cb101-742"><a href="#cb101-742" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>outstat,<span class="at">col=</span><span class="fu">c</span>(<span class="dv">4</span>,<span class="dv">1</span>,<span class="dv">2</span>),<span class="at">lwd=</span><span class="dv">3</span>,<span class="at">lty=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>))  </span>
<span id="cb101-743"><a href="#cb101-743" aria-hidden="true" tabindex="-1"></a><span class="fu">legend</span>(<span class="st">"topright"</span>,<span class="fu">c</span>(<span class="st">"mode"</span>,<span class="st">"median"</span>,<span class="st">"bias-correct"</span>),  </span>
<span id="cb101-744"><a href="#cb101-744" aria-hidden="true" tabindex="-1"></a>       <span class="at">col=</span><span class="fu">c</span>(<span class="dv">4</span>,<span class="dv">1</span>,<span class="dv">2</span>),<span class="at">lwd=</span><span class="dv">3</span>,<span class="at">bty=</span><span class="st">"n"</span>,<span class="at">cex=</span><span class="fl">1.2</span>,<span class="at">lty=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>))  </span>
<span id="cb101-745"><a href="#cb101-745" aria-hidden="true" tabindex="-1"></a>outh <span class="ot">&lt;-</span> <span class="fu">hist</span>(<span class="fu">log</span>(x),<span class="at">breaks=</span><span class="dv">30</span>,<span class="at">col=</span><span class="dv">0</span>,<span class="at">main=</span><span class="st">""</span>)   <span class="co"># approxnormal  </span></span>
<span id="cb101-746"><a href="#cb101-746" aria-hidden="true" tabindex="-1"></a>hans <span class="ot">&lt;-</span> <span class="fu">addnorm</span>(outh,<span class="fu">log</span>(x)) <span class="co">#MQMF function; try  ?addnorm  </span></span>
<span id="cb101-747"><a href="#cb101-747" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(hans<span class="sc">$</span>x,hans<span class="sc">$</span>y,<span class="at">lwd=</span><span class="dv">3</span>,<span class="at">col=</span><span class="dv">1</span>) <span class="co"># type addnorm into the console  </span></span>
<span id="cb101-748"><a href="#cb101-748" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-749"><a href="#cb101-749" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-750"><a href="#cb101-750" aria-hidden="true" tabindex="-1"></a>我们可以检查输入参数的预期统计量，并将其与变量 outstat 中的参数估计进行比较。</span>
<span id="cb101-751"><a href="#cb101-751" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-754"><a href="#cb101-754" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-755"><a href="#cb101-755" aria-hidden="true" tabindex="-1"></a> <span class="co">#examine log-normal propoerties. It is a bad idea to reuse   </span></span>
<span id="cb101-756"><a href="#cb101-756" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">12345</span>) <span class="co">#'random' seeds, use getseed() for suggestions  </span></span>
<span id="cb101-757"><a href="#cb101-757" aria-hidden="true" tabindex="-1"></a>meanL <span class="ot">&lt;-</span> <span class="fl">0.7</span>;   sdL <span class="ot">&lt;-</span> <span class="fl">0.5</span>  <span class="co">#5000 random log-normal values then  </span></span>
<span id="cb101-758"><a href="#cb101-758" aria-hidden="true" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">rlnorm</span>(<span class="dv">5000</span>,<span class="at">meanlog =</span> meanL,<span class="at">sdlog =</span> sdL) <span class="co">#try with only 500   </span></span>
<span id="cb101-759"><a href="#cb101-759" aria-hidden="true" tabindex="-1"></a>meanx <span class="ot">&lt;-</span> <span class="fu">mean</span>(<span class="fu">log</span>(x)); sdx <span class="ot">&lt;-</span> <span class="fu">sd</span>(<span class="fu">log</span>(x))  </span>
<span id="cb101-760"><a href="#cb101-760" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"               Original  Sample </span><span class="sc">\n</span><span class="st">"</span>)  </span>
<span id="cb101-761"><a href="#cb101-761" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"Mode(x)     = "</span>,<span class="fu">exp</span>(meanL <span class="sc">-</span> sdL<span class="sc">^</span><span class="dv">2</span>),outstat[<span class="dv">1</span>],<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)  </span>
<span id="cb101-762"><a href="#cb101-762" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"Median(x)   = "</span>,<span class="fu">exp</span>(meanL),outstat[<span class="dv">2</span>],<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)  </span>
<span id="cb101-763"><a href="#cb101-763" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"Mean(x)     = "</span>,<span class="fu">exp</span>(meanL <span class="sc">+</span> (sdL<span class="sc">^</span><span class="dv">2</span>)<span class="sc">/</span><span class="dv">2</span>),outstat[<span class="dv">3</span>],<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)  </span>
<span id="cb101-764"><a href="#cb101-764" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"Mean(log(x) =  0.7     "</span>,meanx,<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)  </span>
<span id="cb101-765"><a href="#cb101-765" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"sd(log(x)   =  0.5     "</span>,sdx,<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)  </span>
<span id="cb101-766"><a href="#cb101-766" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-767"><a href="#cb101-767" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-768"><a href="#cb101-768" aria-hidden="true" tabindex="-1"></a>中位数与均值之间的差异，即 $+ (\sigma^2/2)$ 项，被称为偏差修正项，并试图通过将中心倾向的测量值进一步向右偏离模式来解释分布的向右偏斜。模似乎位于最高组的左侧，但这只是反映了 R 绘制直方图的方式（您可以增加一半的二进制宽度来解决这个视觉问题）。</span>
<span id="cb101-769"><a href="#cb101-769" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-770"><a href="#cb101-770" aria-hidden="true" tabindex="-1"></a><span class="fu">### 应用对数似然拟合曲线</span></span>
<span id="cb101-771"><a href="#cb101-771" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-772"><a href="#cb101-772" aria-hidden="true" tabindex="-1"></a>我们可以使用 Penn 和 Caputi（1986）关于澳大利亚埃克斯茅斯湾老虎虾（*Penaeus semisulcatus*；MQMF 数据集 *tigers*）的产卵种群生物量及其补充量数据。种群补充关系通常假定为对数正态残差（有时为伽马分布，见后），通常在种群评估模型中得出。Penn 和 Caputi（1986 年）使用的是 Ricker 曲线，但作为替代方案，我们将尝试根据这些观测数据拟合 Beverton-Holt 种群补充量曲线（我们将在静态模型一章中更详细地研究种群补充量关系）。Beverton-Holt 种群补充量关系可以有多种形式，但在本例中我们将使用 @eq-4_26 ：</span>
<span id="cb101-773"><a href="#cb101-773" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-774"><a href="#cb101-774" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-775"><a href="#cb101-775" aria-hidden="true" tabindex="-1"></a>R_t=\frac{aB_t}{b+B_t}e^{N(0,\sigma^2)}   </span>
<span id="cb101-776"><a href="#cb101-776" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_26}</span>
<span id="cb101-777"><a href="#cb101-777" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-778"><a href="#cb101-778" aria-hidden="true" tabindex="-1"></a>其中 $R_t$ 是年 $t$ 的补充量， $B_t$ 是繁殖亲体量，它能生产出 $R_t$ 的补充量，$a$ 是渐近最大补充量水平，$b$ 是生产最大补充量的 50% 时的繁殖亲体量。残差误差是 $\mu=0$、方差为 $\sigma^2$ 的对数分布，这些参数可以通过对数据进行模型拟合得到。我们将继续使用 <span class="in">`negNLL()`</span>，但如果您检查一下 <span class="in">`negNLL()`</span> 的代码，就会发现我们需要输入对数变换后的观测补充量水平，并编写一个简短函数来计算预测补充量水平的对数。我们将再次使用 <span class="in">`nlm()`</span> 来最小化 <span class="in">`negNLL()`</span> 的输出结果。当我们考虑 @tbl-4-2 中的对数正态残差（观测补充量/预测补充量）时，注意到有两个特殊的残差值，一个接近 $2.04$，另一个接近 $0.44$。低点的潜在影响可能值得进一步研究，因为它是相对特殊的事件（事实上，它似乎受到气旋发生的影响，Penn 和 Caputi，1986 ）。</span>
<span id="cb101-779"><a href="#cb101-779" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-782"><a href="#cb101-782" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-783"><a href="#cb101-783" aria-hidden="true" tabindex="-1"></a> <span class="co"># fit a Beverton-Holt recruitment curve to tigers data Table 4.2  </span></span>
<span id="cb101-784"><a href="#cb101-784" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(tigers)   <span class="co"># use the tiger prawn data set  </span></span>
<span id="cb101-785"><a href="#cb101-785" aria-hidden="true" tabindex="-1"></a>lbh <span class="ot">&lt;-</span> <span class="cf">function</span>(p,biom) <span class="fu">return</span>(<span class="fu">log</span>((p[<span class="dv">1</span>]<span class="sc">*</span>biom)<span class="sc">/</span>(p[<span class="dv">2</span>] <span class="sc">+</span> biom)))  </span>
<span id="cb101-786"><a href="#cb101-786" aria-hidden="true" tabindex="-1"></a> <span class="co">#note we are returning the log of Beverton-Holt recruitment </span></span>
<span id="cb101-787"><a href="#cb101-787" aria-hidden="true" tabindex="-1"></a>pars <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"a"</span><span class="ot">=</span><span class="dv">25</span>,<span class="st">"b"</span><span class="ot">=</span><span class="fl">4.5</span>,<span class="st">"sigma"</span><span class="ot">=</span><span class="fl">0.4</span>)   <span class="co"># includes a sigma  </span></span>
<span id="cb101-788"><a href="#cb101-788" aria-hidden="true" tabindex="-1"></a>best <span class="ot">&lt;-</span> <span class="fu">nlm</span>(negNLL,pars,<span class="at">funk=</span>lbh,<span class="at">observed=</span><span class="fu">log</span>(tigers<span class="sc">$</span>Recruit),  </span>
<span id="cb101-789"><a href="#cb101-789" aria-hidden="true" tabindex="-1"></a>            <span class="at">biom=</span>tigers<span class="sc">$</span>Spawn,<span class="at">typsize=</span><span class="fu">magnitude</span>(pars))  </span>
<span id="cb101-790"><a href="#cb101-790" aria-hidden="true" tabindex="-1"></a><span class="fu">outfit</span>(best,<span class="at">backtran=</span><span class="cn">FALSE</span>,<span class="at">title=</span><span class="st">"Beverton-Holt Recruitment"</span>)  </span>
<span id="cb101-791"><a href="#cb101-791" aria-hidden="true" tabindex="-1"></a>predR <span class="ot">&lt;-</span> <span class="fu">exp</span>(<span class="fu">lbh</span>(best<span class="sc">$</span>estimate,tigers<span class="sc">$</span>Spawn))   </span>
<span id="cb101-792"><a href="#cb101-792" aria-hidden="true" tabindex="-1"></a> <span class="co">#note exp(lbh(...)) is the median because no bias adjustment  </span></span>
<span id="cb101-793"><a href="#cb101-793" aria-hidden="true" tabindex="-1"></a>result <span class="ot">&lt;-</span> <span class="fu">cbind</span>(tigers,predR,tigers<span class="sc">$</span>Recruit<span class="sc">/</span>predR)  </span>
<span id="cb101-794"><a href="#cb101-794" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-795"><a href="#cb101-795" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-798"><a href="#cb101-798" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-799"><a href="#cb101-799" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb101-800"><a href="#cb101-800" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-4-2 </span></span>
<span id="cb101-801"><a href="#cb101-801" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: "The Exmouth Gulf tiger prawn data set of spawning biomass with consequent recruitment levels, with the predicted recruitment level from the optimum model fit, along with the Log-Normal"</span></span>
<span id="cb101-802"><a href="#cb101-802" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-803"><a href="#cb101-803" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(result) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"SpawnB"</span>, <span class="st">"Recruit"</span>, <span class="st">"PredR"</span>, <span class="st">"Residual"</span>) </span>
<span id="cb101-804"><a href="#cb101-804" aria-hidden="true" tabindex="-1"></a>knitr<span class="sc">::</span><span class="fu">kable</span>(result)</span>
<span id="cb101-805"><a href="#cb101-805" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-806"><a href="#cb101-806" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-807"><a href="#cb101-807" aria-hidden="true" tabindex="-1"></a>我们可以绘制出解，直观地比较数据拟合结果：</span>
<span id="cb101-808"><a href="#cb101-808" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-811"><a href="#cb101-811" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-812"><a href="#cb101-812" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-4-12</span></span>
<span id="cb101-813"><a href="#cb101-813" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "The optimum fit to the Exmouth Gulf tiger prawns Beverton-Holt stock recruitment relationship using log-normal likelihoods."</span></span>
<span id="cb101-814"><a href="#cb101-814" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-815"><a href="#cb101-815" aria-hidden="true" tabindex="-1"></a> <span class="co"># Fig 4.12 visual examination of the fit to the tigers data  </span></span>
<span id="cb101-816"><a href="#cb101-816" aria-hidden="true" tabindex="-1"></a><span class="fu">plot1</span>(tigers<span class="sc">$</span>Spawn,predR,<span class="at">xlab=</span><span class="st">"Spawning Biomass"</span>,<span class="st">"Recruitment"</span>,  </span>
<span id="cb101-817"><a href="#cb101-817" aria-hidden="true" tabindex="-1"></a>      <span class="at">maxy=</span><span class="fu">getmax</span>(<span class="fu">c</span>(predR,tigers<span class="sc">$</span>Recruit)),<span class="at">lwd=</span><span class="dv">2</span>)  </span>
<span id="cb101-818"><a href="#cb101-818" aria-hidden="true" tabindex="-1"></a><span class="fu">points</span>(tigers<span class="sc">$</span>Spawn,tigers<span class="sc">$</span>Recruit,<span class="at">pch=</span><span class="dv">16</span>,<span class="at">cex=</span><span class="fl">1.1</span>,<span class="at">col=</span><span class="dv">2</span>)  </span>
<span id="cb101-819"><a href="#cb101-819" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-820"><a href="#cb101-820" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-821"><a href="#cb101-821" aria-hidden="true" tabindex="-1"></a><span class="fu">### 应用对数正态误差拟合动态模型</span></span>
<span id="cb101-822"><a href="#cb101-822" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-823"><a href="#cb101-823" aria-hidden="true" tabindex="-1"></a>本例中，我们将回顾第 <span class="co">[</span><span class="ot">-@sec-surplusproduction</span><span class="co">]</span> 章“剩余生产模型 ”中的一个例子（并在第 <span class="co">[</span><span class="ot">-@sec-simplemodel</span><span class="co">]</span> 章“简单种群模型 ”中查看）。具体而言，我们将使用所谓的Schaefer（1954，1957）剩余生产模型（Hilborn 和 Walters，1992；Polacheck 等，1993；Prager，1994；Haddon，2011）。用于描述 Schaefer 模型的最简单方程包含两个项：</span>
<span id="cb101-824"><a href="#cb101-824" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-825"><a href="#cb101-825" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-826"><a href="#cb101-826" aria-hidden="true" tabindex="-1"></a>\begin{aligned}  </span>
<span id="cb101-827"><a href="#cb101-827" aria-hidden="true" tabindex="-1"></a>  {B_0} &amp;= {B_{init}} <span class="sc">\\</span>   </span>
<span id="cb101-828"><a href="#cb101-828" aria-hidden="true" tabindex="-1"></a>  {B_{t+1}} &amp;= {B_t}+r{B_t}\left( 1-\frac{{B_t}}{K} \right)-{C_t}   </span>
<span id="cb101-829"><a href="#cb101-829" aria-hidden="true" tabindex="-1"></a>\end{aligned}    </span>
<span id="cb101-830"><a href="#cb101-830" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_27}</span>
<span id="cb101-831"><a href="#cb101-831" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-832"><a href="#cb101-832" aria-hidden="true" tabindex="-1"></a>其中 $r$ 是内禀自然增长率（种群增长率项），$K$ 是环境容纳量或未被捕捞时的生物量，一般用 $B_0$ 表示（注意的是，这里的 $B_0$ 简单地表示 $t=0$ 时的初始生物量），$B_{init}$ 可能已衰退低于 $K$。$B_t$ 表示年 $t$ 可用生物量，那么 $B_{init}$ 是第一年中可用生物量。如果资源未被捕捞，那么 $B_{init} =K$，但在其他情况下，它将构成一个单独的模型参数。最后， $C_t$ 是年 $t$ 中捕捞的总获量。当然，时间步长不必以年为单位，可能需要更短的时间，这取决于相关物种的生物学特性，不过，使用年是很常见的。注意 @eq-4_27 中没有误差项。这意味着种群动态是确定的，渔获量是已知的，没有误差。估算该模型的参数就是使用观察误差估算的一个例子。</span>
<span id="cb101-833"><a href="#cb101-833" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-834"><a href="#cb101-834" aria-hidden="true" tabindex="-1"></a>@eq-4_27 中的简单动态模型，在所需参数（$B_{init}$、$r$ 及 $K$ ）已知时，将初始生物量向前推算，生成种群生物量水平的时间序列。如果有相对丰度指数的时间序列（可能是调查得出的生物量估计值，也可能是渔业相关数据得出的标准化单位努力量渔获量（CPUE）），就可以将剩余产量模型与自然界的观测结果进行比较。在下面的例子中，我们将使用 **MQMF** 数据集 *abdat* 中潜水捕捞无脊椎动物的渔获量和 CPUE。假设相对丰度指数与种群生物量之间存在简单的线性关系：</span>
<span id="cb101-835"><a href="#cb101-835" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-836"><a href="#cb101-836" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-837"><a href="#cb101-837" aria-hidden="true" tabindex="-1"></a>{I_t}=\frac{C_t}{E_t}=q{B_t}e^{\varepsilon}{ \;\;\;\;\;\;  \text{or}  \;\;\;\;\;\; } {C_t}=q{E_t}{B_t}e^{\varepsilon}  </span>
<span id="cb101-838"><a href="#cb101-838" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_28}</span>
<span id="cb101-839"><a href="#cb101-839" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-840"><a href="#cb101-840" aria-hidden="true" tabindex="-1"></a>其中 $I_t$ 是年 $t$ 的观测 CPUE，$E_t$ 是年 $t$ 的努力量， $q$ 为可捕系数（Arreguin-Sanchez, 1996），$e^{\varepsilon}$ 表示CPUE 和 种群生物量关系的对数正态残差误差。 该 $q$ 可以作为一个参数直接估算，尽管也有所谓的闭合形式估算值（Polacheck 等，1993）：</span>
<span id="cb101-841"><a href="#cb101-841" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-842"><a href="#cb101-842" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-843"><a href="#cb101-843" aria-hidden="true" tabindex="-1"></a>q={e}^{\frac{1}{n}{\sum{\log}\left( \frac{{{I}_{t}}}{{{{\hat{B}}}_{t}}} \right)}}=\exp \left( {\frac{1}{n}}\sum{\log}\left( \frac{{I}_{t}}{\hat{B}_{t}} \right) \right)  </span>
<span id="cb101-844"><a href="#cb101-844" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_29}</span>
<span id="cb101-845"><a href="#cb101-845" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-846"><a href="#cb101-846" aria-hidden="true" tabindex="-1"></a>基本上就是观测到的 CPUE 向量的几何平均数除以预测的每年生物量水平。使用这种封闭形式的一个好处是，在拟合数据时，模型需要估计的参数较少。它还强调 $q$ 参数只是一个比例因子，反映了可开发生物量与相对丰度指数之间的假定线性关系。如果假定存在非线性关系，则需要更复杂的可捕量表示方法。</span>
<span id="cb101-847"><a href="#cb101-847" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-848"><a href="#cb101-848" aria-hidden="true" tabindex="-1"></a>上例中拟合的种群增殖曲线使用了一个相对简单的方程和相关函数作为拟合模型，但模型中不涉及动态变化。当试图将 @eq-4_27 至 @eq-4_29 中描述的剩余产量模型与观测到的 CPUE 和渔获量数据进行拟合时，得出预测 CPUE 的函数需要更加复杂，因为它需要包含种群动态。对于简单的非动态模型，自变量和因变量的使用相对简单。在此，我们将说明（并强化）在将动态模型拟合到数据时需要做哪些工作。</span>
<span id="cb101-849"><a href="#cb101-849" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-850"><a href="#cb101-850" aria-hidden="true" tabindex="-1"></a>我们将使用名为 *abdat* 的 **MQMF** 数据集，该数据集因包含鲍鱼数据而得名。</span>
<span id="cb101-851"><a href="#cb101-851" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-854"><a href="#cb101-854" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-855"><a href="#cb101-855" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-4-13</span></span>
<span id="cb101-856"><a href="#cb101-856" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "The abdat data set plotting the catch and the cpue through time to illustrate their relationship."</span></span>
<span id="cb101-857"><a href="#cb101-857" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-858"><a href="#cb101-858" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(abdat)  <span class="co"># plot abdat fishery data using a MQMF helper  Fig 4.13  </span></span>
<span id="cb101-859"><a href="#cb101-859" aria-hidden="true" tabindex="-1"></a><span class="fu">plotspmdat</span>(abdat) <span class="co"># function to quickly plot catch and cpue</span></span>
<span id="cb101-860"><a href="#cb101-860" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-861"><a href="#cb101-861" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-862"><a href="#cb101-862" aria-hidden="true" tabindex="-1"></a>我们需要在 <span class="in">`nlm()`</span> 中使用两个函数来找到最佳参数。您应该检查每个函数的代码，并了解它们与所用方程的关系。第一个函数用于计算预测 cpue 的对数（我们使用 <span class="in">`simpspm()`</span>），第二个函数用于计算 *-veLL*，其中我们使用对数正态残差误差来表示 cpue 数据的残差（因此我们使用 `negLL()`；将其代码与 `negNLL()` 进行比较）。请注意模型参数将进行对数变换的预期，我们这样做是因为它通常比使用 *typsize* 选项更稳定。你应该通过尝试不同的起始点来实验这段代码。你应该仔细检查 <span class="in">`simpspm`</span> 和 <span class="in">`negLL()`</span> 的代码，直到理解它们之间的相互作用，并相信您可以用不同的数据集重复这一分析（参见第 <span class="co">[</span><span class="ot">-@sec-surplusproduction</span><span class="co">]</span> 章“剩余产量模型 ” ）。</span>
<span id="cb101-863"><a href="#cb101-863" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-866"><a href="#cb101-866" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-867"><a href="#cb101-867" aria-hidden="true" tabindex="-1"></a> <span class="co"># Use log-transformed parameters for increased stability when  </span></span>
<span id="cb101-868"><a href="#cb101-868" aria-hidden="true" tabindex="-1"></a> <span class="co"># fitting the surplus production model to the abdat data-set  </span></span>
<span id="cb101-869"><a href="#cb101-869" aria-hidden="true" tabindex="-1"></a>param <span class="ot">&lt;-</span> <span class="fu">log</span>(<span class="fu">c</span>(<span class="at">r=</span> <span class="fl">0.42</span>,<span class="at">K=</span><span class="dv">9400</span>,<span class="at">Binit=</span><span class="dv">3400</span>,<span class="at">sigma=</span><span class="fl">0.05</span>))   </span>
<span id="cb101-870"><a href="#cb101-870" aria-hidden="true" tabindex="-1"></a>obslog <span class="ot">&lt;-</span> <span class="fu">log</span>(abdat<span class="sc">$</span>cpue) <span class="co">#input log-transformed observed data  </span></span>
<span id="cb101-871"><a href="#cb101-871" aria-hidden="true" tabindex="-1"></a>bestmod <span class="ot">&lt;-</span> <span class="fu">nlm</span>(<span class="at">f=</span>negLL,<span class="at">p=</span>param,<span class="at">funk=</span>simpspm,<span class="at">indat=</span><span class="fu">as.matrix</span>(abdat),  </span>
<span id="cb101-872"><a href="#cb101-872" aria-hidden="true" tabindex="-1"></a>               <span class="at">logobs=</span>obslog)  <span class="co"># no typsize, or iterlim needed  </span></span>
<span id="cb101-873"><a href="#cb101-873" aria-hidden="true" tabindex="-1"></a> <span class="co">#backtransform estimates, outfit's default, as log-transformed   </span></span>
<span id="cb101-874"><a href="#cb101-874" aria-hidden="true" tabindex="-1"></a><span class="fu">outfit</span>(bestmod,<span class="at">backtran =</span> <span class="cn">TRUE</span>,<span class="at">title=</span><span class="st">"abdat"</span>)        <span class="co"># in param  </span></span>
<span id="cb101-875"><a href="#cb101-875" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-876"><a href="#cb101-876" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-877"><a href="#cb101-877" aria-hidden="true" tabindex="-1"></a>将观察到的数据与最优模型的预测值对比绘制成图总是一个好主意。在这里，我们将它们绘制成对数比例，以准确说明拟合结果，并帮助确定哪些点与预测值相差最大。由于很少有人能直观地掌握对数标度，因此在标称标度上绘制数据和拟合结果也是一个好主意，此外，我们通常还会绘制残差图来寻找规律。</span>
<span id="cb101-878"><a href="#cb101-878" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-881"><a href="#cb101-881" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-882"><a href="#cb101-882" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-4-14</span></span>
<span id="cb101-883"><a href="#cb101-883" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "The optimum fit of the Schaefer surplus production model to the abdat data set plotted in log-space on the y-axis."</span></span>
<span id="cb101-884"><a href="#cb101-884" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-885"><a href="#cb101-885" aria-hidden="true" tabindex="-1"></a> <span class="co"># Fig 4.14 Examine fit of predicted to data  </span></span>
<span id="cb101-886"><a href="#cb101-886" aria-hidden="true" tabindex="-1"></a>predce <span class="ot">&lt;-</span> <span class="fu">simpspm</span>(bestmod<span class="sc">$</span>estimate,abdat) <span class="co">#compare obs vs pred  </span></span>
<span id="cb101-887"><a href="#cb101-887" aria-hidden="true" tabindex="-1"></a>ymax <span class="ot">&lt;-</span> <span class="fu">getmax</span>(<span class="fu">c</span>(predce,obslog))  </span>
<span id="cb101-888"><a href="#cb101-888" aria-hidden="true" tabindex="-1"></a><span class="fu">plot1</span>(abdat<span class="sc">$</span>year,obslog,<span class="at">type=</span><span class="st">"p"</span>,<span class="at">maxy=</span>ymax,<span class="at">ylab=</span><span class="st">"Log(CPUE)"</span>,  </span>
<span id="cb101-889"><a href="#cb101-889" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlab=</span><span class="st">"Year"</span>,<span class="at">cex=</span><span class="fl">0.9</span>)  </span>
<span id="cb101-890"><a href="#cb101-890" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(abdat<span class="sc">$</span>year,predce,<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">2</span>)  </span>
<span id="cb101-891"><a href="#cb101-891" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-892"><a href="#cb101-892" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-893"><a href="#cb101-893" aria-hidden="true" tabindex="-1"></a><span class="fu">## 二项式分布的似然</span></span>
<span id="cb101-894"><a href="#cb101-894" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-895"><a href="#cb101-895" aria-hidden="true" tabindex="-1"></a>到目前为止，通过正态分布和对数正态分布，我们一直在处理连续变量（如产卵生物量和 cpue）特定值的似然。当然，有些观测结果和事件在本质上是离散的。常见的例子包括动物是否成熟、是否有标签或类似的 “是”/“否 ”情况。与连续变量不同，当使用离散型分布（如二项分布）计算特定值（如在 $n$ 个观测样本中看到 $m$ 个标记的似然）的似然时，它们是真正的概率，而不仅仅是概率密度。这样，就避免了理解并非真实概率的似然的复杂性；这可能就是为什么许多介绍极大似然方法的文章倾向于从使用二项分布的例子开始的原因。</span>
<span id="cb101-896"><a href="#cb101-896" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-897"><a href="#cb101-897" aria-hidden="true" tabindex="-1"></a>在观察结果有真有假的情况下（所谓伯努利试验；例如，捕获的鱼要么有标记，要么没有标记），$n$ 次观察（试验）的成功概率为参数 $p$，那么通常最好使用二项分布来描述观察结果。二项分布概率密度函数产生真实概率，有两个参数：$n$，即试验次数（样本大小）；$p$，即试验成功的概率（事件/观察结果证明为真）：</span>
<span id="cb101-898"><a href="#cb101-898" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-899"><a href="#cb101-899" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-900"><a href="#cb101-900" aria-hidden="true" tabindex="-1"></a>P\left<span class="sc">\{</span> m|n,p \right<span class="sc">\}</span>=\left<span class="co">[</span><span class="ot"> \frac{n!}{m!\left( n-m \right)!} \right</span><span class="co">]</span>{{p}^{m}}{{\left( 1-p \right)}^{\left( n-m \right)}}  </span>
<span id="cb101-901"><a href="#cb101-901" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_30}</span>
<span id="cb101-902"><a href="#cb101-902" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-903"><a href="#cb101-903" aria-hidden="true" tabindex="-1"></a>读为给定 $n$ 次试验中 $m$ 个事件为真的概率（如 $n$ 个观测样本中出现 $m$ 个标记），其中 $p$ 是事件为真的概率。项 $(1-p)$ 常写作 $q$，即 $(1-p) =q$。 “！”符号表示阶乘。方括号中的项是组合数，是从 $n$ 个元素中一次取 $m$ 个元素形成的组合数，有时写成:</span>
<span id="cb101-904"><a href="#cb101-904" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-905"><a href="#cb101-905" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-906"><a href="#cb101-906" aria-hidden="true" tabindex="-1"></a>\left( \begin{matrix}  </span>
<span id="cb101-907"><a href="#cb101-907" aria-hidden="true" tabindex="-1"></a>   n  <span class="sc">\\</span>  </span>
<span id="cb101-908"><a href="#cb101-908" aria-hidden="true" tabindex="-1"></a>   m  <span class="sc">\\</span>  </span>
<span id="cb101-909"><a href="#cb101-909" aria-hidden="true" tabindex="-1"></a>\end{matrix} \right)=\frac{n!}{m!\left( n-m \right)!}  </span>
<span id="cb101-910"><a href="#cb101-910" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_31}</span>
<span id="cb101-911"><a href="#cb101-911" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-912"><a href="#cb101-912" aria-hidden="true" tabindex="-1"></a>总有 $n \geq m$ 的情况，因为一个人不可能有比试验更多的成功。</span>
<span id="cb101-913"><a href="#cb101-913" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-914"><a href="#cb101-914" aria-hidden="true" tabindex="-1"></a><span class="fu">### 二项式似然的示例</span></span>
<span id="cb101-915"><a href="#cb101-915" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-916"><a href="#cb101-916" aria-hidden="true" tabindex="-1"></a>作为第一个示例子，我们可以从一个种群中只捕捞雄性（澳大利亚昆士兰州捕捞泥蟹（*Scylla serrata*）就是一个例子）。人们可能会问，这种管理策略是否会对特定种群中合法规格动物的性别比例产生负面影响。在一个假设的 $60$ 只动物样本中，如果我们获得了 $40$ 只雌性动物，而只有 $20$ 只雄性动物，那么我们是否可以得出结论，渔业对性别比例产生了影响？回答这个问题的一种方法是研究出现这种结果的相对似然（虽然二项式似然是真正的概率，但我们仍将其称为似然）。典型的性别比为 $1:1$，这意味着我们可能会期望从 $60$ 个样本中找到 $30$ 只雄性动物，因此，如果我们在本例中宣布找到一只雄性动物是成功的，我们就应该研究不同 $m$ 值的似然（ $n$ 个样本中雄性个体数），并确定在样本中找到 $m=20$ 的相对似然。</span>
<span id="cb101-917"><a href="#cb101-917" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-920"><a href="#cb101-920" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-921"><a href="#cb101-921" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-4-15</span></span>
<span id="cb101-922"><a href="#cb101-922" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "如果性别比为 1:1，那么在 60 只动物样本中只观察到 20 只雄性动物的可能性有多大。垂直红线是 95% 置信区间的下限，表明只观察到 20 只的可能性不大。A graphical answer to the question of how likely is it to obtain only 20 males in a sample of 60 animals if the sex ratio is 1:1. The vertical red line is the lower bound of the 95% confidence intervals, which suggests that observing only 20 would be unlikely."</span></span>
<span id="cb101-923"><a href="#cb101-923" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-924"><a href="#cb101-924" aria-hidden="true" tabindex="-1"></a> <span class="co">#Use Binomial distribution to test biased sex-ratio Fig 4.15  </span></span>
<span id="cb101-925"><a href="#cb101-925" aria-hidden="true" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="dv">60</span>    <span class="co"># a sample of 60 animals  </span></span>
<span id="cb101-926"><a href="#cb101-926" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> <span class="fl">0.5</span>   <span class="co"># assume a sex-ration of 1:1   </span></span>
<span id="cb101-927"><a href="#cb101-927" aria-hidden="true" tabindex="-1"></a>m <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">60</span>  <span class="co"># how likely is each of the 60 possibilites?  </span></span>
<span id="cb101-928"><a href="#cb101-928" aria-hidden="true" tabindex="-1"></a>binom <span class="ot">&lt;-</span> <span class="fu">dbinom</span>(m,n,p)   <span class="co"># get individual likelihoods  </span></span>
<span id="cb101-929"><a href="#cb101-929" aria-hidden="true" tabindex="-1"></a>cumbin <span class="ot">&lt;-</span> <span class="fu">pbinom</span>(m,n,p)  <span class="co"># get cumulative distribution  </span></span>
<span id="cb101-930"><a href="#cb101-930" aria-hidden="true" tabindex="-1"></a><span class="fu">plot1</span>(m,binom,<span class="at">type=</span><span class="st">"h"</span>,<span class="at">xlab=</span><span class="st">"Number of Males"</span>,<span class="at">ylab=</span><span class="st">"Probability"</span>)   </span>
<span id="cb101-931"><a href="#cb101-931" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span><span class="fu">which.closest</span>(<span class="fl">0.025</span>,cumbin),<span class="at">col=</span><span class="dv">2</span>,<span class="at">lwd=</span><span class="dv">2</span>) <span class="co"># lower 95% CI  </span></span>
<span id="cb101-932"><a href="#cb101-932" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-933"><a href="#cb101-933" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-934"><a href="#cb101-934" aria-hidden="true" tabindex="-1"></a>我们可以通过检查 *binom*（单个似然）和 *cumbin*（累积二项式似然）的内容来研究具体值。但很明显，如果性别比为 $1:1$，那么获得少于 $18$ 或多于 $42$ 的可能性都非常小。事实上，只有 $20$ 个雄性的可能性不到 95%。通过研究 *binom\[20\]*，我们可以看到，得到整整 $20$ 个雄性（假设性别比为 1:1）的似然刚刚超过 $1%$ 的三分之一（$0.003636$），而 *cumbin\[20\]* 告诉我们，得到 $20$ 个或更少的概率只有 $0.006745$）。我们当然有理由说，从这一群中抽取样本的性别比率出现了下降。我们还在累积概率约为 $0.025$ 的地方划了一条垂直线。由于我们对上限并不感兴趣，我们可以使用 $0.05$，这样会更保守一些。但是，这种上限具有任意性，真正重要的是，捕鱼对性别比率没有重要影响的证据权重是多少？</span>
<span id="cb101-935"><a href="#cb101-935" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-936"><a href="#cb101-936" aria-hidden="true" tabindex="-1"></a>请注意，当样本相对较大时，二项分布会变得对称。不过，尾部比正态分布窄。对于较小的样本，尤其是低 $p$ 值，二项分布可能会高度倾斜，零成功率值具有特定的概率。</span>
<span id="cb101-937"><a href="#cb101-937" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-938"><a href="#cb101-938" aria-hidden="true" tabindex="-1"></a>与其确定一个给定的性别比例是否合理，我们可以寻找使 $60$ 个样本中有 $20$ 个雄性的似然最大化的性别比例（ $p$ 值）。我们期望它是 $20/60(0.333…)$，但仍然有兴趣知道合理值的范围。</span>
<span id="cb101-939"><a href="#cb101-939" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-942"><a href="#cb101-942" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-943"><a href="#cb101-943" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-4-16</span></span>
<span id="cb101-944"><a href="#cb101-944" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Representing the relative likelihood of the proportional sex-ratio when a sample exhibits only 20 males out of 60. Note that the likelihood of there having been a sex-ratio of 0.5 is confirmed as very low."</span></span>
<span id="cb101-945"><a href="#cb101-945" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-946"><a href="#cb101-946" aria-hidden="true" tabindex="-1"></a> <span class="co"># plot relative likelihood of different p values Fig 4.16  </span></span>
<span id="cb101-947"><a href="#cb101-947" aria-hidden="true" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="dv">60</span>  <span class="co"># sample size; should really plot points as each independent   </span></span>
<span id="cb101-948"><a href="#cb101-948" aria-hidden="true" tabindex="-1"></a>m <span class="ot">&lt;-</span> <span class="dv">20</span>  <span class="co"># number of successes = finding a male  </span></span>
<span id="cb101-949"><a href="#cb101-949" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="fl">0.1</span>,<span class="fl">0.6</span>,<span class="fl">0.001</span>) <span class="co">#range of probability we find a male   </span></span>
<span id="cb101-950"><a href="#cb101-950" aria-hidden="true" tabindex="-1"></a>lik <span class="ot">&lt;-</span> <span class="fu">dbinom</span>(m,n,p)    <span class="co"># R function for binomial likelihoods  </span></span>
<span id="cb101-951"><a href="#cb101-951" aria-hidden="true" tabindex="-1"></a><span class="fu">plot1</span>(p,lik,<span class="at">type=</span><span class="st">"l"</span>,<span class="at">xlab=</span><span class="st">"Prob. of 20 Males"</span>,<span class="at">ylab=</span><span class="st">"Prob."</span>)  </span>
<span id="cb101-952"><a href="#cb101-952" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>p[<span class="fu">which.max</span>(lik)],<span class="at">col=</span><span class="dv">2</span>,<span class="at">lwd=</span><span class="dv">2</span>) <span class="co"># try "p" instead of "l"  </span></span>
<span id="cb101-953"><a href="#cb101-953" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-954"><a href="#cb101-954" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-955"><a href="#cb101-955" aria-hidden="true" tabindex="-1"></a>当我们只搜索一个参数时，使用 <span class="in">`optimize()`</span>（或 <span class="in">`optimise()`</span>，查看 <span class="in">`?optimize`</span>）比使用 <span class="in">`nlm()`</span> 更有效。它需要一个函数，该函数的第一个项是要在定义的区间内最小化或最大化的值，在本例中为 $p$，定义的区间内最小化或最大化的值，因此 <span class="in">`dbinom()`</span> 使用了简单的封装函数。</span>
<span id="cb101-956"><a href="#cb101-956" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-959"><a href="#cb101-959" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-960"><a href="#cb101-960" aria-hidden="true" tabindex="-1"></a> <span class="co"># find best estimate using optimize to finely search an interval  </span></span>
<span id="cb101-961"><a href="#cb101-961" aria-hidden="true" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="dv">60</span>; m <span class="ot">&lt;-</span> <span class="dv">20</span>  <span class="co"># trials and successes  </span></span>
<span id="cb101-962"><a href="#cb101-962" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.1</span>,<span class="fl">0.6</span>) <span class="co">#range of probability we find a male   </span></span>
<span id="cb101-963"><a href="#cb101-963" aria-hidden="true" tabindex="-1"></a><span class="fu">optimize</span>(<span class="cf">function</span>(p) {<span class="fu">dbinom</span>(m,n,p)},<span class="at">interval=</span>p,<span class="at">maximum=</span><span class="cn">TRUE</span>)  </span>
<span id="cb101-964"><a href="#cb101-964" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-965"><a href="#cb101-965" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-966"><a href="#cb101-966" aria-hidden="true" tabindex="-1"></a><span class="fu">### 开放海湾幼年海狗种群数量</span></span>
<span id="cb101-967"><a href="#cb101-967" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-968"><a href="#cb101-968" aria-hidden="true" tabindex="-1"></a>与其使用第二个假设的例子，不如使用一个真实案例的数据更有意思。对新西兰南岛西海岸开阔湾群岛上的新西兰海狗（*Arctocephalus forsteri*）幼崽种群进行了适当的研究（Greaves，1992 ；York 和 Kozlof，1987 ）。新西兰海狗在 19 世纪被大量捕杀后一直在恢复，目前在南岛和北岛都发现了新的出没地点。1894 年，新西兰正式停止了对毛皮海豹的捕猎，1978 年开始在新西兰专属经济区内对其进行全面保护（Greaves，1992 ）。格里夫斯女士与新西兰保护部合作，前往其中一个近海岛屿，并在岛上度过了一周的时间。她剪掉了 151 只海狗幼崽头上的一小块护毛，给它们做了标记，然后对海狗群进行了多次巡视，以重新观察被标记的海狗（Greaves，1992 ）。每次巡视都是进一步的抽样调查，每次抽样调查都发现了不同数量的被标记动物。问题是：海狗幼崽种群的数量（$X$）是多少？</span>
<span id="cb101-969"><a href="#cb101-969" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-972"><a href="#cb101-972" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-973"><a href="#cb101-973" aria-hidden="true" tabindex="-1"></a> <span class="co"># Juvenile furseal data-set Greaves, 1992.  Table 4.3  </span></span>
<span id="cb101-974"><a href="#cb101-974" aria-hidden="true" tabindex="-1"></a>furseal <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">32</span>,<span class="dv">222</span>,<span class="dv">1020</span>,<span class="dv">704</span>,<span class="dv">1337</span>,<span class="fl">161.53</span>,<span class="dv">31</span>,<span class="dv">181</span>,<span class="dv">859</span>,<span class="dv">593</span>,<span class="dv">1125</span>,  </span>
<span id="cb101-975"><a href="#cb101-975" aria-hidden="true" tabindex="-1"></a>             <span class="fl">135.72</span>,<span class="dv">29</span>,<span class="dv">185</span>,<span class="dv">936</span>,<span class="dv">634</span>,<span class="dv">1238</span>,<span class="fl">153.99</span>)  </span>
<span id="cb101-976"><a href="#cb101-976" aria-hidden="true" tabindex="-1"></a>columns <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"tagged(m)"</span>,<span class="st">"Sample(n)"</span>,<span class="st">"Population(X)"</span>,  </span>
<span id="cb101-977"><a href="#cb101-977" aria-hidden="true" tabindex="-1"></a>             <span class="st">"95%Lower"</span>,<span class="st">"95%Upper"</span>,<span class="st">"StErr"</span>)  </span>
<span id="cb101-978"><a href="#cb101-978" aria-hidden="true" tabindex="-1"></a>furs <span class="ot">&lt;-</span> <span class="fu">matrix</span>(furseal,<span class="at">nrow=</span><span class="dv">3</span>,<span class="at">ncol=</span><span class="dv">6</span>,<span class="at">dimnames=</span><span class="fu">list</span>(<span class="cn">NULL</span>,columns),  </span>
<span id="cb101-979"><a href="#cb101-979" aria-hidden="true" tabindex="-1"></a>               <span class="at">byrow=</span><span class="cn">TRUE</span>)  </span>
<span id="cb101-980"><a href="#cb101-980" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-981"><a href="#cb101-981" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-984"><a href="#cb101-984" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-985"><a href="#cb101-985" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-4-3</span></span>
<span id="cb101-986"><a href="#cb101-986" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: "格雷夫斯（1992）在新西兰南岛西海岸开阔湾岛对新西兰海狗幼崽进行的三次计数。种群估计值、标准误差和置信区间均采用确定性方程计算得出。前两行为独立计数，后一行为六次独立计数的平均值。Three of the counts of New Zealand fur seal pups made by Greaves (1992) on Open Bay Island, West Coast, South Island, New Zealand. The Population estimates, Standard error and confidence intervals were calculated using deterministic equations. The top two rows were independent counts while the bottom row averages six separate counts."</span></span>
<span id="cb101-987"><a href="#cb101-987" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb101-988"><a href="#cb101-988" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-989"><a href="#cb101-989" aria-hidden="true" tabindex="-1"></a>knitr<span class="sc">::</span><span class="fu">kable</span>(furs)</span>
<span id="cb101-990"><a href="#cb101-990" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-991"><a href="#cb101-991" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-992"><a href="#cb101-992" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-993"><a href="#cb101-993" aria-hidden="true" tabindex="-1"></a>所有标记实验的常规假设均适用；即我们处理的是一个封闭种群--没有迁入或迁出，在实验期间没有自然死亡或标记死亡，没有标记丢失，标记不会影响动物的重捕概率。最后，在不同的日子里，幼崽可以四处走动，因此看到的动物都是相互独立的。格里夫斯（1992）估计了所有这些影响，并在她的分析中考虑了这些影响。在对标记进行标记和重新观察后，利用彼得森估算器找到了确定性答案（Caughley, 1977; Seber, 1982）：</span>
<span id="cb101-994"><a href="#cb101-994" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-995"><a href="#cb101-995" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-996"><a href="#cb101-996" aria-hidden="true" tabindex="-1"></a>\frac{{{n}_{1}}}{X}=\frac{m}{n} \;\;\;\;\;\; \therefore \;\;\;\;\;\; \hat{X}=\frac{{{n}_{1}}n}{m}  </span>
<span id="cb101-997"><a href="#cb101-997" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_32}</span>
<span id="cb101-998"><a href="#cb101-998" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-999"><a href="#cb101-999" aria-hidden="true" tabindex="-1"></a>其中 $n_1$ 是种群中标记数量， $n$ 是后续样本量，$m$ 是回捕的标记数，$\hat X$ 是估算的资源量。另一种估计方法是对第二个样本的计数进行调整，以考虑到在这种情况下我们处理的是离散事件这一事实。这就是贝利调整（Bailey's adjustment）（Caughley，1977）：</span>
<span id="cb101-1000"><a href="#cb101-1000" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1001"><a href="#cb101-1001" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-1002"><a href="#cb101-1002" aria-hidden="true" tabindex="-1"></a>\hat{X}=\frac{{{n}_{1}}\left( n+1 \right)}{m+1}  </span>
<span id="cb101-1003"><a href="#cb101-1003" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_33}</span>
<span id="cb101-1004"><a href="#cb101-1004" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1005"><a href="#cb101-1005" aria-hidden="true" tabindex="-1"></a>相关的标准误差估计值用于使用正态近似法计算近似的 95% 置信区间，从而在使用确定性方程时得出对称的置信区间。</span>
<span id="cb101-1006"><a href="#cb101-1006" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1007"><a href="#cb101-1007" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-1008"><a href="#cb101-1008" aria-hidden="true" tabindex="-1"></a>StErr=\sqrt{\frac{n_{1}^{2}\left( n+1 \right)\left( n-m \right)}{{{\left( m+1 \right)}^{2}}\left( m+2 \right)}}  </span>
<span id="cb101-1009"><a href="#cb101-1009" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_34}</span>
<span id="cb101-1010"><a href="#cb101-1010" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1011"><a href="#cb101-1011" aria-hidden="true" tabindex="-1"></a>这些方程可以用来证实 <span class="co">[</span><span class="ot">@tbl-4-3</span><span class="co">]</span> 中的估计。然而，与其使用确定性方程，一个好的替代方法是使用二项概率密度函数应用最大似然来估计总体大小 $\hat  X$。</span>
<span id="cb101-1012"><a href="#cb101-1012" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1013"><a href="#cb101-1013" aria-hidden="true" tabindex="-1"></a>我们只估计一个参数，$\hat X$，即总体大小，这需要搜索使数据的似然最大化的总体大小。对于二项分布，$P <span class="sc">\{</span>m | n, p<span class="sc">\}</span>$，@eq-4_30 给出了在标记比例为 $p$ 的总体中，从 $n$ 个样本中观察到 $m$ 个标记个体的概率(Snedecor和Cochran, 1967, 1989;Forbes et al, 2011)。标记的幼崽比例与总体大小 $\hat X$ 和最初标记的幼崽数量( 151 只)有关。因此 $p = 151 / \hat X$。我们将重新分析 @tbl-4-3 中的前两个样本。</span>
<span id="cb101-1014"><a href="#cb101-1014" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1017"><a href="#cb101-1017" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-1018"><a href="#cb101-1018" aria-hidden="true" tabindex="-1"></a> <span class="co"># analyse two pup counts 32 from 222, and 31 from 181, rows 1-2 in  </span></span>
<span id="cb101-1019"><a href="#cb101-1019" aria-hidden="true" tabindex="-1"></a> <span class="co"># Table 4.3.   Now set-up storage for solutions  </span></span>
<span id="cb101-1020"><a href="#cb101-1020" aria-hidden="true" tabindex="-1"></a>optsol <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="dv">0</span>,<span class="at">nrow=</span><span class="dv">2</span>,<span class="at">ncol=</span><span class="dv">2</span>,  </span>
<span id="cb101-1021"><a href="#cb101-1021" aria-hidden="true" tabindex="-1"></a>                 <span class="at">dimnames=</span><span class="fu">list</span>(furs[<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>,<span class="dv">2</span>],<span class="fu">c</span>(<span class="st">"p"</span>,<span class="st">"Likelihood"</span>)))  </span>
<span id="cb101-1022"><a href="#cb101-1022" aria-hidden="true" tabindex="-1"></a>X <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="dv">525</span>,<span class="dv">1850</span>,<span class="dv">1</span>) <span class="co"># range of potential population sizes  </span></span>
<span id="cb101-1023"><a href="#cb101-1023" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> <span class="dv">151</span><span class="sc">/</span>X  <span class="co">#range of proportion tagged; 151 originally tagged  </span></span>
<span id="cb101-1024"><a href="#cb101-1024" aria-hidden="true" tabindex="-1"></a>m <span class="ot">&lt;-</span> furs[<span class="dv">1</span>,<span class="dv">1</span>] <span class="sc">+</span> <span class="dv">1</span> <span class="co">#tags observed, with Bailey's adjustment  </span></span>
<span id="cb101-1025"><a href="#cb101-1025" aria-hidden="true" tabindex="-1"></a>n <span class="ot">&lt;-</span> furs[<span class="dv">1</span>,<span class="dv">2</span>] <span class="sc">+</span> <span class="dv">1</span> <span class="co"># sample size with Bailey's adjustment  </span></span>
<span id="cb101-1026"><a href="#cb101-1026" aria-hidden="true" tabindex="-1"></a>lik1 <span class="ot">&lt;-</span> <span class="fu">dbinom</span>(m,n,p) <span class="co"># individaul likelihoods  </span></span>
<span id="cb101-1027"><a href="#cb101-1027" aria-hidden="true" tabindex="-1"></a> <span class="co">#find best estimate with optimize to finely search an interval  </span></span>
<span id="cb101-1028"><a href="#cb101-1028" aria-hidden="true" tabindex="-1"></a> <span class="co">#use unlist to convert the output list into a vector  </span></span>
<span id="cb101-1029"><a href="#cb101-1029" aria-hidden="true" tabindex="-1"></a> <span class="co">#Note use of Bailey's adjustment (m+1), (n+1) Caughley, (1977)  </span></span>
<span id="cb101-1030"><a href="#cb101-1030" aria-hidden="true" tabindex="-1"></a>optsol[<span class="dv">1</span>,] <span class="ot">&lt;-</span> <span class="fu">unlist</span>(<span class="fu">optimize</span>(<span class="cf">function</span>(p) {<span class="fu">dbinom</span>(m,n,p)},p,  </span>
<span id="cb101-1031"><a href="#cb101-1031" aria-hidden="true" tabindex="-1"></a>                              <span class="at">maximum=</span><span class="cn">TRUE</span>))  </span>
<span id="cb101-1032"><a href="#cb101-1032" aria-hidden="true" tabindex="-1"></a>m <span class="ot">&lt;-</span> furs[<span class="dv">2</span>,<span class="dv">1</span>]<span class="sc">+</span><span class="dv">1</span>;  n <span class="ot">&lt;-</span> furs[<span class="dv">2</span>,<span class="dv">2</span>]<span class="sc">+</span><span class="dv">1</span> <span class="co">#repeat for sample2  </span></span>
<span id="cb101-1033"><a href="#cb101-1033" aria-hidden="true" tabindex="-1"></a>lik2 <span class="ot">&lt;-</span> <span class="fu">dbinom</span>(m,n,p)    </span>
<span id="cb101-1034"><a href="#cb101-1034" aria-hidden="true" tabindex="-1"></a>totlik <span class="ot">&lt;-</span> lik1 <span class="sc">*</span> lik2 <span class="co">#Joint likelihood of 2 vectors  </span></span>
<span id="cb101-1035"><a href="#cb101-1035" aria-hidden="true" tabindex="-1"></a>optsol[<span class="dv">2</span>,] <span class="ot">&lt;-</span> <span class="fu">unlist</span>(<span class="fu">optimize</span>(<span class="cf">function</span>(p) {<span class="fu">dbinom</span>(m,n,p)},p,  </span>
<span id="cb101-1036"><a href="#cb101-1036" aria-hidden="true" tabindex="-1"></a>                              <span class="at">maximum=</span><span class="cn">TRUE</span>))  </span>
<span id="cb101-1037"><a href="#cb101-1037" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-1038"><a href="#cb101-1038" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1039"><a href="#cb101-1039" aria-hidden="true" tabindex="-1"></a>我们当然可以将结果制成表格，但更清楚的是将它们绘制为每个假设总体大小的似然(在这里是概率)。然后我们可以使用变量 *optsol* 中的 $p$ 列来计算每种情况下的最佳总体大小。该图的优点是，人们可以立即看到每个样本的似然曲线的重叠，并获得任何百分位数置信区间都不是对称的印象。</span>
<span id="cb101-1040"><a href="#cb101-1040" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1043"><a href="#cb101-1043" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-1044"><a href="#cb101-1044" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-4-17</span></span>
<span id="cb101-1045"><a href="#cb101-1045" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "通过标记实验，对151只海狗进行了标记，得出了海狗种群大小的两种估计，种群大小与似然分布(Greaves, 1992)。右边的黑线来自222只观察到的幼崽的32个标记，而左边的虚线来自181只观察到的31个标记。模型(最佳种群估计值)由竖线和图例表示。"</span></span>
<span id="cb101-1046"><a href="#cb101-1046" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1047"><a href="#cb101-1047" aria-hidden="true" tabindex="-1"></a> <span class="co"># Compare outcome for 2 independent seal estimates Fig 4.17  </span></span>
<span id="cb101-1048"><a href="#cb101-1048" aria-hidden="true" tabindex="-1"></a> <span class="co"># Should plot points not a line as each are independent   </span></span>
<span id="cb101-1049"><a href="#cb101-1049" aria-hidden="true" tabindex="-1"></a><span class="fu">plot1</span>(X,lik1,<span class="at">type=</span><span class="st">"l"</span>,<span class="at">xlab=</span><span class="st">"Total Pup Numbers"</span>,  </span>
<span id="cb101-1050"><a href="#cb101-1050" aria-hidden="true" tabindex="-1"></a>      <span class="at">ylab=</span><span class="st">"Probability"</span>,<span class="at">maxy=</span><span class="fl">0.085</span>,<span class="at">lwd=</span><span class="dv">2</span>)  </span>
<span id="cb101-1051"><a href="#cb101-1051" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>X[<span class="fu">which.max</span>(lik1)],<span class="at">col=</span><span class="dv">1</span>,<span class="at">lwd=</span><span class="dv">1</span>)  </span>
<span id="cb101-1052"><a href="#cb101-1052" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(X,lik2,<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">2</span>,<span class="at">lty=</span><span class="dv">3</span>)  <span class="co"># add line to plot  </span></span>
<span id="cb101-1053"><a href="#cb101-1053" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>X[<span class="fu">which.max</span>(lik2)],<span class="at">col=</span><span class="dv">2</span>,<span class="at">lwd=</span><span class="dv">1</span>) <span class="co"># add optimum  </span></span>
<span id="cb101-1054"><a href="#cb101-1054" aria-hidden="true" tabindex="-1"></a> <span class="co">#given p = 151/X, then X = 151/p and p = optimum proportion   </span></span>
<span id="cb101-1055"><a href="#cb101-1055" aria-hidden="true" tabindex="-1"></a><span class="fu">legend</span>(<span class="st">"topright"</span>,<span class="at">legend=</span><span class="fu">round</span>((<span class="dv">151</span><span class="sc">/</span>optsol[,<span class="st">"p"</span>])),<span class="at">col=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>),<span class="at">lwd=</span><span class="dv">3</span>,  </span>
<span id="cb101-1056"><a href="#cb101-1056" aria-hidden="true" tabindex="-1"></a>       <span class="at">bty=</span><span class="st">"n"</span>,<span class="at">cex=</span><span class="fl">1.1</span>,<span class="at">lty=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">3</span>))  </span>
<span id="cb101-1057"><a href="#cb101-1057" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-1058"><a href="#cb101-1058" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1059"><a href="#cb101-1059" aria-hidden="true" tabindex="-1"></a><span class="fu">### 使用多个独立样本</span></span>
<span id="cb101-1060"><a href="#cb101-1060" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1061"><a href="#cb101-1061" aria-hidden="true" tabindex="-1"></a>如果有多个调查、观测或样本，或不同类型的数据，而这些数据又是相互独立的，那么就有可能将这些估计值合并起来，以改进总体估计值。就像概率一样，一组独立观测数据的似然是特定观测数据似然的乘积。因此，我们可以将刚才研究的两个样本的每个种群大小的似然值相乘，得到一个联合似然值，在前面的例子中，这个似然值被放入变量 *totlik* 中，@fig-4-18。</span>
<span id="cb101-1062"><a href="#cb101-1062" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1065"><a href="#cb101-1065" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-1066"><a href="#cb101-1066" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-4-18</span></span>
<span id="cb101-1067"><a href="#cb101-1067" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "前两个海狗幼崽样本的综合似然（黑线）。与单个样本相比，这些样本的百分位数置信区间（垂直细红线）更小。六个样本的平均计数和样本量（绿色虚线）在平均位置上与单个样本相似，但百分比置信区间更宽。图例显示了组合似然曲线的最佳值和 95% 百分位数 CI。The combined likelihood from the first two fur seal pup samples (black line). These have tighter percentile confidence intervals (vertical thin red lines) than the individual samples. The average count and sample size of six samples (green dashed line) remains similar in mean location to the single samples but would have much wider CI. The legend shows the optimum and the 95% percentile CI foir the combined likelihoods curve."</span></span>
<span id="cb101-1068"><a href="#cb101-1068" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1069"><a href="#cb101-1069" aria-hidden="true" tabindex="-1"></a> <span class="co">#Combined likelihood from 2 independent samples Fig 4.18  </span></span>
<span id="cb101-1070"><a href="#cb101-1070" aria-hidden="true" tabindex="-1"></a>totlik <span class="ot">&lt;-</span> totlik<span class="sc">/</span><span class="fu">sum</span>(totlik) <span class="co"># rescale so the total sums to one  </span></span>
<span id="cb101-1071"><a href="#cb101-1071" aria-hidden="true" tabindex="-1"></a>cumlik <span class="ot">&lt;-</span> <span class="fu">cumsum</span>(totlik) <span class="co">#approx cumulative likelihood for CI      </span></span>
<span id="cb101-1072"><a href="#cb101-1072" aria-hidden="true" tabindex="-1"></a><span class="fu">plot1</span>(X,totlik,<span class="at">type=</span><span class="st">"l"</span>,<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">xlab=</span><span class="st">"Total Pup Numbers"</span>,  </span>
<span id="cb101-1073"><a href="#cb101-1073" aria-hidden="true" tabindex="-1"></a>      <span class="at">ylab=</span><span class="st">"Posterior Joint Probability"</span>)  </span>
<span id="cb101-1074"><a href="#cb101-1074" aria-hidden="true" tabindex="-1"></a>percs <span class="ot">&lt;-</span> <span class="fu">c</span>(X[<span class="fu">which.closest</span>(<span class="fl">0.025</span>,cumlik)],X[<span class="fu">which.max</span>(totlik)],  </span>
<span id="cb101-1075"><a href="#cb101-1075" aria-hidden="true" tabindex="-1"></a>           X[<span class="fu">which.closest</span>(<span class="fl">0.975</span>,cumlik)])  </span>
<span id="cb101-1076"><a href="#cb101-1076" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>percs,<span class="at">lwd=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>),<span class="at">col=</span><span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">2</span>))  </span>
<span id="cb101-1077"><a href="#cb101-1077" aria-hidden="true" tabindex="-1"></a><span class="fu">legend</span>(<span class="st">"topright"</span>,<span class="at">legend=</span>percs,<span class="at">lwd=</span><span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">2</span>),<span class="at">bty=</span><span class="st">"n"</span>,<span class="at">col=</span><span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">2</span>),  </span>
<span id="cb101-1078"><a href="#cb101-1078" aria-hidden="true" tabindex="-1"></a>       <span class="at">cex=</span><span class="fl">1.2</span>)  <span class="co"># now compare with averaged count  </span></span>
<span id="cb101-1079"><a href="#cb101-1079" aria-hidden="true" tabindex="-1"></a>m <span class="ot">&lt;-</span> furs[<span class="dv">3</span>,<span class="dv">1</span>];  n <span class="ot">&lt;-</span> furs[<span class="dv">3</span>,<span class="dv">2</span>] <span class="co"># likelihoods for the   </span></span>
<span id="cb101-1080"><a href="#cb101-1080" aria-hidden="true" tabindex="-1"></a>lik3 <span class="ot">&lt;-</span> <span class="fu">dbinom</span>(m,n,p)            <span class="co"># average of six samples  </span></span>
<span id="cb101-1081"><a href="#cb101-1081" aria-hidden="true" tabindex="-1"></a>lik4 <span class="ot">&lt;-</span> lik3<span class="sc">/</span><span class="fu">sum</span>(lik3)  <span class="co"># rescale for comparison with totlik  </span></span>
<span id="cb101-1082"><a href="#cb101-1082" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(X,lik4,<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">3</span>,<span class="at">lty=</span><span class="dv">2</span>) <span class="co">#add 6 sample average to plot  </span></span>
<span id="cb101-1083"><a href="#cb101-1083" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-1084"><a href="#cb101-1084" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1085"><a href="#cb101-1085" aria-hidden="true" tabindex="-1"></a>请注意，虽然中心倾向仍然非常相似，但从组合似然值（红色细线）得出的 95% 置信区间比从六个组合样本得出的平均值要小，而且在平均值周围不对称。与所有分析一样，只要使用的程序是站得住脚的，那么分析就可以继续进行（例如，在这种情况下，可以说样本是独立的，这意味着它们在时间上相隔足够远，因此无法得知被标记幼崽的位置，幼崽也可以移动等）。这与贝叶斯方法利用新数据的似然更新先验概率有相似之处。具体的贝叶斯方法将在后面详细介绍。对六个样本取平均值以获得平均计数和样本大小的方法提供了非常相似的种群估计值，但其不确定性范围更大。取这些样本的平均值并不是最佳的分析策略。</span>
<span id="cb101-1086"><a href="#cb101-1086" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1087"><a href="#cb101-1087" aria-hidden="true" tabindex="-1"></a><span class="fu">### 分析方法</span></span>
<span id="cb101-1088"><a href="#cb101-1088" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1089"><a href="#cb101-1089" aria-hidden="true" tabindex="-1"></a>有些生物过程，如动物是否成熟、是否被渔具选择捕捞等，非常适合用二项分布作为观测的基础进行分析。然而，这类过程是以累积的方式运行的，例如，随着时间的推移，种群中成熟的群体百分比最终应达到 100%。这种过程通常可以用众所周知的 logistic 曲线来很好地描述。我们可以使用数值方法来估计 logistic 模型参数，也可以使用二项分布的广义线性模型。我们将在本章之后的静态模型一章中介绍这些方法。</span>
<span id="cb101-1090"><a href="#cb101-1090" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1091"><a href="#cb101-1091" aria-hidden="true" tabindex="-1"></a><span class="fu">## 其它分布</span></span>
<span id="cb101-1092"><a href="#cb101-1092" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1093"><a href="#cb101-1093" aria-hidden="true" tabindex="-1"></a>在基础 stats R 软件包中（使用 <span class="in">`sessionInfo()`</span> 确定加载的 7 个基础软件包），有许多分布的概率密度函数。事实上，只要在控制台中输入 <span class="in">`?Distributions`</span>（不带括号），就能立即获得 R 中可用的分布列表。此外，CRAN 系统中还有一个关于分布的任务视图，网址是：https://CRAN.R-project.org/view=Distributions。该任务视图提供了详细的讨论，同时也指向了大量独立软件包，这些软件包提供了更广泛的统计分布。</span>
<span id="cb101-1094"><a href="#cb101-1094" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1095"><a href="#cb101-1095" aria-hidden="true" tabindex="-1"></a>在渔业科学中，有几种其他分布可以直接使用。它们都有用于计算似然的概率密度函数（以 *d* 开头，如 <span class="in">`dmultinom()`</span>），而且通常都有随机数生成器（以 r 开头，如 <span class="in">`rgamma()`</span>）。如果你查看一些函数的帮助，就会明白其中的含义和概要。下面我们将详细介绍几种对渔业和生态工作更有用的随机数生成器（另见 Forbes 等，2011 ）。</span>
<span id="cb101-1096"><a href="#cb101-1096" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1097"><a href="#cb101-1097" aria-hidden="true" tabindex="-1"></a><span class="fu">## 多项式分布的似然</span></span>
<span id="cb101-1098"><a href="#cb101-1098" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1099"><a href="#cb101-1099" aria-hidden="true" tabindex="-1"></a>如上文所述，当观测结果有两种可能结果（真/假、标记/未标记、成熟/未成熟）时，我们会使用二项分布。不过，在很多情况下，观测结果可能会有两种以上的离散结果，在这种情况下，我们可以使用多项分布。在处理长度或年龄样本内的频率分布时，就会出现这种情况；例如，随机给定一尾鱼，它的年龄可能只是众多年龄类别中的一个。在这种多变量意义上，多项式分布是二项分布的扩展。多项式分布是另一种离散分布，它提供的是不同的概率，而不仅仅是似然。</span>
<span id="cb101-1100"><a href="#cb101-1100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1101"><a href="#cb101-1101" aria-hidden="true" tabindex="-1"></a>对于二项分布，我们使用 $P (m|n, P)$ 来表示似然。对于多项式，这需要扩展，这样就不是只有两个结果(一个概率 $p$ )，而是在 $n$ 个观测值的样本中，我们有 $k$ 个可能结果中的每一个的概率( $k_p$ )。多项式分布的概率密度函数为(Forbes et al .， 2011):</span>
<span id="cb101-1102"><a href="#cb101-1102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1103"><a href="#cb101-1103" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-1104"><a href="#cb101-1104" aria-hidden="true" tabindex="-1"></a>P\left<span class="sc">\{</span> {{x}_{i}}|n,{{p}_{1}},{{p}_{2}},...,{{p}_{k}} \right\}=n!\prod\limits_{i=1}^{k}{\frac{\hat{p}_{i}^{{{x}_{i}}}}{x!}}  </span>
<span id="cb101-1105"><a href="#cb101-1105" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_35}</span>
<span id="cb101-1106"><a href="#cb101-1106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1107"><a href="#cb101-1107" aria-hidden="true" tabindex="-1"></a>其中 $x_i$ 是 $n$ 个样本中 $i$ 类事件发生的次数(在统计文献中通常称为试验)，$p_i$ 是 $k$ 类可能事件中每种事件的单独概率。每种事件类型的期望为 $E(x_i) = np_i$，其中 $n$ 为样本量，$p_i$ 为事件类型 $i$ 的概率。由于 PDF 中存在阶乘项，这可能导致数值溢出问题，因此进行对数转换:</span>
<span id="cb101-1108"><a href="#cb101-1108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1109"><a href="#cb101-1109" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-1110"><a href="#cb101-1110" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb101-1111"><a href="#cb101-1111" aria-hidden="true" tabindex="-1"></a>P<span class="sc">\{</span>x_i|n,p_1, \cdots, p_k<span class="sc">\}</span> &amp;=n! \prod_{i=1}^{k} \dfrac{\hat p_i^{x_i}}{x_i !} <span class="sc">\\</span></span>
<span id="cb101-1112"><a href="#cb101-1112" aria-hidden="true" tabindex="-1"></a>LL\left<span class="sc">\{</span> {{x}_{i}}|n,{{p}_{1}},...,{{p}_{k}} \right\}&amp;=\sum\limits_{j=1}^{n}{\log\left( j \right)}+\sum\limits_{i=1}^{k}{\left[ {{x}_{i}}\log\left( {{{\hat{p}}}_{i}} \right)-\sum\limits_{j=1}^{x}{\log\left( j \right)} \right]}  </span>
<span id="cb101-1113"><a href="#cb101-1113" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb101-1114"><a href="#cb101-1114" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_36}</span>
<span id="cb101-1115"><a href="#cb101-1115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1116"><a href="#cb101-1116" aria-hidden="true" tabindex="-1"></a>实际上，对数变换后的阶乘项 $n!$ 还有 $x!$，涉及 $\log(j)$ 的和，其中 $j$从 $1$ 到 $n$, $1$ 到 $x$ 的步长总是常数，通常在计算中被省略，此外负对数似然在最小化中使用:</span>
<span id="cb101-1117"><a href="#cb101-1117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1118"><a href="#cb101-1118" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-1119"><a href="#cb101-1119" aria-hidden="true" tabindex="-1"></a>-LL\left<span class="sc">\{</span>{x_i}|n,{p_1},{p_2},...,{p_k} \right<span class="sc">\}</span> \;\;= \;\; -\sum\limits_{i=1}^{k}{\left<span class="co">[</span><span class="ot"> {x_i}\log\left( {{\hat{p}}_{i}} \right)\right</span><span class="co">]</span>}  </span>
<span id="cb101-1120"><a href="#cb101-1120" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_37}</span>
<span id="cb101-1121"><a href="#cb101-1121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1122"><a href="#cb101-1122" aria-hidden="true" tabindex="-1"></a>我们有理由费心研究概率密度函数的简化方法，因为 R 中已经开发出了非常适用于计算概率密度函数的函数。了解我们所使用的任何函数的作用始终是个好主意，这也是了解我们希望在分析中使用的任何统计函数的属性的明智之举。在某些情况下，例如 R 的 <span class="in">`dmultinom()`</span> 用于多项式分布，它的帮助页面告诉我们，它目前还没有矢量化，因此在渔业中的使用有点笨拙。相反，我们将在 **MQMF** 函数 <span class="in">`mnnegLL()`</span> 中对 @eq-4_37 进行 R 运行。此外，在只处理几百个观测值时，计算速度的差异并不重要，但如果要重复计算一组数据的总对数似然几百万次（在渔业模型中使用马尔可夫链-蒙特-卡洛或 MCMC（有时为 McMC）时很有可能出现这种情况），那么任何节省时间的方法都是有价值的。我们将在讨论贝叶斯方法和其他方法来描述模型和数据中固有的不确定性时讨论这些问题。</span>
<span id="cb101-1123"><a href="#cb101-1123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1124"><a href="#cb101-1124" aria-hidden="true" tabindex="-1"></a><span class="fu">### 使用多项式分布</span></span>
<span id="cb101-1125"><a href="#cb101-1125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1126"><a href="#cb101-1126" aria-hidden="true" tabindex="-1"></a>在对年龄或大小组成数据进行模型拟合时，通常使用多项式分布来表示观测结果在可能类别中的预期分布。我们将以塔斯马尼亚德文特河口希望岛的黑唇鲍（*Haliotis rubra*）幼体的生长模态分析研究为例（Helidoniotis 和 Haddon，2012）。在 1992 年 11 月采集的样本中，以 2 毫米组距绘图时两个模式非常明显。</span>
<span id="cb101-1127"><a href="#cb101-1127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1130"><a href="#cb101-1130" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-1131"><a href="#cb101-1131" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-4-19</span></span>
<span id="cb101-1132"><a href="#cb101-1132" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "The length-frequency counts of a sample of juvenile abalone from the south-east of Tasmania illustrating two modes taken in 1992."</span></span>
<span id="cb101-1133"><a href="#cb101-1133" aria-hidden="true" tabindex="-1"></a> <span class="co">#plot counts x shell-length of 2 cohorts   Figure 4.19  </span></span>
<span id="cb101-1134"><a href="#cb101-1134" aria-hidden="true" tabindex="-1"></a>cw <span class="ot">&lt;-</span> <span class="dv">2</span>  <span class="co"># 2 mm size classes, of which mids are the centers  </span></span>
<span id="cb101-1135"><a href="#cb101-1135" aria-hidden="true" tabindex="-1"></a>mids <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="dv">8</span>,<span class="dv">54</span>,cw) <span class="co">#each size class = 2 mm as in 7-9, 9-11, ...  </span></span>
<span id="cb101-1136"><a href="#cb101-1136" aria-hidden="true" tabindex="-1"></a>obs <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">6</span>,<span class="dv">12</span>,<span class="dv">35</span>,<span class="dv">40</span>,<span class="dv">29</span>,<span class="dv">23</span>,<span class="dv">13</span>,<span class="dv">7</span>,<span class="dv">10</span>,<span class="dv">14</span>,<span class="dv">11</span>,<span class="dv">16</span>,<span class="dv">11</span>,<span class="dv">11</span>,<span class="dv">9</span>,<span class="dv">8</span>,<span class="dv">5</span>,<span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>)  </span>
<span id="cb101-1137"><a href="#cb101-1137" aria-hidden="true" tabindex="-1"></a> <span class="co"># data from (Helidoniotis and Haddon, 2012)  </span></span>
<span id="cb101-1138"><a href="#cb101-1138" aria-hidden="true" tabindex="-1"></a>dat <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>(<span class="fu">cbind</span>(mids,obs)) <span class="co">#xy matrix needed by inthist  </span></span>
<span id="cb101-1139"><a href="#cb101-1139" aria-hidden="true" tabindex="-1"></a><span class="fu">parset</span>()  <span class="co">#set up par declaration then use an MQMF function   </span></span>
<span id="cb101-1140"><a href="#cb101-1140" aria-hidden="true" tabindex="-1"></a><span class="fu">inthist</span>(dat,<span class="at">col=</span><span class="dv">2</span>,<span class="at">border=</span><span class="dv">3</span>,<span class="at">width=</span><span class="fl">1.8</span>, <span class="co">#histogram of integers  </span></span>
<span id="cb101-1141"><a href="#cb101-1141" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlabel=</span><span class="st">"Shell Length mm"</span>,<span class="at">ylabel=</span><span class="st">"Frequency"</span>,<span class="at">xmin=</span><span class="dv">7</span>,<span class="at">xmax=</span><span class="dv">55</span>)   </span>
<span id="cb101-1142"><a href="#cb101-1142" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-1143"><a href="#cb101-1143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1144"><a href="#cb101-1144" aria-hidden="true" tabindex="-1"></a>假设数据中的可观测模式与不同的世代或栖息地有关，并且我们希望估计每个世代的属性。使用正态概率密度函数来描述每种模式/队列中每个大小组的预期相对频率，并将其组合起来生成样本中 $k$ 个 2mm 长度组中每一个的期望相对频率(Helidoniotis和Haddon, 2012)。需要五个参数，每个世代的均值和标准差，以及第一个世代中包含的观测总数的比例(第二个世代的比例是通过减去1.0得到的)。因此，使用 $\theta=(\mu_c, \sigma_c, \varphi)$，其中，在这种情况下，有 $c=2$ 个世代，我们可以得到每个大小分组内观测值的期望比例。一种方法是计算每个 2mm 分组中心的相对似然，乘以样本总数，再根据分配给每个世代的比例进行调节<span class="co">[</span><span class="ot">@eq-4_38</span><span class="co">]</span>。</span>
<span id="cb101-1145"><a href="#cb101-1145" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1146"><a href="#cb101-1146" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-1147"><a href="#cb101-1147" aria-hidden="true" tabindex="-1"></a>\begin{aligned}  </span>
<span id="cb101-1148"><a href="#cb101-1148" aria-hidden="true" tabindex="-1"></a>{{{\hat{N}}}_{i}} &amp;= {{\varphi }_{1}}n\sum\limits_{{{S}_{i}}=6}^{56}{\frac{1}{{{\sigma }_{1}}\sqrt{2\pi }}}\exp \left( \frac{-\left( {{S}_{i}}-{{\mu }_{1}} \right)}{2{{\sigma }_{1}}} \right)  <span class="sc">\\</span>   </span>
<span id="cb101-1149"><a href="#cb101-1149" aria-hidden="true" tabindex="-1"></a>  &amp;+ \left( 1-{{\varphi }_{2}} \right)n\sum\limits_{{{S}_{i}}=6}^{56}{\frac{1}{{{\sigma }_{2}}\sqrt{2\pi }}}\exp \left( \frac{-\left( {{S}_{i}}-{{\mu }_{2}} \right)}{2{{\sigma }_{2}}} \right) <span class="sc">\\</span>   </span>
<span id="cb101-1150"><a href="#cb101-1150" aria-hidden="true" tabindex="-1"></a>  {{p}_{i}} &amp;= {{{\hat{N}}}_{i}}/\sum{{{{\hat{N}}}_{i}}} <span class="sc">\\</span>   </span>
<span id="cb101-1151"><a href="#cb101-1151" aria-hidden="true" tabindex="-1"></a>\end{aligned}  </span>
<span id="cb101-1152"><a href="#cb101-1152" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_38}</span>
<span id="cb101-1153"><a href="#cb101-1153" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1154"><a href="#cb101-1154" aria-hidden="true" tabindex="-1"></a>其中 $\hat N_i$ 是每个分组 $i$ 中观测的期望数，$i$ 表示分组数（这晨在7-55mm 之间为 2mm 的步长，中心值为 $8, \cdots, 54$）。$\varphi (phi)$ 是世代 1 中发现的观测总数 $n$ 的比例，$\mu_c$ 为每个世代 $c$ 的平均大小，$\sigma_c$ 为它们的标准差。 @eq-4_38 最后一行的 $p_i$ 是分组 $i$ 中观测值的期望比例，其中 $S_i$ 是每个分组的中点。</span>
<span id="cb101-1155"><a href="#cb101-1155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1156"><a href="#cb101-1156" aria-hidden="true" tabindex="-1"></a>或者，更准确地说，我们可以从每个大小类的顶部的累积概率中减去每个大小类i的底部的累积概率。然而，一般来说，这在分析中几乎没有什么不同，所以这里我们将只关注第一种方法(您可以尝试自己实现替代方法来进行比较，因为有时相信打印出来的一切并不是一个好主意!)。</span>
<span id="cb101-1157"><a href="#cb101-1157" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1158"><a href="#cb101-1158" aria-hidden="true" tabindex="-1"></a>无论采用哪种方法，我们都需要定义两个正态分布，并求和它们的相对贡献。我们可以使用对数正态分布或伽马分布等其他累积统计分布来代替正态分布。如果没有令人信服的理由来证明使用其中一种分布是正确的，那么理想的做法是比较使用其他分布与现有数据的相对拟合程度。</span>
<span id="cb101-1159"><a href="#cb101-1159" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1160"><a href="#cb101-1160" aria-hidden="true" tabindex="-1"></a>为了获得预期频率与观测频率进行比较，有必要限制预期总数与观测总数大致相同。多项式的负对数似然值为</span>
<span id="cb101-1161"><a href="#cb101-1161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1162"><a href="#cb101-1162" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-1163"><a href="#cb101-1163" aria-hidden="true" tabindex="-1"></a>-LL\left<span class="sc">\{</span> N|{\mu_c},{\sigma_c},{\varphi} \right<span class="sc">\}</span>=-\sum\limits_{c=1}^{2}\sum\limits_{i=1}^{k}{{N_i}\log\left( {{\hat{p}}_i} \right)}=-\sum\limits_{i=1}^{k}{{N_i}\log\left( \frac{{{\hat{N}}_i}}{\sum{{{\hat{N}}_i}}} \right)}    </span>
<span id="cb101-1164"><a href="#cb101-1164" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_39}</span>
<span id="cb101-1165"><a href="#cb101-1165" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1166"><a href="#cb101-1166" aria-hidden="true" tabindex="-1"></a>其中，$\mu_c$ 和 $\sigma_c$ 是 $c$ 世代假设生成观察分布的均值和标准差。有 $k$ 个分组和 2 个世代 $c$，$N_i$ 是分组 $i$ 的观测频率， $\hat p_i$ 是组合分布分组 $i$ 内期望比例。 目标是最小化负对数似然，以找到 $c$ 个正态分布参数和 $\varphi$ 的最佳组合。</span>
<span id="cb101-1167"><a href="#cb101-1167" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1170"><a href="#cb101-1170" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-1171"><a href="#cb101-1171" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-4-20</span></span>
<span id="cb101-1172"><a href="#cb101-1172" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "根据对 1992 年塔斯马尼亚南部采样的幼鲍长度-频率计数的初始参数猜测得出的两个正态分布。Two Normal distributions from initial parameter guesses imposed upon the length-frequency counts of juvenile abalone from southern Tasmania sampled in 1992."</span></span>
<span id="cb101-1173"><a href="#cb101-1173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1174"><a href="#cb101-1174" aria-hidden="true" tabindex="-1"></a> <span class="co">#cohort data with 2 guess-timated normal curves Fig 4.20  </span></span>
<span id="cb101-1175"><a href="#cb101-1175" aria-hidden="true" tabindex="-1"></a><span class="fu">parset</span>()  <span class="co"># set up the required par declaration  </span></span>
<span id="cb101-1176"><a href="#cb101-1176" aria-hidden="true" tabindex="-1"></a><span class="fu">inthist</span>(dat,<span class="at">col=</span><span class="dv">0</span>,<span class="at">border=</span><span class="dv">8</span>,<span class="at">width=</span><span class="fl">1.8</span>,<span class="at">xlabel=</span><span class="st">"Shell Length mm"</span>,  </span>
<span id="cb101-1177"><a href="#cb101-1177" aria-hidden="true" tabindex="-1"></a>        <span class="at">ylabel=</span><span class="st">"Frequency"</span>,<span class="at">xmin=</span><span class="dv">7</span>,<span class="at">xmax=</span><span class="dv">55</span>,<span class="at">lwd=</span><span class="dv">2</span>)  <span class="co"># MQMF function        </span></span>
<span id="cb101-1178"><a href="#cb101-1178" aria-hidden="true" tabindex="-1"></a> <span class="co">#Guess normal parameters and plot those curves on histogram  </span></span>
<span id="cb101-1179"><a href="#cb101-1179" aria-hidden="true" tabindex="-1"></a>av <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">18.0</span>,<span class="fl">34.5</span>)    <span class="co"># the initial trial and error means and  </span></span>
<span id="cb101-1180"><a href="#cb101-1180" aria-hidden="true" tabindex="-1"></a>stdev <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">2.75</span>,<span class="fl">5.75</span>)  <span class="co"># their standard deviations  </span></span>
<span id="cb101-1181"><a href="#cb101-1181" aria-hidden="true" tabindex="-1"></a>prop1 <span class="ot">&lt;-</span> <span class="fl">0.55</span>       <span class="co">#  proportion of observations in cohort 1  </span></span>
<span id="cb101-1182"><a href="#cb101-1182" aria-hidden="true" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="fu">sum</span>(obs) <span class="co">#262 observations, now calculate expected counts  </span></span>
<span id="cb101-1183"><a href="#cb101-1183" aria-hidden="true" tabindex="-1"></a>cohort1 <span class="ot">&lt;-</span> (n<span class="sc">*</span>prop1<span class="sc">*</span>cw)<span class="sc">*</span><span class="fu">dnorm</span>(mids,av[<span class="dv">1</span>],stdev[<span class="dv">1</span>]) <span class="co"># for each  </span></span>
<span id="cb101-1184"><a href="#cb101-1184" aria-hidden="true" tabindex="-1"></a>cohort2 <span class="ot">&lt;-</span> (n<span class="sc">*</span>(<span class="dv">1</span><span class="sc">-</span>prop1)<span class="sc">*</span>cw)<span class="sc">*</span><span class="fu">dnorm</span>(mids,av[<span class="dv">2</span>],stdev[<span class="dv">2</span>])<span class="co"># cohort  </span></span>
<span id="cb101-1185"><a href="#cb101-1185" aria-hidden="true" tabindex="-1"></a> <span class="co">#(n*prop1*cw) scales likelihoods to suit the 2mm class width  </span></span>
<span id="cb101-1186"><a href="#cb101-1186" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(mids,cohort1,<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">1</span>)  </span>
<span id="cb101-1187"><a href="#cb101-1187" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(mids,cohort2,<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">4</span>)  </span>
<span id="cb101-1188"><a href="#cb101-1188" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-1189"><a href="#cb101-1189" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1190"><a href="#cb101-1190" aria-hidden="true" tabindex="-1"></a>两种模式的初始试验和误差猜测的中心估计值似乎是合理的，但左侧世代中的散布似乎太小，世代间的比例分配似乎偏向于第一个世代。由于比例会以非线性方式改变数值，因此寻找最佳似然值对起始值很敏感。我们可以将 <span class="in">`nlm()`</span> 应用于一个封装函数来生成多项式的负对数似然估计值，从而寻找一个更理想的参数集，就象 @eq-4_39 中定义的那样。如前所述，我们需要一个函数来生成每个大小分组中观测值的预测数，在 **MQMF** 中我们称之为 <span class="in">`predfreq()`</span>。我们还需要一个封装函数来计算使用 <span class="in">`predfreq()`</span> 函数的负对数似然，这里我们将其称为 <span class="in">`wrapper()`</span>（见下面的代码块）。在开发 <span class="in">`predfreq()`</span> 函数时，我们要求对参数进行排序，首先是拟合的各世代的均值，然后是标准差，最后是分配给除最后一世代之外的所有世代的比例。这样，算法就能在规定的位置找到所需的参数。因此，对于三个世代的问题来说， 在 R 语言中，我们将有 $pars={c(\mu_1,\mu_2,\mu_3,\sigma_1,\sigma_2,\sigma_3,\varphi_1,\varphi2)}$。我们还加入了使用累积正态概率密度的选项。</span>
<span id="cb101-1191"><a href="#cb101-1191" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1194"><a href="#cb101-1194" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-1195"><a href="#cb101-1195" aria-hidden="true" tabindex="-1"></a> <span class="co">#wrapper function for calculating the multinomial log-likelihoods  </span></span>
<span id="cb101-1196"><a href="#cb101-1196" aria-hidden="true" tabindex="-1"></a> <span class="co">#using predfreq and mnnegLL, Use ? and examine their code  </span></span>
<span id="cb101-1197"><a href="#cb101-1197" aria-hidden="true" tabindex="-1"></a>wrapper <span class="ot">&lt;-</span> <span class="cf">function</span>(pars,obs,sizecl,<span class="at">midval=</span><span class="cn">TRUE</span>) {  </span>
<span id="cb101-1198"><a href="#cb101-1198" aria-hidden="true" tabindex="-1"></a>  freqf <span class="ot">&lt;-</span> <span class="fu">predfreq</span>(pars,<span class="fu">sum</span>(obs),<span class="at">sizecl=</span>sizecl,<span class="at">midval=</span>midval)  </span>
<span id="cb101-1199"><a href="#cb101-1199" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">mnnegLL</span>(obs,freqf))  </span>
<span id="cb101-1200"><a href="#cb101-1200" aria-hidden="true" tabindex="-1"></a>} <span class="co"># end of wrapper which uses MQMF::predfreq and MQMF::mnnegLL  </span></span>
<span id="cb101-1201"><a href="#cb101-1201" aria-hidden="true" tabindex="-1"></a>mids <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="dv">8</span>,<span class="dv">54</span>,<span class="dv">2</span>) <span class="co"># each size class = 2 mm as in 7-9, 9-11, ...  </span></span>
<span id="cb101-1202"><a href="#cb101-1202" aria-hidden="true" tabindex="-1"></a>av <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">18.0</span>,<span class="fl">34.5</span>)   <span class="co"># the trial and error means and  </span></span>
<span id="cb101-1203"><a href="#cb101-1203" aria-hidden="true" tabindex="-1"></a>stdev <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">2.95</span>,<span class="fl">5.75</span>)  <span class="co"># standard deviations  </span></span>
<span id="cb101-1204"><a href="#cb101-1204" aria-hidden="true" tabindex="-1"></a>phi1 <span class="ot">&lt;-</span> <span class="fl">0.55</span>      <span class="co"># proportion of observations in cohort 1  </span></span>
<span id="cb101-1205"><a href="#cb101-1205" aria-hidden="true" tabindex="-1"></a>pars <span class="ot">&lt;-</span><span class="fu">c</span>(av,stdev,phi1)  <span class="co"># combine parameters into a vector  </span></span>
<span id="cb101-1206"><a href="#cb101-1206" aria-hidden="true" tabindex="-1"></a><span class="fu">wrapper</span>(pars,<span class="at">obs=</span>obs,<span class="at">sizecl=</span>mids) <span class="co"># calculate total -veLL  </span></span>
<span id="cb101-1207"><a href="#cb101-1207" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-1208"><a href="#cb101-1208" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1211"><a href="#cb101-1211" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-1212"><a href="#cb101-1212" aria-hidden="true" tabindex="-1"></a> <span class="co"># First use the midpoints  </span></span>
<span id="cb101-1213"><a href="#cb101-1213" aria-hidden="true" tabindex="-1"></a>bestmod <span class="ot">&lt;-</span> <span class="fu">nlm</span>(<span class="at">f=</span>wrapper,<span class="at">p=</span>pars,<span class="at">obs=</span>obs,<span class="at">sizecl=</span>mids,<span class="at">midval=</span><span class="cn">TRUE</span>,   </span>
<span id="cb101-1214"><a href="#cb101-1214" aria-hidden="true" tabindex="-1"></a>               <span class="at">typsize=</span><span class="fu">magnitude</span>(pars))  </span>
<span id="cb101-1215"><a href="#cb101-1215" aria-hidden="true" tabindex="-1"></a><span class="fu">outfit</span>(bestmod,<span class="at">backtran=</span><span class="cn">FALSE</span>,<span class="at">title=</span><span class="st">"Using Midpts"</span>); <span class="fu">cat</span>(<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)  </span>
<span id="cb101-1216"><a href="#cb101-1216" aria-hidden="true" tabindex="-1"></a> <span class="co">#Now use the size class bounds and cumulative distribution  </span></span>
<span id="cb101-1217"><a href="#cb101-1217" aria-hidden="true" tabindex="-1"></a> <span class="co">#more sensitive to starting values, so use best pars from midpoints  </span></span>
<span id="cb101-1218"><a href="#cb101-1218" aria-hidden="true" tabindex="-1"></a>X <span class="ot">&lt;-</span> <span class="fu">seq</span>((mids[<span class="dv">1</span>]<span class="sc">-</span>cw<span class="sc">/</span><span class="dv">2</span>),(<span class="fu">tail</span>(mids,<span class="dv">1</span>)<span class="sc">+</span>cw<span class="sc">/</span><span class="dv">2</span>),cw)  </span>
<span id="cb101-1219"><a href="#cb101-1219" aria-hidden="true" tabindex="-1"></a>bestmodb <span class="ot">&lt;-</span> <span class="fu">nlm</span>(<span class="at">f=</span>wrapper,<span class="at">p=</span>bestmod<span class="sc">$</span>estimate,<span class="at">obs=</span>obs,<span class="at">sizecl=</span>X,  </span>
<span id="cb101-1220"><a href="#cb101-1220" aria-hidden="true" tabindex="-1"></a>                <span class="at">midval=</span><span class="cn">FALSE</span>,<span class="at">typsize=</span><span class="fu">magnitude</span>(pars))  </span>
<span id="cb101-1221"><a href="#cb101-1221" aria-hidden="true" tabindex="-1"></a><span class="fu">outfit</span>(bestmodb,<span class="at">backtran=</span><span class="cn">FALSE</span>,<span class="at">title=</span><span class="st">"Using size-class bounds"</span>)   </span>
<span id="cb101-1222"><a href="#cb101-1222" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-1223"><a href="#cb101-1223" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1224"><a href="#cb101-1224" aria-hidden="true" tabindex="-1"></a>现在对照原始数据绘制这些最优解。绘制数据图非常简单，但随后我们需要找出每种情况下的最优参数，并计算出每个参数的隐含正态分布。</span>
<span id="cb101-1225"><a href="#cb101-1225" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1228"><a href="#cb101-1228" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-1229"><a href="#cb101-1229" aria-hidden="true" tabindex="-1"></a> <span class="co">#prepare the predicted Normal distribution curves  </span></span>
<span id="cb101-1230"><a href="#cb101-1230" aria-hidden="true" tabindex="-1"></a>pars <span class="ot">&lt;-</span> bestmod<span class="sc">$</span>estimate <span class="co"># best estimate using mid-points  </span></span>
<span id="cb101-1231"><a href="#cb101-1231" aria-hidden="true" tabindex="-1"></a>cohort1 <span class="ot">&lt;-</span> (n<span class="sc">*</span>pars[<span class="dv">5</span>]<span class="sc">*</span>cw)<span class="sc">*</span><span class="fu">dnorm</span>(mids,pars[<span class="dv">1</span>],pars[<span class="dv">3</span>])   </span>
<span id="cb101-1232"><a href="#cb101-1232" aria-hidden="true" tabindex="-1"></a>cohort2 <span class="ot">&lt;-</span> (n<span class="sc">*</span>(<span class="dv">1</span><span class="sc">-</span>pars[<span class="dv">5</span>])<span class="sc">*</span>cw)<span class="sc">*</span><span class="fu">dnorm</span>(mids,pars[<span class="dv">2</span>],pars[<span class="dv">4</span>])   </span>
<span id="cb101-1233"><a href="#cb101-1233" aria-hidden="true" tabindex="-1"></a>parsb <span class="ot">&lt;-</span> bestmodb<span class="sc">$</span>estimate <span class="co"># best estimate with bounds  </span></span>
<span id="cb101-1234"><a href="#cb101-1234" aria-hidden="true" tabindex="-1"></a>nedge <span class="ot">&lt;-</span> <span class="fu">length</span>(mids) <span class="sc">+</span> <span class="dv">1</span>  <span class="co"># one extra estimate  </span></span>
<span id="cb101-1235"><a href="#cb101-1235" aria-hidden="true" tabindex="-1"></a>cump1 <span class="ot">&lt;-</span> (n<span class="sc">*</span>pars[<span class="dv">5</span>])<span class="sc">*</span><span class="fu">pnorm</span>(X,pars[<span class="dv">1</span>],pars[<span class="dv">3</span>])<span class="co">#no need to rescale  </span></span>
<span id="cb101-1236"><a href="#cb101-1236" aria-hidden="true" tabindex="-1"></a>cohort1b <span class="ot">&lt;-</span> (cump1[<span class="dv">2</span><span class="sc">:</span>nedge] <span class="sc">-</span> cump1[<span class="dv">1</span><span class="sc">:</span>(nedge<span class="dv">-1</span>)])   </span>
<span id="cb101-1237"><a href="#cb101-1237" aria-hidden="true" tabindex="-1"></a>cump2 <span class="ot">&lt;-</span> (n<span class="sc">*</span>(<span class="dv">1</span><span class="sc">-</span>pars[<span class="dv">5</span>]))<span class="sc">*</span><span class="fu">pnorm</span>(X,pars[<span class="dv">2</span>],pars[<span class="dv">4</span>])  <span class="co"># cohort 2  </span></span>
<span id="cb101-1238"><a href="#cb101-1238" aria-hidden="true" tabindex="-1"></a>cohort2b <span class="ot">&lt;-</span> (cump2[<span class="dv">2</span><span class="sc">:</span>nedge] <span class="sc">-</span> cump2[<span class="dv">1</span><span class="sc">:</span>(nedge<span class="dv">-1</span>)])  </span>
<span id="cb101-1239"><a href="#cb101-1239" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-1240"><a href="#cb101-1240" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1243"><a href="#cb101-1243" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-1244"><a href="#cb101-1244" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-4-21</span></span>
<span id="cb101-1245"><a href="#cb101-1245" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "长度-频率信息左侧模式的最佳拟合。使用长度分组中值或边界值的参数值差异出现在小数点后第四位。右侧模式的差异很小，无法辨别。The optimum fit to the left-hand mode of the length-frequency information. The differences in parameter values between using size-class midpts or bounds occurs at the fourth decimal place. The difference in the right-hand mode was so small as not to be discernible."</span></span>
<span id="cb101-1246"><a href="#cb101-1246" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1247"><a href="#cb101-1247" aria-hidden="true" tabindex="-1"></a> <span class="co">#plot the alternate model fits to cohorts  Fig 4.21  </span></span>
<span id="cb101-1248"><a href="#cb101-1248" aria-hidden="true" tabindex="-1"></a><span class="fu">parset</span>()  <span class="co"># set up required par declaration; then plot curves  </span></span>
<span id="cb101-1249"><a href="#cb101-1249" aria-hidden="true" tabindex="-1"></a>pick <span class="ot">&lt;-</span> <span class="fu">which</span>(mids <span class="sc">&lt;</span> <span class="dv">28</span>)  </span>
<span id="cb101-1250"><a href="#cb101-1250" aria-hidden="true" tabindex="-1"></a><span class="fu">inthist</span>(dat[pick,],<span class="at">col=</span><span class="dv">0</span>,<span class="at">border=</span><span class="dv">8</span>,<span class="at">width=</span><span class="fl">1.8</span>,<span class="at">xmin=</span><span class="dv">5</span>,<span class="at">xmax=</span><span class="dv">28</span>,  </span>
<span id="cb101-1251"><a href="#cb101-1251" aria-hidden="true" tabindex="-1"></a>        <span class="at">xlabel=</span><span class="st">"Shell Length mm"</span>,<span class="at">ylabel=</span><span class="st">"Frequency"</span>,<span class="at">lwd=</span><span class="dv">3</span>)   </span>
<span id="cb101-1252"><a href="#cb101-1252" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(mids,cohort1,<span class="at">lwd=</span><span class="dv">3</span>,<span class="at">col=</span><span class="dv">1</span>,<span class="at">lty=</span><span class="dv">2</span>) <span class="co"># have used setpalette("R4")  </span></span>
<span id="cb101-1253"><a href="#cb101-1253" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(mids,cohort1b,<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">4</span>)      <span class="co"># add the bounded results  </span></span>
<span id="cb101-1254"><a href="#cb101-1254" aria-hidden="true" tabindex="-1"></a>label <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"midpoints"</span>,<span class="st">"bounds"</span>)      <span class="co"># very minor differences </span></span>
<span id="cb101-1255"><a href="#cb101-1255" aria-hidden="true" tabindex="-1"></a><span class="fu">legend</span>(<span class="st">"topleft"</span>,<span class="at">legend=</span>label,<span class="at">lwd=</span><span class="dv">3</span>,<span class="at">col=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">4</span>),<span class="at">bty=</span><span class="st">"n"</span>,  </span>
<span id="cb101-1256"><a href="#cb101-1256" aria-hidden="true" tabindex="-1"></a>       <span class="at">cex=</span><span class="fl">1.2</span>,<span class="at">lty=</span><span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">1</span>))  </span>
<span id="cb101-1257"><a href="#cb101-1257" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-1258"><a href="#cb101-1258" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1259"><a href="#cb101-1259" aria-hidden="true" tabindex="-1"></a>在这种情况下，使用不同长度组的中点所得到的参数与使用每个长度组的上限和下限所得到的参数几乎没有差别，所得到的正态曲线几乎完全重合。我们可以通过列出每种情况下的观测计数和预测计数，以及每个长度组中预测数和观测数之间的差异来了解这些拟合的细节。如 @fig-4-21 所示， @tbl-4-4 中的数字本身更清楚地说明了两种方法的接近性。从严格意义上讲，使用上下限更为正确，但在实践中往往差别不大。</span>
<span id="cb101-1260"><a href="#cb101-1260" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1261"><a href="#cb101-1261" aria-hidden="true" tabindex="-1"></a>Venebles 和 Ripley（2002，p 436）采用不同的策略将模态分布拟合为混合分布。他们的方法更为复杂和优雅，因为他们使用了分析梯度来辅助模型拟合过程。希望大家都能清楚地认识到，几乎所有分析问题都有不止一种解决方法。使用数值方法往往需要探索其他方法来寻找解决方案。</span>
<span id="cb101-1262"><a href="#cb101-1262" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1265"><a href="#cb101-1265" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-1266"><a href="#cb101-1266" aria-hidden="true" tabindex="-1"></a> <span class="co"># setup table of results for comparison of fitting strategies  </span></span>
<span id="cb101-1267"><a href="#cb101-1267" aria-hidden="true" tabindex="-1"></a>predmid <span class="ot">&lt;-</span> <span class="fu">rowSums</span>(<span class="fu">cbind</span>(cohort1,cohort2))  </span>
<span id="cb101-1268"><a href="#cb101-1268" aria-hidden="true" tabindex="-1"></a>predbnd <span class="ot">&lt;-</span> <span class="fu">rowSums</span>(<span class="fu">cbind</span>(cohort1b,cohort2b))  </span>
<span id="cb101-1269"><a href="#cb101-1269" aria-hidden="true" tabindex="-1"></a>result <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>(<span class="fu">cbind</span>(mids,obs,predmid,predbnd,predbnd<span class="sc">-</span>predmid))  </span>
<span id="cb101-1270"><a href="#cb101-1270" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(result) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"mids"</span>,<span class="st">"Obs"</span>,<span class="st">"Predmid"</span>,<span class="st">"Predbnd"</span>,<span class="st">"Difference"</span>)  </span>
<span id="cb101-1271"><a href="#cb101-1271" aria-hidden="true" tabindex="-1"></a>result <span class="ot">&lt;-</span> <span class="fu">rbind</span>(result,<span class="fu">c</span>(<span class="cn">NA</span>,<span class="fu">colSums</span>(result,<span class="at">na.rm=</span><span class="cn">TRUE</span>)[<span class="dv">2</span><span class="sc">:</span><span class="dv">5</span>]))  </span>
<span id="cb101-1272"><a href="#cb101-1272" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-1273"><a href="#cb101-1273" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1276"><a href="#cb101-1276" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-1277"><a href="#cb101-1277" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-4-4</span></span>
<span id="cb101-1278"><a href="#cb101-1278" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: "A tabulation of the predicted counts for the two normal distributions from the optimum model fit. The original sample had 262 observations."</span></span>
<span id="cb101-1279"><a href="#cb101-1279" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1280"><a href="#cb101-1280" aria-hidden="true" tabindex="-1"></a>knitr<span class="sc">::</span><span class="fu">kable</span>(result)</span>
<span id="cb101-1281"><a href="#cb101-1281" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-1282"><a href="#cb101-1282" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1283"><a href="#cb101-1283" aria-hidden="true" tabindex="-1"></a><span class="fu">## Gamma 分布的似然</span></span>
<span id="cb101-1284"><a href="#cb101-1284" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1285"><a href="#cb101-1285" aria-hidden="true" tabindex="-1"></a>与我们在前几节中所考虑的统计分布相比，Gamma 分布通常不太为人所知。然而，Gamma 分布在渔业建模和模拟中越来越常用；在基于长度的种群模型中可以找到实际的例子(Sullivan等，1990；Sullivan,1992)。Gamma分布的概率密度函数有两个参数，一个尺度参数 $b$ （ $b &lt; 0$；有时使用的替代方式是 $\lambda$，其中 $\lambda &lt; 1/b$），以及一个形状参数 $c$ （$c&gt;0$）。分布范围是 $0 \leq{x} \leq{\infty}$ （即无负值）。分布的期望或均值 $E(x)$ 与两个参数（尺度参数 $b$ 和形状参数 $c$）有关。因此：</span>
<span id="cb101-1286"><a href="#cb101-1286" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1287"><a href="#cb101-1287" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-1288"><a href="#cb101-1288" aria-hidden="true" tabindex="-1"></a>E{( x )}=bc \;\;\;\ \text{or} \;\;\;\ c=\frac{E{( x )}}{b}   </span>
<span id="cb101-1289"><a href="#cb101-1289" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_40}</span>
<span id="cb101-1290"><a href="#cb101-1290" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1291"><a href="#cb101-1291" aria-hidden="true" tabindex="-1"></a>计算 Gamma 分布的单个似然的概率密度函数为（Forbes et al, 2011）：</span>
<span id="cb101-1292"><a href="#cb101-1292" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1293"><a href="#cb101-1293" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-1294"><a href="#cb101-1294" aria-hidden="true" tabindex="-1"></a>L\left<span class="sc">\{</span> x \vert b,c \right<span class="sc">\}</span>=\frac{{{\left( \frac{x}{b} \right)}^{( c-1 )}}{{e}^{\frac{-x}{b}}}}{b\Gamma (c)}  </span>
<span id="cb101-1295"><a href="#cb101-1295" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_41}</span>
<span id="cb101-1296"><a href="#cb101-1296" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1297"><a href="#cb101-1297" aria-hidden="true" tabindex="-1"></a>其中 $x$ 是变量值 ，$b$ 是尺度参数， $c$ 是形状参数， $\Gamma(c)$ 是 $c$ 参数的 gamma 函数。$c$ 取整数值的情况下，分布还被称为 Erlang 分布，此时 gamma 函数（$\Gamma(c)$）替代为阶乘 $(c-1)!$ (Forbes 等，2011)：</span>
<span id="cb101-1298"><a href="#cb101-1298" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1299"><a href="#cb101-1299" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-1300"><a href="#cb101-1300" aria-hidden="true" tabindex="-1"></a>L\left<span class="sc">\{</span> x|b,c \right<span class="sc">\}</span>=\frac{{{\left( \frac{x}{b} \right)}^{\left( c-1 \right)}}{{e}^{\frac{-x}{b}}}}{b\left( c-1 \right)!}    </span>
<span id="cb101-1301"><a href="#cb101-1301" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_42}</span>
<span id="cb101-1302"><a href="#cb101-1302" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1303"><a href="#cb101-1303" aria-hidden="true" tabindex="-1"></a>与通常的似然计算一样，为了避免过流和欠流的计算问题，标准的做法是计算对数似然，更具体地说是负对数似然。使用对数似然总是更能规避风险：</span>
<span id="cb101-1304"><a href="#cb101-1304" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1305"><a href="#cb101-1305" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-1306"><a href="#cb101-1306" aria-hidden="true" tabindex="-1"></a>-LL<span class="sc">\{</span>x|b,c<span class="sc">\}</span>= -\left[ \left( (c-1)\log\left( \frac{x}{b} \right)-\frac{x}{b} \right)   </span>
<span id="cb101-1307"><a href="#cb101-1307" aria-hidden="true" tabindex="-1"></a>-<span class="sc">\{</span>\log{(b)}+ \log{\left( \Gamma \left( c \right) \right)} <span class="sc">\}</span> \right]  </span>
<span id="cb101-1308"><a href="#cb101-1308" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_43}</span>
<span id="cb101-1309"><a href="#cb101-1309" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1310"><a href="#cb101-1310" aria-hidden="true" tabindex="-1"></a>对于多个观测值，这可以将它们相加而不是相乘，但仍需要计算对数 gamma 函数 $\log(\Gamma (c))$。幸运的是在 R 语言中可以使用 <span class="in">`gamma()`</span> 和 <span class="in">`lgamma()`</span> 两个函数。</span>
<span id="cb101-1311"><a href="#cb101-1311" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1312"><a href="#cb101-1312" aria-hidden="true" tabindex="-1"></a>Gamma 分布（不要与 gamma 函数 $\Gamma$ 混淆）非常灵活，形状的范围从实际上的反向曲线，到右偏曲线，再到近似正态曲线。它的灵活性使其成为一个非常有用的模拟函数，@fig-4-22。</span>
<span id="cb101-1313"><a href="#cb101-1313" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1316"><a href="#cb101-1316" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-1317"><a href="#cb101-1317" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-4-22</span></span>
<span id="cb101-1318"><a href="#cb101-1318" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Different Gamma distributions all with a scale c = 1.0."</span></span>
<span id="cb101-1319"><a href="#cb101-1319" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1320"><a href="#cb101-1320" aria-hidden="true" tabindex="-1"></a> <span class="co">#Illustrate different Gamma function curves  Figure 4.22  </span></span>
<span id="cb101-1321"><a href="#cb101-1321" aria-hidden="true" tabindex="-1"></a>X <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="fl">0.0</span>,<span class="dv">10</span>,<span class="fl">0.1</span>) <span class="co">#now try different shapes and scale values  </span></span>
<span id="cb101-1322"><a href="#cb101-1322" aria-hidden="true" tabindex="-1"></a>dg <span class="ot">&lt;-</span> <span class="fu">dgamma</span>(X,<span class="at">shape=</span><span class="dv">1</span>,<span class="at">scale=</span><span class="dv">1</span>)   </span>
<span id="cb101-1323"><a href="#cb101-1323" aria-hidden="true" tabindex="-1"></a><span class="fu">plot1</span>(X,dg,<span class="at">xlab =</span> <span class="st">"Quantile"</span>,<span class="st">"Probability Density"</span>)  </span>
<span id="cb101-1324"><a href="#cb101-1324" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(X,<span class="fu">dgamma</span>(X,<span class="at">shape=</span><span class="fl">1.5</span>,<span class="at">scale=</span><span class="dv">1</span>),<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">2</span>,<span class="at">lty=</span><span class="dv">2</span>)  </span>
<span id="cb101-1325"><a href="#cb101-1325" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(X,<span class="fu">dgamma</span>(X,<span class="at">shape=</span><span class="dv">2</span>,<span class="at">scale=</span><span class="dv">1</span>),<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">3</span>,<span class="at">lty=</span><span class="dv">3</span>)  </span>
<span id="cb101-1326"><a href="#cb101-1326" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(X,<span class="fu">dgamma</span>(X,<span class="at">shape=</span><span class="dv">4</span>,<span class="at">scale=</span><span class="dv">1</span>),<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">4</span>,<span class="at">lty=</span><span class="dv">4</span>)  </span>
<span id="cb101-1327"><a href="#cb101-1327" aria-hidden="true" tabindex="-1"></a><span class="fu">legend</span>(<span class="st">"topright"</span>,<span class="at">legend=</span><span class="fu">c</span>(<span class="st">"Shape 1"</span>,<span class="st">"Shape 1.5"</span>,<span class="st">"Shape 2"</span>,  </span>
<span id="cb101-1328"><a href="#cb101-1328" aria-hidden="true" tabindex="-1"></a>       <span class="st">"Shape 4"</span>),<span class="at">lwd=</span><span class="dv">3</span>,<span class="at">col=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>),<span class="at">bty=</span><span class="st">"n"</span>,<span class="at">cex=</span><span class="fl">1.25</span>,<span class="at">lty=</span><span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>)  </span>
<span id="cb101-1329"><a href="#cb101-1329" aria-hidden="true" tabindex="-1"></a><span class="fu">mtext</span>(<span class="st">"Scale c = 1"</span>,<span class="at">side=</span><span class="dv">3</span>,<span class="at">outer=</span><span class="cn">FALSE</span>,<span class="at">line=</span><span class="sc">-</span><span class="fl">1.1</span>,<span class="at">cex=</span><span class="fl">1.0</span>,<span class="at">font=</span><span class="dv">7</span>)  </span>
<span id="cb101-1330"><a href="#cb101-1330" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-1331"><a href="#cb101-1331" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1332"><a href="#cb101-1332" aria-hidden="true" tabindex="-1"></a>在 “多项式分布 ”一节中，我们使用正态分布来描述一个世代中长度的预期分布。也有可能使用 Gamma 分布来更好地描述物种的生长模式。</span>
<span id="cb101-1333"><a href="#cb101-1333" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1334"><a href="#cb101-1334" aria-hidden="true" tabindex="-1"></a><span class="fu">## Beta 分布的似然</span></span>
<span id="cb101-1335"><a href="#cb101-1335" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1336"><a href="#cb101-1336" aria-hidden="true" tabindex="-1"></a>Beta 分布只适用于 0.0 到 1.0 之间的变量值。这使它成为模拟中另一个非常有用的分布，因为从 0 到 1 之间的分布中采样是比较常见的，而不可能获得超出这些限制的值，如 @fig-4-23 。在 “不确定性 ”一章中，我们将使用多变量正态分布，这需要使用一个额外的 R 软件包。可用于分析和模拟的分布阵列非常庞大。探索是发现其特性的最佳途径。</span>
<span id="cb101-1337"><a href="#cb101-1337" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1340"><a href="#cb101-1340" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-1341"><a href="#cb101-1341" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-4-23</span></span>
<span id="cb101-1342"><a href="#cb101-1342" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Different Beta probability density distributions all with a shape1 value = 3.0, and with values of shape2 ranging from 1 to 10."</span></span>
<span id="cb101-1343"><a href="#cb101-1343" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1344"><a href="#cb101-1344" aria-hidden="true" tabindex="-1"></a> <span class="co">#Illustrate different Beta function curves. Figure 4.23  </span></span>
<span id="cb101-1345"><a href="#cb101-1345" aria-hidden="true" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="at">length =</span> <span class="dv">1000</span>)  </span>
<span id="cb101-1346"><a href="#cb101-1346" aria-hidden="true" tabindex="-1"></a><span class="fu">parset</span>()  </span>
<span id="cb101-1347"><a href="#cb101-1347" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(x,<span class="fu">dbeta</span>(x,<span class="at">shape1=</span><span class="dv">3</span>,<span class="at">shape2=</span><span class="dv">1</span>),<span class="at">type=</span><span class="st">"l"</span>,<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">ylim=</span><span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">4</span>),  </span>
<span id="cb101-1348"><a href="#cb101-1348" aria-hidden="true" tabindex="-1"></a>     <span class="at">yaxs=</span><span class="st">"i"</span>,<span class="at">panel.first=</span><span class="fu">grid</span>(), <span class="at">xlab=</span><span class="st">"Variable 0 - 1"</span>,   </span>
<span id="cb101-1349"><a href="#cb101-1349" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylab=</span><span class="st">"Beta Probability Density - Scale1 = 3"</span>)  </span>
<span id="cb101-1350"><a href="#cb101-1350" aria-hidden="true" tabindex="-1"></a>bval <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">1.25</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">10</span>)  </span>
<span id="cb101-1351"><a href="#cb101-1351" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(bval))   </span>
<span id="cb101-1352"><a href="#cb101-1352" aria-hidden="true" tabindex="-1"></a>  <span class="fu">lines</span>(x,<span class="fu">dbeta</span>(x,<span class="at">shape1=</span><span class="dv">3</span>,<span class="at">shape2=</span>bval[i]),<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span>(i<span class="sc">+</span><span class="dv">1</span>),<span class="at">lty=</span><span class="fu">c</span>(i<span class="sc">+</span><span class="dv">1</span>))  </span>
<span id="cb101-1353"><a href="#cb101-1353" aria-hidden="true" tabindex="-1"></a><span class="fu">legend</span>(<span class="fl">0.5</span>,<span class="fl">3.95</span>,<span class="fu">c</span>(<span class="fl">1.0</span>,bval),<span class="at">col=</span><span class="fu">c</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">7</span>),<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">bty=</span><span class="st">"n"</span>,<span class="at">lty=</span><span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>)  </span>
<span id="cb101-1354"><a href="#cb101-1354" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-1355"><a href="#cb101-1355" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1356"><a href="#cb101-1356" aria-hidden="true" tabindex="-1"></a><span class="fu">## 贝叶斯定理</span></span>
<span id="cb101-1357"><a href="#cb101-1357" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1358"><a href="#cb101-1358" aria-hidden="true" tabindex="-1"></a><span class="fu">### 简介</span></span>
<span id="cb101-1359"><a href="#cb101-1359" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1360"><a href="#cb101-1360" aria-hidden="true" tabindex="-1"></a>贝叶斯统计在渔业科学中的应用不断扩大（McAllister 等，1994；McAllister 和 Ianelli，1997；Punt 和 Hilborn，1997；反对意见见 Dennis，1996；最近见 Winker 等，2018）。Gelman 等（2014）出版了一本与这些方法的使用相关的优秀书籍。在此，我们不打算对渔业中使用的方法进行回顾；Punt 和 Hilborn（1997）中有很好的介绍，而且还有许多更近期的例子。相反，我们将集中讨论渔业中使用的贝叶斯方法的基础，并与最大似然法进行一些比较。关于如何使用这些方法的详情，请参阅 “不确定性 ”一章。</span>
<span id="cb101-1361"><a href="#cb101-1361" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1362"><a href="#cb101-1362" aria-hidden="true" tabindex="-1"></a>条件概率用于描述人们对特定事件发生的概率感兴趣的情况，比如在事件 $A$ 已经发生的情况下，事件 $B_i$ 发生的概率。这个表达式的符号是 $P (B_i | A)$，其中垂直线“\|” 表示“给定（given）”的意思。</span>
<span id="cb101-1363"><a href="#cb101-1363" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1364"><a href="#cb101-1364" aria-hidden="true" tabindex="-1"></a>贝叶斯定理就是基于对这种条件概率的操纵。因此，如果一组 $n$ 个事件，标记为 $B_i$，在事件 $A$ 发生的情况下发生，那么我们可以正式地发展贝叶斯定理。首先，我们考虑在 $A$ 发生的情况下观察到特定 $B_i$ 的概率:</span>
<span id="cb101-1365"><a href="#cb101-1365" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1366"><a href="#cb101-1366" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-1367"><a href="#cb101-1367" aria-hidden="true" tabindex="-1"></a>P\left( {{B}_{i}}|A \right)=\frac{P\left( A <span class="sc">\&amp;</span> B_i \right)}{P\left( A \right)}   </span>
<span id="cb101-1368"><a href="#cb101-1368" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_44}</span>
<span id="cb101-1369"><a href="#cb101-1369" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1370"><a href="#cb101-1370" aria-hidden="true" tabindex="-1"></a>也就是说，在 $A$ 已经发生的情况下，$B_i$ 发生的概率等于 $A$ 和 $B_i$ 同时发生的概率除以 $A$ 发生的概率。以同样的方式，我们可以考虑给定事件 $B_i$ 发生的情况下事件 $A$ 的条件概率。</span>
<span id="cb101-1371"><a href="#cb101-1371" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1372"><a href="#cb101-1372" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-1373"><a href="#cb101-1373" aria-hidden="true" tabindex="-1"></a>P\left( {A}|{B_i} \right)=\frac{P\left( {A} <span class="sc">\&amp;</span> {B}_{i} \right)}{P\left( {B}_{i} \right)}  </span>
<span id="cb101-1374"><a href="#cb101-1374" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_45}</span>
<span id="cb101-1375"><a href="#cb101-1375" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1376"><a href="#cb101-1376" aria-hidden="true" tabindex="-1"></a>这两种条件概率可以重新排列，得到:</span>
<span id="cb101-1377"><a href="#cb101-1377" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1378"><a href="#cb101-1378" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-1379"><a href="#cb101-1379" aria-hidden="true" tabindex="-1"></a>P\left( A|{B_i} \right)P\left( {B}_{i} \right)=P\left( A \&amp; {B}_{i} \right)  </span>
<span id="cb101-1380"><a href="#cb101-1380" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_46}</span>
<span id="cb101-1381"><a href="#cb101-1381" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1382"><a href="#cb101-1382" aria-hidden="true" tabindex="-1"></a>我们使用这个代替 @eq-4_44 中的 $P(A <span class="sc">\&amp;</span> B_i)$ 项可得到 传统的贝叶斯定理：</span>
<span id="cb101-1383"><a href="#cb101-1383" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1384"><a href="#cb101-1384" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-1385"><a href="#cb101-1385" aria-hidden="true" tabindex="-1"></a>P\left({B_i}|A\right)=\frac{P\left(A|{B_i}\right)P\left({B_i}\right)}{P\left(A\right)}    </span>
<span id="cb101-1386"><a href="#cb101-1386" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_47}</span>
<span id="cb101-1387"><a href="#cb101-1387" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1388"><a href="#cb101-1388" aria-hidden="true" tabindex="-1"></a>如果我们把这个看似晦涩的定理翻译成这样，即 $A$ 代表从自然界获得的数据，而各种 $B_i$ 作为可以用来解释数据的单独假设（假设是模型加上参数向量 $\theta$），那么我们就可以推导出渔业中使用的贝叶斯定理的形式。因此，$P(A | B_i)$ 就是给定模型加上参数 $B_i$ （假设）的数据 $A$ 的似然;我们已经从极大似然理论和实践中熟悉了这一点。新内容是 $P(B_i)$，它是在对数据 $A$ 进行任何分析或考虑之前假设的概率。这就是假设 $B_i$ 的**先验**概率。 @eq-4_47 中的 $P(A)$ 是所有可能的数据和假设组合的组合概率。“所有”这个词的使用需要强调，因为它实际上意味着考虑所有可能的结果。这种完备性就是为什么贝叶斯统计在纸牌游戏和其他受限制的机会游戏等封闭系统中如此有效的原因。然而，在开放世界中，所有的可能性都被考虑过是一个强有力的假设。最好的解释是，所考虑的一系列备选假设（模型加特定参数）构成了正在进行的分析的适用范围。b也就是对于所有 $B_i$， $\sum P(B_i|A)=0$，因此得到了 @eq-4_48。</span>
<span id="cb101-1389"><a href="#cb101-1389" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1390"><a href="#cb101-1390" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-1391"><a href="#cb101-1391" aria-hidden="true" tabindex="-1"></a>P\left(A\right)=\sum\limits_{i=1}^{n}{P\left( A|{B_i}\right)}P\left({B_i}\right)  </span>
<span id="cb101-1392"><a href="#cb101-1392" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_48}</span>
<span id="cb101-1393"><a href="#cb101-1393" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1394"><a href="#cb101-1394" aria-hidden="true" tabindex="-1"></a><span class="fu">### 贝叶斯方法</span></span>
<span id="cb101-1395"><a href="#cb101-1395" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1396"><a href="#cb101-1396" aria-hidden="true" tabindex="-1"></a>如前所述，贝叶斯定理与条件概率有关(Gelman et al, 2014)，因此，当我们试图确定一系列 $n$ 个离散假设（ $H_i = model + \theta_i$ ）中哪个是最可能的时，我们使用:</span>
<span id="cb101-1397"><a href="#cb101-1397" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1398"><a href="#cb101-1398" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-1399"><a href="#cb101-1399" aria-hidden="true" tabindex="-1"></a>P\left<span class="sc">\{</span> {H_i}|data \right<span class="sc">\}</span>=\frac{L\left<span class="sc">\{</span>data|{H_i}\right<span class="sc">\}</span>P\left<span class="sc">\{</span>{H_i} \right<span class="sc">\}</span>}{\sum\limits_{i=1}^{n}{\left<span class="co">[</span><span class="ot"> L\left\{ data|{H_i} \right\}P\left\{{H_i}\right\} \right</span><span class="co">]</span>}}  </span>
<span id="cb101-1400"><a href="#cb101-1400" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_49}</span>
<span id="cb101-1401"><a href="#cb101-1401" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1402"><a href="#cb101-1402" aria-hidden="true" tabindex="-1"></a>其中 $H_i$ 指的是被考虑的 $n$ 个假设中的 $i$ （假设是具有特定参数值集的特定模型），而数据只是模型拟合的数据。重要的是，$P <span class="sc">\{</span>H_i | data<span class="sc">\}</span>$ 是假设 $H_i$ 的**后验**概率(即 0 到 1 之间的严格概率)。这定义了除数 $\sum\limits_{i=1}^{n}{\left<span class="co">[</span><span class="ot"> L\left\{ data|{H_i} \right\}P\left\{{H_i}\right\} \right</span><span class="co">]</span>}$，重新调整后的概率总和为 1.0。在考虑观察数据之前，$P<span class="sc">\{</span>H_i <span class="sc">\}</span>$ 是假设的先验概率（模型加上特定的参数值）。同样，这是一个严格的概率，所有假设的先验值之和必须为 1。最后，$L\left<span class="sc">\{</span>data|H_i\right<span class="sc">\}</span>$ 是给定假设 $i$ 时数据的似然，正如之前在最大似然法部分所讨论的那样。</span>
<span id="cb101-1403"><a href="#cb101-1403" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1404"><a href="#cb101-1404" aria-hidden="true" tabindex="-1"></a>如果参数是连续变量（如von Bertalanffy 曲线中 $L_\infty$ 和 $K$），替代假设必须使用连续参数的向量来描述，而不是使用离散参数集的列表，这样贝叶斯条件概率就变成了连续的:</span>
<span id="cb101-1405"><a href="#cb101-1405" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1406"><a href="#cb101-1406" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb101-1407"><a href="#cb101-1407" aria-hidden="true" tabindex="-1"></a>P\left<span class="sc">\{</span> {H_i}|data \right<span class="sc">\}</span>=\frac{L\left<span class="sc">\{</span> data|{H_i} \right<span class="sc">\}</span>P\left({H_i} \right)}{\int\limits_{i=1}^{n}{L\left<span class="co">[</span><span class="ot"> \left\{data|{H_i}\right\}P\left\{{H_i}\right\} \right</span><span class="co">]</span>d{H_i}}}  </span>
<span id="cb101-1408"><a href="#cb101-1408" aria-hidden="true" tabindex="-1"></a>$$ {#eq-4_50}</span>
<span id="cb101-1409"><a href="#cb101-1409" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1410"><a href="#cb101-1410" aria-hidden="true" tabindex="-1"></a>在渔业和生态学中，要使用贝叶斯定理生成所需的后验分布，我们需要三样东西：</span>
<span id="cb101-1411"><a href="#cb101-1411" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1412"><a href="#cb101-1412" aria-hidden="true" tabindex="-1"></a><span class="ss">1.  </span>要考虑的模型假设列表（即我们要尝试的参数和模型的组合（或范围））；</span>
<span id="cb101-1413"><a href="#cb101-1413" aria-hidden="true" tabindex="-1"></a><span class="ss">2.  </span>计算每个假设 $i$ 下观测数据的概率密度所需的似然函数, $L\left<span class="sc">\{</span>data|H_i\right<span class="sc">\}</span>$ ；</span>
<span id="cb101-1414"><a href="#cb101-1414" aria-hidden="true" tabindex="-1"></a><span class="ss">3.  </span>每个假设 $i$ 的先验概率，标准化后所有先验概率之和等于 1.0。</span>
<span id="cb101-1415"><a href="#cb101-1415" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1416"><a href="#cb101-1416" aria-hidden="true" tabindex="-1"></a>除了对一组先验概率的要求之外，这与确定最大似然的要求完全相同。然而，先验概率的引入是一个很大的区别，也是我们将重点讨论的内容。这种方法的本质是利用数据信息更新先验概率。</span>
<span id="cb101-1417"><a href="#cb101-1417" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1418"><a href="#cb101-1418" aria-hidden="true" tabindex="-1"></a>如果模型中有许多参数需要估计，那么确定特定问题中的后验概率所涉及的整合工作就会耗费大量的计算机时间。用于确定贝叶斯后验分布的技术有很多，Gelman 等（2014）介绍了比较常用的方法。我们将介绍和讨论一种估算贝叶斯后验概率的灵活方法（MCMC），我们将在讨论不确定性特征的章节中使用这种方法。这实际上是一种新的模型拟合方法，但为了方便起见，我们将把它包含在有关不确定性的章节中。贝叶斯分析法的明确目标不仅仅是发现后验分布的模式，从最大似然的角度看，后验分布可能被认为代表了最优模型。相反，其目的是明确描述分析得出的不同可能结果的相对概率，即描述每个参数和模型输出的不确定性。可能会有一个最可能的结果，但它是在所有其他可能性的概率分布的背景下提出的。</span>
<span id="cb101-1419"><a href="#cb101-1419" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1420"><a href="#cb101-1420" aria-hidden="true" tabindex="-1"></a><span class="fu">### 先验概率</span></span>
<span id="cb101-1421"><a href="#cb101-1421" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1422"><a href="#cb101-1422" aria-hidden="true" tabindex="-1"></a>对于如何确定先验概率没有任何限制。人们可能已经从以前对同一物种的同一种群或不同种群的研究中对模型的参数有了很好的估计，或者至少对参数有了有用的限制（如不可能出现负增长或存活率 <span class="sc">\&gt;</span>1）。如果没有足够的信息来产生有参考价值的先验概率，通常会采用一组均匀或无信息的先验概率，即所有被考虑的假设都被赋予相等的先验概率。这样做的效果是在分析前给每个假设赋予相同的权重。当然，如果在分析中不考虑某一假设，这就等于给该假设（模型加上特定参数）分配了一个零权重或先验概率。</span>
<span id="cb101-1423"><a href="#cb101-1423" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1424"><a href="#cb101-1424" aria-hidden="true" tabindex="-1"></a>使用先验概率的想法之所以如此吸引人，原因之一是认为所有可能的参数值都具有同等可能性的想法有违直觉。渔业和生物学方面的任何经验都会让人对生物体的自然制约因素有先验知识。因此，举例来说，即使在彻底取样之前，就应该预料到深水（大于 800 米水深）鱼类物种，如橙连鳍鲑（*Hoplostethus atlanticus*），很可能寿命长、生长慢。这一特征反映了生活在低温和低生产力环境中的影响。贝叶斯方法的一大优势是，它允许人们摆脱所有可能性都具有同等可能性的反直觉假设。我们可以尝试在先验分布中捕捉模型中不同参数值的相对可能性。这样，先验知识就可以直接纳入分析。</span>
<span id="cb101-1425"><a href="#cb101-1425" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1426"><a href="#cb101-1426" aria-hidden="true" tabindex="-1"></a>使用先前信息可能引起争议的地方是在纳入意见时。例如，可以召集渔业利益相关者，了解他们对当前生物量等参数状况的看法（也许是相对于五年前的看法）。这种以委员会为基础的参数先验概率分布可以很容易地纳入贝叶斯分析，就像单独评估的结果一样（不是以前的评估，人们会认为以前的评估使用了大部分相同的数据，而是使用了独立的数据）。在正式分析中，是否应同样接受来自这些不同来源的先验数据，经常引起争论。Punt 和 Hilborn（1997，第 43 页）在一篇可读性很强的文章中讨论了先验来源的合理性问题：</span>
<span id="cb101-1427"><a href="#cb101-1427" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1428"><a href="#cb101-1428" aria-hidden="true" tabindex="-1"></a>*因此，我们强烈建议，无论何时进行贝叶斯评估，都应非常谨慎地充分记录各种先验分布的依据....。在选择先验函数形式时应小心谨慎，因为选择不当会导致不正确的推论。我们还注意到一种低估不确定性的倾向，即指定不切实际的先验信息--这种倾向应得到明确承认并加以避免。*</span>
<span id="cb101-1429"><a href="#cb101-1429" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1430"><a href="#cb101-1430" aria-hidden="true" tabindex="-1"></a>辩论的有效性的使用丰富的案底已经这样，walters 和 Ludwig （1994）建议非翔实的先验被用来作为一个默认在贝股的评估。 然而，除了不同意沃尔特斯和路德维希，平底船和Hilborn(1997年)突出强调的一个问题与我们的能力产生非翔实的前科(Box 和 Tiao,1973). 一个问题产生非翔实的先验是，他们感到特别测量系统( @fig-4-24). 因此，现有概率密度，是统一的线性规模将不代表一个统一的密度在一个日志的规模。</span>
<span id="cb101-1431"><a href="#cb101-1431" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1434"><a href="#cb101-1434" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb101-1435"><a href="#cb101-1435" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-4-24</span></span>
<span id="cb101-1436"><a href="#cb101-1436" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "A constant set of prior probabilities accumulated on a linear scale and on a log scale."</span></span>
<span id="cb101-1437"><a href="#cb101-1437" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1438"><a href="#cb101-1438" aria-hidden="true" tabindex="-1"></a> <span class="co"># can prior probabilities ever be uniniformative?  Figure 4.24  </span></span>
<span id="cb101-1439"><a href="#cb101-1439" aria-hidden="true" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">1000</span>  </span>
<span id="cb101-1440"><a href="#cb101-1440" aria-hidden="true" tabindex="-1"></a>y <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">/</span><span class="dv">1000</span>,<span class="dv">1000</span>)  </span>
<span id="cb101-1441"><a href="#cb101-1441" aria-hidden="true" tabindex="-1"></a>cumy <span class="ot">&lt;-</span> <span class="fu">cumsum</span>(y)  </span>
<span id="cb101-1442"><a href="#cb101-1442" aria-hidden="true" tabindex="-1"></a>group <span class="ot">&lt;-</span> <span class="fu">sort</span>(<span class="fu">rep</span>(<span class="fu">c</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">50</span>),<span class="dv">20</span>))  </span>
<span id="cb101-1443"><a href="#cb101-1443" aria-hidden="true" tabindex="-1"></a>xlab <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="dv">10</span>,<span class="dv">990</span>,<span class="dv">20</span>)  </span>
<span id="cb101-1444"><a href="#cb101-1444" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow=</span><span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">1</span>),<span class="at">mai=</span><span class="fu">c</span>(<span class="fl">0.45</span>,<span class="fl">0.3</span>,<span class="fl">0.05</span>,<span class="fl">0.05</span>),<span class="at">oma=</span><span class="fu">c</span>(<span class="fl">0.0</span>,<span class="fl">1.0</span>,<span class="fl">0.0</span>,<span class="fl">0.0</span>))   </span>
<span id="cb101-1445"><a href="#cb101-1445" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">cex=</span><span class="fl">0.75</span>, <span class="at">mgp=</span><span class="fu">c</span>(<span class="fl">1.35</span>,<span class="fl">0.35</span>,<span class="dv">0</span>), <span class="at">font.axis=</span><span class="dv">7</span>,<span class="at">font=</span><span class="dv">7</span>,<span class="at">font.lab=</span><span class="dv">7</span>)    </span>
<span id="cb101-1446"><a href="#cb101-1446" aria-hidden="true" tabindex="-1"></a>yval <span class="ot">&lt;-</span> <span class="fu">tapply</span>(y,group,sum)  </span>
<span id="cb101-1447"><a href="#cb101-1447" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(x,cumy,<span class="at">type=</span><span class="st">"p"</span>,<span class="at">pch=</span><span class="dv">16</span>,<span class="at">cex=</span><span class="fl">0.5</span>,<span class="at">panel.first=</span><span class="fu">grid</span>(),  </span>
<span id="cb101-1448"><a href="#cb101-1448" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlim=</span><span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1000</span>),<span class="at">ylim=</span><span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1</span>),<span class="at">ylab=</span><span class="st">""</span>,<span class="at">xlab=</span><span class="st">"Linear Scale"</span>)  </span>
<span id="cb101-1449"><a href="#cb101-1449" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">log</span>(x),cumy,<span class="at">type=</span><span class="st">"p"</span>,<span class="at">pch=</span><span class="dv">16</span>,<span class="at">cex=</span><span class="fl">0.5</span>,<span class="at">panel.first=</span><span class="fu">grid</span>(),  </span>
<span id="cb101-1450"><a href="#cb101-1450" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlim=</span><span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">7</span>),<span class="at">xlab=</span><span class="st">"Logarithmic Scale"</span>,<span class="at">ylab=</span><span class="st">""</span>)  </span>
<span id="cb101-1451"><a href="#cb101-1451" aria-hidden="true" tabindex="-1"></a><span class="fu">mtext</span>(<span class="st">"Cumulative Probability"</span>,<span class="at">side=</span><span class="dv">2</span>,<span class="at">outer=</span><span class="cn">TRUE</span>,<span class="at">cex=</span><span class="fl">0.9</span>,<span class="at">font=</span><span class="dv">7</span>)  </span>
<span id="cb101-1452"><a href="#cb101-1452" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb101-1453"><a href="#cb101-1453" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1454"><a href="#cb101-1454" aria-hidden="true" tabindex="-1"></a>由于渔业模型往往充满非线性关系，使用非信息先验是有争议的，因为对某些参 数非信息先验很可能对其他参数有信息影响。虽然这种影响可能是无意的，但却不容忽视。这意味着信息可能以完全无意的方式被纳入模型，这也是讨论先验概率时争议的一个来源。如果要使用先验概率，那么 Punt 和 Hilborn（1997 年）关于充分记录先验概率的起源和属性的建议是非常明智的。我们将在 “不确定性 ”一章中更详细地探讨贝叶斯方法的使用。</span>
<span id="cb101-1455"><a href="#cb101-1455" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1456"><a href="#cb101-1456" aria-hidden="true" tabindex="-1"></a><span class="fu">## 结语</span></span>
<span id="cb101-1457"><a href="#cb101-1457" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1458"><a href="#cb101-1458" aria-hidden="true" tabindex="-1"></a>在任何分析情况下，使用哪种方法最合适在很大程度上取决于分析的目标。如果只想找到模型的最佳拟合方法，那么使用最小二乘法、最大似然法还是贝叶斯法其实并不重要。有时，先用最小二乘法拟合模型，然后再用似然法或贝叶斯法建立置信区间和进行风险评估，可能会更容易一些。</span>
<span id="cb101-1459"><a href="#cb101-1459" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1460"><a href="#cb101-1460" aria-hidden="true" tabindex="-1"></a>模型参数和输出的置信区间可以用传统的渐近方法（保证对称，对于强非线性模型，只能大致近似）、似然法或贝叶斯后验积分法（两者显然密切相关）来生成，也可以用引导法或蒙特卡洛技术。</span>
<span id="cb101-1461"><a href="#cb101-1461" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-1462"><a href="#cb101-1462" aria-hidden="true" tabindex="-1"></a>并不是说只有使用贝叶斯方法才能更详细地评估备选管理方案的相对风险。Bootstrapping 和 Monte Carlo 方法为开展此类工作提供了必要的工具。首要问题是确定分析目标。然而，如果在拟合模型时，不对每个参数的不确定性以及模型对各种输入参数动态的敏感性有一定的了解，那将是一种糟糕的做法。由于各种方法之间没有明显的优胜者，如果有时间，使用一种以上的方法（特别是比较似然概 念、贝叶斯后验和引导法）是一个合理的想法。至于是否有足够的资源让资源建模者有时间进行这一系列分析，则是一个不同但同样现实的问题。如果发现存在重大差异，那么最好对其背后的原因进行调查。如果不同的程序得出的答案大相径庭，则可能是对现有数据的要求过高，需要进行不同的分析。</span>
</code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->



</body></html>