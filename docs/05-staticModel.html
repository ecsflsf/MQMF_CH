<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-Hans" xml:lang="zh-Hans"><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>使用 R 语言进行渔业建模和定量方法研究 - 5&nbsp; 静态模型</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>

<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./06-uncertainty.html" rel="next">
<link href="./04-application.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark"><script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "没有结果",
    "search-matching-documents-text": "匹配的文档",
    "search-copy-link-title": "复制搜索链接",
    "search-hide-matches-text": "隐藏其它匹配结果",
    "search-more-match-text": "更多匹配结果",
    "search-more-matches-text": "更多匹配结果",
    "search-clear-button-title": "清除",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "取消",
    "search-submit-button-title": "提交",
    "search-label": "搜索"
  }
}</script><script>
    MathJax ={
  tex: {
    macros: {
      bm: ["{\\boldsymbol #1}",1],
    }
  }
};
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>
</head>
<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top"><nav class="quarto-secondary-nav"><div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="切换侧边栏导航" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./05-staticModel.html"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">静态模型</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="切换侧边栏导航" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav></header><!-- content --><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto"><div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">使用 R 语言进行渔业建模和定量方法研究</a> 
        <div class="sidebar-tools-main">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="切换深色模式"><i class="bi"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="搜索"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01-intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">关于建模</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-NonIntroductiontoR.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">R 语言的不完全介绍</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03-simpopmodel.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">简单种群模型</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04-application.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">模型参数估算</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05-staticModel.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">静态模型</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06-uncertainty.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">不确定性</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07-spm.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">剩余生产模型</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08-references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">参考文献</span></a>
  </div>
</li>
    </ul>
</div>
</nav><div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="2"><h2 id="toc-title">目录</h2>
   
  <ul>
<li><a href="#%E7%AE%80%E4%BB%8B" id="toc-简介" class="nav-link active" data-scroll-target="#%E7%AE%80%E4%BB%8B"><span class="header-section-number">5.1</span> 简介</a></li>
  <li><a href="#%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%8F%82%E6%95%B0" id="toc-生产力参数" class="nav-link" data-scroll-target="#%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%8F%82%E6%95%B0"><span class="header-section-number">5.2</span> 生产力参数</a></li>
  <li>
<a href="#%E7%94%9F%E9%95%BF" id="toc-生长" class="nav-link" data-scroll-target="#%E7%94%9F%E9%95%BF"><span class="header-section-number">5.3</span> 生长</a>
  <ul class="collapse">
<li><a href="#%E5%AD%A3%E8%8A%82%E6%80%A7%E7%94%9F%E9%95%BF%E6%9B%B2%E7%BA%BF" id="toc-季节性生长曲线" class="nav-link" data-scroll-target="#%E5%AD%A3%E8%8A%82%E6%80%A7%E7%94%9F%E9%95%BF%E6%9B%B2%E7%BA%BF"><span class="header-section-number">5.3.1</span> 季节性生长曲线</a></li>
  <li><a href="#%E6%A0%87%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%9A%84-fabens-%E6%96%B9%E6%B3%95" id="toc-标记数据的-fabens-方法" class="nav-link" data-scroll-target="#%E6%A0%87%E8%AE%B0%E6%95%B0%E6%8D%AE%E7%9A%84-fabens-%E6%96%B9%E6%B3%95"><span class="header-section-number">5.3.2</span> 标记数据的 Fabens 方法</a></li>
  <li><a href="#%E6%8B%9F%E5%90%88%E6%A0%87%E8%AE%B0%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B" id="toc-拟合标记数据模型" class="nav-link" data-scroll-target="#%E6%8B%9F%E5%90%88%E6%A0%87%E8%AE%B0%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="header-section-number">5.3.3</span> 拟合标记数据模型</a></li>
  <li><a href="#%E5%AF%B9-fabens-%E6%96%B9%E6%B3%95%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8" id="toc-对-fabens-方法的深入探讨" class="nav-link" data-scroll-target="#%E5%AF%B9-fabens-%E6%96%B9%E6%B3%95%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8"><span class="header-section-number">5.3.4</span> 对 Fabens 方法的深入探讨</a></li>
  <li><a href="#%E9%9D%9E%E6%81%92%E5%AE%9A%E6%96%B9%E5%B7%AE%E7%9A%84%E5%AE%9E%E7%8E%B0" id="toc-非恒定方差的实现" class="nav-link" data-scroll-target="#%E9%9D%9E%E6%81%92%E5%AE%9A%E6%96%B9%E5%B7%AE%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="header-section-number">5.3.5</span> 非恒定方差的实现</a></li>
  </ul>
</li>
  <li>
<a href="#sec-label" id="toc-sec-label" class="nav-link" data-scroll-target="#sec-label"><span class="header-section-number">5.4</span> 目标模型选择</a>
  <ul class="collapse">
<li><a href="#akaike-%E4%BF%A1%E6%81%AF%E5%87%86%E5%88%99" id="toc-akaike-信息准则" class="nav-link" data-scroll-target="#akaike-%E4%BF%A1%E6%81%AF%E5%87%86%E5%88%99"><span class="header-section-number">5.4.1</span> Akaike 信息准则</a></li>
  <li><a href="#%E4%BC%BC%E7%84%B6%E6%AF%94%E6%A3%80%E9%AA%8C" id="toc-似然比检验" class="nav-link" data-scroll-target="#%E4%BC%BC%E7%84%B6%E6%AF%94%E6%A3%80%E9%AA%8C"><span class="header-section-number">5.4.2</span> 似然比检验</a></li>
  <li><a href="#%E4%BC%BC%E7%84%B6%E6%AF%94%E6%A3%80%E9%AA%8C%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" id="toc-似然比检验的注意事项" class="nav-link" data-scroll-target="#%E4%BC%BC%E7%84%B6%E6%AF%94%E6%A3%80%E9%AA%8C%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="header-section-number">5.4.3</span> 似然比检验的注意事项</a></li>
  </ul>
</li>
  <li><a href="#%E5%85%B3%E4%BA%8E%E7%94%9F%E9%95%BF%E7%9A%84%E8%AF%B4%E6%98%8E" id="toc-关于生长的说明" class="nav-link" data-scroll-target="#%E5%85%B3%E4%BA%8E%E7%94%9F%E9%95%BF%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="header-section-number">5.5</span> 关于生长的说明</a></li>
  <li>
<a href="#%E6%88%90%E7%86%9F" id="toc-成熟" class="nav-link" data-scroll-target="#%E6%88%90%E7%86%9F"><span class="header-section-number">5.6</span> 成熟</a>
  <ul class="collapse">
<li><a href="#%E5%BC%95%E8%A8%80" id="toc-引言" class="nav-link" data-scroll-target="#%E5%BC%95%E8%A8%80"><span class="header-section-number">5.6.1</span> 引言</a></li>
  <li><a href="#%E6%9B%BF%E4%BB%A3%E7%9A%84%E6%88%90%E7%86%9F%E5%BA%A6%E6%9B%B2%E7%BA%BF" id="toc-替代的成熟度曲线" class="nav-link" data-scroll-target="#%E6%9B%BF%E4%BB%A3%E7%9A%84%E6%88%90%E7%86%9F%E5%BA%A6%E6%9B%B2%E7%BA%BF"><span class="header-section-number">5.6.2</span> 替代的成熟度曲线</a></li>
  <li><a href="#%E5%AF%B9%E7%A7%B0%E6%80%A7%E5%81%87%E8%AE%BE" id="toc-对称性假设" class="nav-link" data-scroll-target="#%E5%AF%B9%E7%A7%B0%E6%80%A7%E5%81%87%E8%AE%BE"><span class="header-section-number">5.6.3</span> 对称性假设</a></li>
  </ul>
</li>
  <li>
<a href="#%E8%A1%A5%E5%85%85%E9%87%8F" id="toc-补充量" class="nav-link" data-scroll-target="#%E8%A1%A5%E5%85%85%E9%87%8F"><span class="header-section-number">5.7</span> 补充量</a>
  <ul class="collapse">
<li><a href="#%E5%BC%95%E8%A8%80-1" id="toc-引言-1" class="nav-link" data-scroll-target="#%E5%BC%95%E8%A8%80-1"><span class="header-section-number">5.7.1</span> 引言</a></li>
  <li><a href="#%E8%89%AF%E5%A5%BD%E7%A7%8D%E7%BE%A4%E8%A1%A5%E5%85%85%E9%87%8F%E5%85%B3%E7%B3%BB%E7%9A%84%E6%80%A7%E8%B4%A8" id="toc-良好种群补充量关系的性质" class="nav-link" data-scroll-target="#%E8%89%AF%E5%A5%BD%E7%A7%8D%E7%BE%A4%E8%A1%A5%E5%85%85%E9%87%8F%E5%85%B3%E7%B3%BB%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="header-section-number">5.7.2</span> “良好”种群补充量关系的性质</a></li>
  <li><a href="#%E8%A1%A5%E5%85%85%E5%9E%8B%E8%BF%87%E5%BA%A6%E6%8D%95%E6%8D%9E" id="toc-补充型过度捕捞" class="nav-link" data-scroll-target="#%E8%A1%A5%E5%85%85%E5%9E%8B%E8%BF%87%E5%BA%A6%E6%8D%95%E6%8D%9E"><span class="header-section-number">5.7.3</span> 补充型过度捕捞</a></li>
  <li><a href="#beverton-holt-%E8%A1%A5%E5%85%85%E9%87%8F" id="toc-beverton-holt-补充量" class="nav-link" data-scroll-target="#beverton-holt-%E8%A1%A5%E5%85%85%E9%87%8F"><span class="header-section-number">5.7.4</span> Beverton-Holt 补充量</a></li>
  <li><a href="#ricker-%E8%A1%A5%E5%85%85%E9%87%8F" id="toc-ricker-补充量" class="nav-link" data-scroll-target="#ricker-%E8%A1%A5%E5%85%85%E9%87%8F"><span class="header-section-number">5.7.5</span> Ricker 补充量</a></li>
  <li><a href="#deriso-%E7%9A%84%E9%80%9A%E7%94%A8%E6%A8%A1%E5%9E%8B" id="toc-deriso-的通用模型" class="nav-link" data-scroll-target="#deriso-%E7%9A%84%E9%80%9A%E7%94%A8%E6%A8%A1%E5%9E%8B"><span class="header-section-number">5.7.6</span> Deriso 的通用模型</a></li>
  <li><a href="#%E9%87%8D%E6%96%B0%E5%8F%82%E6%95%B0%E5%8C%96%E7%9A%84-beverton-holt-%E6%96%B9%E7%A8%8B" id="toc-重新参数化的-beverton-holt-方程" class="nav-link" data-scroll-target="#%E9%87%8D%E6%96%B0%E5%8F%82%E6%95%B0%E5%8C%96%E7%9A%84-beverton-holt-%E6%96%B9%E7%A8%8B"><span class="header-section-number">5.7.7</span> 重新参数化的 Beverton-Holt 方程</a></li>
  <li><a href="#%E9%87%8D%E6%96%B0%E5%8F%82%E6%95%B0%E5%8C%96%E7%9A%84-ricker-%E6%96%B9%E7%A8%8B" id="toc-重新参数化的-ricker-方程" class="nav-link" data-scroll-target="#%E9%87%8D%E6%96%B0%E5%8F%82%E6%95%B0%E5%8C%96%E7%9A%84-ricker-%E6%96%B9%E7%A8%8B"><span class="header-section-number">5.7.8</span> 重新参数化的 Ricker 方程</a></li>
  </ul>
</li>
  <li>
<a href="#%E9%80%89%E6%8B%A9%E6%80%A7" id="toc-选择性" class="nav-link" data-scroll-target="#%E9%80%89%E6%8B%A9%E6%80%A7"><span class="header-section-number">5.8</span> 选择性</a>
  <ul class="collapse">
<li><a href="#%E5%BC%95%E8%A8%80-2" id="toc-引言-2" class="nav-link" data-scroll-target="#%E5%BC%95%E8%A8%80-2"><span class="header-section-number">5.8.1</span> 引言</a></li>
  <li><a href="#%E9%80%BB%E8%BE%91%E6%96%AF%E8%92%82%E9%80%89%E6%8B%A9" id="toc-逻辑斯蒂选择" class="nav-link" data-scroll-target="#%E9%80%BB%E8%BE%91%E6%96%AF%E8%92%82%E9%80%89%E6%8B%A9"><span class="header-section-number">5.8.2</span> 逻辑斯蒂选择</a></li>
  <li><a href="#%E7%90%83%E9%9D%A2%E9%80%89%E6%8B%A9%E6%80%A7" id="toc-球面选择性" class="nav-link" data-scroll-target="#%E7%90%83%E9%9D%A2%E9%80%89%E6%8B%A9%E6%80%A7"><span class="header-section-number">5.8.3</span> 球面选择性</a></li>
  </ul>
</li>
  <li><a href="#%E9%9D%99%E6%80%81%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%BB%93%E8%AE%BA%E6%80%A7%E8%AF%84%E8%BF%B0" id="toc-静态模型的结论性评述" class="nav-link" data-scroll-target="#%E9%9D%99%E6%80%81%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%BB%93%E8%AE%BA%E6%80%A7%E8%AF%84%E8%BF%B0"><span class="header-section-number">5.9</span> 静态模型的结论性评述</a></li>
  <li><a href="#%E9%99%84%E5%BD%95fabens-%E5%8F%98%E6%8D%A2%E7%9A%84%E6%8E%A8%E5%AF%BC" id="toc-附录fabens-变换的推导" class="nav-link" data-scroll-target="#%E9%99%84%E5%BD%95fabens-%E5%8F%98%E6%8D%A2%E7%9A%84%E6%8E%A8%E5%AF%BC"><span class="header-section-number">5.10</span> 附录：Fabens 变换的推导</a></li>
  <li><a href="#%E9%99%84%E5%BD%95beverton-holt-%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%87%8D%E6%96%B0%E5%8F%82%E6%95%B0%E5%8C%96" id="toc-附录beverton-holt-模型的重新参数化" class="nav-link" data-scroll-target="#%E9%99%84%E5%BD%95beverton-holt-%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%87%8D%E6%96%B0%E5%8F%82%E6%95%B0%E5%8C%96"><span class="header-section-number">5.11</span> 附录：Beverton-Holt 模型的重新参数化</a></li>
  </ul></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block default"><div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title"><span id="sec-staticmodel" class="quarto-section-identifier"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">静态模型</span></span></h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> 代码</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">显示所有代码</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">隐藏所有代码</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">查看源代码</a></li></ul></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header><section id="简介" class="level2" data-number="5.1"><h2 data-number="5.1" class="anchored" data-anchor-id="简介">
<span class="header-section-number">5.1</span> 简介</h2>
<p>在本书中，我们将重点讨论相对简单的种群模型，但也将开始为理解更复杂模型的某些要求做准备。我们所说的 “更复杂”是指通常用于模拟捕捞种群动态的年龄结构模型。然而，我们可以利用这些更复杂模型的组成部分来说明我们可以称之为 “静态模型”的数据拟合。静态模型用于描述个体生长过程的方程形式、成熟度如何随年龄或体型变化、补充与成熟或产卵生物量之间的 “种群-补充”关系，以及渔具对被捕捞种群的选择性。这种静态模型显示了相关变量（年龄长度、成熟年龄或长度等）之间的函数关系，而且这些关系被赋予了一个相当大的假设，即随着时间的推移保持不变。</p>
<p>这种静态模型与我们所说的动态模型形成对比，动态模型试图描述诸如资源量变化之类的过程，其中估算的值是早期资源量的函数。这样的动态模型总是包含一个自我参考的元素，可能还有其他驱动因素，所有这些都有助于我们试图描述或建模的动态。</p>
<p>在某些情况下，如果假定静态或稳定的过程发生了明显的变化，这些本应是静态的关系可能会被 “时间阻断”，这意味着假定这些关系在两个不同的时间段之间以阶梯状的方式发生变化。实际上，如果这些过程发生了变化，很可能是在一段时期内比较平稳地发生了变化，但遗憾的是，拥有足够的数据来很好地描述这种渐进的变化通常是不可能的。</p>
<p>我们首先用这类模型来实现更多的例子，因为正如我们在第 <a href="04-application.html" class="quarto-xref"><span>4</span></a> 章 “<a href="./04-application.html">模型参数估计</a>（<em>Model Parameter Estimation</em>）”中所看到的，这些静态模型往往比具有足够灵活性来描述动态过程的模型更容易实现。</p>
</section><section id="生产力参数" class="level2" data-number="5.2"><h2 data-number="5.2" class="anchored" data-anchor-id="生产力参数">
<span class="header-section-number">5.2</span> 生产力参数</h2>
<p>顾名思义，所有的生物种群都是由个体集合而成的，因此会表现出一些新出现的特性，这些特性部分地概括了这些种群的特性。鉴于目前正在发生的许多物种灭绝事件，我同意，一个物种中的少数甚至单个个体可能会构成 “种群（population）”的某种限制，但我们将只关注更丰富的种群，而撇开这些可悲的极端情况。在这里，我们将重点关注个体的生长、成熟和补充，所有这些都与种群的生产力有关。与生长快、成熟早、繁殖力高的物种相比，生长慢、成熟晚、繁殖力低的物种的生产力往往较低，尽管其潜在稳定性更高。生命史特征的进化是一个复杂而又引人入胜的课题，我建议大家对其进行研究 <span class="citation" data-cites="beverton1993a stearns1977 stearns1992">(<a href="08-references.html#ref-beverton1993a" role="doc-biblioref">Beverton 和 Holt 1993</a>; <a href="08-references.html#ref-stearns1977" role="doc-biblioref">S. C. Stearns 1977</a>; <a href="08-references.html#ref-stearns1992" role="doc-biblioref">S. Stearns 1992</a>)</span>。不过，在这里我们将重点讨论简单得多的模型。即便如此，在对捕捞种群进行建模时，了解相关物种的生命史特征可能产生的影响，对于解释观察到的动态变化还是很有帮助的。不要忘记，生物过程建模极大地受益于生物知识和理解。</p>
</section><section id="生长" class="level2" data-number="5.3"><h2 data-number="5.3" class="anchored" data-anchor-id="生长">
<span class="header-section-number">5.3</span> 生长</h2>
<p>忽略任何潜在的迁入和迁出，种群生产力是种群中新个体的补充和种群中已有个体的生长的综合结果。这些都是积极因素，而自然死亡率以及捕捞种群中的捕捞死亡率等消极因素则抵消了这些积极因素。个体生长的重要性是渔业生态学中有大量关于个体生长的文献的原因之一（Summerfelt 和 Hall，1987）。尽管我刚才写到，如果要建立模型，了解生物过程非常重要，但其中大部分文献都与生长生物学有关，我们将忽略这些文献。相反，我们将专注于个体生长的数学描述。重点在于描述，这一点很重要，因为有些人似乎过于偏爱特定的生长模型，而这些模型仅仅描述了生长过程，并没有真正解释生长过程。</p>
<p>在第 <a href="04-application.html" class="quarto-xref"><span>4</span></a> 章 “<a href="./04-application.html">模型参数估算</a>”中，我们已经介绍了可用于描述年龄-长度的三种候选模型 （von Bertalanffy、Gompertz 和 Michaelis-Menton），因此我们不再重新讨论这些模型。相反，我们将考虑描述生长的另外两个方面。在年龄-长度方面，我们将研究与季节性生长模型有关的观点，尽管这些观点在淡水系统中很重要，但往往用处有限。更常用的是，我们还将研究如何从标记数据中估计个体生长情况。</p>
<p>在本章中，我们将主要讨论 von Bertalanffy 生长曲线以及使用函数 <code>vB()</code> 对其进行的拓展：</p>
<p><span id="eq-5_1"><span class="math display">\[
L_t = L_{\infty} \left(1 - e^{-K(t - t_0)} \right )
\qquad(5.1)\]</span></span></p>
<section id="季节性生长曲线" class="level3" data-number="5.3.1"><h3 data-number="5.3.1" class="anchored" data-anchor-id="季节性生长曲线">
<span class="header-section-number">5.3.1</span> 季节性生长曲线</h3>
<p>生长速度是一个复杂的过程，不仅受每种动物的体长或年龄的影响，还受环境条件的影响。因此，在温带和极地地区，全年温度变化很大，生长率也会随季节变化。这可以表现为鱼类耳骨（耳石）和其他坚硬部位的确切生长环，它们源于一年中新陈代谢的变化。当然，还有其他因素和事件带来的复杂性和不确定性（例如，硬壳中的假环），但在此我们还是要把重点放在对数据的描述上，假定在分析之前已经解决了这些复杂性（实际情况往往与此不同，不要低估收集有效渔业数据的难度！）。</p>
<p>不同的季节性生长模型已很多，但在此我们将使用 <span class="citation" data-cites="pitcher1973">Pitcher 和 Macdonald (<a href="08-references.html#ref-pitcher1973" role="doc-biblioref">1973</a>)</span> 提出的一个模型，对 von Bertalanffy 生长曲线进行了修改，在生长率项中加入了正弦波，试图将周期性水温作为生长率的驱动因素，使生长率在冬季减慢，在夏季加快。</p>
<p><span id="eq-5_2"><span class="math display">\[
{L}_{t}={{L}_{\infty }}\left( 1-{{e}^{-\left[ C\sin \left( \frac{2\pi \left( t-s \right)}{52} \right)+K(t-{{t}_{0}} \right]}} \right)
\qquad(5.2)\]</span></span></p>
<p>其中 <span class="math inline">\(L_{\infty}\)</span> 、<span class="math inline">\(K\)</span> 和 <span class="math inline">\(t_0\)</span> 是 von Bertalanffy 参数，<span class="math inline">\(t\)</span> 是长度 <span class="math inline">\(L_t\)</span> 的周龄， <span class="math inline">\(C\)</span> 决定了围绕非季节性增长曲线的振荡幅度，<span class="math inline">\(s\)</span> 是正弦波在年份中的起点，使用常数 52 反映了使用周作为年内时间步长的单位。如果我们使用月或日作为取样事件之间的时间单位，那么我们将分别使用 12 或 365。我们可以使用 <span class="citation" data-cites="pitcher1973">Pitcher 和 Macdonald (<a href="08-references.html#ref-pitcher1973" role="doc-biblioref">1973</a>)</span> 对英国淡水鲦鱼（<em>Phoxinus phoxinus</em>；虽然鲦鱼的数据是从他们的图中读取的，因此只是近似正确，但足以说明问题）研究的数据。</p>
<p>首先，我们可以绘制现有数据并拟合一条标准的非季节性 von Bertalanffy 生长曲线。拟合曲线使用的是正态随机误差而非对数正态误差，因此我们使用了 <code>negNLL()</code> 函数。使用 <code>ssq()</code> 函数也是可行的，但由于我们对预测曲线的变化特别感兴趣，因此下文将继续使用 <code>negNLL()</code>。如果我们忽略季节性趋势，那么预计曲线周围的变化（由 <em>sigma</em> 参数描述）将相对较大。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb1"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#vB growth curve fit to Pitcher and Macdonald derived seasonal data  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="va">minnow</span><span class="op">)</span>; <span class="va">week</span> <span class="op">&lt;-</span> <span class="va">minnow</span><span class="op">$</span><span class="va">week</span>; <span class="va">length</span> <span class="op">&lt;-</span> <span class="va">minnow</span><span class="op">$</span><span class="va">length</span>  </span>
<span><span class="va">pars</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">75</span>,<span class="fl">0.1</span>,<span class="op">-</span><span class="fl">10.0</span>,<span class="fl">3.5</span><span class="op">)</span>; <span class="va">label</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Linf"</span>,<span class="st">"K"</span>,<span class="st">"t0"</span>,<span class="st">"sigma"</span><span class="op">)</span>  </span>
<span><span class="va">bestvB</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/nlm.html">nlm</a></span><span class="op">(</span>f<span class="op">=</span><span class="va">negNLL</span>,p<span class="op">=</span><span class="va">pars</span>,funk<span class="op">=</span><span class="va">vB</span>,ages<span class="op">=</span><span class="va">week</span>,observed<span class="op">=</span><span class="va">length</span>,  </span>
<span>              typsize<span class="op">=</span><span class="fu">magnitude</span><span class="op">(</span><span class="va">pars</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="va">predL</span> <span class="op">&lt;-</span> <span class="fu">vB</span><span class="op">(</span><span class="va">bestvB</span><span class="op">$</span><span class="va">estimate</span>,<span class="fl">0</span><span class="op">:</span><span class="fl">160</span><span class="op">)</span>  </span>
<span><span class="fu">outfit</span><span class="op">(</span><span class="va">bestvB</span>,backtran <span class="op">=</span> <span class="cn">FALSE</span>,title<span class="op">=</span><span class="st">"Non-Seasonal vB"</span>,parnames<span class="op">=</span><span class="va">label</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>nlm solution:  Non-Seasonal vB 
minimum     :  150.6117 
iterations  :  41 
code        :  3 Either ~local min or steptol too small 
                par      gradient
Linf   89.447640823  5.878821e-05
K       0.009909338  2.705709e-01
t0    -16.337065207 -4.717809e-05
sigma   3.741419172  2.711355e-04</code></pre>
</div>
</div>
<p>根据季节性数据拟合的标准 von Bertalanffy 曲线 <a href="#eq-5_1" class="quarto-xref">公式&nbsp;<span>5.1</span></a> ，其 <em>sigma</em> 参数约为 <span class="math inline">\(3.7\)</span>，这只是反映了一个事实，即数据围绕平均增长曲线摆动，因此残差会相对较大。如果我们使用季节性调整曲线，这种变化会大大减少，因此我们可以预测 <em>sigma</em> 应该小得多。为了拟合季节性增长曲线，我们需要定义一个反映新模型结构的修改后 <code>vB()</code> 函数 <a href="#eq-5_2" class="quarto-xref">公式&nbsp;<span>5.2</span></a>。当然，在拟合任何新模型时，第一步必然是需要一个函数来根据一组参数生成预测值。我们可以将负对数似然的计算包含在这个新函数中，但将预测长度的生成保留在一个单独的函数中可以增加我们代码的灵活性。因此，我们将坚持分别使用预测函数和负对数似然计算函数的策略。在参数向量 <em>pars</em> 中，我们还需要包含 <a href="#eq-5_2" class="quarto-xref">公式&nbsp;<span>5.2</span></a> 中 <span class="math inline">\(C\)</span> 和 <span class="math inline">\(s\)</span> 的初始估计值。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb3"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#plot the non-seasonal fit and its residuals.  Figure 5.1  </span></span>
<span><span class="fu">parset</span><span class="op">(</span>plots<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">)</span>,margin<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.35</span>,<span class="fl">0.45</span>,<span class="fl">0.02</span>,<span class="fl">0.05</span><span class="op">)</span><span class="op">)</span>   </span>
<span><span class="fu">plot1</span><span class="op">(</span><span class="va">week</span>,<span class="va">length</span>,type<span class="op">=</span><span class="st">"p"</span>,cex<span class="op">=</span><span class="fl">1.0</span>,col<span class="op">=</span><span class="fl">2</span>,xlab<span class="op">=</span><span class="st">"Weeks"</span>,pch<span class="op">=</span><span class="fl">16</span>,  </span>
<span>      ylab<span class="op">=</span><span class="st">"Length (mm)"</span>,defpar<span class="op">=</span><span class="cn">FALSE</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="fl">0</span><span class="op">:</span><span class="fl">160</span>,<span class="va">predL</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">1</span><span class="op">)</span>  </span>
<span> <span class="co"># calculate and plot the residuals  </span></span>
<span><span class="va">resids</span> <span class="op">&lt;-</span> <span class="va">length</span> <span class="op">-</span> <span class="fu">vB</span><span class="op">(</span><span class="va">bestvB</span><span class="op">$</span><span class="va">estimate</span>,<span class="va">week</span><span class="op">)</span>  </span>
<span><span class="fu">plot1</span><span class="op">(</span><span class="va">week</span>,<span class="va">resids</span>,type<span class="op">=</span><span class="st">"l"</span>,col<span class="op">=</span><span class="st">"darkgrey"</span>,cex<span class="op">=</span><span class="fl">0.9</span>,lwd<span class="op">=</span><span class="fl">2</span>,  </span>
<span>    xlab<span class="op">=</span><span class="st">"Weeks"</span>,lty<span class="op">=</span><span class="fl">3</span>,ylab<span class="op">=</span><span class="st">"Normal Residuals"</span>,defpar<span class="op">=</span><span class="cn">FALSE</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html">points</a></span><span class="op">(</span><span class="va">week</span>,<span class="va">resids</span>,pch<span class="op">=</span><span class="fl">16</span>,cex<span class="op">=</span><span class="fl">1.1</span>,col<span class="op">=</span><span class="st">"red"</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html">abline</a></span><span class="op">(</span>h<span class="op">=</span><span class="fl">0</span>,col<span class="op">=</span><span class="fl">1</span>,lwd<span class="op">=</span><span class="fl">1</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-5-1" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-5-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="05-staticModel_files/figure-html/fig-5-1-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-5-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;5.1: 年龄长度数据来自 Pitcher 和 Macdonald（1973 年），与最佳拟合的 von Bertalanffy 曲线相比， 显示出生长率的强烈季节性波动。下图中的正态随机残差的季节性模式非常明显，并随着年龄的增长而减小。
</figcaption></figure>
</div>
</div>
</div>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb4"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co"># Fit seasonal vB curve, parameters = Linf, K, t0, C, s, sigma  </span></span>
<span><span class="va">svb</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">p</span>,<span class="va">ages</span>,<span class="va">inc</span><span class="op">=</span><span class="fl">52</span><span class="op">)</span> <span class="op">{</span>  </span>
<span>  <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="va">p</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">*</span><span class="op">(</span><span class="fl">1</span> <span class="op">-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="op">-</span><span class="op">(</span><span class="va">p</span><span class="op">[</span><span class="fl">4</span><span class="op">]</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/Trig.html">sin</a></span><span class="op">(</span><span class="fl">2</span><span class="op">*</span><span class="va">pi</span><span class="op">*</span><span class="op">(</span><span class="va">ages</span> <span class="op">-</span> <span class="va">p</span><span class="op">[</span><span class="fl">5</span><span class="op">]</span><span class="op">)</span><span class="op">/</span><span class="va">inc</span><span class="op">)</span> <span class="op">+</span>   </span>
<span>                           <span class="va">p</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span> <span class="op">*</span> <span class="op">(</span><span class="va">ages</span> <span class="op">-</span> <span class="va">p</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="op">}</span> <span class="co"># end of svB  </span></span>
<span><span class="va">spars</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">bestvB</span><span class="op">$</span><span class="va">estimate</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span><span class="op">]</span>,<span class="fl">0.1</span>,<span class="fl">5</span>,<span class="fl">2.0</span><span class="op">)</span>  <span class="co"># keep sigma at end  </span></span>
<span><span class="va">bestsvb</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/nlm.html">nlm</a></span><span class="op">(</span>f<span class="op">=</span><span class="va">negNLL</span>,p<span class="op">=</span><span class="va">spars</span>,funk<span class="op">=</span><span class="va">svb</span>,ages<span class="op">=</span><span class="va">week</span>,observed<span class="op">=</span><span class="va">length</span>,  </span>
<span>              typsize<span class="op">=</span><span class="fu">magnitude</span><span class="op">(</span><span class="va">spars</span><span class="op">)</span><span class="op">)</span>   </span>
<span><span class="va">predLs</span> <span class="op">&lt;-</span> <span class="fu">svb</span><span class="op">(</span><span class="va">bestsvb</span><span class="op">$</span><span class="va">estimate</span>,<span class="fl">0</span><span class="op">:</span><span class="fl">160</span><span class="op">)</span>  </span>
<span><span class="fu">outfit</span><span class="op">(</span><span class="va">bestsvb</span>,backtran <span class="op">=</span> <span class="cn">FALSE</span>,title<span class="op">=</span><span class="st">"Seasonal Growth"</span>,  </span>
<span>       parnames<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Linf"</span>,<span class="st">"K"</span>,<span class="st">"t0"</span>,<span class="st">"C"</span>,<span class="st">"s"</span>,<span class="st">"sigma"</span><span class="op">)</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>nlm solution:  Seasonal Growth 
minimum     :  105.2252 
iterations  :  21 
code        :  2 &gt;1 iterates in tolerance, probably solution 
               par      gradient
Linf   89.06448059  7.259920e-05
K       0.01040808  3.973383e-01
t0    -13.46176841 -5.575919e-05
C       0.10816263 -5.358897e-03
s       6.96964772  2.208197e-05
sigma   1.63926525  7.775261e-05</code></pre>
</div>
</div>
<p>增长率的季节性调整对 <span class="math inline">\(L_{\infty}\)</span> 和 <span class="math inline">\(K\)</span> 值的影响较小，但对 <span class="math inline">\(t_0\)</span> 值的影响较大，因为季节性比标准 <code>vB()</code> 函数更能允许最初的快速上升。正如预期的那样，对 <em>sigma</em> 参数的影响很大(从 3.74 下降到 1.64 )。模型拟合的改进也很大(增加两个参数的代价是 -veLL 从 150 下降到 105)。如 <a href="#fig-5-2" class="quarto-xref">图&nbsp;<span>5.2</span></a> 所示，这也反映在整个残差模式的减少及其最大值和最小值的减半上。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb6"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#Plot seasonal growth curve and residuals   Figure 5.2  </span></span>
<span><span class="fu">parset</span><span class="op">(</span>plots<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">)</span><span class="op">)</span>  <span class="co"># MQMF utility wrapper function  </span></span>
<span><span class="fu">plot1</span><span class="op">(</span><span class="va">week</span>,<span class="va">length</span>,type<span class="op">=</span><span class="st">"p"</span>,cex<span class="op">=</span><span class="fl">0.9</span>,col<span class="op">=</span><span class="fl">2</span>,xlab<span class="op">=</span><span class="st">"Weeks"</span>,pch<span class="op">=</span><span class="fl">16</span>,  </span>
<span>      ylab<span class="op">=</span><span class="st">"Length (mm)"</span>,defpar<span class="op">=</span><span class="cn">FALSE</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="fl">0</span><span class="op">:</span><span class="fl">160</span>,<span class="va">predLs</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">1</span><span class="op">)</span>  </span>
<span> <span class="co"># calculate and plot the residuals  </span></span>
<span><span class="va">resids</span> <span class="op">&lt;-</span> <span class="va">length</span> <span class="op">-</span> <span class="fu">svb</span><span class="op">(</span><span class="va">bestsvb</span><span class="op">$</span><span class="va">estimate</span>,<span class="va">week</span><span class="op">)</span>  </span>
<span><span class="fu">plot1</span><span class="op">(</span><span class="va">week</span>,<span class="va">resids</span>,type<span class="op">=</span><span class="st">"l"</span>,col<span class="op">=</span><span class="st">"darkgrey"</span>,cex<span class="op">=</span><span class="fl">0.9</span>,xlab<span class="op">=</span><span class="st">"Weeks"</span>,  </span>
<span>      lty<span class="op">=</span><span class="fl">3</span>,ylab<span class="op">=</span><span class="st">"Normal Residuals"</span>,defpar<span class="op">=</span><span class="cn">FALSE</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html">points</a></span><span class="op">(</span><span class="va">week</span>,<span class="va">resids</span>,pch<span class="op">=</span><span class="fl">16</span>,cex<span class="op">=</span><span class="fl">1.1</span>,col<span class="op">=</span><span class="st">"red"</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html">abline</a></span><span class="op">(</span>h<span class="op">=</span><span class="fl">0</span>,col<span class="op">=</span><span class="fl">1</span>,lwd<span class="op">=</span><span class="fl">1</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-5-2" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-5-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="05-staticModel_files/figure-html/fig-5-2-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-5-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;5.2: Pitcher 和 Macdonald（1973）的近似龄长数据与 von Bertalanffy 生长曲线的拟合季节版本。下图是正态随机残差图，残差仍有一系列高于和低于零的运行，但不如非季节性曲线那么有规律。
</figcaption></figure>
</div>
</div>
</div>
<p>这当然不是唯一可以描述生长率季节性变化的生长曲线，但本节只是对其原理的介绍。事实上，文献中还有很多可供选择的生长曲线，例如甲壳动物的生长曲线，它们是通过蜕皮来增大体型的。因此，严格来说，描述它们的生长需要估算从初始尺寸开始的生长增量，以及它们蜕皮时生长增量的持续时间和频率。不过，在种群层面，如果数量足够多，在种群动力学模型中，连续的生长曲线往往可以充分近似地描述这种生长。</p>
<p><span class="citation" data-cites="pitcher1973">Pitcher 和 Macdonald (<a href="08-references.html#ref-pitcher1973" role="doc-biblioref">1973</a>)</span> 对他们的第一条季节性生长曲线所预测的负增长的出现表示反对，但由于他们处理的是从鱼群中选取的样本，并对这些样本的平均值进行拟合，因此没有生物学上的理由可以解释为什么这些样本的平均值在一年中的某些时候不能略有下降。他们还指出，使用直接拟合过程“……在带有交互式图形的 PDP 8-E 计算机上联机需要几个小时：然而，有效的优化方法可以大大缩短时间” <span class="citation" data-cites="pitcher1973">(<a href="08-references.html#ref-pitcher1973" role="doc-biblioref">Pitcher 和 Macdonald 1973</a>，第603页)</span>。希望这样的陈述能让读者更加了解现在非线性优化器的易得性、卓越的计算机速度及其分析能力（免费提供的软件，如 R，确实是一种能力）。</p>
</section><section id="标记数据的-fabens-方法" class="level3" data-number="5.3.2"><h3 data-number="5.3.2" class="anchored" data-anchor-id="标记数据的-fabens-方法">
<span class="header-section-number">5.3.2</span> 标记数据的 Fabens 方法</h3>
<p>到目前为止，在第<a href="04-application.html" class="quarto-xref"><span>4</span></a> 章 “<a href="./04-application.html">模型参数估计</a>”一章和本节的 “静态模型”中，我们主要讨论的是年龄-长度数据，这显然需要对样本进行年龄测定和长度测量。遗憾的是，并非所有动物的年龄都能精确到足以使用这种生长描述。在渔业相关科学的早期，一种常用的做法是给鱼类标记、放流（Petersen，1896 ）。回捕鱼类可用于描述其运动特征，后来，通过测量标记时和回捕时的鱼体长度，可用于描述动物的生长情况。在使用标记数据拟合曲线时，需要对用于描述更标准的年龄长度曲线的方程进行转换。因为我们不知道被标记动物的年龄，我们需要一个方程，根据 von Bertalanffy 参数生成预期长度增量，标记时的长度 <span class="math inline">\(L_t\)</span>，以及经过时间 <span class="math inline">\(\Delta t\)</span> 后的长度将是 <span class="math inline">\(L_{t + \Delta t}\)</span>。Fabens(1965) 对 von Bertalanffy 曲线进行了改造，使其可以用于从标记程序中获得的信息(参见本章附录中的完整推导)。通过对一般的 von-Bertalanffy 曲线（ <a href="#eq-5_1" class="quarto-xref">公式&nbsp;<span>5.1</span></a>） 的处理，Fabens 得到下面的方程：</p>
<p><span id="eq-5_3"><span class="math display">\[
\begin{split}  
  &amp; \Delta \hat{L}={{L}_{t+\Delta t}}-{{L}_{t}} \\  
&amp; \Delta \hat{L}=\left( {{L}_{\infty }}-{{L}_{t}} \right)\left( 1-{{e}^{-K\Delta t}} \right)  
\end{split}  
\qquad(5.3)\]</span></span></p>
<p>其中，某一动物的初始长度是 <span class="math inline">\(L_t\)</span>，<span class="math inline">\(\Delta L\)</span> 是 <span class="math inline">\(\Delta t\)</span> 时间段的长度的期望变化。通过使用最小二乘法或负对数似然法，可以估算出 <span class="math inline">\(L_{\infty}\)</span> 和 <span class="math inline">\(K\)</span> 的值。为了估算 <span class="math inline">\(t_0\)</span>值，需要可知年龄的平均长度，因此，通常无法进行 <span class="math inline">\(t_0\)</span> 估计，并且无法确定生长曲线沿年龄轴的确切位置。在这种情况下，<span class="math inline">\(t_0\)</span> 通常被设为 <span class="math inline">\(0\)</span>。</p>
<p>如果能够获得至少记录了标记时的初始长度、标记和回捕之间的时间间隔以及在该时间间隔内发生的生长增量的数据，那么我们在给定初始长度和两个参数 <span class="math inline">\(L_{\infty}\)</span> 和 <span class="math inline">\(K\)</span> 的情况下，建立一个函数，生成所需的预测增长增量，然后利用最大似然，我们就可以获得我们所拥有的任何数据的最佳拟合。</p>
<p>这最好通过绘制一些标记的图来说明 <a href="#fig-5-3" class="quarto-xref">图&nbsp;<span>5.3</span></a> （数据在 <strong>MQMF</strong> 数据集 <em>blackisland</em>（鲍鱼种群）中找到）。包括一些较大鲍鱼的零增长。数据云是分散的（噪声），但某种形式的趋势是明显的，生长模型将试图拟合这种趋势。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb7"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co"># tagging growth increment data from Black Island, Tasmania  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="va">blackisland</span><span class="op">)</span>;  <span class="va">bi</span> <span class="op">&lt;-</span> <span class="va">blackisland</span> <span class="co"># just to keep things brief  </span></span>
<span><span class="fu">parset</span><span class="op">(</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">bi</span><span class="op">$</span><span class="va">l1</span>,<span class="va">bi</span><span class="op">$</span><span class="va">dl</span>,type<span class="op">=</span><span class="st">"p"</span>,pch<span class="op">=</span><span class="fl">16</span>,cex<span class="op">=</span><span class="fl">1.0</span>,col<span class="op">=</span><span class="fl">2</span>,ylim<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">1</span>,<span class="fl">33</span><span class="op">)</span>,  </span>
<span>     ylab<span class="op">=</span><span class="st">"Growth Increment mm"</span>,xlab<span class="op">=</span><span class="st">"Initial Length mm"</span>,  </span>
<span>     panel.first <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/graphics/grid.html">grid</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html">abline</a></span><span class="op">(</span>h<span class="op">=</span><span class="fl">0</span>,col<span class="op">=</span><span class="fl">1</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-5-3" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-5-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="05-staticModel_files/figure-html/fig-5-3-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-5-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;5.3: 从塔斯马尼亚州西南角黑岛采集的黑唇鲍鱼标记数据。标记与重捕之间的时间间隔平均为 1.02 年。
</figcaption></figure>
</div>
</div>
</div>
<p>与第 <a href="04-application.html" class="quarto-xref"><span>4</span></a> 章“<a href="./04-application.html">模型参数估计</a>”中对生长的描述一样，这里我们将拟合两条生长曲线并与示例标记数据 进行比较。这两条曲线分别是 von Bertalanffy 曲线（Fabens，1965；见 <a href="#eq-5_3" class="quarto-xref">公式&nbsp;<span>5.3</span></a> ）（鱼类和其它种类的）以及逆 logistic 曲线（Haddon 等，2008 ），更适合难以测定年龄的无脊椎动物所表现出的不确定连续生长。与 von Bertalanffy 曲线相比，逆 logistic 曲线的局限性更大，因为它设计用于以一年为单位的时间增量，或至少是一个恒定的时间增量。</p>
<p><span id="eq-5_4"><span class="math display">\[
\begin{split}  
  \Delta L &amp;= \frac{Max\Delta L}{1+{{e}^{log(19)({L_t}-L_{50})/\delta }}} + \varepsilon \\   
  {L_{t+1}} &amp;= {L_t}+\Delta L + \varepsilon   
\end{split}  
\qquad(5.4)\]</span></span></p>
<p><span class="math inline">\(\delta\)</span> 等于 <span class="math inline">\(L_{95} - L_{50}\)</span>，其中 <span class="math inline">\(L_{50}\)</span> 和 <span class="math inline">\(L_{95}\)</span> 是增长率分别为 <span class="math inline">\(Max \Delta L\)</span> 的 50% 和 5% 时的长度，<span class="math inline">\(\varepsilon\)</span> 表示一定长度的平均预期增量的正态随机残差误差。 事后来看，<span class="math inline">\(L_{95}\)</span> 可能定义为 <span class="math inline">\(L_5\)</span> 更好。 请注意，由于进行了 Fabens 变换，Fabens 模型的残差误差与年龄长度模型的残差误差有所不同，尽管二者都使用了正态概率密度函数（稍后详述）。</p>
<p><strong>MQMF</strong> 中定义了两个函数来生成 von Bertalanffy 曲线的预测生长增量：<code>fabens()</code> 和逆 logistic <code>invl()</code>。这两个函数的实现非常简单，反映了 <a href="#eq-5_3" class="quarto-xref">公式&nbsp;<span>5.3</span></a> 和 <a href="#eq-5_4" class="quarto-xref">公式&nbsp;<span>5.4</span></a> 。读者应检查这些函数的代码（即不带括号的 <code>fabens()</code> 或 <code>invl()</code>），并阅读每个函数的帮助。读者很快就会明白，这些函数的定义方式可以方便地使用列名不是 <span class="math inline">\(l1\)</span> 和 <span class="math inline">\(dt\)</span> 的 data.frames。在下文中，我们明确使用了这些名称，尽管我们本可以直接使用默认值。</p>
</section><section id="拟合标记数据模型" class="level3" data-number="5.3.3"><h3 data-number="5.3.3" class="anchored" data-anchor-id="拟合标记数据模型">
<span class="header-section-number">5.3.3</span> 拟合标记数据模型</h3>
<p>在模型拟合方面中，我们已经有了生成预测生长增量（ <span class="math inline">\(\Delta L\)</span> ）所需的函数（<code>fabens()</code> 和 <code>invl()</code> ）以及优化器 <code><a href="https://rdrr.io/r/stats/nlm.html">nlm()</a></code>，仍然需要的是在搜索最小值期间计算负对数似然的函数。在这一点上，没有理由使用正态随机误差以外的其他误差。我们将使用 <strong>MQMF</strong> 函数 <code>negNLL()</code> 来拟合两条曲线，然后通过可视化和似然比检验对它们进行比较。如果需要更改用于所需数据的列名，可以使用 ….。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb8"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co"># Fit the vB and Inverse Logistic to the tagging data  </span></span>
<span><span class="va">linm</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html">lm</a></span><span class="op">(</span><span class="va">bi</span><span class="op">$</span><span class="va">dl</span> <span class="op">~</span> <span class="va">bi</span><span class="op">$</span><span class="va">l1</span><span class="op">)</span> <span class="co"># simple linear regression  </span></span>
<span><span class="va">param</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">170.0</span>,<span class="fl">0.3</span>,<span class="fl">4.0</span><span class="op">)</span>; <span class="va">label</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Linf"</span>,<span class="st">"K"</span>,<span class="st">"sigma"</span><span class="op">)</span>  </span>
<span><span class="va">modelvb</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/nlm.html">nlm</a></span><span class="op">(</span>f<span class="op">=</span><span class="va">negNLL</span>,p<span class="op">=</span><span class="va">param</span>,funk<span class="op">=</span><span class="va">fabens</span>,observed<span class="op">=</span><span class="va">bi</span><span class="op">$</span><span class="va">dl</span>,indat<span class="op">=</span><span class="va">bi</span>,  </span>
<span>               initL<span class="op">=</span><span class="st">"l1"</span>,delT<span class="op">=</span><span class="st">"dt"</span><span class="op">)</span> <span class="co"># could have used the defaults  </span></span>
<span><span class="fu">outfit</span><span class="op">(</span><span class="va">modelvb</span>,backtran <span class="op">=</span> <span class="cn">FALSE</span>,title<span class="op">=</span><span class="st">"vB"</span>,parnames<span class="op">=</span><span class="va">label</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>nlm solution:  vB 
minimum     :  291.1691 
iterations  :  24 
code        :  1 gradient close to 0, probably solution 
              par     gradient
Linf  173.9677972 9.563666e-07
K       0.2653003 2.656839e-04
sigma   3.5861240 1.391768e-05</code></pre>
</div>
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb10"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">predvB</span> <span class="op">&lt;-</span> <span class="fu">fabens</span><span class="op">(</span><span class="va">modelvb</span><span class="op">$</span><span class="va">estimate</span>,<span class="va">bi</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"\n"</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb11"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">param2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">25.0</span>,<span class="fl">130.0</span>,<span class="fl">35.0</span>,<span class="fl">3.0</span><span class="op">)</span>   </span>
<span><span class="va">label2</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"MaxDL"</span>,<span class="st">"L50"</span>,<span class="st">"delta"</span>,<span class="st">"sigma"</span><span class="op">)</span>  </span>
<span><span class="va">modelil</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/nlm.html">nlm</a></span><span class="op">(</span>f<span class="op">=</span><span class="va">negNLL</span>,p<span class="op">=</span><span class="va">param2</span>,funk<span class="op">=</span><span class="va">invl</span>,observed<span class="op">=</span><span class="va">bi</span><span class="op">$</span><span class="va">dl</span>,indat<span class="op">=</span><span class="va">bi</span>,  </span>
<span>               initL<span class="op">=</span><span class="st">"l1"</span>,delT<span class="op">=</span><span class="st">"dt"</span><span class="op">)</span>  </span>
<span><span class="fu">outfit</span><span class="op">(</span><span class="va">modelil</span>,backtran <span class="op">=</span> <span class="cn">FALSE</span>,title<span class="op">=</span><span class="st">"IL"</span>,parnames<span class="op">=</span><span class="va">label2</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>nlm solution:  IL 
minimum     :  277.0122 
iterations  :  26 
code        :  1 gradient close to 0, probably solution 
            par      gradient
MaxDL  21.05654 -2.021972e-06
L50   130.92643  5.900276e-07
delta  40.98771  2.218945e-07
sigma   3.14555  4.535835e-06</code></pre>
</div>
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb13"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">predil</span> <span class="op">&lt;-</span> <span class="fu">invl</span><span class="op">(</span><span class="va">modelil</span><span class="op">$</span><span class="va">estimate</span>,<span class="va">bi</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>逆 logistic 模型的负对数似然小于 von Bertalanffy 模型的负对数似然，而且逆 logistic 呈现出较小的 <span class="math inline">\(\sigma\)</span> 值。如果我们将这两条增长曲线与原始数据进行对比，就可以更清楚地看到它们之间的差异<a href="#fig-5-4" class="quarto-xref">图&nbsp;<span>5.4</span></a>。此外，对各自的残差进行检验也会发现曲线之间的差异，预测的 von Bertalanffy 曲线的残差呈圆弧状，这与其预测的初始长度与生长增量之间的线性关系是一致的。在 <a href="#fig-5-4" class="quarto-xref">图&nbsp;<span>5.4</span></a> 中，线性回归绘制在 von Bertalanffy 曲线的上方，以说明它实际上是重合的。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb14"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#growth curves and regression fitted to tagging data Fig 5.4  </span></span>
<span><span class="fu">parset</span><span class="op">(</span>margin<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.4</span>,<span class="fl">0.4</span>,<span class="fl">0.05</span>,<span class="fl">0.05</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">bi</span><span class="op">$</span><span class="va">l1</span>,<span class="va">bi</span><span class="op">$</span><span class="va">dl</span>,type<span class="op">=</span><span class="st">"p"</span>,pch<span class="op">=</span><span class="fl">16</span>,cex<span class="op">=</span><span class="fl">1.0</span>,col<span class="op">=</span><span class="fl">3</span>,ylim<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">2</span>,<span class="fl">31</span><span class="op">)</span>,  </span>
<span>     ylab<span class="op">=</span><span class="st">"Growth Increment mm"</span>,xlab<span class="op">=</span><span class="st">"Length mm"</span>,panel.first<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/graphics/grid.html">grid</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html">abline</a></span><span class="op">(</span>h<span class="op">=</span><span class="fl">0</span>,col<span class="op">=</span><span class="fl">1</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">bi</span><span class="op">$</span><span class="va">l1</span>,<span class="va">predvB</span>,pch<span class="op">=</span><span class="fl">16</span>,col<span class="op">=</span><span class="fl">1</span>,lwd<span class="op">=</span><span class="fl">3</span>,lty<span class="op">=</span><span class="fl">1</span><span class="op">)</span>  <span class="co"># vB  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">bi</span><span class="op">$</span><span class="va">l1</span>,<span class="va">predil</span>,pch<span class="op">=</span><span class="fl">16</span>,col<span class="op">=</span><span class="fl">2</span>,lwd<span class="op">=</span><span class="fl">3</span>,lty<span class="op">=</span><span class="fl">2</span><span class="op">)</span>  <span class="co"># IL  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html">abline</a></span><span class="op">(</span><span class="va">linm</span>,lwd<span class="op">=</span><span class="fl">3</span>,col<span class="op">=</span><span class="fl">7</span>,lty<span class="op">=</span><span class="fl">2</span><span class="op">)</span> <span class="co"># add dashed linear regression  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/legend.html">legend</a></span><span class="op">(</span><span class="st">"topright"</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"vB"</span>,<span class="st">"LinReg"</span>,<span class="st">"IL"</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">3</span>,bty<span class="op">=</span><span class="st">"n"</span>,cex<span class="op">=</span><span class="fl">1.2</span>,  </span>
<span>                    col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">7</span>,<span class="fl">2</span><span class="op">)</span>,lty<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-5-4" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-5-4-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="05-staticModel_files/figure-html/fig-5-4-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-5-4-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;5.4: 黑岛黑唇鲍标记数据的von Betalanffy（黑色）、逆 logistic （红色曲线虚线）和线性回归（黄色虚线）拟合。 标记与回捕之间的时间间隔为 1.02 年。显然，vB 和线性回归是相同的。
</figcaption></figure>
</div>
</div>
</div>
<p>两条生长曲线的残差也显示了各自模型拟合的差异。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb15"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#residuals for vB and inverse logistic for tagging data Fig 5.5  </span></span>
<span><span class="fu">parset</span><span class="op">(</span>plots<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">2</span><span class="op">)</span>,outmargin<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">0</span>,<span class="fl">0</span><span class="op">)</span>,margin<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">.25</span>,<span class="fl">.25</span>,<span class="fl">.05</span>,<span class="fl">.05</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">bi</span><span class="op">$</span><span class="va">l1</span>,<span class="op">(</span><span class="va">bi</span><span class="op">$</span><span class="va">dl</span> <span class="op">-</span> <span class="va">predvB</span><span class="op">)</span>,type<span class="op">=</span><span class="st">"p"</span>,pch<span class="op">=</span><span class="fl">16</span>,col<span class="op">=</span><span class="fl">1</span>,ylab<span class="op">=</span><span class="st">""</span>,  </span>
<span>     xlab<span class="op">=</span><span class="st">""</span>,panel.first<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/graphics/grid.html">grid</a></span><span class="op">(</span><span class="op">)</span>,ylim<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">8</span>,<span class="fl">11</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html">abline</a></span><span class="op">(</span>h<span class="op">=</span><span class="fl">0</span>,col<span class="op">=</span><span class="fl">1</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/mtext.html">mtext</a></span><span class="op">(</span><span class="st">"vB"</span>,side<span class="op">=</span><span class="fl">1</span>,outer<span class="op">=</span><span class="cn">FALSE</span>,line<span class="op">=</span><span class="op">-</span><span class="fl">1.1</span>,cex<span class="op">=</span><span class="fl">1.2</span>,font<span class="op">=</span><span class="fl">7</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">bi</span><span class="op">$</span><span class="va">l1</span>,<span class="op">(</span><span class="va">bi</span><span class="op">$</span><span class="va">dl</span> <span class="op">-</span> <span class="va">predil</span><span class="op">)</span>,type<span class="op">=</span><span class="st">"p"</span>,pch<span class="op">=</span><span class="fl">16</span>,col<span class="op">=</span><span class="fl">1</span>,ylab<span class="op">=</span><span class="st">""</span>,  </span>
<span>     xlab<span class="op">=</span><span class="st">""</span>,panel.first<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/graphics/grid.html">grid</a></span><span class="op">(</span><span class="op">)</span>,ylim<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">8</span>,<span class="fl">11</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html">abline</a></span><span class="op">(</span>h<span class="op">=</span><span class="fl">0</span>,col<span class="op">=</span><span class="fl">1</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/mtext.html">mtext</a></span><span class="op">(</span><span class="st">"IL"</span>,side<span class="op">=</span><span class="fl">3</span>,outer<span class="op">=</span><span class="cn">FALSE</span>,line<span class="op">=</span><span class="op">-</span><span class="fl">1.2</span>,cex<span class="op">=</span><span class="fl">1.2</span>,font<span class="op">=</span><span class="fl">7</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/mtext.html">mtext</a></span><span class="op">(</span><span class="st">"Length mm"</span>,side<span class="op">=</span><span class="fl">1</span>,line<span class="op">=</span><span class="op">-</span><span class="fl">0.1</span>,cex<span class="op">=</span><span class="fl">1.0</span>,font<span class="op">=</span><span class="fl">7</span>,outer<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/mtext.html">mtext</a></span><span class="op">(</span><span class="st">"Residual"</span>,side<span class="op">=</span><span class="fl">2</span>,line<span class="op">=</span><span class="op">-</span><span class="fl">0.1</span>,cex<span class="op">=</span><span class="fl">1.0</span>,font<span class="op">=</span><span class="fl">7</span>,outer<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-5-5" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-5-5-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="05-staticModel_files/figure-html/fig-5-5-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-5-5-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;5.5: 黑岛黑唇鲍标记数据的 von Betalanffy 曲线残差图（左侧）和 逆 Logistic 曲线残差图（右侧）。标记与回捕之间的时间间隔为 1.02 年。
</figcaption></figure>
</div>
</div>
</div>
</section><section id="对-fabens-方法的深入探讨" class="level3" data-number="5.3.4"><h3 data-number="5.3.4" class="anchored" data-anchor-id="对-fabens-方法的深入探讨">
<span class="header-section-number">5.3.4</span> 对 Fabens 方法的深入探讨</h3>
<p>von Bertalanffy 方程的 Fabens 变换所描述的生长曲线使用了相同的参数，但却暗藏了一些不易察觉的差异。您一定还记得我们使用两种不同的残差误差结构拟合 vB 曲线的例子，这使得结果无法比较，或者更严格地说，无法比较。Fabens 变换改变了残差结构以及参数之间的相互作用方式。取而代之的是 <span class="math inline">\(L_{\infty}\)</span> 变成了绝对最大值，这就是它能预测负增长的原因。严格来说，Fabens 模型的参数与 von Bertalanffy 模型的参数含义不同。</p>
<p>我们对 von Bertalanffy 曲线和逆 logistic 曲线进行了比较，但由于我们使用了鲍鱼种群的数据作为例子，我们对哪条曲线可能更有用的看法有失偏颇。在大多数有鳞鱼类渔业中，人们发现 von Bertalanffy 曲线作为对生长的一般描述是最有用的，尽管它还存在一些问题。但所有生长模型（不只是标记生长模型）的一个普遍问题是我们迄今为止所使用的假设，即围绕预测生长趋势的观测变化将是恒定的。如果我们看一下 <a href="#fig-5-3" class="quarto-xref">图&nbsp;<span>5.3</span></a> 或 <a href="#fig-5-4" class="quarto-xref">图&nbsp;<span>5.4</span></a> ，还记得我们在第 <a href="04-application.html" class="quarto-xref"><span>4</span></a> 章“<a href="./04-application.html">模型参数估计</a>”中绘制的年龄长度数据，那么在每种情况下，初始长度或年龄的变化趋势都比较明显。与其坚持在残差中使用恒定的方差（如 SSQ 所要求的），不如使用恒定的变异系数（ <span class="math inline">\(\sigma/\mu\)</span> ）。如果我们使用最大似然法，就有可能对残差的方差进行单独建模，从而得出一系列不同的结果；Francis（1988 ）正是这样做的。他使用最大似然法对数据进行了标记模型拟合，并假定每种情况下的残差都是正态分布的，但他对残差方差与期望 <span class="math inline">\(\Delta L\)</span> 之间的关系提出了一些不同的函数形式（与初始长度的函数关系也是可能的）。迄今为止，我们使用的方法假定方差为常数，因此我们估算了一个常数 <span class="math inline">\(\sigma\)</span> 参数。Francis（1988）则建议，方差可以有一个介于 <span class="math inline">\(\sigma\)</span> 和 <span class="math inline">\(\Delta L\)</span> 之间的恒定乘数，标记数据之间可以存在反比关系。这些考虑因素也适用于年龄-长度模型，在这种模型中，常数乘数将使年龄与 <span class="math inline">\(\sigma\)</span> 之间呈线性关系。</p>
<p><span id="eq-5_5"><span class="math display">\[
\sigma = \upsilon (\Delta \hat{L})
\qquad(5.5)\]</span></span></p>
<p>其中 <span class="math inline">\(\upsilon\)</span> 是期望 <span class="math inline">\(\Delta L\)</span> 的常数乘数，需要分别估算。此时正态似然将变为：</p>
<p><span id="eq-5_6"><span class="math display">\[
L\left( \Delta L|Data \right)=\sum\limits_{i}{\frac{1}{\sqrt{2\pi }\upsilon \Delta \hat{L}}}\exp \left( \frac{{{\left( \Delta L-\Delta \hat{L} \right)}^{2}}}{2{{\left( \upsilon \Delta \hat{L} \right)}^{2}}} \right)  
\qquad(5.6)\]</span></span></p>
<p>其中用 <span class="math inline">\(2\left(\upsilon \Delta \hat L \right)^2\)</span> 替代一般正态似然的 <span class="math inline">\(\sigma^2\)</span>。除这一简单的替代方案外，Francis（1988 ）还建议对标记数据采用指数递减的残差标准差，再加上一个可估算的常数 <span class="math inline">\(\tau\)</span> ：</p>
<p><span id="eq-5_-_7"><span class="math display">\[
\sigma = \tau \left( 1 - e^{-\upsilon (\Delta \hat{L})}  \right)  
\qquad(5.7)\]</span></span></p>
<p>最后，Francis（1988）建议采用幂律描述的残差标准差：</p>
<p><span id="eq-5_8"><span class="math display">\[
\sigma = \upsilon (\Delta \hat{L})^\tau  
\qquad(5.8)\]</span></span></p>
<p>Francis（1988）还通过考虑偏差、生长率的季节性变化以及离群污染的影响，将 Fabens 方法扩展到分析标记数据。文献中往往只强调了报告的一个方面，这也是经常查阅原始文献而不是依赖其他论文或书籍（如这本书）中的摘要的一个很好的理由。如果需要对标记数据拟合生长曲线，Francis（1988）是一个很好的起点。</p>
<p>由于方差与预期 <span class="math inline">\(\Delta L\)</span> 之间关系的表达不同，常数 <span class="math inline">\(\tau\)</span> 和 <span class="math inline">\(\upsilon\)</span> 的解释也发生变化。 如前所述，如果假定的误差结构不同，从同一模型中得到的参数估计值也会不同，从而变得不可比较。遗憾的是，如何选择最合适的误差结构并不是一个简单的问题。充其量，无论选择哪种曲线，使用非恒定方差都能提供与之相关的不确定性的另一种视角。</p>
</section><section id="非恒定方差的实现" class="level3" data-number="5.3.5"><h3 data-number="5.3.5" class="anchored" data-anchor-id="非恒定方差的实现">
<span class="header-section-number">5.3.5</span> 非恒定方差的实现</h3>
<p>通过包含期望 <span class="math inline">\(\Delta L\)</span> 和 残差方差之间关系，我们需要改变包装函数，围绕如何使用预测值 <span class="math inline">\(\Delta \hat L\)</span> 计算负对数似然。之前，对于常数 <span class="math inline">\(\sigma\)</span> 我们用 <code>negNULL()</code> ，所以我们可从它开始修改。我们所做的只是包括一个额外函数 <code>funksig()</code> ，作为 <code>negnormL()</code> 的参数（参见其帮助和代码），从而包括 sigma 值的计算。通过这种方法，我们可以在 <code>funksig()</code> 中保留常数 <span class="math inline">\(\sigma\)</span> 的长版本。但这也表明函数的行为符合预期。然后，我们可以加入一个替代的 <code>funksig()</code>，实现上述三个选项之一（或我们自己设计的选项）。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb16"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span>   <span class="co"># fit the Fabens tag growth curve with and without the option to   </span></span>
<span> <span class="co"># modify variation with predicted length. See the MQMF function  </span></span>
<span> <span class="co"># negnormL. So first no variation and then linear variation.   </span></span>
<span><span class="va">sigfunk</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">pars</span>,<span class="va">predobs</span><span class="op">)</span> <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/utils/head.html">tail</a></span><span class="op">(</span><span class="va">pars</span>,<span class="fl">1</span><span class="op">)</span><span class="op">)</span> <span class="co">#no effect  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="va">blackisland</span><span class="op">)</span>  </span>
<span><span class="va">bi</span> <span class="op">&lt;-</span> <span class="va">blackisland</span> <span class="co"># just to keep things brief  </span></span>
<span><span class="va">param</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">170.0</span>,<span class="fl">0.3</span>,<span class="fl">4.0</span><span class="op">)</span>; <span class="va">label</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Linf"</span>,<span class="st">"K"</span>,<span class="st">"sigma"</span><span class="op">)</span>  </span>
<span><span class="va">modelvb</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/nlm.html">nlm</a></span><span class="op">(</span>f<span class="op">=</span><span class="va">negnormL</span>,p<span class="op">=</span><span class="va">param</span>,funk<span class="op">=</span><span class="va">fabens</span>,funksig<span class="op">=</span><span class="va">sigfunk</span>,  </span>
<span>               indat<span class="op">=</span><span class="va">bi</span>,initL<span class="op">=</span><span class="st">"l1"</span>,delT<span class="op">=</span><span class="st">"dt"</span><span class="op">)</span>  </span>
<span><span class="fu">outfit</span><span class="op">(</span><span class="va">modelvb</span>,backtran <span class="op">=</span> <span class="cn">FALSE</span>,title<span class="op">=</span><span class="st">"vB constant sigma"</span>,  </span>
<span>       parnames <span class="op">=</span> <span class="va">label</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>nlm solution:  vB constant sigma 
minimum     :  291.1691 
iterations  :  24 
code        :  1 gradient close to 0, probably solution 
              par     gradient
Linf  173.9677972 9.563666e-07
K       0.2653003 2.656839e-04
sigma   3.5861240 1.391768e-05</code></pre>
</div>
</div>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb18"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">sigfunk2</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">pars</span>,<span class="va">predo</span><span class="op">)</span> <span class="op">{</span> <span class="co"># linear with predicted length  </span></span>
<span>  <span class="va">sig</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/utils/head.html">tail</a></span><span class="op">(</span><span class="va">pars</span>,<span class="fl">1</span><span class="op">)</span> <span class="op">*</span> <span class="va">predo</span>      <span class="co"># sigma x predDL, see negnormL  </span></span>
<span>  <span class="va">pick</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/which.html">which</a></span><span class="op">(</span><span class="va">sig</span> <span class="op">&lt;=</span> <span class="fl">0</span><span class="op">)</span>          <span class="co"># ensure no negative sigmas from   </span></span>
<span>  <span class="va">sig</span><span class="op">[</span><span class="va">pick</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0.01</span>           <span class="co"># possible negative predicted lengths  </span></span>
<span>  <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="va">sig</span><span class="op">)</span>  </span>
<span><span class="op">}</span> <span class="co"># end of sigfunk2  </span></span>
<span><span class="va">param</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">170.0</span>,<span class="fl">0.3</span>,<span class="fl">1.0</span><span class="op">)</span>; <span class="va">label</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Linf"</span>,<span class="st">"K"</span>,<span class="st">"sigma"</span><span class="op">)</span>  </span>
<span><span class="va">modelvb2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/nlm.html">nlm</a></span><span class="op">(</span>f<span class="op">=</span><span class="va">negnormL</span>,p<span class="op">=</span><span class="va">param</span>,funk<span class="op">=</span><span class="va">fabens</span>,funksig<span class="op">=</span><span class="va">sigfunk2</span>,  </span>
<span>                indat<span class="op">=</span><span class="va">bi</span>,initL<span class="op">=</span><span class="st">"l1"</span>,delT<span class="op">=</span><span class="st">"dt"</span>,    </span>
<span>                typsize<span class="op">=</span><span class="fu">magnitude</span><span class="op">(</span><span class="va">param</span><span class="op">)</span>,iterlim<span class="op">=</span><span class="fl">200</span><span class="op">)</span>  </span>
<span><span class="fu">outfit</span><span class="op">(</span><span class="va">modelvb2</span>,backtran <span class="op">=</span> <span class="cn">FALSE</span>,parnames <span class="op">=</span> <span class="va">label</span>,  </span>
<span>       title<span class="op">=</span><span class="st">"vB inverse DeltaL, sigma &lt; 1"</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>nlm solution:  vB inverse DeltaL, sigma &lt; 1 
minimum     :  288.1933 
iterations  :  64 
code        :  2 &gt;1 iterates in tolerance, probably solution 
              par    gradient
Linf  171.0000001 45579.23697
K       0.2724177    77.18211
sigma   0.4139252    19.64508</code></pre>
</div>
</div>
<p>请记住，通过改变残差结构，似然值变得不相称，因此我们无法确定哪种拟合效果更好。恒定方差使得 von Bertalanffy 曲线在长度大于 148 左右时有效地保持在数据之上，而变化方差生长曲线大部分时间仍在数据之上，但由于方差随预测长度的减少而向后推近数据。我们可以通过重写 <code>negnormL()</code> 来进行实验，使用初始长度而不是预测长度。如前所述，将平均预测长度与相关方差分离可以获得极大的灵活性。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb20"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#plot to two Faben's lines with constant and varying sigma Fig 5.6  </span></span>
<span><span class="va">predvB</span> <span class="op">&lt;-</span> <span class="fu">fabens</span><span class="op">(</span><span class="va">modelvb</span><span class="op">$</span><span class="va">estimate</span>,<span class="va">bi</span><span class="op">)</span>  </span>
<span><span class="va">predvB2</span> <span class="op">&lt;-</span> <span class="fu">fabens</span><span class="op">(</span><span class="va">modelvb2</span><span class="op">$</span><span class="va">estimate</span>,<span class="va">bi</span><span class="op">)</span>  </span>
<span><span class="fu">parset</span><span class="op">(</span>margin<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.4</span>,<span class="fl">0.4</span>,<span class="fl">0.05</span>,<span class="fl">0.05</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">bi</span><span class="op">$</span><span class="va">l1</span>,<span class="va">bi</span><span class="op">$</span><span class="va">dl</span>,type<span class="op">=</span><span class="st">"p"</span>,pch<span class="op">=</span><span class="fl">1</span>,cex<span class="op">=</span><span class="fl">1.0</span>,col<span class="op">=</span><span class="fl">1</span>,ylim<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">2</span>,<span class="fl">31</span><span class="op">)</span>,  </span>
<span>     ylab<span class="op">=</span><span class="st">"Growth Increment mm"</span>,xlab<span class="op">=</span><span class="st">"Length mm"</span>,panel.first<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/graphics/grid.html">grid</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html">abline</a></span><span class="op">(</span>h<span class="op">=</span><span class="fl">0</span>,col<span class="op">=</span><span class="fl">1</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">bi</span><span class="op">$</span><span class="va">l1</span>,<span class="va">predvB</span>,col<span class="op">=</span><span class="fl">1</span>,lwd<span class="op">=</span><span class="fl">2</span><span class="op">)</span>         <span class="co"># vB  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">bi</span><span class="op">$</span><span class="va">l1</span>,<span class="va">predvB2</span>,col<span class="op">=</span><span class="fl">2</span>,lwd<span class="op">=</span><span class="fl">2</span>,lty<span class="op">=</span><span class="fl">2</span><span class="op">)</span>  <span class="co"># IL  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/legend.html">legend</a></span><span class="op">(</span><span class="st">"topright"</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Constant sigma"</span>,<span class="st">"Changing sigma"</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">3</span>,  </span>
<span>       col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">2</span><span class="op">)</span>,bty<span class="op">=</span><span class="st">"n"</span>,cex<span class="op">=</span><span class="fl">1.1</span>,lty<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">2</span><span class="op">)</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-5-6" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-5-6-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="05-staticModel_files/figure-html/fig-5-6-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-5-6-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;5.6: 与黑岛黑唇鲍标记数据拟合的具有恒定 sigma von Bertalanffy（皇家蓝）和 具有与不断变化的 DeltaL 相关的 sgima 的 von Bertalanffy（红色虚线）。 标记与再捕之间的平均时间间隔为 1.02 年。
</figcaption></figure>
</div>
</div>
</div>
<p>我们的眼睛习惯于欣赏对称性，因此 <a href="#fig-5-6" class="quarto-xref">图&nbsp;<span>5.6</span></a> 中不断变化的变化线看起来拟合得相对较差。但是，假设误差只存在于 y 轴上（y-on-x 问题），并且残差的方差也在不断变化，作为拟合模型的反映，下部的红色虚线使数据的值内有一条内在的曲线。使用更复杂的残差结构使模型拟合对初始条件更敏感。您会注意到，在输出结果中，假设残差方差恒定只需要 20-30 次迭代，而使用方差函数关系则需要两倍的迭代次数（这是在使用 Typsize 可选参数来增强稳定性的情况下，而在更简单的模型中没有使用）。如果修改这些起始值，很容易得到难以置信的答案。</p>
<p>尽管在使用年龄长度数据时，特别是在非常小的年龄段，变化的差异往往很明显，但在建模中引入这种复杂性还是需要有充分的理由。</p>
</section></section><section id="sec-label" class="level2" data-number="5.4"><h2 data-number="5.4" class="anchored" data-anchor-id="sec-label">
<span class="header-section-number">5.4</span> 目标模型选择</h2>
<p>在第 <a href="04-application.html" class="quarto-xref"><span>4</span></a> 章“<a href="./04-application.html">模型参数估计</a>（<em>Model Parameter Estimation</em>） ”中，我们看到了一个类似的章节，其中介绍了基于平方和的 Akaike 信息准则（AIC；Akaike，1974）的信息理论近似值（Burnham 和 Anderson，2002）。现在我们使用最大似然法，我们将介绍 AIC 的原始版本，并讨论似然比。</p>
<section id="akaike-信息准则" class="level3" data-number="5.4.1"><h3 data-number="5.4.1" class="anchored" data-anchor-id="akaike-信息准则">
<span class="header-section-number">5.4.1</span> Akaike 信息准则</h3>
<p>在试图描述数据集中的模式时，选择使用哪种模型时，使用的参数数量与模型拟合数据集的质量之间的权衡始终是一个问题。经典的方法是选择最简单的模型，该模型能很好地描述该模式（奥卡姆剃刀只是一个关于简约性的劝告，因此如果两个模型产生的结果相同，就选择最简单的一个）。但是，“等效结果”到底有多接近，“最简单”又是什么意思。Akaike 的解决方案（1974）是将似然比和 “模型内独立调整参数的数量”结合起来使用。AIC 是一种基于似然值的惩罚性模型选择标准，最小的 AIC 表示最佳模型（在似然值与参数数量之间取得平衡）。</p>
<p><span id="eq-5_9"><span class="math display">\[
AIC = -2 \log(L) + \alpha p
\qquad(5.9)\]</span></span></p>
<p>其中， <span class="math inline">\(\log(L)\)</span> 是总对数似然值， <span class="math inline">\(p\)</span> 是拟合模型时显式调整的参数数量，而 <span class="math inline">\(\alpha\)</span> 是一个乘数（惩罚项，在惩罚似然中），其值由 Akaike（1974）设定为 2.0，这是基于信息论的一个论点。强调“独立调整的参数”是“显式调整的”是为了避免混淆那些保持不变或从其他参数和模型变量推导出来的模型参数（我们在过剩产量模型中的捕获率参数中会看到一个例子）。例如，在渔业模型中一个常见的假设是自然死亡率，通常表示为&nbsp;<span class="math inline">\(M\)</span>，是一个常数。因此，在 AIC 的&nbsp;<span class="math inline">\(p\)</span>&nbsp;值中不会将其计算在内。将&nbsp;<span class="math inline">\(\alpha\)</span>&nbsp;作为惩罚项的显式标识，而不是直接使用常数值 2.0，是为了强调关于应使用的确切值存在争议（Bhansali 和 Downham, 1977；Schwartz, 1978；Akaike, 1979；Atkinson, 1980），以确保模型复杂度（参数数量）与拟合质量（最大似然或最小平方和）之间的平衡能够反映模拟中的实际情况。 尽管统计论据相对较为密集，最终归结为&nbsp;<span class="math inline">\(\alpha\)</span>&nbsp;的值&nbsp;<span class="math inline">\(p\)</span>&nbsp;应该多大？这一结果被称为施瓦茨的贝叶斯信息准则，简称 BIC。</p>
<p><span id="eq-5_10"><span class="math display">\[
BIC = -2 \log(L) + \log(n) p
\qquad(5.10)\]</span></span></p>
<p>其中 <span class="math inline">\(n\)</span> 是样本大小或模型拟合的数据点数， <span class="math inline">\(p\)</span> 是参数数量。只要数据点数大于或等于 8（ <span class="math inline">\(\log(8)=2.079\)</span>），BIC 将比 AIC 更严厉地惩罚复杂模型。另一方面，从直观上讲，考虑样本大小是有道理的。如果我们使用 MQMF 函数&nbsp;<code>aicbic()</code>&nbsp;对 von Bertalanffy 模型和逆逻辑斯蒂模型的拟合结果进行比较，其中使用了常数 <span class="math inline">\(\sigma\)</span> 估计 <a href="#fig-5-4" class="quarto-xref">图&nbsp;<span>5.4</span></a>，逆逻辑斯蒂模型的 AIC 和 BIC 均较小，因此在这种情况下，逆逻辑斯蒂模型将是更优的选择。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb21"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#compare the relative model fits of Vb and IL  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"von Bertalanffy \n"</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>von Bertalanffy </code></pre>
</div>
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb23"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">aicbic</span><span class="op">(</span><span class="va">modelvb</span>,<span class="va">bi</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>     aic      bic    negLL        p 
588.3382 596.3846 291.1691   3.0000 </code></pre>
</div>
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb25"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"inverse-logistic \n"</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>inverse-logistic </code></pre>
</div>
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb27"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">aicbic</span><span class="op">(</span><span class="va">modelil</span>,<span class="va">bi</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>     aic      bic    negLL        p 
562.0244 572.7529 277.0122   4.0000 </code></pre>
</div>
</div>
</section><section id="似然比检验" class="level3" data-number="5.4.2"><h3 data-number="5.4.2" class="anchored" data-anchor-id="似然比检验">
<span class="header-section-number">5.4.2</span> 似然比检验</h3>
<p>可以使用广义似然比检验（Neter et al, 1996）来比较不同模型拟合效果与复杂度之间的差异。该方法依赖于似然比检验在样本量增大时渐近趋近于 <span class="math inline">\(\chi^2\)</span> 分布的事实。这意味着在通常的渔业数据量下，这种方法只是近似的方法。似然比检验正如其名所示，是两个似然性的比值的对数，或者直接处理对数似然性时，是两个对数似然性的相减，两者是等价的（当然，这两个似然性必须来自同一个概率密度函数）。我们希望确定两个使用相同数据和残差结构但模型结构不同的模型（即不同的参数），哪一个能显著更好地拟合可用数据。由于似然比可以由 <span class="math inline">\(\chi^2\)</span> 分布描述，因此可以正式回答这个问题。 因此，对于两个模型的似然性，如果它们要么具有相同数量的参数，要么仅相差一个参数，在考虑显著性差异时，它们的比值需要大于所需的自由度（不同参数的数量）对应的 <span class="math inline">\(\chi^2\)</span> 分布。</p>
<p><span id="eq-5_11"><span class="math display">\[
\begin{split}
-2 \times \log\left[\dfrac{L(\theta)_{\alpha}}{L(\theta)_b} \right] &amp;\le \chi_{1,1 -\alpha}^2 \\
-2 \times [LL(\theta)_a -LL(\theta)_b &amp; \le \chi_{1,1-\alpha}^2
\end{split}
\qquad(5.11)\]</span></span></p>
<p>其中 <span class="math inline">\(L(\theta)_x\)</span> 是模型 <span class="math inline">\(x\)</span> 的 <span class="math inline">\(\theta\)</span> 参数的似然， <span class="math inline">\(LL(\theta)_x\)</span> 是等效的对数似然。 <span class="math inline">\(\chi_{1, 1-\alpha}^2\)</span> 是 <span class="math inline">\(\chi^2\)</span> 分布的 <span class="math inline">\(1-\alpha\)</span> 百分位数（例如，对于 95% 的置信区间， <span class="math inline">\(\alpha = 0.95\)</span> 和 <span class="math inline">\(1-\alpha = 0.05\)</span> ，即 <span class="math inline">\(\chi_{1,1-\alpha}^2= 3.84\)</span>。</p>
<p>简而言之，如果我们要比较两个仅相差一个或没有参数的模型，那么如果它们的负对数似然值相差超过 1.92（3.84/2），则可以认为这两个模型在统计上显著不同，其中一个模型将比另一个模型提供显著更好的拟合。如果两个模型之间相差两个参数，那么这两个模型在统计上显著不同的负对数似然值的最小差异需要达到 <span class="math inline">\(2.995(5.99/2)=\chi_{2, 0.95}^2/2\)</span> 自由度为 2），依此类推，对于参数差异更多的情况（Venzon 和 Moolgavkar, 1988）。</p>
<p>关于 von Bertalanffy 曲线和逆逻辑斯蒂曲线的比较，逆逻辑斯蒂负对数似然值为 <span class="math inline">\(-2.0 \times(277.0122-291.1691) = 28.3138\)</span> ，明显小于 von Bertalanffy 曲线的负对数似然值。我们可以使用 MQMF 函数 <code>likeratio()</code>来说明这两种曲线在拟合数据方面的差异具有高度显著性。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb29"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co"># Likelihood ratio comparison of two growth models see Fig 5.4  </span></span>
<span><span class="va">vb</span> <span class="op">&lt;-</span> <span class="va">modelvb</span><span class="op">$</span><span class="va">minimum</span> <span class="co"># their respective -ve log-likelihoods  </span></span>
<span><span class="va">il</span> <span class="op">&lt;-</span> <span class="va">modelil</span><span class="op">$</span><span class="va">minimum</span>  </span>
<span><span class="va">dof</span> <span class="op">&lt;-</span> <span class="fl">1</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="fu">likeratio</span><span class="op">(</span><span class="va">vb</span>,<span class="va">il</span>,<span class="va">dof</span><span class="op">)</span>,<span class="fl">8</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>         LR           P      mindif          df 
28.31380340  0.00000005  3.84145882  1.00000000 </code></pre>
</div>
</div>
</section><section id="似然比检验的注意事项" class="level3" data-number="5.4.3"><h3 data-number="5.4.3" class="anchored" data-anchor-id="似然比检验的注意事项">
<span class="header-section-number">5.4.3</span> 似然比检验的注意事项</h3>
<p>由于在渔业模型中广泛使用加权对数似然，当使用似然比检验来比较替代模型时，需要小心确保这些模型实际上是可比的。当我们使用相同的数据和相同的概率密度函数来描述残差分布时，可以使用似然比检验。但请记住，当我们仅对相同的生长模型应用不同的残差误差结构假设（对数正态而非正态）时，这些曲线是完全不可比的（不具可比性）。同样，在使用惩罚似然时，不同版本的模型可能会对不同的数据流给予不同的权重，这种变化使得模型不可比。很明显，应该只比较可比的模型，但在一些更复杂的模型中，确定什么是公平比较有时并不总是简单的。</p>
</section></section><section id="关于生长的说明" class="level2" data-number="5.5"><h2 data-number="5.5" class="anchored" data-anchor-id="关于生长的说明">
<span class="header-section-number">5.5</span> 关于生长的说明</h2>
<p>对个体生长过程的描述对渔业模型很重要，因为个体的大小和重量的生长是特定种群生产力的重要组成部分。这种生长显然是增加种群生物量过程与减少种群生物量过程之间平衡的一个积极因素。但重要的是要理解，生长的描述总是描述性的，并且主要适用于我们有数据的大小范围。有许多实例表明，von Bertalanffy 曲线外推的弱点会导致生物学上荒谬的预测（Knight，1968）。但这类实例是将模型参数的特定解释误认为现实，而曲线仅仅是生长数据的描述，严格来说只在有数据的地方有效。这就是为什么已经产生了生长模型转换，这些转换估计的参数可以位于可用数据的范围内（Schnute，1981；Francis，1988，1995）。</p>
</section><section id="成熟" class="level2" data-number="5.6"><h2 data-number="5.6" class="anchored" data-anchor-id="成熟">
<span class="header-section-number">5.6</span> 成熟</h2>
<section id="引言" class="level3" data-number="5.6.1"><h3 data-number="5.6.1" class="anchored" data-anchor-id="引言">
<span class="header-section-number">5.6.1</span> 引言</h3>
<p>目前，渔业管理倾向于使用所谓的生物参考点来构建其希望构成合理且可辩护的管理决策的基础，这些决策针对的是可再生的自然资源（FAO，1995，1996，1997；Restrepo 和 POwers，1999；Haddon，2007）。简单来说，这个想法是设定一个目标参考点，通常定义为成熟生物量水平或其某种替代指标，该指标被认为是种群的一种理想状态。它是理想状态，因为通常它应该能够为后续的补充提供良好的水平，并为种群提供足够的恢复力以抵御偶尔的环境冲击。常见的默认值可以是 <span class="math inline">\(B_{40}\)</span>，即 <span class="math inline">\(40\% B_0\)</span>，或 40% 的消耗水平，这被用作 <span class="math inline">\(B_{MSY}\)</span> 的替代指标，或者是能够可持续产生最大可持续产量的产卵生物量。在澳大利亚，联邦收获策略政策将目标定义为 <span class="math inline">\(B_{48}\)</span>，这被用作 <span class="math inline">\(B_{MEY}\)</span> 的替代指标，即应该能够产生最大经济效益的产卵生物量（注意，目标是生物量水平 <span class="math inline">\(B_{MSY}\)</span>，而不是 <span class="math inline">\(MEY\)</span>；DAFF，2007；Rayns，2007）。 此外，还需定义一个极限参考点，同样以成熟生物量（或替代指标）的水平来表示，低于该水平时，所关注的种群将被认为其补充量存在受损害的风险。生物参考点通常以未受干扰的产卵生物量的估计值（ <span class="math inline">\(B_0\)</span> ）为基准来表述。 <span class="math inline">\(B_0\)</span> 的概念可以是均衡概念，也可以是更动态的版本，试图解释补充量的变化。无论哪种情况，这个数值在评估中往往具有不确定性，并且在不同评估中经常发生变化（Punt 等，2018 ）。为了提供管理建议，需要三个要素：</p>
<ul>
<li><p>对当前种群状态进行评估，包括繁殖生物量的消耗情况，从而</p></li>
<li><p>当前未捕捞的产卵生物量估计值，最后</p></li>
<li><p>一个决定下一个季节（些）允许的捕捞死亡率、努力量或渔获量的捕捞控制规则。</p></li>
</ul>
<p>也许你注意到了，我在成熟和产卵生物量这两个术语之间互换使用。这样做并不是想让你感到困惑，而是想让你习惯于文献中会遇到的术语变化。</p>
<p>强调成熟生物量或产卵生物量的重要性，是获得合理成熟大小或年龄估计的原因。这是为了确保对成熟生物量有多少的估计能够反映鱼种的生物学特性以及当前渔业状态。在本书中，我们试图专注于建模，但始终试图模拟潜在的生物学现实。事实上，生物学现实，就像生长的细节一样，往往相当复杂。在渔业理论中，许多基础来自北半球，特别是对北海和大西洋的高生产力鱼种进行研究（Smith，1994）。那里的许多商业物种具有相对简单的繁殖历史。有雄性和雌性，作为一个种群，它们按一般节律成熟，它们在死亡之前要么产卵一次，要么每年产卵。当然，这是一种过度简化，生物学世界比这要多样化得多，即使在北半球也是如此。 有些物种从一开始就是雌性，其中一些较大的雌性会转变为雄性（原雌雄同体），反之亦然（原雄雌同体）。存在许多不同的繁殖策略，其中许多策略会影响诸如成熟大小和/或年龄等因素。然而，在这里我们将只关注经典方法。尽管如此，使用你自己的例子时，不要对生物学做出假设，始终情况下，来自种群的代表性证据比假设更好。</p>
<p>成熟时的个体大小或年龄是一个种群特性。个体可能经历成熟过程，并需要时间才能具备繁殖能力，但我们描述的过程是针对整个种群的平均值。给定一个样本，希望是一个足够大的样本，能够覆盖成熟时个体大小或年龄的范围，我们的目标是描述每个个体大小或年龄的鱼类中成熟的比例。成熟时个体大小（size-at-maturity ）的概念通常被总结为 种群中50% 个体性成熟（具备繁殖能力）时的个体大小。实际上， <span class="math inline">\(Lm_{50}\)</span> ，即 50% 成熟的个体长度，只是重要因素的一部分，此外，正如我们将看到的，关于物种随长度或年龄成熟的速度的某种度量也同样重要。一些更简单的渔业模型仍然使用一种被称为“刀刃式成熟”（knife-edge matruity）的假设，这意味着一个强烈的假设，即 100% 的动物在某个特定年龄成熟。我们将在后面讨论种群成熟所需的时间如何影响种群动态。 如何确定成熟度在此不予考虑，尽管理想情况下应使用组织学来确认成熟的配子，而不是仅仅通过观察鱼类的性腺。再次强调，有大量文献致力于详细说明确定各种物种成熟阶段的细节，但我们不会尝试去探讨这些内容。我们所要完成的任务是找到预期种群成熟曲线的数学描述。预期的是，被认为成熟的动物比例会随着体型和年龄的增长而增加，直到 100%成熟（尽管即使对此也有例外，某些物种的雌性会花几年时间从产生卵子所需的大量能量投资中恢复，从而暂时停止繁殖）。生命史特征体现在物种是适应一次性繁殖（半繁殖性）还是多次繁殖（多次繁殖性），或者它产生的是大量小卵还是远少得多的大卵，甚至生产少量活体幼崽。始终要记住，生物学可以非常复杂，而生物学的数学描述是相对简单的抽象。</p>
</section><section id="替代的成熟度曲线" class="level3" data-number="5.6.2"><h3 data-number="5.6.2" class="anchored" data-anchor-id="替代的成熟度曲线">
<span class="header-section-number">5.6.2</span> 替代的成熟度曲线</h3>
<p>一个种群内成熟的一般模式是，成熟度会分布在一系列长度和年龄中，其中一部分早熟，一部分晚熟，大多数则在某个平均时间成熟。如果我们想象一个随时间变化的成熟比例的抛物线曲线，可能接近正态分布但尾部更短，那么我们想要的是该分布的累积密度函数，在某个长度或年龄范围内从 0% 到 100% 运行。结果是常见的 S 形曲线，通常称为逻辑斯蒂曲线，在文献中，有大量不同的数学表达式来描述这类曲线。我们关注的统计量是 <span class="math inline">\(Lm_{50}\)</span> （50%成熟的大小/年龄），以及 <span class="math inline">\(IQ\)</span> ，即四分位距，它衡量成熟度曲线（在 25%和 75%成熟时的年龄）之间的大小/年龄范围。使用四分位距是一个任意选择，但反映了常见做法（如箱线图所示），但并不排除使用更宽或更窄的范围，如果这些范围更方便的话。</p>
<p>在众多不同版本中，有一个经典的逻辑斯蒂曲线 <a href="#eq-5_12" class="quarto-xref">公式&nbsp;<span>5.12</span></a>，常用于描述许多种群的成熟过程（参见 <strong>MQMF</strong> 函数）。这种形式非常适合使用具有二项式误差的广义线性模型进行拟合。我们一直使用 R 作为编程环境，但这里是一个提醒我们，它的最初目的是作为统计分析工具的机会。</p>
<p><span id="eq-5_12"><span class="math display">\[
p_L = \dfrac{\exp(a +bL)}{1+ \exp(a +bL)} = \dfrac{1}{1+\exp(a +bL)^{-1}}
\qquad(5.12)\]</span></span></p>
<p><span class="math inline">\(p_L\)</span> 是长度 <span class="math inline">\(L\)</span> 的成熟比例，而 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 是指数参数。请注意，我在方程中未包含误差项。这里我们试图对不同个体大小（为简洁起见，我将停止每次写“尺寸或年龄”）的成熟或不成熟观测进行预测。这正是建议我们应使用二元误差的原因，如模型参数估计章节所述。这种公式的另一个优点是 <span class="math inline">\(Lm_{50} = -a/b\)</span> ，即 50% 成熟时的个体大小，可以直接从参数中推导出来。类似地，四分位距也可以从参数中推导出来，表示为 <span class="math inline">\(IQ = 2\times \log(3)/b = 2.197225 \times b\)</span>。</p>
<p>成熟数据具有二元特性，在特定采样时间对种群进行采样时，观测值是每个大小为 <span class="math inline">\(L\)</span> 的采样鱼是否成熟。本书的 R 包 <strong>MQMF</strong> 包含一个示例数据集 tasab，其中包含来自塔斯马尼亚海岸线 16 公里段上两个地点的黑唇鲍鱼（<em>Haliotis rubra</em>）数据。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb31"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span>   <span class="co"># The Maturity data from tasab data-set  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="va">tasab</span><span class="op">)</span>       <span class="co"># see ?tasab for a list of the codes used  </span></span>
<span><span class="fu">properties</span><span class="op">(</span><span class="va">tasab</span><span class="op">)</span> <span class="co"># summarize properties of columns in tasab  </span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>       Index isNA Unique     Class Min Max Example
site       1    0      2   integer   1   2       1
sex        2    0      3 character   0   0       I
length     3    0     85   integer  62 160     102
mature     4    0      2   integer   0   1       0</code></pre>
</div>
</div>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb33"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/table.html">table</a></span><span class="op">(</span><span class="va">tasab</span><span class="op">$</span><span class="va">site</span>,<span class="va">tasab</span><span class="op">$</span><span class="va">sex</span><span class="op">)</span> <span class="co"># sites 1 &amp; 2 vs F, I, and M  </span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>   
      F   I   M
  1 116  11 123
  2 207  85 173</code></pre>
</div>
</div>
<p>鲍鱼因其生物学特征在相对较小的空间尺度上具有高度变异性而臭名昭著，因此采样地点的细节非常重要（Haddon 和 Helidoniotis，2013）。这些数据都是由同一群人在同一个月同年收集的，因此除了壳长之外，我们唯一可能认为会影响成熟度的因素就是具体地点（性别似乎在同一时间、同一个体大小成熟； <a href="#fig-5-7" class="quarto-xref">图&nbsp;<span>5.7</span></a> ）。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb35"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span>   <span class="co">#plot the proportion mature vs shell length  Fig 5.7  </span></span>
<span><span class="va">propm</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/tapply.html">tapply</a></span><span class="op">(</span><span class="va">tasab</span><span class="op">$</span><span class="va">mature</span>,<span class="va">tasab</span><span class="op">$</span><span class="va">length</span>,<span class="va">mean</span><span class="op">)</span> <span class="co">#mean maturity at L  </span></span>
<span><span class="va">lens</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html">as.numeric</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span><span class="op">(</span><span class="va">propm</span><span class="op">)</span><span class="op">)</span>            <span class="co"># lengths in the data  </span></span>
<span><span class="fu">plot1</span><span class="op">(</span><span class="va">lens</span>,<span class="va">propm</span>,type<span class="op">=</span><span class="st">"p"</span>,cex<span class="op">=</span><span class="fl">0.9</span>,xlab<span class="op">=</span><span class="st">"Length mm"</span>,  </span>
<span>      ylab<span class="op">=</span><span class="st">"Proportion Mature"</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-5-7" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-5-7-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="05-staticModel_files/figure-html/fig-5-7-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-5-7-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;5.7: tasab 数据集中黑唇鲍鱼成熟数据的长度成熟比例。
</figcaption></figure>
</div>
</div>
</div>
<p>数据看起来相对嘈杂，虽然这很难判断，因为一些观察到的长度，其成熟比例不是 0 也不是 1，可能只有少数几次观测。例如，在长度为 100mm 处有一个成熟比例为 0.5 的点，如果你深入数据会发现该点仅由两个观测组成，一个成熟另一个不成熟。可以通过 <code>pick &lt;- which(tasab$length == 100)</code> 查找这些长度，或者通过 <code>which(propm == 0.5)</code> 查看数据，再使用 <code>tasab[pick,]</code>进一步分析。</p>
<p>使用 <code>properties(tasab)</code> 或 <code>head(tasab,10)</code> 查看数据集，可以告诉我们有哪些变量。虽然我们显然希望检查成熟和长度之间的关系，但请记住，最初我们还想检查站点对成熟的影响。重要的是，我们需要将站点变量转换为分类因子，否则它将被视为包含 1 和 2 的整数向量，而不是潜在的不同处理。我们不能将性别作为因子包括进来，因为所有动物最初都是未成熟状态，尽管可以始终分别分析雄性和雌性数据。然而，在更多的站点上，到目前为止，在黑唇牡蛎中，尚未发现性别在成熟速率或平均大小上的可重复差异。一旦拟合，我们会发现站点对分析无信息性（它不显著），因此我们重新进行不包括站点的分析。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb36"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#Use glm to estimate mature logistic  </span></span>
<span><span class="va">binglm</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>,<span class="va">digits</span><span class="op">=</span><span class="fl">6</span><span class="op">)</span> <span class="op">{</span> <span class="co">#function to simplify printing  </span></span>
<span>  <span class="va">out</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/summary.html">summary</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span>  </span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/print.html">print</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">call</span><span class="op">)</span>  </span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/print.html">print</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">coefficients</span>,<span class="va">digits</span><span class="op">)</span><span class="op">)</span>  </span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"\nNull Deviance  "</span>,<span class="va">out</span><span class="op">$</span><span class="va">null.deviance</span>,<span class="st">"df"</span>,<span class="va">out</span><span class="op">$</span><span class="va">df.null</span>,<span class="st">"\n"</span><span class="op">)</span>  </span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"Resid.Deviance "</span>,<span class="va">out</span><span class="op">$</span><span class="va">deviance</span>,<span class="st">"df"</span>,<span class="va">out</span><span class="op">$</span><span class="va">df.residual</span>,<span class="st">"\n"</span><span class="op">)</span>  </span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"AIC  = "</span>,<span class="va">out</span><span class="op">$</span><span class="va">aic</span>,<span class="st">"\n\n"</span><span class="op">)</span>  </span>
<span>  <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/invisible.html">invisible</a></span><span class="op">(</span><span class="va">out</span><span class="op">)</span><span class="op">)</span> <span class="co"># retain the full summary  </span></span>
<span><span class="op">}</span> <span class="co">#end of binglm  </span></span>
<span><span class="va">tasab</span><span class="op">$</span><span class="va">site</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/factor.html">as.factor</a></span><span class="op">(</span><span class="va">tasab</span><span class="op">$</span><span class="va">site</span><span class="op">)</span> <span class="co"># site as a factor  </span></span>
<span><span class="va">smodel</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/glm.html">glm</a></span><span class="op">(</span><span class="va">mature</span> <span class="op">~</span> <span class="va">site</span> <span class="op">+</span> <span class="va">length</span>,family<span class="op">=</span><span class="va">binomial</span>,data<span class="op">=</span><span class="va">tasab</span><span class="op">)</span> </span>
<span><span class="va">outs</span> <span class="op">&lt;-</span> <span class="fu">binglm</span><span class="op">(</span><span class="va">smodel</span><span class="op">)</span>  <span class="co">#outs contains the whole summary object  </span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>glm(formula = mature ~ site + length, family = binomial, data = tasab)
              Estimate Std. Error   z value Pr(&gt;|z|)
(Intercept) -19.797096   2.361561 -8.383056 0.000000
site2        -0.369502   0.449678 -0.821703 0.411246
length        0.182551   0.019872  9.186463 0.000000

Null Deviance   564.0149 df 714 
Resid.Deviance  170.7051 df 712 
AIC  =  176.7051 </code></pre>
</div>
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb38"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">model</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/glm.html">glm</a></span><span class="op">(</span><span class="va">mature</span> <span class="op">~</span> <span class="va">length</span>, family<span class="op">=</span><span class="va">binomial</span>, data<span class="op">=</span><span class="va">tasab</span><span class="op">)</span>  </span>
<span><span class="va">outm</span> <span class="op">&lt;-</span> <span class="fu">binglm</span><span class="op">(</span><span class="va">model</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>glm(formula = mature ~ length, family = binomial, data = tasab)
              Estimate Std. Error   z value Pr(&gt;|z|)
(Intercept) -20.464131   2.265539 -9.032787        0
length        0.186137   0.019736  9.431291        0

Null Deviance   564.0149 df 714 
Resid.Deviance  171.3903 df 713 
AIC  =  175.3903 </code></pre>
</div>
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb40"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">cof</span> <span class="op">&lt;-</span> <span class="va">outm</span><span class="op">$</span><span class="va">coefficients</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"Lm50 = "</span>,<span class="op">-</span><span class="va">cof</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">1</span><span class="op">]</span><span class="op">/</span><span class="va">cof</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">]</span>,<span class="st">"\n"</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>Lm50 =  109.9414 </code></pre>
</div>
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb42"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"IQ   = "</span>,<span class="fl">2</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="fl">3</span><span class="op">)</span><span class="op">/</span><span class="va">cof</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">]</span>,<span class="st">"\n"</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>IQ   =  11.80436 </code></pre>
</div>
</div>
<p>在第一次分析中，包括了站点因素，因为我在汇总数据时确保所包含的站点相似，因此站点 2（P=0.411）与站点 1 没有显著差异，这意味着在这种情况下，站点因素对分析来说并不具有信息性。因此，我们再次进行了分析，将站点从方程中剔除。如果站点之间表现出显著差异，那么我们需要使用多个曲线来描述模型结果。无论怎样，我们还是会将它们画成不同的曲线来说明过程。额外的站点参数是对初始指数截距值的修饰。因此，ab$length 参数在两种情况下都是 <span class="math inline">\(b\)</span> 参数，但站点 1 的曲线可以通过将截距视为 <span class="math inline">\(a\)</span> 参数来获得，而站点 2 的曲线则需要将截距和 ab$site2 的参数值相加，作为 <span class="math inline">\(a\)</span> 参数。因此，站点 1 模型为 <span class="math inline">\(a = -19.797\)</span> 和 <span class="math inline">\(b = 0.18255\)</span> ，而站点 2 模型为 <span class="math inline">\(a = -19.797 -0.3695\)</span> 和 <span class="math inline">\(b = 0.18255\)</span> 。将最终无站点模型添加到图中表明，综合模型更接近站点 2，这反映了站点 2 的观测次数为 465 次，而站点 1 仅为 250 次。 注意，参数少一个后，残差偏差略有增加，但尽管如此，包含站点因子的模型的 AIC 值仍然大于简化模型的 AIC 值，这再次表明简化模型在复杂性和模型拟合度之间提供了更好的平衡。这与广义线性模型及其比较和操作有明显的类比。如果确实发现截距之间存在显著差异，那么测试差异是否也扩展到 <span class="math inline">\(b\)</span> 参数，以确定是否需要完全分开处理这些曲线是有意义的。共享公共参数通常是有帮助的，因为它可以增加样本量。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb44"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#Add maturity logistics to the maturity data plot Fig 5.8  </span></span>
<span><span class="va">propm</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/tapply.html">tapply</a></span><span class="op">(</span><span class="va">tasab</span><span class="op">$</span><span class="va">mature</span>,<span class="va">tasab</span><span class="op">$</span><span class="va">length</span>,<span class="va">mean</span><span class="op">)</span> <span class="co">#prop mature  </span></span>
<span><span class="va">lens</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html">as.numeric</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span><span class="op">(</span><span class="va">propm</span><span class="op">)</span><span class="op">)</span>       <span class="co"># lengths in the data  </span></span>
<span><span class="va">pick</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/which.html">which</a></span><span class="op">(</span><span class="op">(</span><span class="va">lens</span> <span class="op">&gt;</span> <span class="fl">79</span><span class="op">)</span> <span class="op">&amp;</span> <span class="op">(</span><span class="va">lens</span> <span class="op">&lt;</span> <span class="fl">146</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu">parset</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">lens</span><span class="op">[</span><span class="va">pick</span><span class="op">]</span>,<span class="va">propm</span><span class="op">[</span><span class="va">pick</span><span class="op">]</span>,type<span class="op">=</span><span class="st">"p"</span>,cex<span class="op">=</span><span class="fl">0.9</span>, <span class="co">#the data points  </span></span>
<span>      xlab<span class="op">=</span><span class="st">"Length mm"</span>,ylab<span class="op">=</span><span class="st">"Proportion Mature"</span>,pch<span class="op">=</span><span class="fl">1</span><span class="op">)</span>   </span>
<span><span class="va">L</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fl">80</span>,<span class="fl">145</span>,<span class="fl">1</span><span class="op">)</span> <span class="co"># for increased curve separation  </span></span>
<span><span class="va">pars</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/coef.html">coef</a></span><span class="op">(</span><span class="va">smodel</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">L</span>,<span class="fu">mature</span><span class="op">(</span><span class="va">pars</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>,<span class="va">pars</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span>,<span class="va">L</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">3</span>,col<span class="op">=</span><span class="fl">3</span>,lty<span class="op">=</span><span class="fl">2</span><span class="op">)</span>    </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">L</span>,<span class="fu">mature</span><span class="op">(</span><span class="va">pars</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">+</span><span class="va">pars</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span>,<span class="va">pars</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span>,<span class="va">L</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">3</span>,col<span class="op">=</span><span class="fl">2</span>,lty<span class="op">=</span><span class="fl">4</span><span class="op">)</span>    </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">L</span>,<span class="fu">mature</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/coef.html">coef</a></span><span class="op">(</span><span class="va">model</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>,<span class="fu"><a href="https://rdrr.io/r/stats/coef.html">coef</a></span><span class="op">(</span><span class="va">model</span><span class="op">)</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span>,<span class="va">L</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">1</span>,lty<span class="op">=</span><span class="fl">1</span><span class="op">)</span>    </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html">abline</a></span><span class="op">(</span>h<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.25</span>,<span class="fl">0.5</span>,<span class="fl">0.75</span><span class="op">)</span>,lty<span class="op">=</span><span class="fl">3</span>,col<span class="op">=</span><span class="st">"grey"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/legend.html">legend</a></span><span class="op">(</span><span class="st">"topleft"</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"site1"</span>,<span class="st">"both"</span>,<span class="st">"site2"</span><span class="op">)</span>,col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">3</span>,<span class="fl">1</span>,<span class="fl">2</span><span class="op">)</span>,lty<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">1</span>,<span class="fl">4</span><span class="op">)</span>,  </span>
<span>       lwd<span class="op">=</span><span class="fl">3</span>,bty<span class="op">=</span><span class="st">"n"</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-5-8" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-5-8-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="05-staticModel_files/figure-html/fig-5-8-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-5-8-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;5.8: 黑唇牡蛎成熟度数据（tasab 数据集）的长度成熟比例。不考虑站点的综合分析（两者）更接近站点 2（点划线）而非站点 1（划线），这反映了站点 2 样本量更大。
</figcaption></figure>
</div>
</div>
</div>
<p>大样本量通常能提高模型拟合的质量。如果有足够的数据，当前数据所表现出的变异性可能会被充分降低，从而可以在这些站点之间找到统计学上的显著差异。然而，如果我们考虑站点 1 和站点 2 的 <span class="math inline">\(Lm_{50}\)</span> 差异约为 2 毫米（总共 110 毫米），从生物学角度来看，这种差异可能并不重要，因为两个站点之间的生长速率也可能不同。正如任何模型或统计分析一样，在关注统计显著性的同时，还应考虑生物学意义。</p>
</section><section id="对称性假设" class="level3" data-number="5.6.3"><h3 data-number="5.6.3" class="anchored" data-anchor-id="对称性假设">
<span class="header-section-number">5.6.3</span> 对称性假设</h3>
<p>在很多情况下，标准逻辑曲线很好地描述了从未成熟到成熟（或者可能是其他生物过渡，如隐性到显性、 molt 阶段 A 到阶段 B 等）的过程。然而，经典逻辑曲线的主要限制是它在 <span class="math inline">\(L_{50}\)</span> 点对称，这可能不是对现实世界事件的最佳描述。</p>
<p>已经提出了多种替代的非对称曲线，但幸运的是，Schnute 和 Richards（1990）提出了一种通用或统一模型，用于描述“鱼类生长、成熟和存活数据”，这种模型不仅推广了用于描述成熟度的经典逻辑斯谛模型，还推广了 Gompertz（1825）、von Bertalanffy（1938）、Richards（1959）、Chapman（1961）和 Schnute（1981）提出的生长模型，其中一些模型也可以用于描述成熟过程。</p>
<p>Schnute 和 Richards (1990) 模型有四个参数：</p>
<p><span id="eq-5_13"><span class="math display">\[
y^{b} = 1+ \alpha \exp(-a x^c)
\qquad(5.13)\]</span></span></p>
<p>可以重新排列， <a href="#eq-5_14" class="quarto-xref">公式&nbsp;<span>5.14</span></a> ，以更好地展示其与经典的逻辑斯蒂曲线 <a href="#eq-5_12" class="quarto-xref">公式&nbsp;<span>5.12</span></a> 的关系，如果我们将两者设置为 <span class="math inline">\(b = c = 1.0\)</span> ，则相当于经典的逻辑斯蒂曲线（例如，设置 <span class="math inline">\(\alpha = 300\)</span> 和 <span class="math inline">\(a = 0.12\)</span> ）。</p>
<p><span id="eq-5_14"><span class="math display">\[
y = \dfrac{1}{1+ \alpha \exp(-a x^c)^{1/b}}
\qquad(5.14)\]</span></span></p>
<p>如果使用其中一种特殊的经典情况，可能会有解析解来确定 <span class="math inline">\(L_{50}\)</span> 和 <span class="math inline">\(IQ\)</span>，但通常情况下需要通过数值方法来找到它们（参见 <strong>MQMF</strong> 函数<code>bracket()</code>和 <code>linter()</code> ）。这条曲线可以用二项式误差来拟合成熟数据，就像之前那样，尽管可以使用 <code><a href="https://rdrr.io/r/stats/nlm.html">nlm()</a></code> 或其他非线性求解器（Schnute 和 Richards, 1990 年提供了所需的似然函数）。但特殊情况可能为完整的四参数模型提供更稳定的解。从（5.14）式所示的可能曲线的不对称性，可以很容易地使用 <strong>MQMF</strong> <code>srug()</code> 函数（Schnute 和 Richards 统一增长模型）来证明。在没有找到 <span class="math inline">\(L_{50}\)</span> 和 <span class="math inline">\(IQ\)</span> 的解析解时，我们可以使用两个函数 <code>bracket()</code> 和 <code>linter()</code>，它们界定了目标值（在这种情况下为 0.25、0.5 和 0.75），然后线性插值以生成所需的统计量的近似估计值（参见它们的帮助文件和示例）。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb45"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#Asymmetrical maturity curve from Schnute and Richard's curve Fig5.9  </span></span>
<span><span class="va">L</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fl">50</span>,<span class="fl">160</span>,<span class="fl">1</span><span class="op">)</span>  </span>
<span><span class="va">p</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span>a<span class="op">=</span><span class="fl">0.07</span>,b<span class="op">=</span><span class="fl">0.2</span>,c<span class="op">=</span><span class="fl">1.0</span>,alpha<span class="op">=</span><span class="fl">100</span><span class="op">)</span>  </span>
<span><span class="va">asym</span> <span class="op">&lt;-</span> <span class="fu">srug</span><span class="op">(</span>p<span class="op">=</span><span class="va">p</span>,sizeage<span class="op">=</span><span class="va">L</span><span class="op">)</span>  </span>
<span><span class="va">L25</span> <span class="op">&lt;-</span> <span class="fu">linter</span><span class="op">(</span><span class="fu">bracket</span><span class="op">(</span><span class="fl">0.25</span>,<span class="va">asym</span>,<span class="va">L</span><span class="op">)</span><span class="op">)</span>   </span>
<span><span class="va">L50</span> <span class="op">&lt;-</span> <span class="fu">linter</span><span class="op">(</span><span class="fu">bracket</span><span class="op">(</span><span class="fl">0.5</span>,<span class="va">asym</span>,<span class="va">L</span><span class="op">)</span><span class="op">)</span>   </span>
<span><span class="va">L75</span> <span class="op">&lt;-</span> <span class="fu">linter</span><span class="op">(</span><span class="fu">bracket</span><span class="op">(</span><span class="fl">0.75</span>,<span class="va">asym</span>,<span class="va">L</span><span class="op">)</span><span class="op">)</span> </span>
<span><span class="fu">parset</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">L</span>,<span class="va">asym</span>,type<span class="op">=</span><span class="st">"l"</span>,lwd<span class="op">=</span><span class="fl">2</span>,xlab<span class="op">=</span><span class="st">"Length mm"</span>,ylab<span class="op">=</span><span class="st">"Proportion Mature"</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html">abline</a></span><span class="op">(</span>h<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.25</span>,<span class="fl">0.5</span>,<span class="fl">0.75</span><span class="op">)</span>,lty<span class="op">=</span><span class="fl">3</span>,col<span class="op">=</span><span class="st">"grey"</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html">abline</a></span><span class="op">(</span>v<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">L25</span>,<span class="va">L50</span>,<span class="va">L75</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">1</span><span class="op">)</span>,col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">1</span><span class="op">)</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-5-9" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-5-9-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="05-staticModel_files/figure-html/fig-5-9-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-5-9-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;5.9: 使用 Schnute 和 Richards 统一生长曲线的假设示例中达到成熟长度的比例。通过绿色虚线所示的四分位距左右两侧的差异，展示了该逻辑斯蒂曲线的不对称性。
</figcaption></figure>
</div>
</div>
</div>
<p>使用 <a href="#fig-5-9" class="quarto-xref">图&nbsp;<span>5.9</span></a> 中使用的参数作为基准，我们可以单独改变各个参数来确定其对结果曲线的影响。 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(c\)</span> 参数相对影响四分位距，而所有四个参数都影响 <span class="math inline">\(L_{50}\)</span>。</p>
<p>Schnute（1981）的模型在文献中似乎比 Schnute 和 Richards（1990）的更通用的模型使用得更多，这在 Schnute 和 Richards 模型旨在展示所有这些不同曲线可以统一，并因此具有一定程度的共性时是自然的。这强调了这些曲线主要提供的是生物学过程的经验描述，而这些过程本身是所研究种群的涌现属性。严格地对这些参数进行生物学解释，并期望自然界总是提供合理的或有意义的参数值，这是过度推断。例如，Knight（1968）描述的情况，他讨论的是生长，但实际上是在讨论是否应该对经验模型参数进行明确解释。他指出：“更为重要的是，将 <span class="math inline">\(L_{\infty}\)</span> 视为自然事实，而不是数据分析的产物，会引发扭曲的观点。”（Knight, 1968, p 1306）。 描述性而非解释性的模型（关于过程的假设性描述）仍然是经验性描述，当尝试解释其参数时需要格外小心。</p>
</section></section><section id="补充量" class="level2" data-number="5.7"><h2 data-number="5.7" class="anchored" data-anchor-id="补充量">
<span class="header-section-number">5.7</span> 补充量</h2>
<section id="引言-1" class="level3" data-number="5.7.1"><h3 data-number="5.7.1" class="anchored" data-anchor-id="引言-1">
<span class="header-section-number">5.7.1</span> 引言</h3>
<p>种群生物量生产的主要贡献者包括新个体对种群的补充和个体的生长（其中，种群的定义意味着我们无需考虑迁入）。再次强调，关于补充过程的文献非常丰富（Cushing，1988；Myers 和 Barrowman，1996；Myers，2001），但在这里我们将主要关注在尝试将其动态纳入模型时如何描述它。与其他生长和成熟静态模型一样，这些模型被认为随时间保持不变，尽管在种群评估模型中存在时间分段选项，可以在特定界定的时间段内使用不同的参数集（Wayte，2013）。本节中我们将重点关注简单的描述。</p>
<p>鱼类种群的补充量自然倾向于高度变异，不同物种的变异程度有所不同。如果你觉得我在一句话中频繁使用”变异”及相关术语，或许这会强化补充量确实高度变异的观点。渔业科学家面临的主要问题是补充量是由繁殖群体资源量、环境变异或两者的某种组合决定的。这让人回想起 20 世纪 50 年代种群动态学中的争论，即种群是否受密度依赖或密度独立效应的控制（Andrewartha and Birch, 1954）。这个变异问题导致了一种普遍但错误的信念，即在一个观察到的群体规模范围内，渔业的补充量实际上与成鱼群体规模无关。这可能是一个危险的假设（Gulland, 1983）。补充量与繁殖群体资源量之间没有关系的观点认为，科学家和管理者可以忽视群体补充量关系，除非有明确证据表明补充量与群体资源量无关。 种群补充量无关系的观点源于通常情况下关于这种关系的数据显得非常分散，没有明显的特征。</p>
<p>尽管存在争议，但在渔业模型中，对 补充过程的建模仍然具有重要意义。因为用这些模型提供从当前时间点出发的管理建议时，通常会在评估不同捕捞或努力量水平的影响时，将模型动态向前预测。通过在这些预测中包含不确定性，可以估计不同管理方案未能实现预期管理目标的相对风险（Francis，1992）。但要进行此类预测，需要了解鱼群的生产力。假设已包含了个体生长动态，那么对补充量水平的时间序列估计或某种定义的鱼群补充量关系可以用来为这些预测生成未来补充量水平的估计。</p>
<p>在本章中，我们将仅考虑鱼类种群补充量关系的数学描述，并且大多忽略这些关系背后的生物学因素，尽管总会有例外。我们将回顾两种最常用的鱼类种群补充量数学模型，并讨论它们在复杂程度不同的种群评估模型中的应用。</p>
</section><section id="良好种群补充量关系的性质" class="level3" data-number="5.7.2"><h3 data-number="5.7.2" class="anchored" data-anchor-id="良好种群补充量关系的性质">
<span class="header-section-number">5.7.2</span> “良好”种群补充量关系的性质</h3>
<p>Cushing（1988）为种群补充关系的生物学过程提供了很好的介绍，他概述了卵和幼鱼死亡的原因，并提供了丰富的实例和该主题的参考文献。与其他讨论的基本生产过程一样，关于种群补充量关系的生物学及其调节因素的文献非常丰富。</p>
<p>已有研究已证实多种生物学和物理因素对补充量结果有影响。我们不会考虑任何真实物种的生物学细节，除非指出种群资源量与补充量之间的关系并非决定性，且可能存在多种反馈形式影响结果。已提出多种描述种群补充量关系的数学模型，但我们仅考虑 Beverton 和 Holt 以及 Ricker 的模型，而 Deriso-Schnute（Deriso, 1980; Schnute, 1985）等模型也同样重要。</p>
<p>Ricker (1975) 列出了他认为理想的平均种群补充关系的四个特性：</p>
<ul>
<li><p>种群补充曲线应通过原点；也就是说，当种群数量为零时，补充量应为零。这假设所考虑的观测值与总种群相关，并且不存在由移民组成的“补充”。</p></li>
<li><p>补充量不应在高种群密度时降至零。这不是一个必要条件，尽管观察到补充量随种群密度增加而下降，但并未观察到补充量降至零的情况。即使种群在最大生物量时达到平衡，补充量仍应与自然死亡率相匹配。</p></li>
<li><p>补充量率（单位繁殖群体补充量）应随着亲本群体的增加而持续减少。只有当正密度依赖机制（补偿性机制）在起作用时（例如，群体增加导致幼体死亡率增加），这种情况才是合理的。但如果负密度依赖机制（消耗性机制）在起作用（例如，捕食者饱和和 Allee 效应；Begon and Mortimer, 1986），那么这并不总是成立。</p></li>
<li><p>补充量必须超过亲代种群在亲代种群可能范围的部分。严格来说，这仅适用于在死亡前只繁殖一次的物种（例如鲑鱼）。对于寿命更长、多次繁殖的物种，应解释为补充量必须足够高，以超过因年度自然死亡率造成的损失。</p></li>
</ul>
<p>Hilborn 和 Walters（1992）提出了另外两种他们认为与良好种群补充关系相关的普遍特性：</p>
<ul>
<li><p>平均繁殖群体补充量曲线应该是连续的，在群体规模的小幅变化中不应有剧烈变化。他们指的是连续性，即平均补充量应该随着群体规模平滑变化，与上述条件 3 相关。</p></li>
<li><p>平均种群补充关系的稳定性是随时间不变的。这就是平稳性，即这种关系不会随时间发生显著变化。这一假设在生态系统发生显著变化（其中被开发种群是其中一部分）的系统中可能不成立。但在模型中，可以通过使用参数时间块来处理这种情况（例如，参见 Wayte，2013 年）。</p></li>
</ul></section><section id="补充型过度捕捞" class="level3" data-number="5.7.3"><h3 data-number="5.7.3" class="anchored" data-anchor-id="补充型过度捕捞">
<span class="header-section-number">5.7.3</span> 补充型过度捕捞</h3>
<p>“过度捕捞（overfishing）”这一术语通常在两种情境下进行讨论，即生长型过度捕捞（growth overfishing）和补充型过度捕捞（recruitment overfishing）。生长型过度捕捞是指捕捞强度过大，导致最终大多数个体在相对较小时就被捕捞。这在“单位补充量渔获量”（YPR）方面是一个问题。YPR 的分析着重于平衡因总死亡率导致的种群损失与因个体生长带来的种群增长，旨在确定开始捕捞该物种的最佳个体大小和年龄（这里的“最佳”可以有多种含义）。生长型过度捕捞是指鱼群在没有时间达到这种最佳个体大小之前就被捕获。</p>
<p>补充型过度捕捞发生时，意味着对鱼群捕捞过度，使得繁殖群体规模降低到其作为一个种群无法产生足够的新补充量来替代那些死亡（无论是自然死亡还是其他原因）的个体水平。显然，这种情况不可能持续太久，不幸的是，过度捕捞通常会导致渔业崩溃。虽然需要记住，渔业崩溃通常意味着渔业不再具有经济可行性，但这并不意味着字面意义上的灭绝。</p>
<p>虽然生长型过度捕捞相对容易检测（如果种群处于 YPR 最佳状态？尽管当然，可能会有复杂情况）。不幸的是，对于补充型过度捕捞的检测来说，情况并非如此，这可能需要确定成熟或产卵种群资源量与补充水平之间的关系。这已被证明是许多渔业面临的艰巨任务。相反，随着正式捕捞策略的出现，人们普遍的做法是确定一个被认为对后续补充构成不可接受风险的繁殖生物量水平。一个非常常见的极限参考点是未受干扰繁殖生物量的 20%（ <span class="math inline">\(0.2B_0\)</span>）。关于极限参考点耗竭水平 <span class="math inline">\(20 \% B_0\)</span> 的最早参考似乎来自 Beddington &amp; Cooke (1983)。他们以如下方式解释了他们对不同种群潜在产量分析所施加的限制：</p>
<p>“…使用预期未开发产卵生物量 20%的逃逸水平。这个数字并非保守估计，但它代表了一个较低的限制，即在此水平下可能观察到补充量的下降。”（Beddington &amp; Cooke, 1983, 第 9-10 页）。</p>
<p>导致产生 <span class="math inline">\(B_{20\%}\)</span>（注意 <span class="math inline">\(0.2B_0\)</span> 的不同表示方式）作为潜在过度捕捞指标的一个合理捕捞强度的观念的最具影响力的文件，是一份为美国国家海洋渔业服务局准备的文件（Restrepo 等，1998）。事实上，他们推荐 <span class="math inline">\(0.5B_{MSY}\)</span>，但认为 <span class="math inline">\(B20\%\)</span> 是该数值的一个可接受的替代值。然而，需要注意的是，这只是一个“经验法则”，没有实证基础将替代值 <span class="math inline">\(B_{LIM} =B_{20\%}\)</span> 或 <span class="math inline">\(0.5B_{MSY}\)</span> 联系起来。实际上，对于某些物种选择 <span class="math inline">\(0.5B_{MSY}\)</span> 可能导致 <span class="math inline">\(B_{LIM}\)</span> 远低于 <span class="math inline">\(B_{20\%}\)</span>。</p>
</section><section id="beverton-holt-补充量" class="level3" data-number="5.7.4"><h3 data-number="5.7.4" class="anchored" data-anchor-id="beverton-holt-补充量">
<span class="header-section-number">5.7.4</span> Beverton-Holt 补充量</h3>
<p>历史上，Beverton 和 Holt（1957）的种群补充曲线因其简单的解释而有用，也就意味着可以从基本原理推导出这种关系。对他们来说，数学上易于处理也很重要，因为当时只有解析方法可行。事实上，它持续使用似乎很大程度上源于惯性和传统。请注意，如果我们仅仅将 Beverton-Holt 曲线视为一种数学描述，那么实际上任何具有前面列出的良好性质的曲线都可以使用。然而，人们谈论“Beverton-Holt 种群补充模型”，但它有多种形式。有两种常见的使用形式：</p>
<p><span id="eq-5_15"><span class="math display">\[
R_y = \dfrac{B_{y-1}}{\alpha + \beta B_{y-1}} \exp \left(N(0, \sigma_R^2) \right)
\qquad(5.15)\]</span></span></p>
<p>其中 <span class="math inline">\(R_y\)</span> 代表第 <span class="math inline">\(y\)</span> 年的补充量， <span class="math inline">\(B_y\)</span> 代表第 <span class="math inline">\(y\)</span> 年的繁殖生物量， <span class="math inline">\(\alpha\)</span> 和 <span class="math inline">\(\beta\)</span> 是两个 Beverton-Holt 参数， <span class="math inline">\(\exp(N(0, \sigma^2_R))\)</span> 表示预测模型值与自然观测值之间的关系呈对数正态分布（常表示为 <span class="math inline">\(e^{\varepsilon}\)</span>）。 <span class="math inline">\(\beta\)</span> 值决定渐近极限（ <span class="math inline">\(=1/\beta\)</span> ），而 <span class="math inline">\(\alpha\)</span> 的不同值与每条曲线达到渐近线的速度成反比，从而决定原点附近的相对陡峭程度（一个关键词，我们将会更多地讨论它）（ <span class="math inline">\(\alpha\)</span> 的值越小， 补充量达到最大值的速度越快）。当然，这是一种平均关系，曲线周围的散布与曲线本身同样重要。一个常见的替代重新参数化公式是：</p>
<p><span id="eq-5_16"><span class="math display">\[
R_y = \dfrac{a B_{y-1}}{b +B_{y-1}} e^{\varepsilon}
\qquad(5.16)\]</span></span></p>
<p>其中 <span class="math inline">\(a\)</span> 代表最大最大补充 量（即 <span class="math inline">\(a = 1/\beta\)</span>），而 <span class="math inline">\(b\)</span> 代表为产生平均最大补充量一半（即 <span class="math inline">\(a/2\)</span> ）所需的产卵群体（即 <span class="math inline">\(b = \alpha/\beta\)</span> ）。使用 <span class="math inline">\(y-1\)</span> 年的生物量代表产生第 <span class="math inline">\(y\)</span> 年补充量，这会影响产卵时间。如果产卵发生在十二月，而仔稚鱼沉底发生在次年，那么这样是正确的；如果两者发生在同一年，那么显然需要更改下标。需要注意的是，生物学现实，在这种情况下与时间相关，甚至可能渗入非常简单的模型中。数学模型可以提供对自然的绝佳表征，但需要了解所建模动物的生物学特性，以避免简单的错误！</p>
<p>从 <a href="#fig-5-11" class="quarto-xref">图&nbsp;<span>5.10</span></a> 中可以看出，Beverton–Holt 曲线的初始陡峭程度以及渐近值捕捉了该方程行为的重要方面。渐近线由参数 <span class="math inline">\(a\)</span> 的值给出，而初始陡峭程度则由( <span class="math inline">\(a/b = 1/\alpha\)</span> )的值近似表示，这发生在 <span class="math inline">\(B_y\)</span> 相对较小时。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb46"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#plot the MQMF bh function for Beverton-Holt recruitment  Fig 5.11  </span></span>
<span><span class="va">B</span> <span class="op">&lt;-</span> <span class="fl">1</span><span class="op">:</span><span class="fl">3000</span>  </span>
<span><span class="va">bhb</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1000</span>,<span class="fl">500</span>,<span class="fl">250</span>,<span class="fl">150</span>,<span class="fl">50</span><span class="op">)</span>  </span>
<span><span class="fu">parset</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">B</span>,<span class="fu">bh</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1000</span>,<span class="va">bhb</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span>,<span class="va">B</span><span class="op">)</span>,type<span class="op">=</span><span class="st">"l"</span>,ylim<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">1050</span><span class="op">)</span>,</span>
<span>      xlab<span class="op">=</span><span class="st">"Spawning Biomass"</span>,ylab<span class="op">=</span><span class="st">"Recruitment"</span><span class="op">)</span>  </span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="fl">5</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">B</span>,<span class="fu">bh</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1000</span>,<span class="va">bhb</span><span class="op">[</span><span class="va">i</span><span class="op">]</span><span class="op">)</span>,<span class="va">B</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="va">i</span>,lty<span class="op">=</span><span class="va">i</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/legend.html">legend</a></span><span class="op">(</span><span class="st">"bottomright"</span>,legend<span class="op">=</span><span class="va">bhb</span>,col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">5</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">3</span>,bty<span class="op">=</span><span class="st">"n"</span>,lty<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">5</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html">abline</a></span><span class="op">(</span>h<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">500</span>,<span class="fl">1000</span><span class="op">)</span>,col<span class="op">=</span><span class="fl">1</span>,lty<span class="op">=</span><span class="fl">2</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-5-11" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-5-11-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="05-staticModel_files/figure-html/fig-5-11-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-5-11-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;5.10: 有恒定 a = 1000 和五个递减的 b 值的Beverton-Holt 种群补充曲线，导致越来越高效的曲线。
</figcaption></figure>
</div>
</div>
</div>
</section><section id="ricker-补充量" class="level3" data-number="5.7.5"><h3 data-number="5.7.5" class="anchored" data-anchor-id="ricker-补充量">
<span class="header-section-number">5.7.5</span> Ricker 补充量</h3>
<p>由 Ricker（1954，1958）提出了 Beverton-Holt 曲线的替代方案，但这同样有多种参数化方式：</p>
<p><span id="eq-5_17"><span class="math display">\[
R_y = a S_ye^{-bS_y}e^{\varepsilon}
\qquad(5.17)\]</span></span></p>
<p>其中 <span class="math inline">\(R_y\)</span> 代表 <span class="math inline">\(y\)</span> 年产卵群体 <span class="math inline">\(S_y\)</span> 产生的补充量， <span class="math inline">\(a\)</span> 代表低种群水平时的单位繁殖资源量-补充量， <span class="math inline">\(b\)</span> 与单位繁殖补充量随 <span class="math inline">\(S\)</span> 增加而减少的速率相关。 <span class="math inline">\(e^{\varepsilon}\)</span> 表示关系与观测数据之间的对数正态残差误差。请注意，参数 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 与 Beverton–Holt 方程中的参数非常不同。该种群-补充量曲线不会达到渐近线，而是在高种群水平时表现出补充量水平的下降 <a href="#fig-5-12" class="quarto-xref">图&nbsp;<span>5.11</span></a> 。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb47"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#plot the MQMF ricker function for Ricker recruitment  Fig 5.12  </span></span>
<span><span class="va">B</span> <span class="op">&lt;-</span> <span class="fl">1</span><span class="op">:</span><span class="fl">20000</span>  </span>
<span><span class="va">rickb</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.0002</span>,<span class="fl">0.0003</span>,<span class="fl">0.0004</span><span class="op">)</span> </span>
<span><span class="fu">parset</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">B</span>,<span class="fu">ricker</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">10</span>,<span class="va">rickb</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span>,<span class="va">B</span><span class="op">)</span>,type<span class="op">=</span><span class="st">"l"</span>,xlab<span class="op">=</span><span class="st">"Spawning Biomass"</span>,  </span>
<span>               ylab<span class="op">=</span><span class="st">"Recruitment"</span><span class="op">)</span>  </span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="fl">3</span><span class="op">)</span>   </span>
<span>   <span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">B</span>,<span class="fu">ricker</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">10</span>,<span class="va">rickb</span><span class="op">[</span><span class="va">i</span><span class="op">]</span><span class="op">)</span>,<span class="va">B</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="va">i</span>,lty<span class="op">=</span><span class="va">i</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/legend.html">legend</a></span><span class="op">(</span><span class="st">"topright"</span>,legend<span class="op">=</span><span class="va">rickb</span>,col<span class="op">=</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span>,lty<span class="op">=</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span>,bty<span class="op">=</span><span class="st">"n"</span>,lwd<span class="op">=</span><span class="fl">2</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-5-12" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-5-12-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="05-staticModel_files/figure-html/fig-5-12-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-5-12-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;5.11: 两条具有相同常数 <span class="math inline">\(a=10\)</span> 但具有不同 <span class="math inline">\(b\)</span> 值的 Ricker 种群补充量曲线。请注意， <span class="math inline">\(b\)</span> 值主要影响补充量随生物量增加而下降的水平，对初始陡峭程度影响较小。
</figcaption></figure>
</div>
</div>
</div>
<p>补充量随着繁殖生物量增加而下降背后的理念是，这与某些群体对其他群体的竞争或捕食效应（同类相食）有关。已经提出了各种机制，包括成鱼捕食幼鱼、疾病在密度依赖性传播、繁殖成鱼对彼此产卵场的损害（主要发生在像鲑鱼这样的鱼类生活的河流中），以及最终密度依赖性生长与大小依赖性捕食相结合。这些机制中的每一种都可以导致对 Ricker 曲线参数的不同解释。</p>
<p>再次，方程是否应该被解释为对可观察世界的说明，而不仅仅是平均补充量的便利经验描述，这一点变得重要。此外，尽管参数当然可以被赋予现实世界的解释，但方程仍然倾向于过于简单，最好被视为对事件的说明，而不是经验描述（Punt and Cope, 2019）。</p>
</section><section id="deriso-的通用模型" class="level3" data-number="5.7.6"><h3 data-number="5.7.6" class="anchored" data-anchor-id="deriso-的通用模型">
<span class="header-section-number">5.7.6</span> Deriso 的通用模型</h3>
<p>Deriso (1980) 提出了一个通用方程，其中 Beverton–Holt 和 Ricker 种群补充曲线是它的特例。Schnute (1985) 重新构建了 Deriso 的方程，产生了一个更加灵活的版本，具有更高的灵活性：</p>
<p><span id="eq-5_18"><span class="math display">\[
R_y = \alpha S_y(1-\beta \gamma S_y)^{1/\gamma}
\qquad(5.18)\]</span></span></p>
<p>在这个 Schnute (1985) 通用情况下有三个参数 <span class="math inline">\(\alpha\)</span> 、 <span class="math inline">\(\beta\)</span> 和 <span class="math inline">\(\gamma\)</span>，前两个参数应始终为正，但 <span class="math inline">\(\gamma\)</span> 可以为正或负。通过修改 <span class="math inline">\(\gamma\)</span> 值，会出现不同的特例 <a href="#fig-5-13" class="quarto-xref">图&nbsp;<span>5.12</span></a> ：</p>
<p><span id="eq-5_19"><span class="math display">\[
\begin{split}
\gamma = -\infty \quad &amp;R_y =\alpha B_y \\
\gamma = -1 \quad &amp;R_y = \alpha B_y/(1+\beta B_y) \\
\gamma \to 0 \quad &amp;R_y = \alpha B_y e^{-\beta B_y} \\
\gamma = 1 \quad &amp;R_y = \alpha B_y (1-\beta B_y)
\end{split}
\qquad(5.19)\]</span></span></p>
<p>第三个情况中的箭头表示“趋近”，例如 <span class="math inline">\(\gamma\)</span> 趋近于零。第一个情况是密度无关的补充率常数，也可以通过设置 <span class="math inline">\(\beta= 0\)</span> 得到。接下来的三种情况分别对应于 Beverton–Holt (1957)、Ricker (1954, 1958) 和 Schaefer (1954) 的标准种群-补充量关系，这是一种逻辑斯蒂曲线的形式。当然，在每种情况下都需要小心选择 <span class="math inline">\(\alpha\)</span> 和 <span class="math inline">\(\beta\)</span> 的适当值。</p>
<p>Deriso–Schnute 模型存在一些数学上不稳定的特性，如果我们设 <span class="math inline">\(\gamma = 0\)</span> ，这一点应该很清楚。这会导致数学上的奇点（除以零）。参数限制应该始终为 <span class="math inline">\(\gamma \to 0\)</span> ，无论是从负方向还是正方向。使用这个方程，有许多参数组合会产生不合理的种群补充关系。这个方程的主要价值在于展示不同曲线之间的关系，虽然人们不会在拟合模型中使用 Deriso-Schnute 模型，但它可能在模拟模型中很有用。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb48"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co"># plot of three special cases from Deriso-Schnute curve  Fig. 5.13  </span></span>
<span><span class="va">deriso</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">p</span>,<span class="va">B</span><span class="op">)</span> <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="va">p</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span> <span class="op">*</span> <span class="va">B</span> <span class="op">*</span><span class="op">(</span><span class="fl">1</span> <span class="op">-</span> <span class="va">p</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span><span class="op">*</span><span class="va">p</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span><span class="op">*</span><span class="va">B</span><span class="op">)</span><span class="op">^</span><span class="op">(</span><span class="fl">1</span><span class="op">/</span><span class="va">p</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="va">B</span> <span class="op">&lt;-</span> <span class="fl">1</span><span class="op">:</span><span class="fl">10000</span>  </span>
<span><span class="fu">plot1</span><span class="op">(</span><span class="va">B</span>,<span class="fu">deriso</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">10</span>,<span class="fl">0.001</span>,<span class="op">-</span><span class="fl">1</span><span class="op">)</span>,<span class="va">B</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">2</span>,  </span>
<span>      xlab<span class="op">=</span><span class="st">"Spawning Biomass"</span>,ylab<span class="op">=</span><span class="st">"Recruitment"</span><span class="op">)</span>       <span class="co"># BH  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">B</span>,<span class="fu">deriso</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">10</span>,<span class="fl">0.0004</span>,<span class="fl">0.25</span><span class="op">)</span>,<span class="va">B</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">2</span>,lty<span class="op">=</span><span class="fl">2</span><span class="op">)</span>  <span class="co"># DS  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">B</span>,<span class="fu">deriso</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">10</span>,<span class="fl">0.0004</span>,<span class="fl">1e-06</span><span class="op">)</span>,<span class="va">B</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">3</span>,lty<span class="op">=</span><span class="fl">3</span><span class="op">)</span> <span class="co"># Ricker  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">B</span>,<span class="fu">deriso</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">10</span>,<span class="fl">0.0004</span>,<span class="fl">0.5</span><span class="op">)</span>,<span class="va">B</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">1</span>,lty<span class="op">=</span><span class="fl">3</span><span class="op">)</span>   <span class="co"># odd line  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/legend.html">legend</a></span><span class="op">(</span>x<span class="op">=</span><span class="fl">7000</span>,y<span class="op">=</span><span class="fl">8500</span>,legend<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"BH"</span>,<span class="st">"DS"</span>,<span class="st">"Ricker"</span>,<span class="st">"odd line"</span><span class="op">)</span>,  </span>
<span>       col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">3</span>,<span class="fl">1</span><span class="op">)</span>,lty<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">3</span>,<span class="fl">3</span><span class="op">)</span>,bty<span class="op">=</span><span class="st">"n"</span>,lwd<span class="op">=</span><span class="fl">3</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-5-13" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-5-13-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="05-staticModel_files/figure-html/fig-5-13-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-5-13-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;5.12: Beverton-Holt (BH)、Ricker 和 Deriso-Schnute (DS) 种群-补充量曲线的比较， 这些曲线在 Deriso-Schnute 通用方程 Equ (5.19) 中实现。 对于 DS 曲线， <span class="math inline">\(\gamma = 0.5\)</span> 导致不切实际的结果（奇线）。
</figcaption></figure>
</div>
</div>
</div>
</section><section id="重新参数化的-beverton-holt-方程" class="level3" data-number="5.7.7"><h3 data-number="5.7.7" class="anchored" data-anchor-id="重新参数化的-beverton-holt-方程">
<span class="header-section-number">5.7.7</span> 重新参数化的 Beverton-Holt 方程</h3>
<p>在《模型参数估计》( <a href="04-application.html" class="quarto-xref"><span>章节 4</span></a>) 章中，对 tigers 数据集中的虎虾 Beverton-Holt 种群-补充量曲线的参数进行了估计。相对丰度的估计可以等同于短命对虾种类的补充量水平，但对于使用年龄结构模型的寿命更长的物种，估计此类参数将相对抽象。Francis（1992）对更复杂的种群评估模型做出了重要发展，他重新参数化了 Beverton-Holt 种群-补充量关系，以曲线的初始陡峭程度 <span class="math inline">\(h\)</span> 和初始补充量 <span class="math inline">\(R_0\)</span> 来表示，其中 <span class="math inline">\(R_0\)</span> 是从未捕捞或原始繁殖生物量 <span class="math inline">\(B_0\)</span> 推导出来的。他首先将这些想法应用于胸棘鲷（<em>Haplostethus atlanticus</em>）的年龄结构剩余生产模型，该模型具有捕捞数据、来自调查的相对丰度指数以及与年龄相关生长和重量的生物学数据。使用这些数据，他能够以更合理的方式拟合模型，并利用他对补充量的更有意义的参数化方法。</p>
<p>Francis（1992）将陡峭程度，记作 <span class="math inline">\(h\)</span>，定义为当成熟生物量减少到未捕捞水平的 20%时，种群产生的确定性补充量。他开始描述时使用了：</p>
<p><span id="eq-5_20"><span class="math display">\[
R_0 = \dfrac{A_0}{\alpha + \beta A_0}
\qquad(5.20)\]</span></span></p>
<p>因此，通过定义陡峭度， <span class="math inline">\(h = 0.2 B_0\)</span>，我们得到：</p>
<p><span id="eq-5_21"><span class="math display">\[
h R_0 =\dfrac{0.2 A_0}{\alpha + \beta 0.2 A_0}
\qquad(5.21)\]</span></span></p>
<p>其中 <span class="math inline">\(\alpha\)</span> 和 <span class="math inline">\(\beta\)</span> 是 Beverton-Holt 参数， <span class="math inline">\(A_0\)</span> 是未受捕捞种群中稳定年龄分布的单位补充量总繁殖生物量。”单位补充“ 部分对年龄结构模型很重要，因为它允许我们独立于 Beverton-Holt 方程 <a href="#eq-5_15" class="quarto-xref">公式&nbsp;<span>5.15</span></a> 来确定 <span class="math inline">\(R_0\)</span> 和 <span class="math inline">\(B_0\)</span> 之间的关系。稳定的年龄分布是由恒定的补充量水平 <span class="math inline">\(R_0\)</span> 在恒定的自然死亡率（ <span class="math inline">\(M\)</span> ）产生的 ，导致年龄组数量呈现标准指数下降。如果自然死亡率较低，则可能需要增加一个年龄组。这个稳定年龄分布可以定义为：</p>
<p><span id="eq-5_22"><span class="math display">\[
\begin{split}
n_{0,a} = \left \{ \begin{matrix}
R_0 e^{-Ma} \quad  &amp; a &lt; t_{max} \\
R_0 e^{-Mt_{max}}/(1-e^{-M})  \quad &amp;a = t_{max}  \end{matrix} \right.
\end{split}
\qquad(5.22)\]</span></span></p>
<p>其中 <span class="math inline">\(n_{0,a}\)</span> 表示年龄 <span class="math inline">\(a\)</span> 的单位补充量未被捕捞的数量，而 <span class="math inline">\(t_{max}\)</span> 表示模型中模拟的最大年龄。 <span class="math inline">\(t_{max}\)</span> 作为一组附加年龄组，因此需要除以 <span class="math inline">\((1-e^{-M})\)</span> 以提供指数序列的和。生物量 <span class="math inline">\(A_0\)</span> 将是具有恒定补充水平为 1 时产生的种群生物量。因此，对于生物量 <span class="math inline">\(A_0\)</span>，在稳定的年龄分布下，产生的补充水平将是 <span class="math inline">\(R_0 = 1\)</span>（反之亦然）。</p>
<p><span id="eq-5_23"><span class="math display">\[
A_0 = \left(\sum_m n_{0,a} w_a \right)
\qquad(5.23)\]</span></span></p>
<p>其中 <span class="math inline">\(m\)</span> 表示成熟年龄， <span class="math inline">\(n_{0,a}\)</span> 表示年龄 <span class="math inline">\(a\)</span> 的单位补充量未被捕捞的数量， <span class="math inline">\(a\)</span> 表示年龄， <span class="math inline">\(w_a\)</span> 表示年龄 <span class="math inline">\(a\)</span> 的单位鱼体重量。人们还可以将部分自然死亡率纳入此方程，使其在一年中的某个时间点与补充量相等。 <span class="math inline">\(A_0\)</span> 作为缩放因子，因为在任何恒定的补充量水平下，未受干扰的种群都会出现稳定的年龄分布。 <span class="math inline">\(A_0\)</span> 的幅度将根据估计的初始生物量 <span class="math inline">\(B_0\)</span> 进行缩放，但其值相对于维持稳定年龄分布所需的恒定补充量 <span class="math inline">\(R_0\)</span> 将保持不变。在实践中，人们会根据生物学信息推导出 <span class="math inline">\(A_0\)</span>，并在种群评估模型中估计 <span class="math inline">\(R_0\)</span>。</p>
<p><span id="eq-5_24"><span class="math display">\[
B_0 = R_0 \left(\sum_m n_{0,a} w_a \right) = (R_0 A_0)
\qquad(5.24)\]</span></span></p>
<p>Francis（1992）随后也使用了他对补充量陡峭程度的定义来重新参数化Beverton-Holt 参数 <span class="math inline">\(a\)</span> 、 <span class="math inline">\(b\)</span> 、 <span class="math inline">\(\alpha\)</span> 和 <span class="math inline">\(\beta\)</span> （见本章附录）：</p>
<p><span id="eq-5_25"><span class="math display">\[
a = \dfrac{4hR_0}{(5h-1)} \quad b = \dfrac{B_0(1-h)}{(5h-1)}
\qquad(5.25)\]</span></span></p>
<p>将这些公式代入 <a href="#eq-5_16" class="quarto-xref">公式&nbsp;<span>5.16</span></a> 中，得到：</p>
<p><span id="eq-5_26"><span class="math display">\[
R_y = \dfrac{\frac{4hR_0}{(5h-1)} B_y}{\frac{B_0(1-h)}{(5h-1)} + B_y}
\qquad(5.26)\]</span></span></p>
<p>将上层的 <span class="math inline">\((5h-1)\)</span> 移到下层：</p>
<p><span id="eq-5_27"><span class="math display">\[
R_y = \dfrac{4hR_0 B_y}{\frac{(5h-1) B_0 (1-h)}{(5h-1)} +(5h-1)B_y}
\qquad(5.27)\]</span></span></p>
<p>然后，在可能的情况下消去 <span class="math inline">\((5h-1)\)</span>，可以将 Beverton-Holt 重新定义为陡峭度 <span class="math inline">\(h\)</span> 、 <span class="math inline">\(B_0\)</span> 和 <span class="math inline">\(R_0\)</span> ，这些都有更明确的解释，并且使用 <a href="#eq-5_25" class="quarto-xref">公式&nbsp;<span>5.25</span></a> 或 <a href="#eq-5_28" class="quarto-xref">公式&nbsp;<span>5.28</span></a> 将更容易在评估模型中进行估计：</p>
<p><span id="eq-5_28"><span class="math display">\[
R_y = \dfrac{4hR_0B_y}{B_0(1-h) + B_y(5h-1)}
\qquad(5.28)\]</span></span></p>
</section><section id="重新参数化的-ricker-方程" class="level3" data-number="5.7.8"><h3 data-number="5.7.8" class="anchored" data-anchor-id="重新参数化的-ricker-方程">
<span class="header-section-number">5.7.8</span> 重新参数化的 Ricker 方程</h3>
<p>类似地，Ricker 种群补充方程可以重新参数化为陡峭度 <span class="math inline">\(h\)</span>、 <span class="math inline">\(B_0\)</span> 和 <span class="math inline">\(R_0\)</span> ：</p>
<p><span id="eq-5_29"><span class="math display">\[
R_y = \dfrac{R_0 B_y}{B_0} \exp \left(h \left(1-\frac{B_y}{B_0} \right) \right)
\qquad(5.29)\]</span></span></p>
<p><a href="#eq-5_25" class="quarto-xref">公式&nbsp;<span>5.25</span></a> 和 <a href="#eq-5_28" class="quarto-xref">公式&nbsp;<span>5.28</span></a> 现在都是用于种群评估和试图包含补充量的模拟模型中更常用的参数化方法。</p>
</section></section><section id="选择性" class="level2" data-number="5.8"><h2 data-number="5.8" class="anchored" data-anchor-id="选择性">
<span class="header-section-number">5.8</span> 选择性</h2>
<section id="引言-2" class="level3" data-number="5.8.1"><h3 data-number="5.8.1" class="anchored" data-anchor-id="引言-2">
<span class="header-section-number">5.8.1</span> 引言</h3>
<p>在种群评估模型（及模拟）中使用的另一类静态模型与渔具对特定物种的选择性有关。其核心思想是，如果一个被开发物种的种群在某个区域存在，那么如果使用特定的渔具（如拖网、丹麦围网、刺网、龙虾笼等），渔具的构造及其使用方式将影响在遇到渔具时，哪些可用的种群成员会对其变得脆弱。在年龄结构评估模型中，选择性的概念因可用性的概念而变得复杂。例如，如果某个物种的主要捕捞场所在水深超过 250 米的区域，而较浅水域中主要只有较小的幼体存在，那么如果仅使用浅水域的数据来估计渔具的选择性，其结果很可能与使用深水域数据得到的估计结果不同。实际上，在评估模型中估计的选择性曲线应该被视为选择性/可用性曲线。</p>
<p>选择选择性曲线的形状是一个重要的决策。某些捕捞工具通常用特定的方程来描述其选择性。因此，拖网工具的选择性通常用逻辑斯蒂方程来描述，而长线工具（使用钩子）通常用拱形选择性函数来描述。</p>
<p>只有在有捕捞年龄或大小组成数据的情况下，才能在资源评估模型中拟合选择性模型。正如我们在模型参数估计章节中所看到的，通常会用多项式似然来拟合这种组成数据。在资源评估模型中，通常会根据预期年龄数量来模拟种群动态，这会隐含某些大小数量。因此，在尝试生成预测的捕捞组成数据（无论是年龄还是大小）时，需要将可用的年龄或大小数量乘以预测的选择性。因此，在拟合过程中，组成数据会帮助估计选择性参数。</p>
<p>本节中我们仅将说明其他选择性的方程式，并展示它们的不同特性。</p>
</section><section id="逻辑斯蒂选择" class="level3" data-number="5.8.2"><h3 data-number="5.8.2" class="anchored" data-anchor-id="逻辑斯蒂选择">
<span class="header-section-number">5.8.2</span> 逻辑斯蒂选择</h3>
<p>描述不同渔具选择性特征的不同方程式有很多，但其中一种极其常见的是标准逻辑斯蒂曲线或 S 形曲线，这通常是拖网渔具选择性的典型特征。它意味着随着年龄或个体大小的增加，渔具的易受害性会逐渐增加，直到 100% 的个体在遇到渔具时都变得易受害（这种逐渐增加到 100% 的过程与成熟过程相同）。通常使用两个方程式，第一个由 <strong>MQMF</strong> 函数 <code>logist()</code> 描述：</p>
<p><span id="eq-5_30"><span class="math display">\[
s_a = \dfrac{1}{1 + e^{-\log(19)(a-a_{50})/\delta}}
\qquad(5.30)\]</span></span></p>
<p>其中 <span class="math inline">\(S_a\)</span> 是年龄 <span class="math inline">\(a\)</span> 的选择性（比例）， <span class="math inline">\(a_{50}\)</span> 是选择性达到 50% 时的年龄， <span class="math inline">\(\delta\)</span> 是曲线的斜率，定义为从选择性 50%到选择性 95%之间的年数。当我们谈论年龄时，同样也可以谈论大小。 <span class="math inline">\(\delta\)</span> 的上限为 95%（实际上 <span class="math inline">\(\delta\)</span> 是 <span class="math inline">\(L95-L50\)</span> ）。另一种对数曲线，我们在《简单种群模型》<a href="03-simpopmodel.html" class="quarto-xref"><span>章节 3</span></a> 一章的 “YPR 中的选择性” <a href="03-simpopmodel.html#sec-ypr_selectivity" class="quarto-xref"><span>章节 3.3.1</span></a> 节中已经见过，也被用来描述年龄成熟度，它在函数 <code>mature()</code> 中定义：</p>
<p><span id="eq-5_31"><span class="math display">\[
s_a = \dfrac{1}{1+(e^{(\alpha + \beta a)})^{-1}} = \dfrac{e^{(\alpha + \beta a)}}{1+ e^{(\alpha + \beta a)}}
\qquad(5.31)\]</span></span></p>
<p>其中 <span class="math inline">\(\alpha\)</span> 和 <span class="math inline">\(\beta\)</span> 是逻辑斯蒂参数， <span class="math inline">\(- \alpha/\beta\)</span> 是0.5 选择性（即 50%）的年龄。四分位距（字面意思是 25%分位数到 75%分位数）定义为 <span class="math inline">\(IQ = 2\log(3)/\beta\)</span> （有关此函数的实现，请参阅 <strong>MQMF</strong> 函数 <code>mature()</code>）。通常，在年龄结构模型中，需要长度或年龄组成数据，以便可以直接估计渔具选择性和渔业可利用性。在进行单位补充量渔获量计算时，通常包含选择性的原因是确定开始应用捕捞死亡率的最佳年龄。出于这个原因，通常使用所谓的刀刃选择性，它本质上识别出以下没有选择性的特定年龄，以及以上 100% 选择性的年龄。这在 <strong>MQMF</strong> 函数 <code>logist()</code> 中实现；尽管刀刃选择性不再倾向于用于完整的年龄结构种群评估模型，但它仍然用于延迟差分模型（Schnute，1985；Hilborn 和 Walters，1992）。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb49"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#Selectivity curves from logist and mature functions  See Fig 5.14</span></span>
<span><span class="va">ages</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">50</span>,<span class="fl">1</span><span class="op">)</span>;   <span class="va">in50</span> <span class="op">&lt;-</span> <span class="fl">25.0</span>  </span>
<span><span class="va">sel1</span> <span class="op">&lt;-</span> <span class="fu">logist</span><span class="op">(</span><span class="va">in50</span>,<span class="fl">12</span>,<span class="va">ages</span><span class="op">)</span>         <span class="co">#-3.65/0.146=L50=25.0  </span></span>
<span><span class="va">sel2</span> <span class="op">&lt;-</span> <span class="fu">mature</span><span class="op">(</span><span class="op">-</span><span class="fl">3.650425</span>,<span class="fl">0.146017</span>,sizeage<span class="op">=</span><span class="va">ages</span><span class="op">)</span>  </span>
<span><span class="va">sel3</span> <span class="op">&lt;-</span> <span class="fu">mature</span><span class="op">(</span><span class="op">-</span><span class="fl">6</span>,<span class="fl">0.2</span>,<span class="va">ages</span><span class="op">)</span>  </span>
<span><span class="va">sel4</span> <span class="op">&lt;-</span> <span class="fu">logist</span><span class="op">(</span><span class="fl">22.0</span>,<span class="fl">14</span>,<span class="va">ages</span>,knifeedge <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>  </span>
<span><span class="fu">plot1</span><span class="op">(</span><span class="va">ages</span>,<span class="va">sel1</span>,xlab<span class="op">=</span><span class="st">"Age Years"</span>,ylab<span class="op">=</span><span class="st">"Selectivity"</span>,cex<span class="op">=</span><span class="fl">0.75</span>,lwd<span class="op">=</span><span class="fl">2</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">ages</span>,<span class="va">sel2</span>,col<span class="op">=</span><span class="fl">2</span>,lwd<span class="op">=</span><span class="fl">2</span>,lty<span class="op">=</span><span class="fl">2</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">ages</span>,<span class="va">sel3</span>,col<span class="op">=</span><span class="fl">3</span>,lwd<span class="op">=</span><span class="fl">2</span>,lty<span class="op">=</span><span class="fl">3</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">ages</span>,<span class="va">sel4</span>,col<span class="op">=</span><span class="fl">4</span>,lwd<span class="op">=</span><span class="fl">2</span>,lty<span class="op">=</span><span class="fl">4</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html">abline</a></span><span class="op">(</span>v<span class="op">=</span><span class="va">in50</span>,col<span class="op">=</span><span class="fl">1</span>,lty<span class="op">=</span><span class="fl">2</span><span class="op">)</span>; <span class="fu"><a href="https://rdrr.io/r/graphics/abline.html">abline</a></span><span class="op">(</span>h<span class="op">=</span><span class="fl">0.5</span>,col<span class="op">=</span><span class="fl">1</span>,lty<span class="op">=</span><span class="fl">2</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/legend.html">legend</a></span><span class="op">(</span><span class="st">"topleft"</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"25_eq5.30"</span>,<span class="st">"25_eq5.31"</span>,<span class="st">"30_eq5.31"</span>,<span class="st">"22_eq5.30N"</span><span class="op">)</span>,  </span>
<span>       col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">3</span>,<span class="fl">4</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">3</span>,cex<span class="op">=</span><span class="fl">1.1</span>,bty<span class="op">=</span><span class="st">"n"</span>,lty<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">4</span><span class="op">)</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-5-14" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-5-14-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="05-staticModel_files/figure-html/fig-5-14-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-5-14-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;5.13: logist() 和 mature() 函数的逻辑 S 形曲线示例。虚线红色和实线黑色曲线具有相同的 L50，但梯度不同。点线绿色展示了改变 <code>mature()</code> 函数的 b 参数的效果，而交叉线蓝色曲线展示了刀刃式选择。图例显示了 L50 和使用的方程。
</figcaption></figure>
</div>
</div>
</div>
</section><section id="球面选择性" class="level3" data-number="5.8.3"><h3 data-number="5.8.3" class="anchored" data-anchor-id="球面选择性">
<span class="header-section-number">5.8.3</span> 球面选择性</h3>
<p>一种上升至峰值的选择性模式、可能存在平台段，然后下降的模式被称为穹顶形，这是网具（如围网）和钩具（如延绳钓）等渔具的典型特征。由于包含如此多的组成部分，选择性曲线往往更为复杂，因为上升段、平台段和下降段都需要连接在一起。现代拟合此类模型的方法倾向于使用自动微分软件，如 AD-Model Builder 或相关软件（Bull 等，2012；Fournier 等，2012；Kristensen 等，2016）。这意味着评估模型中的组件模型需要可微分，以便穹顶形选择性曲线的三个组成部分之间的连接需要连续（Methot 和 Wetzell，2013；Hurtado-Ferro 等，2014）。此类方程至少包含五个组成部分：上升段（<em>asc</em>）、选择性等于 1.0 的平台段、下降段（<em>des</em>）、以及连接这三个主要部分之间的两个连接函数、 <span class="math inline">\(J_1\)</span> 和 <span class="math inline">\(J_2\)</span>， <a href="#eq-5_32" class="quarto-xref">公式&nbsp;<span>5.32</span></a> ：</p>
<p><span id="eq-5_32"><span class="math display">\[
s_L = asc(1-J_{1,L}) +J_{1,L}((1-J_{2,L})+J_{2,L} dsc)
\qquad(5.32)\]</span></span></p>
<p>其中 <span class="math inline">\(S_L\)</span> 表示长度 <span class="math inline">\(L\)</span> 的选择性。各种分量函数定义如下：</p>
<p><span id="eq-5_33"><span class="math display">\[
\begin{split}
asc &amp;= 1-(1-\lambda_5) \left(\dfrac{1-\exp \left((m_L - \lambda_1)^2/\lambda_3 \right)}{1-\exp \left((m_{min}-\lambda_1)^2/\lambda_3 \right)} \right) \\
dsc &amp;= 1- \exp\left(-\left(m_L- \lambda_2)^2/\lambda_4 \right) \right) \\
J_{1,L} &amp;=1/(1+ \exp(-(m_L-\lambda_1)/(1 +|m_L+\lambda_1|)))\\
J_{2,L} &amp;= 1/(1+ \exp(-(m_L-\lambda_2)/(1+|m_L + \lambda_2|)))
\end{split}
\qquad(5.33)\]</span></span></p>
<p>其中 <span class="math inline">\(m_L\)</span> 是长度组 <span class="math inline">\(L\)</span> 的平均长度， <span class="math inline">\(m_{min}\)</span> 是最小长度组的平均长度， <span class="math inline">\(\lambda_1\)</span> 是选择性达到 1.0 的个体大小， <span class="math inline">\(\lambda_2\)</span> 是选择性从 1.0 开始下降的个体大小（如果 <span class="math inline">\(\lambda_1\)</span> 和 <span class="math inline">\(\lambda_2\)</span> 相等则没有平台期）， <span class="math inline">\(\lambda_3\)</span> 影响上升段（<em>asc</em>）的斜率， <span class="math inline">\(\lambda_4\)</span> 影响下降段（<em>dsc</em>）的斜率， <span class="math inline">\(\lambda_5\)</span> 是 <span class="math inline">\(m_{min}\)</span> 处选择性的对数， <span class="math inline">\(\lambda_6\)</span> 是 <span class="math inline">\(m_{max}\)</span> 选择性的对数， <a href="#fig-5-15" class="quarto-xref">图&nbsp;<span>5.14</span></a> 。</p>
<p>因此，需要 <span class="math inline">\(\lambda_1\)</span> 到 <span class="math inline">\(\lambda_6\)</span> 六个参数以及所使用的长度组的平均长度来定义这种穹顶选择性曲线。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb50"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#Examples of domed-shaped selectivity curves from domed. Fig.5.15  </span></span>
<span><span class="va">L</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">30</span>,<span class="fl">1</span><span class="op">)</span>  </span>
<span><span class="va">p</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">10</span>,<span class="fl">11</span>,<span class="fl">16</span>,<span class="fl">33</span>,<span class="op">-</span><span class="fl">5</span>,<span class="op">-</span><span class="fl">2</span><span class="op">)</span>  </span>
<span><span class="fu">plot1</span><span class="op">(</span><span class="va">L</span>,<span class="fu">domed</span><span class="op">(</span><span class="va">p</span>,<span class="va">L</span><span class="op">)</span>,type<span class="op">=</span><span class="st">"l"</span>,lwd<span class="op">=</span><span class="fl">2</span>,ylab<span class="op">=</span><span class="st">"Selectivity"</span>,xlab<span class="op">=</span><span class="st">"Age Years"</span><span class="op">)</span>  </span>
<span><span class="va">p1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">8</span>,<span class="fl">12</span>,<span class="fl">16</span>,<span class="fl">33</span>,<span class="op">-</span><span class="fl">5</span>,<span class="op">-</span><span class="fl">1</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">L</span>,<span class="fu">domed</span><span class="op">(</span><span class="va">p1</span>,<span class="va">L</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">2</span>,lty<span class="op">=</span><span class="fl">2</span><span class="op">)</span>  </span>
<span><span class="va">p2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">9</span>,<span class="fl">10</span>,<span class="fl">16</span>,<span class="fl">33</span>,<span class="op">-</span><span class="fl">5</span>,<span class="op">-</span><span class="fl">4</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">L</span>,<span class="fu">domed</span><span class="op">(</span><span class="va">p2</span>,<span class="va">L</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">4</span>,lty<span class="op">=</span><span class="fl">4</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-5-15" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-5-15-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="05-staticModel_files/figure-html/fig-5-15-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-5-15-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;5.14: 由函数 domed() 产生的三个拱形选择性曲线示例，改变了达到选择性 1.0 的初始年龄（10、8、9），以及停止时的年龄（11、12、10），以及最终年龄组的选择性。
</figcaption></figure>
</div>
</div>
</div>
</section></section><section id="静态模型的结论性评述" class="level2" data-number="5.9"><h2 data-number="5.9" class="anchored" data-anchor-id="静态模型的结论性评述">
<span class="header-section-number">5.9</span> 静态模型的结论性评述</h2>
<p>比我们已考虑的剩余产量模型更复杂的种群评估模型，大多是混合了群体进展的动态模型和本章所说明的静态模型集合。因此，了解生长、成熟、选择性和补充模型对于理解更高级模型的结构至关重要。有时人们会在评估模型之外估计它们的参数，但通常估计会是拟合整个种群评估模型的一部分。一次性拟合所有独立模型组件的优势在于，组件之间的任何交互作用都可以自动考虑。</p>
<p>本章为一系列静态模型提供了入门基础。目标是当你遇到其他模型时，能够像我们这里使用的方法一样使用和拟合它们。每种这样的模型都有其自身的假设。只要你知道这些假设，你应该能够为你在建模中选择使用哪种静态模型做出决策并提供辩护。</p>
</section><section id="附录fabens-变换的推导" class="level2" data-number="5.10"><h2 data-number="5.10" class="anchored" data-anchor-id="附录fabens-变换的推导">
<span class="header-section-number">5.10</span> 附录：Fabens 变换的推导</h2>
<p>Fabens（1965）将 von Bertalanffy 生长曲线进行转换，使其与标记计划提供的数据相匹配（标记时的长度和日期，以及重捕时的长度和日期）。von Bertalanffy 曲线的年龄-长度版本为：</p>
<p><span id="eq-5_34"><span class="math display">\[
\hat {L_t} = L_{\infty} \left(1- e^{(-K(t-t_0))} \right) +N(0, \sigma)
\qquad(5.34)\]</span></span></p>
<p>在标记的背景下，它在给定时间增量（ <span class="math inline">\(\Delta t\)</span> ）后的长度定义为：</p>
<p><span id="eq-5_35"><span class="math display">\[
L_{t +\Delta t} = L_{\infty} - L_{\infty} e^{-K((t + \Delta t)-t_0)}
\qquad(5.35)\]</span></span></p>
<p>在指数项中，可以提取 <span class="math inline">\(\Delta t\)</span> 的贡献：</p>
<p><span id="eq-5_36"><span class="math display">\[
L_{t+\Delta t} = L_{\infty} - L_{\infty} e^{-K(t-t_0)} e^{-K \Delta t}
\qquad(5.36)\]</span></span></p>
<p>现在，在 <span class="math inline">\(\Delta t\)</span> 期间预期发生的生长增量 <span class="math inline">\(\Delta L\)</span> 可以定义为 <span class="math inline">\(L_{t +\Delta t}\)</span> 减去 <span class="math inline">\(L_t\)</span>：</p>
<p><span id="eq-5_37"><span class="math display">\[
\Delta L = (L_{t + \Delta t}-L_t) = \\
\left(L_{\infty}-L_{\infty}e^{-K(t-t_0)}e^{-K \Delta t} \right) - \left(L_{\infty} - L_{\infty}e^{(-K((t-t_0))} \right)
\qquad(5.37)\]</span></span></p>
<p>我们可以去掉括号，这将使第二项中的否定变为加号，然后重新排列分离的项。</p>
<p><span id="eq-5_38"><span class="math display">\[
\Delta L = L_{\infty}-L_{\infty}e^{-K(t-t_0)}e^{-K \Delta t}  - L_{\infty} + L_{\infty}e^{(-K((t-t_0))}
\qquad(5.38)\]</span></span></p>
<p>这两个孤立的 <span class="math inline">\(L_{\infty}\)</span> 项可以消去以提高证明的清晰度，但它们稍后会重新出现。此外，我们还可以重新排列剩下的两个指数项：</p>
<p><span id="eq-5_39"><span class="math display">\[
\Delta L = L_{\infty} e^{(-K(t-t_0))} -L_{\infty} e^{-K(t-t_0)}e^{-K \Delta t}
\qquad(5.39)\]</span></span></p>
<p>重新排列使得可以提出出 <span class="math inline">\(L_{\infty}e^{(-K(t -t_0))}\)</span> 项来简化整个方程：</p>
<p><span id="eq-5_40"><span class="math display">\[
\Delta L = L_{\infty} e^{(-K(t-t_0))}\left(1-e^{-K \Delta t}\right)
\qquad(5.40)\]</span></span></p>
<p>现在我们可以将 <span class="math inline">\(\Delta t\)</span> 项移至左边，并返回 <span class="math inline">\(L_{\infty} - L_{\infty}\)</span> 项</p>
<p><span id="eq-5_41"><span class="math display">\[
\frac{\Delta L}{(1-e^{-K \Delta t})} = L_{\infty} - L_{\infty} + L_{\infty} e^{(-K(t-t_0))}
\qquad(5.41)\]</span></span></p>
<p>如果我们添加一些括号，将加号变为减号，我们最终就能认识到哪些项的组合等于 <span class="math inline">\(L_t\)</span> ：</p>
<p><span id="eq-5_42"><span class="math display">\[
\dfrac{\Delta \hat L}{(1-e^{-K \Delta t})} = L_{\infty}-\left(L_{\infty}-L_{\infty}e^{(-K(t-t_0))} \right)
= (L_{\infty}-L_t) \qquad(5.42)\]</span></span></p>
<p>通过将 <span class="math inline">\(\Delta t\)</span> 项移至右侧，得到经典的 Fabens 生长增量方程：</p>
<p><span id="eq-5_43"><span class="math display">\[
\Delta L = (L_{\infty}-L_t)\left(1-e^{-K \Delta t} \right)
\qquad(5.43)\]</span></span></p>
<p>需要注意的是，这种转换也会转换长度-年龄方程中的正态随机残差，而这些残差当然是在参数估计时使用的。这意味着，尽管这些参数具有相同的名称，但它们并不严格可比。</p>
</section><section id="附录beverton-holt-模型的重新参数化" class="level2" data-number="5.11"><h2 data-number="5.11" class="anchored" data-anchor-id="附录beverton-holt-模型的重新参数化">
<span class="header-section-number">5.11</span> 附录：Beverton-Holt 模型的重新参数化</h2>
<p>Francis（1992）以更具有生物学意义的陡峭程度（ <span class="math inline">\(h\)</span> ）、 初始成熟生物量（ <span class="math inline">\(B_0\)</span>）和 初始补充量（ <span class="math inline">\(R_0\)</span> ）等术语来定义 Beverton-Holt 参数。与其使用</p>
<p><span id="eq-5_44"><span class="math display">\[
R_y = \dfrac{B_{y-1}}{\alpha + \beta B_{y-1}}
\qquad(5.44)\]</span></span></p>
<p>不如使用另外一种公式，尽管最后还是要回到使用关系 <span class="math inline">\(\alpha = b/a\)</span> 和 <span class="math inline">\(\beta = 1/a\)</span> 。</p>
<p>因此，我们将使用：</p>
<p><span id="eq-5_45"><span class="math display">\[
R_y = \dfrac{a B_y}{b+ B_y}
\qquad(5.45)\]</span></span></p>
<p>其中 <span class="math inline">\(R_y\)</span> 是年 <span class="math inline">\(y\)</span> 的补充量， <span class="math inline">\(B_y\)</span> 是 <span class="math inline">\(y\)</span> 年繁殖资源量， <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 是 Beverton-Holt 参数。在未受捕捞的平衡状态下，我们可以将方程表示为：</p>
<p><span id="eq-5_46"><span class="math display">\[
R_0 = \dfrac{a B_0}{b + B_0}
\qquad(5.46)\]</span></span></p>
<p>陡度（ <span class="math inline">\(h\)</span> ）定义为初始生物量的20% 时获得的补充量：</p>
<p><span id="eq-5_47"><span class="math display">\[
h R_0 = \dfrac{0.2 a B_0}{b + 0.2 B_0}
\qquad(5.47)\]</span></span></p>
<p>如果 <span class="math inline">\(R_0\)</span> 的平衡方程代入这个方程，我们将得到：</p>
<p><span id="eq-5_48"><span class="math display">\[
h \dfrac{a B_0}{b + B_0}= \dfrac{0.2 a B_0}{b + 0.2 B_0}
\qquad(5.48)\]</span></span></p>
<p>因此：</p>
<p><span id="eq-5_49"><span class="math display">\[
h = \dfrac{(0.2a B_0)(b+B_0)}{(b+0.2B_0)(aB_0)}= \dfrac{0.2(b + B_0)}{b + 0.2 B_0}
\qquad(5.49)\]</span></span></p>
<p>通过乘法得到 ：</p>
<p><span id="eq-5_50"><span class="math display">\[
h b + 0.2hB_0 = 0.2b + 0.2 B_0
\qquad(5.50)\]</span></span></p>
<p>通过交换项以将 <span class="math inline">\(b\)</span> 和 <span class="math inline">\(B_0\)</span> 分开，然后乘以5 以消除 0.2：</p>
<p><span id="eq-5_51"><span class="math display">\[
5hb -b = B_0- h B_0
\qquad(5.51)\]</span></span></p>
<p>简化后得到：</p>
<p><span id="eq-5_52"><span class="math display">\[
b(5h-1) = B_0 (1-h)
\qquad(5.52)\]</span></span></p>
<p>因此 <span class="math inline">\(b\)</span> 可重新参数为：</p>
<p><span id="eq-5_53"><span class="math display">\[
b = \dfrac{B_0(1-h)}{(5h-1)}
\qquad(5.53)\]</span></span></p>
<p>该版本的 <span class="math inline">\(b\)</span> 可以用于原始方程，并重新排列以对 <span class="math inline">\(a\)</span> 参数做类似处理：</p>
<p><span id="eq-5_54"><span class="math display">\[
R_0 = \dfrac{a B_0}{\frac{B_0(1-h)}{(5h-1)} +B_0}
\qquad(5.54)\]</span></span></p>
<p>转换为：</p>
<p><span id="eq-5_55"><span class="math display">\[
R_0 \dfrac{B_0(1-h)}{(5h-1)} +R_0 B_0 = a B_0
\qquad(5.55)\]</span></span></p>
<p>除以 <span class="math inline">\(B_0\)</span> ，然后将等号左侧的第二项 <span class="math inline">\(R_0\)</span> 乘以 <span class="math inline">\(5h-1\)</span>，简化为：</p>
<p><span id="eq-5_56"><span class="math display">\[
\dfrac{R_0 -R_0h +5hR_0-R_0}{5h-1}= \dfrac{4hR_0}{5h-1} = a
\qquad(5.56)\]</span></span></p>
<p>记住 <span class="math inline">\(\alpha = b/a\)</span> 和 <span class="math inline">\(\beta = 1/a\)</span> ，所以就可以完成了：</p>
<p><span id="eq-5_57"><span class="math display">\[
\alpha =b \times 1/a = \dfrac{B_0(1-h)}{(5h-1)} \times \dfrac{5h-1}{4hR_0} = \dfrac{B_0(1-h)}{4hR_0}
\qquad(5.57)\]</span></span></p>
<p>以及：</p>
<p><span id="eq-5_58"><span class="math display">\[
b = 1/a = \dfrac{5h-1}{4hR_0}
\qquad(5.58)\]</span></span></p>
<p>如 Francis (1992) 所定义。这重新定义了 Beverton-Holt 模型参数，以 <span class="math inline">\(h\)</span>、 <span class="math inline">\(B_0\)</span> 和 <span class="math inline">\(R_0\)</span> 表示。需要确定 <span class="math inline">\(B_0\)</span> 和 <span class="math inline">\(R_0\)</span> 之间的关系，但我们不能使用平衡方程来计算，因此我们假设未受捕捞的种群处于具有稳定年龄分布的平衡状态。从稳定年龄分布中每单位亲体产生的成熟生物量 ( <span class="math inline">\(A_0\)</span> ) 因此定义了 <span class="math inline">\(B_0\)</span> 和 <span class="math inline">\(R_0\)</span> 之间所需的关系。</p>


<!-- -->

<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-beverton1993a" class="csl-entry" role="listitem">
Beverton, Raymond J. H., 和 Sidney J. Holt. 1993. <em>On the Dynamics of Exploited Fish Populations</em>. Springer Netherlands. <a href="https://doi.org/10.1007/978-94-011-2106-4">https://doi.org/10.1007/978-94-011-2106-4</a>.
</div>
<div id="ref-pitcher1973" class="csl-entry" role="listitem">
Pitcher, T. J., 和 P. D. M. Macdonald. 1973. <span>《Two Models for Seasonal Growth in Fishes》</span>. <em>The Journal of Applied Ecology</em> 10 (2): 599. <a href="https://doi.org/10.2307/2402304">https://doi.org/10.2307/2402304</a>.
</div>
<div id="ref-stearns1992" class="csl-entry" role="listitem">
Stearns, SC. 1992. <em>The evolution of life histories</em>. Oxford University Press.
</div>
<div id="ref-stearns1977" class="csl-entry" role="listitem">
Stearns, Stephen C. 1977. <span>《The Evolution of Life History Traits: A Critique of the Theory and a Review of the Data》</span>. <em>Annual Review of Ecology and Systematics</em> 8 (1): 145–71. <a href="https://doi.org/10.1146/annurev.es.08.110177.001045">https://doi.org/10.1146/annurev.es.08.110177.001045</a>.
</div>
</div>
</section></main><!-- /main --><script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "已复制");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "已复制");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><nav class="page-navigation"><div class="nav-page nav-page-previous">
      <a href="./04-application.html" class="pagination-link  aria-label=">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">模型参数估算</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./06-uncertainty.html" class="pagination-link" aria-label="<span class='chapter-number'>6</span>&nbsp; <span class='chapter-title'>不确定性</span>">
        <span class="nav-page-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">不确定性</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">源代码</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb51" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="fu"># 静态模型 {#sec-staticmodel}</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(MQMF)</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a><span class="fu">## 简介</span></span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a>在本书中，我们将重点讨论相对简单的种群模型，但也将开始为理解更复杂模型的某些要求做准备。我们所说的 “更复杂 ”是指通常用于模拟捕捞种群动态的年龄结构模型。然而，我们可以利用这些更复杂模型的组成部分来说明我们可以称之为 “静态模型 ”的数据拟合。静态模型用于描述个体生长过程的方程形式、成熟度如何随年龄或体型变化、补充与成熟或产卵生物量之间的 “种群-补充 ”关系，以及渔具对被捕捞种群的选择性。这种静态模型显示了相关变量（年龄长度、成熟年龄或长度等）之间的函数关系，而且这些关系被赋予了一个相当大的假设，即随着时间的推移保持不变。</span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a>这种静态模型与我们所说的动态模型形成对比，动态模型试图描述诸如资源量变化之类的过程，其中估算的值是早期资源量的函数。这样的动态模型总是包含一个自我参考的元素，可能还有其他驱动因素，所有这些都有助于我们试图描述或建模的动态。</span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-17"><a href="#cb51-17" aria-hidden="true" tabindex="-1"></a>在某些情况下，如果假定静态或稳定的过程发生了明显的变化，这些本应是静态的关系可能会被 “时间阻断”，这意味着假定这些关系在两个不同的时间段之间以阶梯状的方式发生变化。实际上，如果这些过程发生了变化，很可能是在一段时期内比较平稳地发生了变化，但遗憾的是，拥有足够的数据来很好地描述这种渐进的变化通常是不可能的。</span>
<span id="cb51-18"><a href="#cb51-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-19"><a href="#cb51-19" aria-hidden="true" tabindex="-1"></a>我们首先用这类模型来实现更多的例子，因为正如我们在第 <span class="co">[</span><span class="ot">-@sec-paraestimat</span><span class="co">]</span> 章 “<span class="co">[</span><span class="ot">模型参数估计</span><span class="co">](04-application.qmd)</span>（*Model Parameter Estimation*）”中所看到的，这些静态模型往往比具有足够灵活性来描述动态过程的模型更容易实现。</span>
<span id="cb51-20"><a href="#cb51-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-21"><a href="#cb51-21" aria-hidden="true" tabindex="-1"></a><span class="fu">## 生产力参数</span></span>
<span id="cb51-22"><a href="#cb51-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-23"><a href="#cb51-23" aria-hidden="true" tabindex="-1"></a>顾名思义，所有的生物种群都是由个体集合而成的，因此会表现出一些新出现的特性，这些特性部分地概括了这些种群的特性。鉴于目前正在发生的许多物种灭绝事件，我同意，一个物种中的少数甚至单个个体可能会构成 “种群（population） ”的某种限制，但我们将只关注更丰富的种群，而撇开这些可悲的极端情况。在这里，我们将重点关注个体的生长、成熟和补充，所有这些都与种群的生产力有关。与生长快、成熟早、繁殖力高的物种相比，生长慢、成熟晚、繁殖力低的物种的生产力往往较低，尽管其潜在稳定性更高。生命史特征的进化是一个复杂而又引人入胜的课题，我建议大家对其进行研究 <span class="co">[</span><span class="ot">@beverton1993a; @stearns1977; @stearns1992</span><span class="co">]</span>。不过，在这里我们将重点讨论简单得多的模型。即便如此，在对捕捞种群进行建模时，了解相关物种的生命史特征可能产生的影响，对于解释观察到的动态变化还是很有帮助的。不要忘记，生物过程建模极大地受益于生物知识和理解。</span>
<span id="cb51-24"><a href="#cb51-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-25"><a href="#cb51-25" aria-hidden="true" tabindex="-1"></a><span class="fu">## 生长</span></span>
<span id="cb51-26"><a href="#cb51-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-27"><a href="#cb51-27" aria-hidden="true" tabindex="-1"></a>忽略任何潜在的迁入和迁出，种群生产力是种群中新个体的补充和种群中已有个体的生长的综合结果。这些都是积极因素，而自然死亡率以及捕捞种群中的捕捞死亡率等消极因素则抵消了这些积极因素。个体生长的重要性是渔业生态学中有大量关于个体生长的文献的原因之一（Summerfelt 和 Hall，1987）。尽管我刚才写到，如果要建立模型，了解生物过程非常重要，但其中大部分文献都与生长生物学有关，我们将忽略这些文献。相反，我们将专注于个体生长的数学描述。重点在于描述，这一点很重要，因为有些人似乎过于偏爱特定的生长模型，而这些模型仅仅描述了生长过程，并没有真正解释生长过程。</span>
<span id="cb51-28"><a href="#cb51-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-29"><a href="#cb51-29" aria-hidden="true" tabindex="-1"></a>在第 <span class="co">[</span><span class="ot">-@sec-paraestimat</span><span class="co">]</span> 章 “<span class="co">[</span><span class="ot">模型参数估算</span><span class="co">](04-application.qmd)</span>”中，我们已经介绍了可用于描述年龄-长度的三种候选模型 （von Bertalanffy、Gompertz 和 Michaelis-Menton），因此我们不再重新讨论这些模型。相反，我们将考虑描述生长的另外两个方面。在年龄-长度方面，我们将研究与季节性生长模型有关的观点，尽管这些观点在淡水系统中很重要，但往往用处有限。更常用的是，我们还将研究如何从标记数据中估计个体生长情况。</span>
<span id="cb51-30"><a href="#cb51-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-31"><a href="#cb51-31" aria-hidden="true" tabindex="-1"></a>在本章中，我们将主要讨论 von Bertalanffy 生长曲线以及使用函数 <span class="in">`vB()`</span> 对其进行的拓展：</span>
<span id="cb51-32"><a href="#cb51-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-33"><a href="#cb51-33" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-34"><a href="#cb51-34" aria-hidden="true" tabindex="-1"></a>L_t = L_{\infty} \left(1 - e^{-K(t - t_0)} \right ) </span>
<span id="cb51-35"><a href="#cb51-35" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_1}</span>
<span id="cb51-36"><a href="#cb51-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-37"><a href="#cb51-37" aria-hidden="true" tabindex="-1"></a><span class="fu">### 季节性生长曲线</span></span>
<span id="cb51-38"><a href="#cb51-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-39"><a href="#cb51-39" aria-hidden="true" tabindex="-1"></a>生长速度是一个复杂的过程，不仅受每种动物的体长或年龄的影响，还受环境条件的影响。因此，在温带和极地地区，全年温度变化很大，生长率也会随季节变化。这可以表现为鱼类耳骨（耳石）和其他坚硬部位的确切生长环，它们源于一年中新陈代谢的变化。当然，还有其他因素和事件带来的复杂性和不确定性（例如，硬壳中的假环），但在此我们还是要把重点放在对数据的描述上，假定在分析之前已经解决了这些复杂性（实际情况往往与此不同，不要低估收集有效渔业数据的难度！）。</span>
<span id="cb51-40"><a href="#cb51-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-41"><a href="#cb51-41" aria-hidden="true" tabindex="-1"></a>不同的季节性生长模型已很多，但在此我们将使用 @pitcher1973 提出的一个模型，对 von Bertalanffy 生长曲线进行了修改，在生长率项中加入了正弦波，试图将周期性水温作为生长率的驱动因素，使生长率在冬季减慢，在夏季加快。</span>
<span id="cb51-42"><a href="#cb51-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-43"><a href="#cb51-43" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-44"><a href="#cb51-44" aria-hidden="true" tabindex="-1"></a>{L}_{t}={{L}_{\infty }}\left( 1-{{e}^{-\left[ C\sin \left( \frac{2\pi \left( t-s \right)}{52} \right)+K(t-{{t}_{0}} \right]}} \right) </span>
<span id="cb51-45"><a href="#cb51-45" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_2}</span>
<span id="cb51-46"><a href="#cb51-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-47"><a href="#cb51-47" aria-hidden="true" tabindex="-1"></a>其中 $L_{\infty}$ 、$K$ 和 $t_0$ 是 von Bertalanffy 参数，$t$ 是长度 $L_t$ 的周龄， $C$ 决定了围绕非季节性增长曲线的振荡幅度，$s$ 是正弦波在年份中的起点，使用常数 52 反映了使用周作为年内时间步长的单位。如果我们使用月或日作为取样事件之间的时间单位，那么我们将分别使用 12 或 365。我们可以使用 @pitcher1973 对英国淡水鲦鱼（*Phoxinus phoxinus*；虽然鲦鱼的数据是从他们的图中读取的，因此只是近似正确，但足以说明问题）研究的数据。</span>
<span id="cb51-48"><a href="#cb51-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-49"><a href="#cb51-49" aria-hidden="true" tabindex="-1"></a>首先，我们可以绘制现有数据并拟合一条标准的非季节性 von Bertalanffy 生长曲线。拟合曲线使用的是正态随机误差而非对数正态误差，因此我们使用了 <span class="in">`negNLL()`</span> 函数。使用 <span class="in">`ssq()`</span> 函数也是可行的，但由于我们对预测曲线的变化特别感兴趣，因此下文将继续使用 <span class="in">`negNLL()`</span>。如果我们忽略季节性趋势，那么预计曲线周围的变化（由 *sigma* 参数描述）将相对较大。</span>
<span id="cb51-50"><a href="#cb51-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-53"><a href="#cb51-53" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb51-54"><a href="#cb51-54" aria-hidden="true" tabindex="-1"></a> <span class="co">#vB growth curve fit to Pitcher and Macdonald derived seasonal data  </span></span>
<span id="cb51-55"><a href="#cb51-55" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(minnow); week <span class="ot">&lt;-</span> minnow<span class="sc">$</span>week; length <span class="ot">&lt;-</span> minnow<span class="sc">$</span>length  </span>
<span id="cb51-56"><a href="#cb51-56" aria-hidden="true" tabindex="-1"></a>pars <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">75</span>,<span class="fl">0.1</span>,<span class="sc">-</span><span class="fl">10.0</span>,<span class="fl">3.5</span>); label<span class="ot">=</span><span class="fu">c</span>(<span class="st">"Linf"</span>,<span class="st">"K"</span>,<span class="st">"t0"</span>,<span class="st">"sigma"</span>)  </span>
<span id="cb51-57"><a href="#cb51-57" aria-hidden="true" tabindex="-1"></a>bestvB <span class="ot">&lt;-</span> <span class="fu">nlm</span>(<span class="at">f=</span>negNLL,<span class="at">p=</span>pars,<span class="at">funk=</span>vB,<span class="at">ages=</span>week,<span class="at">observed=</span>length,  </span>
<span id="cb51-58"><a href="#cb51-58" aria-hidden="true" tabindex="-1"></a>              <span class="at">typsize=</span><span class="fu">magnitude</span>(pars))  </span>
<span id="cb51-59"><a href="#cb51-59" aria-hidden="true" tabindex="-1"></a>predL <span class="ot">&lt;-</span> <span class="fu">vB</span>(bestvB<span class="sc">$</span>estimate,<span class="dv">0</span><span class="sc">:</span><span class="dv">160</span>)  </span>
<span id="cb51-60"><a href="#cb51-60" aria-hidden="true" tabindex="-1"></a><span class="fu">outfit</span>(bestvB,<span class="at">backtran =</span> <span class="cn">FALSE</span>,<span class="at">title=</span><span class="st">"Non-Seasonal vB"</span>,<span class="at">parnames=</span>label)  </span>
<span id="cb51-61"><a href="#cb51-61" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-62"><a href="#cb51-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-63"><a href="#cb51-63" aria-hidden="true" tabindex="-1"></a>根据季节性数据拟合的标准 von Bertalanffy 曲线 <span class="co">[</span><span class="ot">@eq-5_1</span><span class="co">]</span> ，其 *sigma* 参数约为 $3.7$，这只是反映了一个事实，即数据围绕平均增长曲线摆动，因此残差会相对较大。如果我们使用季节性调整曲线，这种变化会大大减少，因此我们可以预测 *sigma* 应该小得多。为了拟合季节性增长曲线，我们需要定义一个反映新模型结构的修改后 `vB()` 函数 [@eq-5_2]。当然，在拟合任何新模型时，第一步必然是需要一个函数来根据一组参数生成预测值。我们可以将负对数似然的计算包含在这个新函数中，但将预测长度的生成保留在一个单独的函数中可以增加我们代码的灵活性。因此，我们将坚持分别使用预测函数和负对数似然计算函数的策略。在参数向量 *pars* 中，我们还需要包含 @eq-5_2 中 $C$ 和 $s$ 的初始估计值。</span>
<span id="cb51-64"><a href="#cb51-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-67"><a href="#cb51-67" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb51-68"><a href="#cb51-68" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-5-1</span></span>
<span id="cb51-69"><a href="#cb51-69" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: |</span></span>
<span id="cb51-70"><a href="#cb51-70" aria-hidden="true" tabindex="-1"></a><span class="co">#|   年龄长度数据来自 Pitcher 和 Macdonald（1973 年），与最佳拟合的 von Bertalanffy 曲线相比，</span></span>
<span id="cb51-71"><a href="#cb51-71" aria-hidden="true" tabindex="-1"></a><span class="co">#|   显示出生长率的强烈季节性波动。下图中的正态随机残差的季节性模式非常明显，并随着年龄的增长而减小。</span></span>
<span id="cb51-72"><a href="#cb51-72" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb51-73"><a href="#cb51-73" aria-hidden="true" tabindex="-1"></a> <span class="co">#plot the non-seasonal fit and its residuals.  Figure 5.1  </span></span>
<span id="cb51-74"><a href="#cb51-74" aria-hidden="true" tabindex="-1"></a><span class="fu">parset</span>(<span class="at">plots=</span><span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">1</span>),<span class="at">margin=</span><span class="fu">c</span>(<span class="fl">0.35</span>,<span class="fl">0.45</span>,<span class="fl">0.02</span>,<span class="fl">0.05</span>))   </span>
<span id="cb51-75"><a href="#cb51-75" aria-hidden="true" tabindex="-1"></a><span class="fu">plot1</span>(week,length,<span class="at">type=</span><span class="st">"p"</span>,<span class="at">cex=</span><span class="fl">1.0</span>,<span class="at">col=</span><span class="dv">2</span>,<span class="at">xlab=</span><span class="st">"Weeks"</span>,<span class="at">pch=</span><span class="dv">16</span>,  </span>
<span id="cb51-76"><a href="#cb51-76" aria-hidden="true" tabindex="-1"></a>      <span class="at">ylab=</span><span class="st">"Length (mm)"</span>,<span class="at">defpar=</span><span class="cn">FALSE</span>)  </span>
<span id="cb51-77"><a href="#cb51-77" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(<span class="dv">0</span><span class="sc">:</span><span class="dv">160</span>,predL,<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">1</span>)  </span>
<span id="cb51-78"><a href="#cb51-78" aria-hidden="true" tabindex="-1"></a> <span class="co"># calculate and plot the residuals  </span></span>
<span id="cb51-79"><a href="#cb51-79" aria-hidden="true" tabindex="-1"></a>resids <span class="ot">&lt;-</span> length <span class="sc">-</span> <span class="fu">vB</span>(bestvB<span class="sc">$</span>estimate,week)  </span>
<span id="cb51-80"><a href="#cb51-80" aria-hidden="true" tabindex="-1"></a><span class="fu">plot1</span>(week,resids,<span class="at">type=</span><span class="st">"l"</span>,<span class="at">col=</span><span class="st">"darkgrey"</span>,<span class="at">cex=</span><span class="fl">0.9</span>,<span class="at">lwd=</span><span class="dv">2</span>,  </span>
<span id="cb51-81"><a href="#cb51-81" aria-hidden="true" tabindex="-1"></a>    <span class="at">xlab=</span><span class="st">"Weeks"</span>,<span class="at">lty=</span><span class="dv">3</span>,<span class="at">ylab=</span><span class="st">"Normal Residuals"</span>,<span class="at">defpar=</span><span class="cn">FALSE</span>)  </span>
<span id="cb51-82"><a href="#cb51-82" aria-hidden="true" tabindex="-1"></a><span class="fu">points</span>(week,resids,<span class="at">pch=</span><span class="dv">16</span>,<span class="at">cex=</span><span class="fl">1.1</span>,<span class="at">col=</span><span class="st">"red"</span>)  </span>
<span id="cb51-83"><a href="#cb51-83" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">h=</span><span class="dv">0</span>,<span class="at">col=</span><span class="dv">1</span>,<span class="at">lwd=</span><span class="dv">1</span>)  </span>
<span id="cb51-84"><a href="#cb51-84" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-85"><a href="#cb51-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-88"><a href="#cb51-88" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb51-89"><a href="#cb51-89" aria-hidden="true" tabindex="-1"></a> <span class="co"># Fit seasonal vB curve, parameters = Linf, K, t0, C, s, sigma  </span></span>
<span id="cb51-90"><a href="#cb51-90" aria-hidden="true" tabindex="-1"></a>svb <span class="ot">&lt;-</span> <span class="cf">function</span>(p,ages,<span class="at">inc=</span><span class="dv">52</span>) {  </span>
<span id="cb51-91"><a href="#cb51-91" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(p[<span class="dv">1</span>]<span class="sc">*</span>(<span class="dv">1</span> <span class="sc">-</span> <span class="fu">exp</span>(<span class="sc">-</span>(p[<span class="dv">4</span>] <span class="sc">*</span> <span class="fu">sin</span>(<span class="dv">2</span><span class="sc">*</span>pi<span class="sc">*</span>(ages <span class="sc">-</span> p[<span class="dv">5</span>])<span class="sc">/</span>inc) <span class="sc">+</span>   </span>
<span id="cb51-92"><a href="#cb51-92" aria-hidden="true" tabindex="-1"></a>                           p[<span class="dv">2</span>] <span class="sc">*</span> (ages <span class="sc">-</span> p[<span class="dv">3</span>])))))  </span>
<span id="cb51-93"><a href="#cb51-93" aria-hidden="true" tabindex="-1"></a>} <span class="co"># end of svB  </span></span>
<span id="cb51-94"><a href="#cb51-94" aria-hidden="true" tabindex="-1"></a>spars <span class="ot">&lt;-</span> <span class="fu">c</span>(bestvB<span class="sc">$</span>estimate[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>],<span class="fl">0.1</span>,<span class="dv">5</span>,<span class="fl">2.0</span>)  <span class="co"># keep sigma at end  </span></span>
<span id="cb51-95"><a href="#cb51-95" aria-hidden="true" tabindex="-1"></a>bestsvb <span class="ot">&lt;-</span> <span class="fu">nlm</span>(<span class="at">f=</span>negNLL,<span class="at">p=</span>spars,<span class="at">funk=</span>svb,<span class="at">ages=</span>week,<span class="at">observed=</span>length,  </span>
<span id="cb51-96"><a href="#cb51-96" aria-hidden="true" tabindex="-1"></a>              <span class="at">typsize=</span><span class="fu">magnitude</span>(spars))   </span>
<span id="cb51-97"><a href="#cb51-97" aria-hidden="true" tabindex="-1"></a>predLs <span class="ot">&lt;-</span> <span class="fu">svb</span>(bestsvb<span class="sc">$</span>estimate,<span class="dv">0</span><span class="sc">:</span><span class="dv">160</span>)  </span>
<span id="cb51-98"><a href="#cb51-98" aria-hidden="true" tabindex="-1"></a><span class="fu">outfit</span>(bestsvb,<span class="at">backtran =</span> <span class="cn">FALSE</span>,<span class="at">title=</span><span class="st">"Seasonal Growth"</span>,  </span>
<span id="cb51-99"><a href="#cb51-99" aria-hidden="true" tabindex="-1"></a>       <span class="at">parnames=</span><span class="fu">c</span>(<span class="st">"Linf"</span>,<span class="st">"K"</span>,<span class="st">"t0"</span>,<span class="st">"C"</span>,<span class="st">"s"</span>,<span class="st">"sigma"</span>))  </span>
<span id="cb51-100"><a href="#cb51-100" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-101"><a href="#cb51-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-102"><a href="#cb51-102" aria-hidden="true" tabindex="-1"></a>增长率的季节性调整对 $L_{\infty}$ 和 $K$ 值的影响较小，但对 $t_0$ 值的影响较大，因为季节性比标准 <span class="in">`vB()`</span> 函数更能允许最初的快速上升。正如预期的那样，对 *sigma* 参数的影响很大(从 3.74 下降到 1.64 )。模型拟合的改进也很大(增加两个参数的代价是 -veLL 从 150 下降到 105)。如 @fig-5-2 所示，这也反映在整个残差模式的减少及其最大值和最小值的减半上。</span>
<span id="cb51-103"><a href="#cb51-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-106"><a href="#cb51-106" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb51-107"><a href="#cb51-107" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-5-2</span></span>
<span id="cb51-108"><a href="#cb51-108" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Pitcher 和 Macdonald（1973）的近似龄长数据与 von Bertalanffy 生长曲线的拟合季节版本。下图是正态随机残差图，残差仍有一系列高于和低于零的运行，但不如非季节性曲线那么有规律。"</span></span>
<span id="cb51-109"><a href="#cb51-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-110"><a href="#cb51-110" aria-hidden="true" tabindex="-1"></a> <span class="co">#Plot seasonal growth curve and residuals   Figure 5.2  </span></span>
<span id="cb51-111"><a href="#cb51-111" aria-hidden="true" tabindex="-1"></a><span class="fu">parset</span>(<span class="at">plots=</span><span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">1</span>))  <span class="co"># MQMF utility wrapper function  </span></span>
<span id="cb51-112"><a href="#cb51-112" aria-hidden="true" tabindex="-1"></a><span class="fu">plot1</span>(week,length,<span class="at">type=</span><span class="st">"p"</span>,<span class="at">cex=</span><span class="fl">0.9</span>,<span class="at">col=</span><span class="dv">2</span>,<span class="at">xlab=</span><span class="st">"Weeks"</span>,<span class="at">pch=</span><span class="dv">16</span>,  </span>
<span id="cb51-113"><a href="#cb51-113" aria-hidden="true" tabindex="-1"></a>      <span class="at">ylab=</span><span class="st">"Length (mm)"</span>,<span class="at">defpar=</span><span class="cn">FALSE</span>)  </span>
<span id="cb51-114"><a href="#cb51-114" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(<span class="dv">0</span><span class="sc">:</span><span class="dv">160</span>,predLs,<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">1</span>)  </span>
<span id="cb51-115"><a href="#cb51-115" aria-hidden="true" tabindex="-1"></a> <span class="co"># calculate and plot the residuals  </span></span>
<span id="cb51-116"><a href="#cb51-116" aria-hidden="true" tabindex="-1"></a>resids <span class="ot">&lt;-</span> length <span class="sc">-</span> <span class="fu">svb</span>(bestsvb<span class="sc">$</span>estimate,week)  </span>
<span id="cb51-117"><a href="#cb51-117" aria-hidden="true" tabindex="-1"></a><span class="fu">plot1</span>(week,resids,<span class="at">type=</span><span class="st">"l"</span>,<span class="at">col=</span><span class="st">"darkgrey"</span>,<span class="at">cex=</span><span class="fl">0.9</span>,<span class="at">xlab=</span><span class="st">"Weeks"</span>,  </span>
<span id="cb51-118"><a href="#cb51-118" aria-hidden="true" tabindex="-1"></a>      <span class="at">lty=</span><span class="dv">3</span>,<span class="at">ylab=</span><span class="st">"Normal Residuals"</span>,<span class="at">defpar=</span><span class="cn">FALSE</span>)  </span>
<span id="cb51-119"><a href="#cb51-119" aria-hidden="true" tabindex="-1"></a><span class="fu">points</span>(week,resids,<span class="at">pch=</span><span class="dv">16</span>,<span class="at">cex=</span><span class="fl">1.1</span>,<span class="at">col=</span><span class="st">"red"</span>)  </span>
<span id="cb51-120"><a href="#cb51-120" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">h=</span><span class="dv">0</span>,<span class="at">col=</span><span class="dv">1</span>,<span class="at">lwd=</span><span class="dv">1</span>)  </span>
<span id="cb51-121"><a href="#cb51-121" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-122"><a href="#cb51-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-123"><a href="#cb51-123" aria-hidden="true" tabindex="-1"></a>这当然不是唯一可以描述生长率季节性变化的生长曲线，但本节只是对其原理的介绍。事实上，文献中还有很多可供选择的生长曲线，例如甲壳动物的生长曲线，它们是通过蜕皮来增大体型的。因此，严格来说，描述它们的生长需要估算从初始尺寸开始的生长增量，以及它们蜕皮时生长增量的持续时间和频率。不过，在种群层面，如果数量足够多，在种群动力学模型中，连续的生长曲线往往可以充分近似地描述这种生长。</span>
<span id="cb51-124"><a href="#cb51-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-125"><a href="#cb51-125" aria-hidden="true" tabindex="-1"></a>@pitcher1973 对他们的第一条季节性生长曲线所预测的负增长的出现表示反对，但由于他们处理的是从鱼群中选取的样本，并对这些样本的平均值进行拟合，因此没有生物学上的理由可以解释为什么这些样本的平均值在一年中的某些时候不能略有下降。他们还指出，使用直接拟合过程“......在带有交互式图形的 PDP 8-E 计算机上联机需要几个小时：然而，有效的优化方法可以大大缩短时间” <span class="co">[</span><span class="ot">@pitcher1973，第603页</span><span class="co">]</span>。希望这样的陈述能让读者更加了解现在非线性优化器的易得性、卓越的计算机速度及其分析能力（免费提供的软件，如 R，确实是一种能力）。</span>
<span id="cb51-126"><a href="#cb51-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-127"><a href="#cb51-127" aria-hidden="true" tabindex="-1"></a><span class="fu">### 标记数据的 Fabens 方法</span></span>
<span id="cb51-128"><a href="#cb51-128" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-129"><a href="#cb51-129" aria-hidden="true" tabindex="-1"></a>到目前为止，在第<span class="co">[</span><span class="ot">-@sec-paraestimat</span><span class="co">]</span> 章 “<span class="co">[</span><span class="ot">模型参数估计</span><span class="co">](04-application.qmd)</span> ”一章和本节的 “静态模型 ”中，我们主要讨论的是年龄-长度数据，这显然需要对样本进行年龄测定和长度测量。遗憾的是，并非所有动物的年龄都能精确到足以使用这种生长描述。在渔业相关科学的早期，一种常用的做法是给鱼类标记、放流（Petersen，1896 ）。回捕鱼类可用于描述其运动特征，后来，通过测量标记时和回捕时的鱼体长度，可用于描述动物的生长情况。在使用标记数据拟合曲线时，需要对用于描述更标准的年龄长度曲线的方程进行转换。因为我们不知道被标记动物的年龄，我们需要一个方程，根据 von Bertalanffy 参数生成预期长度增量，标记时的长度 $L_t$，以及经过时间 $\Delta t$ 后的长度将是 $L_{t + \Delta t}$。Fabens(1965) 对 von Bertalanffy 曲线进行了改造，使其可以用于从标记程序中获得的信息(参见本章附录中的完整推导)。通过对一般的 von-Bertalanffy 曲线（ <span class="co">[</span><span class="ot">@eq-5_1</span><span class="co">]</span>） 的处理，Fabens 得到下面的方程：</span>
<span id="cb51-130"><a href="#cb51-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-131"><a href="#cb51-131" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-132"><a href="#cb51-132" aria-hidden="true" tabindex="-1"></a>\begin{split}  </span>
<span id="cb51-133"><a href="#cb51-133" aria-hidden="true" tabindex="-1"></a>  &amp; \Delta \hat{L}={{L}_{t+\Delta t}}-{{L}_{t}} <span class="sc">\\</span>  </span>
<span id="cb51-134"><a href="#cb51-134" aria-hidden="true" tabindex="-1"></a>&amp; \Delta \hat{L}=\left( {{L}_{\infty }}-{{L}_{t}} \right)\left( 1-{{e}^{-K\Delta t}} \right)  </span>
<span id="cb51-135"><a href="#cb51-135" aria-hidden="true" tabindex="-1"></a>\end{split}  </span>
<span id="cb51-136"><a href="#cb51-136" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_3}</span>
<span id="cb51-137"><a href="#cb51-137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-138"><a href="#cb51-138" aria-hidden="true" tabindex="-1"></a>其中，某一动物的初始长度是 $L_t$，$\Delta L$ 是 $\Delta t$ 时间段的长度的期望变化。通过使用最小二乘法或负对数似然法，可以估算出 $L_{\infty}$ 和 $K$ 的值。为了估算 $t_0$值，需要可知年龄的平均长度，因此，通常无法进行 $t_0$ 估计，并且无法确定生长曲线沿年龄轴的确切位置。在这种情况下，$t_0$ 通常被设为 $0$。</span>
<span id="cb51-139"><a href="#cb51-139" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-140"><a href="#cb51-140" aria-hidden="true" tabindex="-1"></a>如果能够获得至少记录了标记时的初始长度、标记和回捕之间的时间间隔以及在该时间间隔内发生的生长增量的数据，那么我们在给定初始长度和两个参数 $L_{\infty}$ 和 $K$ 的情况下，建立一个函数，生成所需的预测增长增量，然后利用最大似然，我们就可以获得我们所拥有的任何数据的最佳拟合。</span>
<span id="cb51-141"><a href="#cb51-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-142"><a href="#cb51-142" aria-hidden="true" tabindex="-1"></a>这最好通过绘制一些标记的图来说明 <span class="co">[</span><span class="ot">@fig-5-3</span><span class="co">]</span> （数据在 **MQMF** 数据集 *blackisland*（鲍鱼种群）中找到）。包括一些较大鲍鱼的零增长。数据云是分散的（噪声），但某种形式的趋势是明显的，生长模型将试图拟合这种趋势。</span>
<span id="cb51-143"><a href="#cb51-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-146"><a href="#cb51-146" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb51-147"><a href="#cb51-147" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-5-3</span></span>
<span id="cb51-148"><a href="#cb51-148" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: |</span></span>
<span id="cb51-149"><a href="#cb51-149" aria-hidden="true" tabindex="-1"></a><span class="co">#|   从塔斯马尼亚州西南角黑岛采集的黑唇鲍鱼标记数据。标记与重捕之间的时间间隔平均为 1.02 年。</span></span>
<span id="cb51-150"><a href="#cb51-150" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-151"><a href="#cb51-151" aria-hidden="true" tabindex="-1"></a> <span class="co"># tagging growth increment data from Black Island, Tasmania  </span></span>
<span id="cb51-152"><a href="#cb51-152" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(blackisland);  bi <span class="ot">&lt;-</span> blackisland <span class="co"># just to keep things brief  </span></span>
<span id="cb51-153"><a href="#cb51-153" aria-hidden="true" tabindex="-1"></a><span class="fu">parset</span>()  </span>
<span id="cb51-154"><a href="#cb51-154" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(bi<span class="sc">$</span>l1,bi<span class="sc">$</span>dl,<span class="at">type=</span><span class="st">"p"</span>,<span class="at">pch=</span><span class="dv">16</span>,<span class="at">cex=</span><span class="fl">1.0</span>,<span class="at">col=</span><span class="dv">2</span>,<span class="at">ylim=</span><span class="fu">c</span>(<span class="sc">-</span><span class="dv">1</span>,<span class="dv">33</span>),  </span>
<span id="cb51-155"><a href="#cb51-155" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylab=</span><span class="st">"Growth Increment mm"</span>,<span class="at">xlab=</span><span class="st">"Initial Length mm"</span>,  </span>
<span id="cb51-156"><a href="#cb51-156" aria-hidden="true" tabindex="-1"></a>     <span class="at">panel.first =</span> <span class="fu">grid</span>())  </span>
<span id="cb51-157"><a href="#cb51-157" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">h=</span><span class="dv">0</span>,<span class="at">col=</span><span class="dv">1</span>)  </span>
<span id="cb51-158"><a href="#cb51-158" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-159"><a href="#cb51-159" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-160"><a href="#cb51-160" aria-hidden="true" tabindex="-1"></a>与第 <span class="co">[</span><span class="ot">-@sec-paraestimat</span><span class="co">]</span> 章“<span class="co">[</span><span class="ot">模型参数估计</span><span class="co">](04-application.qmd)</span>”中对生长的描述一样，这里我们将拟合两条生长曲线并与示例标记数据 进行比较。这两条曲线分别是 von Bertalanffy 曲线（Fabens，1965；见 @eq-5_3 ）（鱼类和其它种类的）以及逆 logistic 曲线（Haddon 等，2008 ），更适合难以测定年龄的无脊椎动物所表现出的不确定连续生长。与 von Bertalanffy 曲线相比，逆 logistic 曲线的局限性更大，因为它设计用于以一年为单位的时间增量，或至少是一个恒定的时间增量。</span>
<span id="cb51-161"><a href="#cb51-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-162"><a href="#cb51-162" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-163"><a href="#cb51-163" aria-hidden="true" tabindex="-1"></a>\begin{split}  </span>
<span id="cb51-164"><a href="#cb51-164" aria-hidden="true" tabindex="-1"></a>  \Delta L &amp;= \frac{Max\Delta L}{1+{{e}^{log(19)({L_t}-L_{50})/\delta }}} + \varepsilon <span class="sc">\\</span>   </span>
<span id="cb51-165"><a href="#cb51-165" aria-hidden="true" tabindex="-1"></a>  {L_{t+1}} &amp;= {L_t}+\Delta L + \varepsilon   </span>
<span id="cb51-166"><a href="#cb51-166" aria-hidden="true" tabindex="-1"></a>\end{split}  </span>
<span id="cb51-167"><a href="#cb51-167" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_4}</span>
<span id="cb51-168"><a href="#cb51-168" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-169"><a href="#cb51-169" aria-hidden="true" tabindex="-1"></a>$\delta$ 等于 $L_{95} - L_{50}$，其中 $L_{50}$ 和 $L_{95}$ 是增长率分别为 $Max \Delta L$ 的 50% 和 5% 时的长度，$\varepsilon$ 表示一定长度的平均预期增量的正态随机残差误差。 事后来看，$L_{95}$ 可能定义为 $L_5$ 更好。 请注意，由于进行了 Fabens 变换，Fabens 模型的残差误差与年龄长度模型的残差误差有所不同，尽管二者都使用了正态概率密度函数（稍后详述）。</span>
<span id="cb51-170"><a href="#cb51-170" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-171"><a href="#cb51-171" aria-hidden="true" tabindex="-1"></a>**MQMF** 中定义了两个函数来生成 von Bertalanffy 曲线的预测生长增量：<span class="in">`fabens()`</span> 和逆 logistic <span class="in">`invl()`</span>。这两个函数的实现非常简单，反映了 @eq-5_3 和 @eq-5_4 。读者应检查这些函数的代码（即不带括号的 <span class="in">`fabens()`</span> 或 <span class="in">`invl()`</span>），并阅读每个函数的帮助。读者很快就会明白，这些函数的定义方式可以方便地使用列名不是 $l1$ 和 $dt$ 的 data.frames。在下文中，我们明确使用了这些名称，尽管我们本可以直接使用默认值。</span>
<span id="cb51-172"><a href="#cb51-172" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-173"><a href="#cb51-173" aria-hidden="true" tabindex="-1"></a><span class="fu">### 拟合标记数据模型</span></span>
<span id="cb51-174"><a href="#cb51-174" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-175"><a href="#cb51-175" aria-hidden="true" tabindex="-1"></a>在模型拟合方面中，我们已经有了生成预测生长增量（ $\Delta L$ ）所需的函数（<span class="in">`fabens()`</span> 和 <span class="in">`invl()`</span> ）以及优化器 <span class="in">`nlm()`</span>，仍然需要的是在搜索最小值期间计算负对数似然的函数。在这一点上，没有理由使用正态随机误差以外的其他误差。我们将使用 **MQMF** 函数 <span class="in">`negNLL()`</span> 来拟合两条曲线，然后通过可视化和似然比检验对它们进行比较。如果需要更改用于所需数据的列名，可以使用 ....。</span>
<span id="cb51-176"><a href="#cb51-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-179"><a href="#cb51-179" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb51-180"><a href="#cb51-180" aria-hidden="true" tabindex="-1"></a> <span class="co"># Fit the vB and Inverse Logistic to the tagging data  </span></span>
<span id="cb51-181"><a href="#cb51-181" aria-hidden="true" tabindex="-1"></a>linm <span class="ot">&lt;-</span> <span class="fu">lm</span>(bi<span class="sc">$</span>dl <span class="sc">~</span> bi<span class="sc">$</span>l1) <span class="co"># simple linear regression  </span></span>
<span id="cb51-182"><a href="#cb51-182" aria-hidden="true" tabindex="-1"></a>param <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">170.0</span>,<span class="fl">0.3</span>,<span class="fl">4.0</span>); label <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"Linf"</span>,<span class="st">"K"</span>,<span class="st">"sigma"</span>)  </span>
<span id="cb51-183"><a href="#cb51-183" aria-hidden="true" tabindex="-1"></a>modelvb <span class="ot">&lt;-</span> <span class="fu">nlm</span>(<span class="at">f=</span>negNLL,<span class="at">p=</span>param,<span class="at">funk=</span>fabens,<span class="at">observed=</span>bi<span class="sc">$</span>dl,<span class="at">indat=</span>bi,  </span>
<span id="cb51-184"><a href="#cb51-184" aria-hidden="true" tabindex="-1"></a>               <span class="at">initL=</span><span class="st">"l1"</span>,<span class="at">delT=</span><span class="st">"dt"</span>) <span class="co"># could have used the defaults  </span></span>
<span id="cb51-185"><a href="#cb51-185" aria-hidden="true" tabindex="-1"></a><span class="fu">outfit</span>(modelvb,<span class="at">backtran =</span> <span class="cn">FALSE</span>,<span class="at">title=</span><span class="st">"vB"</span>,<span class="at">parnames=</span>label)  </span>
<span id="cb51-186"><a href="#cb51-186" aria-hidden="true" tabindex="-1"></a>predvB <span class="ot">&lt;-</span> <span class="fu">fabens</span>(modelvb<span class="sc">$</span>estimate,bi)  </span>
<span id="cb51-187"><a href="#cb51-187" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)  </span>
<span id="cb51-188"><a href="#cb51-188" aria-hidden="true" tabindex="-1"></a>param2 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">25.0</span>,<span class="fl">130.0</span>,<span class="fl">35.0</span>,<span class="fl">3.0</span>)   </span>
<span id="cb51-189"><a href="#cb51-189" aria-hidden="true" tabindex="-1"></a>label2<span class="ot">=</span><span class="fu">c</span>(<span class="st">"MaxDL"</span>,<span class="st">"L50"</span>,<span class="st">"delta"</span>,<span class="st">"sigma"</span>)  </span>
<span id="cb51-190"><a href="#cb51-190" aria-hidden="true" tabindex="-1"></a>modelil <span class="ot">&lt;-</span> <span class="fu">nlm</span>(<span class="at">f=</span>negNLL,<span class="at">p=</span>param2,<span class="at">funk=</span>invl,<span class="at">observed=</span>bi<span class="sc">$</span>dl,<span class="at">indat=</span>bi,  </span>
<span id="cb51-191"><a href="#cb51-191" aria-hidden="true" tabindex="-1"></a>               <span class="at">initL=</span><span class="st">"l1"</span>,<span class="at">delT=</span><span class="st">"dt"</span>)  </span>
<span id="cb51-192"><a href="#cb51-192" aria-hidden="true" tabindex="-1"></a><span class="fu">outfit</span>(modelil,<span class="at">backtran =</span> <span class="cn">FALSE</span>,<span class="at">title=</span><span class="st">"IL"</span>,<span class="at">parnames=</span>label2)  </span>
<span id="cb51-193"><a href="#cb51-193" aria-hidden="true" tabindex="-1"></a>predil <span class="ot">&lt;-</span> <span class="fu">invl</span>(modelil<span class="sc">$</span>estimate,bi)  </span>
<span id="cb51-194"><a href="#cb51-194" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-195"><a href="#cb51-195" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-196"><a href="#cb51-196" aria-hidden="true" tabindex="-1"></a>逆 logistic 模型的负对数似然小于 von Bertalanffy 模型的负对数似然，而且逆 logistic 呈现出较小的 $\sigma$ 值。如果我们将这两条增长曲线与原始数据进行对比，就可以更清楚地看到它们之间的差异<span class="co">[</span><span class="ot">@fig-5-4</span><span class="co">]</span>。此外，对各自的残差进行检验也会发现曲线之间的差异，预测的 von Bertalanffy 曲线的残差呈圆弧状，这与其预测的初始长度与生长增量之间的线性关系是一致的。在 @fig-5-4 中，线性回归绘制在 von Bertalanffy 曲线的上方，以说明它实际上是重合的。</span>
<span id="cb51-197"><a href="#cb51-197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-200"><a href="#cb51-200" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb51-201"><a href="#cb51-201" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-5-4</span></span>
<span id="cb51-202"><a href="#cb51-202" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: |</span></span>
<span id="cb51-203"><a href="#cb51-203" aria-hidden="true" tabindex="-1"></a><span class="co">#|   黑岛黑唇鲍标记数据的von Betalanffy（黑色）、逆 logistic （红色曲线虚线）和线性回归（黄色虚线）拟合。</span></span>
<span id="cb51-204"><a href="#cb51-204" aria-hidden="true" tabindex="-1"></a><span class="co">#|   标记与回捕之间的时间间隔为 1.02 年。显然，vB 和线性回归是相同的。</span></span>
<span id="cb51-205"><a href="#cb51-205" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-206"><a href="#cb51-206" aria-hidden="true" tabindex="-1"></a> <span class="co">#growth curves and regression fitted to tagging data Fig 5.4  </span></span>
<span id="cb51-207"><a href="#cb51-207" aria-hidden="true" tabindex="-1"></a><span class="fu">parset</span>(<span class="at">margin=</span><span class="fu">c</span>(<span class="fl">0.4</span>,<span class="fl">0.4</span>,<span class="fl">0.05</span>,<span class="fl">0.05</span>))  </span>
<span id="cb51-208"><a href="#cb51-208" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(bi<span class="sc">$</span>l1,bi<span class="sc">$</span>dl,<span class="at">type=</span><span class="st">"p"</span>,<span class="at">pch=</span><span class="dv">16</span>,<span class="at">cex=</span><span class="fl">1.0</span>,<span class="at">col=</span><span class="dv">3</span>,<span class="at">ylim=</span><span class="fu">c</span>(<span class="sc">-</span><span class="dv">2</span>,<span class="dv">31</span>),  </span>
<span id="cb51-209"><a href="#cb51-209" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylab=</span><span class="st">"Growth Increment mm"</span>,<span class="at">xlab=</span><span class="st">"Length mm"</span>,<span class="at">panel.first=</span><span class="fu">grid</span>())  </span>
<span id="cb51-210"><a href="#cb51-210" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">h=</span><span class="dv">0</span>,<span class="at">col=</span><span class="dv">1</span>)  </span>
<span id="cb51-211"><a href="#cb51-211" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(bi<span class="sc">$</span>l1,predvB,<span class="at">pch=</span><span class="dv">16</span>,<span class="at">col=</span><span class="dv">1</span>,<span class="at">lwd=</span><span class="dv">3</span>,<span class="at">lty=</span><span class="dv">1</span>)  <span class="co"># vB  </span></span>
<span id="cb51-212"><a href="#cb51-212" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(bi<span class="sc">$</span>l1,predil,<span class="at">pch=</span><span class="dv">16</span>,<span class="at">col=</span><span class="dv">2</span>,<span class="at">lwd=</span><span class="dv">3</span>,<span class="at">lty=</span><span class="dv">2</span>)  <span class="co"># IL  </span></span>
<span id="cb51-213"><a href="#cb51-213" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(linm,<span class="at">lwd=</span><span class="dv">3</span>,<span class="at">col=</span><span class="dv">7</span>,<span class="at">lty=</span><span class="dv">2</span>) <span class="co"># add dashed linear regression  </span></span>
<span id="cb51-214"><a href="#cb51-214" aria-hidden="true" tabindex="-1"></a><span class="fu">legend</span>(<span class="st">"topright"</span>,<span class="fu">c</span>(<span class="st">"vB"</span>,<span class="st">"LinReg"</span>,<span class="st">"IL"</span>),<span class="at">lwd=</span><span class="dv">3</span>,<span class="at">bty=</span><span class="st">"n"</span>,<span class="at">cex=</span><span class="fl">1.2</span>,  </span>
<span id="cb51-215"><a href="#cb51-215" aria-hidden="true" tabindex="-1"></a>                    <span class="at">col=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">7</span>,<span class="dv">2</span>),<span class="at">lty=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>))  </span>
<span id="cb51-216"><a href="#cb51-216" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-217"><a href="#cb51-217" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-218"><a href="#cb51-218" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-219"><a href="#cb51-219" aria-hidden="true" tabindex="-1"></a>两条生长曲线的残差也显示了各自模型拟合的差异。</span>
<span id="cb51-220"><a href="#cb51-220" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-223"><a href="#cb51-223" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb51-224"><a href="#cb51-224" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-5-5</span></span>
<span id="cb51-225"><a href="#cb51-225" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: |</span></span>
<span id="cb51-226"><a href="#cb51-226" aria-hidden="true" tabindex="-1"></a><span class="co">#|   黑岛黑唇鲍标记数据的 von Betalanffy 曲线残差图（左侧）和 逆 Logistic 曲线残差图（右侧）。标记与回捕之间的时间间隔为 1.02 年。</span></span>
<span id="cb51-227"><a href="#cb51-227" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-228"><a href="#cb51-228" aria-hidden="true" tabindex="-1"></a> <span class="co">#residuals for vB and inverse logistic for tagging data Fig 5.5  </span></span>
<span id="cb51-229"><a href="#cb51-229" aria-hidden="true" tabindex="-1"></a><span class="fu">parset</span>(<span class="at">plots=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>),<span class="at">outmargin=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>),<span class="at">margin=</span><span class="fu">c</span>(.<span class="dv">25</span>,.<span class="dv">25</span>,.<span class="dv">05</span>,.<span class="dv">05</span>))  </span>
<span id="cb51-230"><a href="#cb51-230" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(bi<span class="sc">$</span>l1,(bi<span class="sc">$</span>dl <span class="sc">-</span> predvB),<span class="at">type=</span><span class="st">"p"</span>,<span class="at">pch=</span><span class="dv">16</span>,<span class="at">col=</span><span class="dv">1</span>,<span class="at">ylab=</span><span class="st">""</span>,  </span>
<span id="cb51-231"><a href="#cb51-231" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlab=</span><span class="st">""</span>,<span class="at">panel.first=</span><span class="fu">grid</span>(),<span class="at">ylim=</span><span class="fu">c</span>(<span class="sc">-</span><span class="dv">8</span>,<span class="dv">11</span>))  </span>
<span id="cb51-232"><a href="#cb51-232" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">h=</span><span class="dv">0</span>,<span class="at">col=</span><span class="dv">1</span>)  </span>
<span id="cb51-233"><a href="#cb51-233" aria-hidden="true" tabindex="-1"></a><span class="fu">mtext</span>(<span class="st">"vB"</span>,<span class="at">side=</span><span class="dv">1</span>,<span class="at">outer=</span><span class="cn">FALSE</span>,<span class="at">line=</span><span class="sc">-</span><span class="fl">1.1</span>,<span class="at">cex=</span><span class="fl">1.2</span>,<span class="at">font=</span><span class="dv">7</span>)  </span>
<span id="cb51-234"><a href="#cb51-234" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(bi<span class="sc">$</span>l1,(bi<span class="sc">$</span>dl <span class="sc">-</span> predil),<span class="at">type=</span><span class="st">"p"</span>,<span class="at">pch=</span><span class="dv">16</span>,<span class="at">col=</span><span class="dv">1</span>,<span class="at">ylab=</span><span class="st">""</span>,  </span>
<span id="cb51-235"><a href="#cb51-235" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlab=</span><span class="st">""</span>,<span class="at">panel.first=</span><span class="fu">grid</span>(),<span class="at">ylim=</span><span class="fu">c</span>(<span class="sc">-</span><span class="dv">8</span>,<span class="dv">11</span>))  </span>
<span id="cb51-236"><a href="#cb51-236" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">h=</span><span class="dv">0</span>,<span class="at">col=</span><span class="dv">1</span>)  </span>
<span id="cb51-237"><a href="#cb51-237" aria-hidden="true" tabindex="-1"></a><span class="fu">mtext</span>(<span class="st">"IL"</span>,<span class="at">side=</span><span class="dv">3</span>,<span class="at">outer=</span><span class="cn">FALSE</span>,<span class="at">line=</span><span class="sc">-</span><span class="fl">1.2</span>,<span class="at">cex=</span><span class="fl">1.2</span>,<span class="at">font=</span><span class="dv">7</span>)  </span>
<span id="cb51-238"><a href="#cb51-238" aria-hidden="true" tabindex="-1"></a><span class="fu">mtext</span>(<span class="st">"Length mm"</span>,<span class="at">side=</span><span class="dv">1</span>,<span class="at">line=</span><span class="sc">-</span><span class="fl">0.1</span>,<span class="at">cex=</span><span class="fl">1.0</span>,<span class="at">font=</span><span class="dv">7</span>,<span class="at">outer=</span><span class="cn">TRUE</span>)  </span>
<span id="cb51-239"><a href="#cb51-239" aria-hidden="true" tabindex="-1"></a><span class="fu">mtext</span>(<span class="st">"Residual"</span>,<span class="at">side=</span><span class="dv">2</span>,<span class="at">line=</span><span class="sc">-</span><span class="fl">0.1</span>,<span class="at">cex=</span><span class="fl">1.0</span>,<span class="at">font=</span><span class="dv">7</span>,<span class="at">outer=</span><span class="cn">TRUE</span>)  </span>
<span id="cb51-240"><a href="#cb51-240" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-241"><a href="#cb51-241" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-242"><a href="#cb51-242" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-243"><a href="#cb51-243" aria-hidden="true" tabindex="-1"></a><span class="fu">### 对 Fabens 方法的深入探讨</span></span>
<span id="cb51-244"><a href="#cb51-244" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-245"><a href="#cb51-245" aria-hidden="true" tabindex="-1"></a>von Bertalanffy 方程的 Fabens 变换所描述的生长曲线使用了相同的参数，但却暗藏了一些不易察觉的差异。您一定还记得我们使用两种不同的残差误差结构拟合 vB 曲线的例子，这使得结果无法比较，或者更严格地说，无法比较。Fabens 变换改变了残差结构以及参数之间的相互作用方式。取而代之的是 $L_{\infty}$ 变成了绝对最大值，这就是它能预测负增长的原因。严格来说，Fabens 模型的参数与 von Bertalanffy 模型的参数含义不同。</span>
<span id="cb51-246"><a href="#cb51-246" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-247"><a href="#cb51-247" aria-hidden="true" tabindex="-1"></a>我们对 von Bertalanffy 曲线和逆 logistic 曲线进行了比较，但由于我们使用了鲍鱼种群的数据作为例子，我们对哪条曲线可能更有用的看法有失偏颇。在大多数有鳞鱼类渔业中，人们发现 von Bertalanffy 曲线作为对生长的一般描述是最有用的，尽管它还存在一些问题。但所有生长模型（不只是标记生长模型）的一个普遍问题是我们迄今为止所使用的假设，即围绕预测生长趋势的观测变化将是恒定的。如果我们看一下 @fig-5-3 或 @fig-5-4 ，还记得我们在第 <span class="co">[</span><span class="ot">-@sec-paraestimat</span><span class="co">]</span> 章“<span class="co">[</span><span class="ot">模型参数估计</span><span class="co">](04-application.qmd)</span>”中绘制的年龄长度数据，那么在每种情况下，初始长度或年龄的变化趋势都比较明显。与其坚持在残差中使用恒定的方差（如 SSQ 所要求的），不如使用恒定的变异系数（ $\sigma/\mu$ ）。如果我们使用最大似然法，就有可能对残差的方差进行单独建模，从而得出一系列不同的结果；Francis（1988 ）正是这样做的。他使用最大似然法对数据进行了标记模型拟合，并假定每种情况下的残差都是正态分布的，但他对残差方差与期望 $\Delta L$ 之间的关系提出了一些不同的函数形式（与初始长度的函数关系也是可能的）。迄今为止，我们使用的方法假定方差为常数，因此我们估算了一个常数 $\sigma$ 参数。Francis（1988）则建议，方差可以有一个介于 $\sigma$ 和 $\Delta L$ 之间的恒定乘数，标记数据之间可以存在反比关系。这些考虑因素也适用于年龄-长度模型，在这种模型中，常数乘数将使年龄与 $\sigma$ 之间呈线性关系。</span>
<span id="cb51-248"><a href="#cb51-248" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-249"><a href="#cb51-249" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-250"><a href="#cb51-250" aria-hidden="true" tabindex="-1"></a>\sigma = \upsilon (\Delta \hat{L})</span>
<span id="cb51-251"><a href="#cb51-251" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_5}</span>
<span id="cb51-252"><a href="#cb51-252" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-253"><a href="#cb51-253" aria-hidden="true" tabindex="-1"></a>其中 $\upsilon$ 是期望 $\Delta L$ 的常数乘数，需要分别估算。此时正态似然将变为：</span>
<span id="cb51-254"><a href="#cb51-254" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-255"><a href="#cb51-255" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-256"><a href="#cb51-256" aria-hidden="true" tabindex="-1"></a>L\left( \Delta L|Data \right)=\sum\limits_{i}{\frac{1}{\sqrt{2\pi }\upsilon \Delta \hat{L}}}\exp \left( \frac{{{\left( \Delta L-\Delta \hat{L} \right)}^{2}}}{2{{\left( \upsilon \Delta \hat{L} \right)}^{2}}} \right)  </span>
<span id="cb51-257"><a href="#cb51-257" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_6}</span>
<span id="cb51-258"><a href="#cb51-258" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-259"><a href="#cb51-259" aria-hidden="true" tabindex="-1"></a>其中用 $2\left(\upsilon \Delta \hat L \right)^2$ 替代一般正态似然的 $\sigma^2$。除这一简单的替代方案外，Francis（1988 ）还建议对标记数据采用指数递减的残差标准差，再加上一个可估算的常数 $\tau$ ：</span>
<span id="cb51-260"><a href="#cb51-260" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-261"><a href="#cb51-261" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-262"><a href="#cb51-262" aria-hidden="true" tabindex="-1"></a>\sigma = \tau \left( 1 - e^{-\upsilon (\Delta \hat{L})}  \right)  </span>
<span id="cb51-263"><a href="#cb51-263" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_-_7}</span>
<span id="cb51-264"><a href="#cb51-264" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-265"><a href="#cb51-265" aria-hidden="true" tabindex="-1"></a>最后，Francis（1988）建议采用幂律描述的残差标准差：</span>
<span id="cb51-266"><a href="#cb51-266" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-267"><a href="#cb51-267" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-268"><a href="#cb51-268" aria-hidden="true" tabindex="-1"></a>\sigma = \upsilon (\Delta \hat{L})^\tau  </span>
<span id="cb51-269"><a href="#cb51-269" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_8}</span>
<span id="cb51-270"><a href="#cb51-270" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-271"><a href="#cb51-271" aria-hidden="true" tabindex="-1"></a>Francis（1988）还通过考虑偏差、生长率的季节性变化以及离群污染的影响，将 Fabens 方法扩展到分析标记数据。文献中往往只强调了报告的一个方面，这也是经常查阅原始文献而不是依赖其他论文或书籍（如这本书）中的摘要的一个很好的理由。如果需要对标记数据拟合生长曲线，Francis（1988）是一个很好的起点。</span>
<span id="cb51-272"><a href="#cb51-272" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-273"><a href="#cb51-273" aria-hidden="true" tabindex="-1"></a>由于方差与预期 $\Delta L$ 之间关系的表达不同，常数 $\tau$ 和 $\upsilon$ 的解释也发生变化。 如前所述，如果假定的误差结构不同，从同一模型中得到的参数估计值也会不同，从而变得不可比较。遗憾的是，如何选择最合适的误差结构并不是一个简单的问题。充其量，无论选择哪种曲线，使用非恒定方差都能提供与之相关的不确定性的另一种视角。</span>
<span id="cb51-274"><a href="#cb51-274" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-275"><a href="#cb51-275" aria-hidden="true" tabindex="-1"></a><span class="fu">### 非恒定方差的实现</span></span>
<span id="cb51-276"><a href="#cb51-276" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-277"><a href="#cb51-277" aria-hidden="true" tabindex="-1"></a>通过包含期望 $\Delta L$ 和 残差方差之间关系，我们需要改变包装函数，围绕如何使用预测值 $\Delta \hat L$ 计算负对数似然。之前，对于常数 $\sigma$ 我们用 <span class="in">`negNULL()`</span> ，所以我们可从它开始修改。我们所做的只是包括一个额外函数 <span class="in">`funksig()`</span> ，作为 <span class="in">`negnormL()`</span> 的参数（参见其帮助和代码），从而包括 sigma 值的计算。通过这种方法，我们可以在 <span class="in">`funksig()`</span> 中保留常数 $\sigma$ 的长版本。但这也表明函数的行为符合预期。然后，我们可以加入一个替代的 <span class="in">`funksig()`</span>，实现上述三个选项之一（或我们自己设计的选项）。</span>
<span id="cb51-278"><a href="#cb51-278" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-281"><a href="#cb51-281" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb51-282"><a href="#cb51-282" aria-hidden="true" tabindex="-1"></a>   <span class="co"># fit the Fabens tag growth curve with and without the option to   </span></span>
<span id="cb51-283"><a href="#cb51-283" aria-hidden="true" tabindex="-1"></a> <span class="co"># modify variation with predicted length. See the MQMF function  </span></span>
<span id="cb51-284"><a href="#cb51-284" aria-hidden="true" tabindex="-1"></a> <span class="co"># negnormL. So first no variation and then linear variation.   </span></span>
<span id="cb51-285"><a href="#cb51-285" aria-hidden="true" tabindex="-1"></a>sigfunk <span class="ot">&lt;-</span> <span class="cf">function</span>(pars,predobs) <span class="fu">return</span>(<span class="fu">tail</span>(pars,<span class="dv">1</span>)) <span class="co">#no effect  </span></span>
<span id="cb51-286"><a href="#cb51-286" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(blackisland)  </span>
<span id="cb51-287"><a href="#cb51-287" aria-hidden="true" tabindex="-1"></a>bi <span class="ot">&lt;-</span> blackisland <span class="co"># just to keep things brief  </span></span>
<span id="cb51-288"><a href="#cb51-288" aria-hidden="true" tabindex="-1"></a>param <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">170.0</span>,<span class="fl">0.3</span>,<span class="fl">4.0</span>); label<span class="ot">=</span><span class="fu">c</span>(<span class="st">"Linf"</span>,<span class="st">"K"</span>,<span class="st">"sigma"</span>)  </span>
<span id="cb51-289"><a href="#cb51-289" aria-hidden="true" tabindex="-1"></a>modelvb <span class="ot">&lt;-</span> <span class="fu">nlm</span>(<span class="at">f=</span>negnormL,<span class="at">p=</span>param,<span class="at">funk=</span>fabens,<span class="at">funksig=</span>sigfunk,  </span>
<span id="cb51-290"><a href="#cb51-290" aria-hidden="true" tabindex="-1"></a>               <span class="at">indat=</span>bi,<span class="at">initL=</span><span class="st">"l1"</span>,<span class="at">delT=</span><span class="st">"dt"</span>)  </span>
<span id="cb51-291"><a href="#cb51-291" aria-hidden="true" tabindex="-1"></a><span class="fu">outfit</span>(modelvb,<span class="at">backtran =</span> <span class="cn">FALSE</span>,<span class="at">title=</span><span class="st">"vB constant sigma"</span>,  </span>
<span id="cb51-292"><a href="#cb51-292" aria-hidden="true" tabindex="-1"></a>       <span class="at">parnames =</span> label)  </span>
<span id="cb51-293"><a href="#cb51-293" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-294"><a href="#cb51-294" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-297"><a href="#cb51-297" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb51-298"><a href="#cb51-298" aria-hidden="true" tabindex="-1"></a>sigfunk2 <span class="ot">&lt;-</span> <span class="cf">function</span>(pars,predo) { <span class="co"># linear with predicted length  </span></span>
<span id="cb51-299"><a href="#cb51-299" aria-hidden="true" tabindex="-1"></a>  sig <span class="ot">&lt;-</span> <span class="fu">tail</span>(pars,<span class="dv">1</span>) <span class="sc">*</span> predo      <span class="co"># sigma x predDL, see negnormL  </span></span>
<span id="cb51-300"><a href="#cb51-300" aria-hidden="true" tabindex="-1"></a>  pick <span class="ot">&lt;-</span> <span class="fu">which</span>(sig <span class="sc">&lt;=</span> <span class="dv">0</span>)          <span class="co"># ensure no negative sigmas from   </span></span>
<span id="cb51-301"><a href="#cb51-301" aria-hidden="true" tabindex="-1"></a>  sig[pick] <span class="ot">&lt;-</span> <span class="fl">0.01</span>           <span class="co"># possible negative predicted lengths  </span></span>
<span id="cb51-302"><a href="#cb51-302" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(sig)  </span>
<span id="cb51-303"><a href="#cb51-303" aria-hidden="true" tabindex="-1"></a>} <span class="co"># end of sigfunk2  </span></span>
<span id="cb51-304"><a href="#cb51-304" aria-hidden="true" tabindex="-1"></a>param <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">170.0</span>,<span class="fl">0.3</span>,<span class="fl">1.0</span>); label<span class="ot">=</span><span class="fu">c</span>(<span class="st">"Linf"</span>,<span class="st">"K"</span>,<span class="st">"sigma"</span>)  </span>
<span id="cb51-305"><a href="#cb51-305" aria-hidden="true" tabindex="-1"></a>modelvb2 <span class="ot">&lt;-</span> <span class="fu">nlm</span>(<span class="at">f=</span>negnormL,<span class="at">p=</span>param,<span class="at">funk=</span>fabens,<span class="at">funksig=</span>sigfunk2,  </span>
<span id="cb51-306"><a href="#cb51-306" aria-hidden="true" tabindex="-1"></a>                <span class="at">indat=</span>bi,<span class="at">initL=</span><span class="st">"l1"</span>,<span class="at">delT=</span><span class="st">"dt"</span>,    </span>
<span id="cb51-307"><a href="#cb51-307" aria-hidden="true" tabindex="-1"></a>                <span class="at">typsize=</span><span class="fu">magnitude</span>(param),<span class="at">iterlim=</span><span class="dv">200</span>)  </span>
<span id="cb51-308"><a href="#cb51-308" aria-hidden="true" tabindex="-1"></a><span class="fu">outfit</span>(modelvb2,<span class="at">backtran =</span> <span class="cn">FALSE</span>,<span class="at">parnames =</span> label,  </span>
<span id="cb51-309"><a href="#cb51-309" aria-hidden="true" tabindex="-1"></a>       <span class="at">title=</span><span class="st">"vB inverse DeltaL, sigma &lt; 1"</span>)  </span>
<span id="cb51-310"><a href="#cb51-310" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-311"><a href="#cb51-311" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-312"><a href="#cb51-312" aria-hidden="true" tabindex="-1"></a>请记住，通过改变残差结构，似然值变得不相称，因此我们无法确定哪种拟合效果更好。恒定方差使得 von Bertalanffy 曲线在长度大于 148 左右时有效地保持在数据之上，而变化方差生长曲线大部分时间仍在数据之上，但由于方差随预测长度的减少而向后推近数据。我们可以通过重写 <span class="in">`negnormL()`</span> 来进行实验，使用初始长度而不是预测长度。如前所述，将平均预测长度与相关方差分离可以获得极大的灵活性。</span>
<span id="cb51-313"><a href="#cb51-313" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-316"><a href="#cb51-316" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb51-317"><a href="#cb51-317" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-5-6</span></span>
<span id="cb51-318"><a href="#cb51-318" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: |</span></span>
<span id="cb51-319"><a href="#cb51-319" aria-hidden="true" tabindex="-1"></a><span class="co">#|   与黑岛黑唇鲍标记数据拟合的具有恒定 sigma von Bertalanffy（皇家蓝）和</span></span>
<span id="cb51-320"><a href="#cb51-320" aria-hidden="true" tabindex="-1"></a><span class="co">#|   具有与不断变化的 DeltaL 相关的 sgima 的 von Bertalanffy（红色虚线）。</span></span>
<span id="cb51-321"><a href="#cb51-321" aria-hidden="true" tabindex="-1"></a><span class="co">#|   标记与再捕之间的平均时间间隔为 1.02 年。</span></span>
<span id="cb51-322"><a href="#cb51-322" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-323"><a href="#cb51-323" aria-hidden="true" tabindex="-1"></a> <span class="co">#plot to two Faben's lines with constant and varying sigma Fig 5.6  </span></span>
<span id="cb51-324"><a href="#cb51-324" aria-hidden="true" tabindex="-1"></a>predvB <span class="ot">&lt;-</span> <span class="fu">fabens</span>(modelvb<span class="sc">$</span>estimate,bi)  </span>
<span id="cb51-325"><a href="#cb51-325" aria-hidden="true" tabindex="-1"></a>predvB2 <span class="ot">&lt;-</span> <span class="fu">fabens</span>(modelvb2<span class="sc">$</span>estimate,bi)  </span>
<span id="cb51-326"><a href="#cb51-326" aria-hidden="true" tabindex="-1"></a><span class="fu">parset</span>(<span class="at">margin=</span><span class="fu">c</span>(<span class="fl">0.4</span>,<span class="fl">0.4</span>,<span class="fl">0.05</span>,<span class="fl">0.05</span>))  </span>
<span id="cb51-327"><a href="#cb51-327" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(bi<span class="sc">$</span>l1,bi<span class="sc">$</span>dl,<span class="at">type=</span><span class="st">"p"</span>,<span class="at">pch=</span><span class="dv">1</span>,<span class="at">cex=</span><span class="fl">1.0</span>,<span class="at">col=</span><span class="dv">1</span>,<span class="at">ylim=</span><span class="fu">c</span>(<span class="sc">-</span><span class="dv">2</span>,<span class="dv">31</span>),  </span>
<span id="cb51-328"><a href="#cb51-328" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylab=</span><span class="st">"Growth Increment mm"</span>,<span class="at">xlab=</span><span class="st">"Length mm"</span>,<span class="at">panel.first=</span><span class="fu">grid</span>())  </span>
<span id="cb51-329"><a href="#cb51-329" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">h=</span><span class="dv">0</span>,<span class="at">col=</span><span class="dv">1</span>)  </span>
<span id="cb51-330"><a href="#cb51-330" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(bi<span class="sc">$</span>l1,predvB,<span class="at">col=</span><span class="dv">1</span>,<span class="at">lwd=</span><span class="dv">2</span>)         <span class="co"># vB  </span></span>
<span id="cb51-331"><a href="#cb51-331" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(bi<span class="sc">$</span>l1,predvB2,<span class="at">col=</span><span class="dv">2</span>,<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">lty=</span><span class="dv">2</span>)  <span class="co"># IL  </span></span>
<span id="cb51-332"><a href="#cb51-332" aria-hidden="true" tabindex="-1"></a><span class="fu">legend</span>(<span class="st">"topright"</span>,<span class="fu">c</span>(<span class="st">"Constant sigma"</span>,<span class="st">"Changing sigma"</span>),<span class="at">lwd=</span><span class="dv">3</span>,  </span>
<span id="cb51-333"><a href="#cb51-333" aria-hidden="true" tabindex="-1"></a>       <span class="at">col=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>),<span class="at">bty=</span><span class="st">"n"</span>,<span class="at">cex=</span><span class="fl">1.1</span>,<span class="at">lty=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>))  </span>
<span id="cb51-334"><a href="#cb51-334" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-335"><a href="#cb51-335" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-336"><a href="#cb51-336" aria-hidden="true" tabindex="-1"></a>我们的眼睛习惯于欣赏对称性，因此 @fig-5-6 中不断变化的变化线看起来拟合得相对较差。但是，假设误差只存在于 y 轴上（y-on-x 问题），并且残差的方差也在不断变化，作为拟合模型的反映，下部的红色虚线使数据的值内有一条内在的曲线。使用更复杂的残差结构使模型拟合对初始条件更敏感。您会注意到，在输出结果中，假设残差方差恒定只需要 20-30 次迭代，而使用方差函数关系则需要两倍的迭代次数（这是在使用 Typsize 可选参数来增强稳定性的情况下，而在更简单的模型中没有使用）。如果修改这些起始值，很容易得到难以置信的答案。</span>
<span id="cb51-337"><a href="#cb51-337" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-338"><a href="#cb51-338" aria-hidden="true" tabindex="-1"></a>尽管在使用年龄长度数据时，特别是在非常小的年龄段，变化的差异往往很明显，但在建模中引入这种复杂性还是需要有充分的理由。</span>
<span id="cb51-339"><a href="#cb51-339" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-340"><a href="#cb51-340" aria-hidden="true" tabindex="-1"></a><span class="fu">## 目标模型选择 {#sec-label}</span></span>
<span id="cb51-341"><a href="#cb51-341" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-342"><a href="#cb51-342" aria-hidden="true" tabindex="-1"></a>在第 <span class="co">[</span><span class="ot">-@sec-paraestimat</span><span class="co">]</span> 章“<span class="co">[</span><span class="ot">模型参数估计</span><span class="co">](04-application.qmd)</span>（*Model Parameter Estimation*） ”中，我们看到了一个类似的章节，其中介绍了基于平方和的 Akaike 信息准则（AIC；Akaike，1974）的信息理论近似值（Burnham 和 Anderson，2002）。现在我们使用最大似然法，我们将介绍 AIC 的原始版本，并讨论似然比。</span>
<span id="cb51-343"><a href="#cb51-343" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-344"><a href="#cb51-344" aria-hidden="true" tabindex="-1"></a><span class="fu">### Akaike 信息准则</span></span>
<span id="cb51-345"><a href="#cb51-345" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-346"><a href="#cb51-346" aria-hidden="true" tabindex="-1"></a>在试图描述数据集中的模式时，选择使用哪种模型时，使用的参数数量与模型拟合数据集的质量之间的权衡始终是一个问题。经典的方法是选择最简单的模型，该模型能很好地描述该模式（奥卡姆剃刀只是一个关于简约性的劝告，因此如果两个模型产生的结果相同，就选择最简单的一个）。但是，“等效结果 ”到底有多接近，“最简单 ”又是什么意思。Akaike 的解决方案（1974）是将似然比和 “模型内独立调整参数的数量 ”结合起来使用。AIC 是一种基于似然值的惩罚性模型选择标准，最小的 AIC 表示最佳模型（在似然值与参数数量之间取得平衡）。</span>
<span id="cb51-347"><a href="#cb51-347" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-348"><a href="#cb51-348" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-349"><a href="#cb51-349" aria-hidden="true" tabindex="-1"></a>AIC = -2 \log(L) + \alpha p</span>
<span id="cb51-350"><a href="#cb51-350" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_9}</span>
<span id="cb51-351"><a href="#cb51-351" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-352"><a href="#cb51-352" aria-hidden="true" tabindex="-1"></a>其中， $\log(L)$ 是总对数似然值， $p$ 是拟合模型时显式调整的参数数量，而 $\alpha$ 是一个乘数（惩罚项，在惩罚似然中），其值由 Akaike（1974）设定为 2.0，这是基于信息论的一个论点。强调“独立调整的参数”是“显式调整的”是为了避免混淆那些保持不变或从其他参数和模型变量推导出来的模型参数（我们在过剩产量模型中的捕获率参数中会看到一个例子）。例如，在渔业模型中一个常见的假设是自然死亡率，通常表示为&nbsp;$M$，是一个常数。因此，在 AIC 的&nbsp;$p$&nbsp;值中不会将其计算在内。将&nbsp;$\alpha$&nbsp;作为惩罚项的显式标识，而不是直接使用常数值 2.0，是为了强调关于应使用的确切值存在争议（Bhansali 和 Downham, 1977；Schwartz, 1978；Akaike, 1979；Atkinson, 1980），以确保模型复杂度（参数数量）与拟合质量（最大似然或最小平方和）之间的平衡能够反映模拟中的实际情况。 尽管统计论据相对较为密集，最终归结为&nbsp;$\alpha$&nbsp;的值&nbsp;$p$&nbsp;应该多大？这一结果被称为施瓦茨的贝叶斯信息准则，简称 BIC。</span>
<span id="cb51-353"><a href="#cb51-353" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-354"><a href="#cb51-354" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-355"><a href="#cb51-355" aria-hidden="true" tabindex="-1"></a>BIC = -2 \log(L) + \log(n) p</span>
<span id="cb51-356"><a href="#cb51-356" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_10}</span>
<span id="cb51-357"><a href="#cb51-357" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-358"><a href="#cb51-358" aria-hidden="true" tabindex="-1"></a>其中 $n$ 是样本大小或模型拟合的数据点数， $p$ 是参数数量。只要数据点数大于或等于 8（ $\log(8)=2.079$），BIC 将比 AIC 更严厉地惩罚复杂模型。另一方面，从直观上讲，考虑样本大小是有道理的。如果我们使用 MQMF 函数&nbsp;<span class="in">`aicbic()`</span>&nbsp;对 von Bertalanffy 模型和逆逻辑斯蒂模型的拟合结果进行比较，其中使用了常数 $\sigma$ 估计 <span class="co">[</span><span class="ot">@fig-5-4</span><span class="co">]</span>，逆逻辑斯蒂模型的 AIC 和 BIC 均较小，因此在这种情况下，逆逻辑斯蒂模型将是更优的选择。</span>
<span id="cb51-359"><a href="#cb51-359" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-362"><a href="#cb51-362" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb51-363"><a href="#cb51-363" aria-hidden="true" tabindex="-1"></a> <span class="co">#compare the relative model fits of Vb and IL  </span></span>
<span id="cb51-364"><a href="#cb51-364" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"von Bertalanffy </span><span class="sc">\n</span><span class="st">"</span>)  </span>
<span id="cb51-365"><a href="#cb51-365" aria-hidden="true" tabindex="-1"></a><span class="fu">aicbic</span>(modelvb,bi)  </span>
<span id="cb51-366"><a href="#cb51-366" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"inverse-logistic </span><span class="sc">\n</span><span class="st">"</span>)  </span>
<span id="cb51-367"><a href="#cb51-367" aria-hidden="true" tabindex="-1"></a><span class="fu">aicbic</span>(modelil,bi)  </span>
<span id="cb51-368"><a href="#cb51-368" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-369"><a href="#cb51-369" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-370"><a href="#cb51-370" aria-hidden="true" tabindex="-1"></a><span class="fu">### 似然比检验</span></span>
<span id="cb51-371"><a href="#cb51-371" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-372"><a href="#cb51-372" aria-hidden="true" tabindex="-1"></a>可以使用广义似然比检验（Neter et al, 1996）来比较不同模型拟合效果与复杂度之间的差异。该方法依赖于似然比检验在样本量增大时渐近趋近于 $\chi^2$ 分布的事实。这意味着在通常的渔业数据量下，这种方法只是近似的方法。似然比检验正如其名所示，是两个似然性的比值的对数，或者直接处理对数似然性时，是两个对数似然性的相减，两者是等价的（当然，这两个似然性必须来自同一个概率密度函数）。我们希望确定两个使用相同数据和残差结构但模型结构不同的模型（即不同的参数），哪一个能显著更好地拟合可用数据。由于似然比可以由 $\chi^2$ 分布描述，因此可以正式回答这个问题。 因此，对于两个模型的似然性，如果它们要么具有相同数量的参数，要么仅相差一个参数，在考虑显著性差异时，它们的比值需要大于所需的自由度（不同参数的数量）对应的 $\chi^2$ 分布。</span>
<span id="cb51-373"><a href="#cb51-373" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-374"><a href="#cb51-374" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-375"><a href="#cb51-375" aria-hidden="true" tabindex="-1"></a>\begin{split}</span>
<span id="cb51-376"><a href="#cb51-376" aria-hidden="true" tabindex="-1"></a>-2 \times \log\left<span class="co">[</span><span class="ot">\dfrac{L(\theta)_{\alpha}}{L(\theta)_b} \right</span><span class="co">]</span> &amp;\le \chi_{1,1 -\alpha}^2 <span class="sc">\\</span></span>
<span id="cb51-377"><a href="#cb51-377" aria-hidden="true" tabindex="-1"></a>-2 \times [LL(\theta)_a -LL(\theta)_b &amp; \le \chi_{1,1-\alpha}^2</span>
<span id="cb51-378"><a href="#cb51-378" aria-hidden="true" tabindex="-1"></a>\end{split}</span>
<span id="cb51-379"><a href="#cb51-379" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_11}</span>
<span id="cb51-380"><a href="#cb51-380" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-381"><a href="#cb51-381" aria-hidden="true" tabindex="-1"></a>其中 $L(\theta)_x$ 是模型 $x$ 的 $\theta$ 参数的似然， $LL(\theta)_x$ 是等效的对数似然。 $\chi_{1, 1-\alpha}^2$ 是 $\chi^2$ 分布的 $1-\alpha$ 百分位数（例如，对于 95% 的置信区间， $\alpha = 0.95$ 和 $1-\alpha = 0.05$ ，即 $\chi_{1,1-\alpha}^2= 3.84$。</span>
<span id="cb51-382"><a href="#cb51-382" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-383"><a href="#cb51-383" aria-hidden="true" tabindex="-1"></a>简而言之，如果我们要比较两个仅相差一个或没有参数的模型，那么如果它们的负对数似然值相差超过 1.92（3.84/2），则可以认为这两个模型在统计上显著不同，其中一个模型将比另一个模型提供显著更好的拟合。如果两个模型之间相差两个参数，那么这两个模型在统计上显著不同的负对数似然值的最小差异需要达到 $2.995(5.99/2)=\chi_{2, 0.95}^2/2$ 自由度为 2），依此类推，对于参数差异更多的情况（Venzon 和 Moolgavkar, 1988）。</span>
<span id="cb51-384"><a href="#cb51-384" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-385"><a href="#cb51-385" aria-hidden="true" tabindex="-1"></a>关于 von Bertalanffy 曲线和逆逻辑斯蒂曲线的比较，逆逻辑斯蒂负对数似然值为 $-2.0 \times(277.0122-291.1691) = 28.3138$ ，明显小于 von Bertalanffy 曲线的负对数似然值。我们可以使用 MQMF 函数 <span class="in">`likeratio()`</span>来说明这两种曲线在拟合数据方面的差异具有高度显著性。</span>
<span id="cb51-386"><a href="#cb51-386" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-389"><a href="#cb51-389" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb51-390"><a href="#cb51-390" aria-hidden="true" tabindex="-1"></a> <span class="co"># Likelihood ratio comparison of two growth models see Fig 5.4  </span></span>
<span id="cb51-391"><a href="#cb51-391" aria-hidden="true" tabindex="-1"></a>vb <span class="ot">&lt;-</span> modelvb<span class="sc">$</span>minimum <span class="co"># their respective -ve log-likelihoods  </span></span>
<span id="cb51-392"><a href="#cb51-392" aria-hidden="true" tabindex="-1"></a>il <span class="ot">&lt;-</span> modelil<span class="sc">$</span>minimum  </span>
<span id="cb51-393"><a href="#cb51-393" aria-hidden="true" tabindex="-1"></a>dof <span class="ot">&lt;-</span> <span class="dv">1</span>  </span>
<span id="cb51-394"><a href="#cb51-394" aria-hidden="true" tabindex="-1"></a><span class="fu">round</span>(<span class="fu">likeratio</span>(vb,il,dof),<span class="dv">8</span>)  </span>
<span id="cb51-395"><a href="#cb51-395" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-396"><a href="#cb51-396" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-397"><a href="#cb51-397" aria-hidden="true" tabindex="-1"></a><span class="fu">### 似然比检验的注意事项</span></span>
<span id="cb51-398"><a href="#cb51-398" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-399"><a href="#cb51-399" aria-hidden="true" tabindex="-1"></a>由于在渔业模型中广泛使用加权对数似然，当使用似然比检验来比较替代模型时，需要小心确保这些模型实际上是可比的。当我们使用相同的数据和相同的概率密度函数来描述残差分布时，可以使用似然比检验。但请记住，当我们仅对相同的生长模型应用不同的残差误差结构假设（对数正态而非正态）时，这些曲线是完全不可比的（不具可比性）。同样，在使用惩罚似然时，不同版本的模型可能会对不同的数据流给予不同的权重，这种变化使得模型不可比。很明显，应该只比较可比的模型，但在一些更复杂的模型中，确定什么是公平比较有时并不总是简单的。</span>
<span id="cb51-400"><a href="#cb51-400" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-401"><a href="#cb51-401" aria-hidden="true" tabindex="-1"></a><span class="fu">## 关于生长的说明</span></span>
<span id="cb51-402"><a href="#cb51-402" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-403"><a href="#cb51-403" aria-hidden="true" tabindex="-1"></a>对个体生长过程的描述对渔业模型很重要，因为个体的大小和重量的生长是特定种群生产力的重要组成部分。这种生长显然是增加种群生物量过程与减少种群生物量过程之间平衡的一个积极因素。但重要的是要理解，生长的描述总是描述性的，并且主要适用于我们有数据的大小范围。有许多实例表明，von Bertalanffy 曲线外推的弱点会导致生物学上荒谬的预测（Knight，1968）。但这类实例是将模型参数的特定解释误认为现实，而曲线仅仅是生长数据的描述，严格来说只在有数据的地方有效。这就是为什么已经产生了生长模型转换，这些转换估计的参数可以位于可用数据的范围内（Schnute，1981；Francis，1988，1995）。</span>
<span id="cb51-404"><a href="#cb51-404" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-405"><a href="#cb51-405" aria-hidden="true" tabindex="-1"></a><span class="fu">## 成熟</span></span>
<span id="cb51-406"><a href="#cb51-406" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-407"><a href="#cb51-407" aria-hidden="true" tabindex="-1"></a><span class="fu">### 引言</span></span>
<span id="cb51-408"><a href="#cb51-408" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-409"><a href="#cb51-409" aria-hidden="true" tabindex="-1"></a>目前，渔业管理倾向于使用所谓的生物参考点来构建其希望构成合理且可辩护的管理决策的基础，这些决策针对的是可再生的自然资源（FAO，1995，1996，1997；Restrepo 和 POwers，1999；Haddon，2007）。简单来说，这个想法是设定一个目标参考点，通常定义为成熟生物量水平或其某种替代指标，该指标被认为是种群的一种理想状态。它是理想状态，因为通常它应该能够为后续的补充提供良好的水平，并为种群提供足够的恢复力以抵御偶尔的环境冲击。常见的默认值可以是 $B_{40}$，即 $40\% B_0$，或 40% 的消耗水平，这被用作 $B_{MSY}$ 的替代指标，或者是能够可持续产生最大可持续产量的产卵生物量。在澳大利亚，联邦收获策略政策将目标定义为 $B_{48}$，这被用作 $B_{MEY}$ 的替代指标，即应该能够产生最大经济效益的产卵生物量（注意，目标是生物量水平 $B_{MSY}$，而不是 $MEY$；DAFF，2007；Rayns，2007）。 此外，还需定义一个极限参考点，同样以成熟生物量（或替代指标）的水平来表示，低于该水平时，所关注的种群将被认为其补充量存在受损害的风险。生物参考点通常以未受干扰的产卵生物量的估计值（ $B_0$ ）为基准来表述。 $B_0$ 的概念可以是均衡概念，也可以是更动态的版本，试图解释补充量的变化。无论哪种情况，这个数值在评估中往往具有不确定性，并且在不同评估中经常发生变化（Punt 等，2018 ）。为了提供管理建议，需要三个要素：</span>
<span id="cb51-410"><a href="#cb51-410" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-411"><a href="#cb51-411" aria-hidden="true" tabindex="-1"></a><span class="ss">-   </span>对当前种群状态进行评估，包括繁殖生物量的消耗情况，从而</span>
<span id="cb51-412"><a href="#cb51-412" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-413"><a href="#cb51-413" aria-hidden="true" tabindex="-1"></a><span class="ss">-   </span>当前未捕捞的产卵生物量估计值，最后</span>
<span id="cb51-414"><a href="#cb51-414" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-415"><a href="#cb51-415" aria-hidden="true" tabindex="-1"></a><span class="ss">-   </span>一个决定下一个季节（些）允许的捕捞死亡率、努力量或渔获量的捕捞控制规则。</span>
<span id="cb51-416"><a href="#cb51-416" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-417"><a href="#cb51-417" aria-hidden="true" tabindex="-1"></a>也许你注意到了，我在成熟和产卵生物量这两个术语之间互换使用。这样做并不是想让你感到困惑，而是想让你习惯于文献中会遇到的术语变化。</span>
<span id="cb51-418"><a href="#cb51-418" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-419"><a href="#cb51-419" aria-hidden="true" tabindex="-1"></a>强调成熟生物量或产卵生物量的重要性，是获得合理成熟大小或年龄估计的原因。这是为了确保对成熟生物量有多少的估计能够反映鱼种的生物学特性以及当前渔业状态。在本书中，我们试图专注于建模，但始终试图模拟潜在的生物学现实。事实上，生物学现实，就像生长的细节一样，往往相当复杂。在渔业理论中，许多基础来自北半球，特别是对北海和大西洋的高生产力鱼种进行研究（Smith，1994）。那里的许多商业物种具有相对简单的繁殖历史。有雄性和雌性，作为一个种群，它们按一般节律成熟，它们在死亡之前要么产卵一次，要么每年产卵。当然，这是一种过度简化，生物学世界比这要多样化得多，即使在北半球也是如此。 有些物种从一开始就是雌性，其中一些较大的雌性会转变为雄性（原雌雄同体），反之亦然（原雄雌同体）。存在许多不同的繁殖策略，其中许多策略会影响诸如成熟大小和/或年龄等因素。然而，在这里我们将只关注经典方法。尽管如此，使用你自己的例子时，不要对生物学做出假设，始终情况下，来自种群的代表性证据比假设更好。</span>
<span id="cb51-420"><a href="#cb51-420" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-421"><a href="#cb51-421" aria-hidden="true" tabindex="-1"></a>成熟时的个体大小或年龄是一个种群特性。个体可能经历成熟过程，并需要时间才能具备繁殖能力，但我们描述的过程是针对整个种群的平均值。给定一个样本，希望是一个足够大的样本，能够覆盖成熟时个体大小或年龄的范围，我们的目标是描述每个个体大小或年龄的鱼类中成熟的比例。成熟时个体大小（size-at-maturity ）的概念通常被总结为 种群中50% 个体性成熟（具备繁殖能力）时的个体大小。实际上， $Lm_{50}$ ，即 50% 成熟的个体长度，只是重要因素的一部分，此外，正如我们将看到的，关于物种随长度或年龄成熟的速度的某种度量也同样重要。一些更简单的渔业模型仍然使用一种被称为“刀刃式成熟”（knife-edge matruity）的假设，这意味着一个强烈的假设，即 100% 的动物在某个特定年龄成熟。我们将在后面讨论种群成熟所需的时间如何影响种群动态。 如何确定成熟度在此不予考虑，尽管理想情况下应使用组织学来确认成熟的配子，而不是仅仅通过观察鱼类的性腺。再次强调，有大量文献致力于详细说明确定各种物种成熟阶段的细节，但我们不会尝试去探讨这些内容。我们所要完成的任务是找到预期种群成熟曲线的数学描述。预期的是，被认为成熟的动物比例会随着体型和年龄的增长而增加，直到 100%成熟（尽管即使对此也有例外，某些物种的雌性会花几年时间从产生卵子所需的大量能量投资中恢复，从而暂时停止繁殖）。生命史特征体现在物种是适应一次性繁殖（半繁殖性）还是多次繁殖（多次繁殖性），或者它产生的是大量小卵还是远少得多的大卵，甚至生产少量活体幼崽。始终要记住，生物学可以非常复杂，而生物学的数学描述是相对简单的抽象。</span>
<span id="cb51-422"><a href="#cb51-422" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-423"><a href="#cb51-423" aria-hidden="true" tabindex="-1"></a><span class="fu">### 替代的成熟度曲线</span></span>
<span id="cb51-424"><a href="#cb51-424" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-425"><a href="#cb51-425" aria-hidden="true" tabindex="-1"></a>一个种群内成熟的一般模式是，成熟度会分布在一系列长度和年龄中，其中一部分早熟，一部分晚熟，大多数则在某个平均时间成熟。如果我们想象一个随时间变化的成熟比例的抛物线曲线，可能接近正态分布但尾部更短，那么我们想要的是该分布的累积密度函数，在某个长度或年龄范围内从 0% 到 100% 运行。结果是常见的 S 形曲线，通常称为逻辑斯蒂曲线，在文献中，有大量不同的数学表达式来描述这类曲线。我们关注的统计量是 $Lm_{50}$ （50%成熟的大小/年龄），以及 $IQ$ ，即四分位距，它衡量成熟度曲线（在 25%和 75%成熟时的年龄）之间的大小/年龄范围。使用四分位距是一个任意选择，但反映了常见做法（如箱线图所示），但并不排除使用更宽或更窄的范围，如果这些范围更方便的话。</span>
<span id="cb51-426"><a href="#cb51-426" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-427"><a href="#cb51-427" aria-hidden="true" tabindex="-1"></a>在众多不同版本中，有一个经典的逻辑斯蒂曲线 <span class="co">[</span><span class="ot">@eq-5_12</span><span class="co">]</span>，常用于描述许多种群的成熟过程（参见 **MQMF** 函数）。这种形式非常适合使用具有二项式误差的广义线性模型进行拟合。我们一直使用 R 作为编程环境，但这里是一个提醒我们，它的最初目的是作为统计分析工具的机会。</span>
<span id="cb51-428"><a href="#cb51-428" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-429"><a href="#cb51-429" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-430"><a href="#cb51-430" aria-hidden="true" tabindex="-1"></a>p_L = \dfrac{\exp(a +bL)}{1+ \exp(a +bL)} = \dfrac{1}{1+\exp(a +bL)^{-1}}</span>
<span id="cb51-431"><a href="#cb51-431" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_12}</span>
<span id="cb51-432"><a href="#cb51-432" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-433"><a href="#cb51-433" aria-hidden="true" tabindex="-1"></a>$p_L$ 是长度 $L$ 的成熟比例，而 $a$ 和 $b$ 是指数参数。请注意，我在方程中未包含误差项。这里我们试图对不同个体大小（为简洁起见，我将停止每次写“尺寸或年龄”）的成熟或不成熟观测进行预测。这正是建议我们应使用二元误差的原因，如模型参数估计章节所述。这种公式的另一个优点是 $Lm_{50} = -a/b$ ，即 50% 成熟时的个体大小，可以直接从参数中推导出来。类似地，四分位距也可以从参数中推导出来，表示为 $IQ = 2\times \log(3)/b = 2.197225 \times b$。</span>
<span id="cb51-434"><a href="#cb51-434" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-435"><a href="#cb51-435" aria-hidden="true" tabindex="-1"></a>成熟数据具有二元特性，在特定采样时间对种群进行采样时，观测值是每个大小为 $L$ 的采样鱼是否成熟。本书的 R 包 **MQMF** 包含一个示例数据集 tasab，其中包含来自塔斯马尼亚海岸线 16 公里段上两个地点的黑唇鲍鱼（*Haliotis rubra*）数据。</span>
<span id="cb51-436"><a href="#cb51-436" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-439"><a href="#cb51-439" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb51-440"><a href="#cb51-440" aria-hidden="true" tabindex="-1"></a>   <span class="co"># The Maturity data from tasab data-set  </span></span>
<span id="cb51-441"><a href="#cb51-441" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(tasab)       <span class="co"># see ?tasab for a list of the codes used  </span></span>
<span id="cb51-442"><a href="#cb51-442" aria-hidden="true" tabindex="-1"></a><span class="fu">properties</span>(tasab) <span class="co"># summarize properties of columns in tasab  </span></span>
<span id="cb51-443"><a href="#cb51-443" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-444"><a href="#cb51-444" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-447"><a href="#cb51-447" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb51-448"><a href="#cb51-448" aria-hidden="true" tabindex="-1"></a><span class="fu">table</span>(tasab<span class="sc">$</span>site,tasab<span class="sc">$</span>sex) <span class="co"># sites 1 &amp; 2 vs F, I, and M  </span></span>
<span id="cb51-449"><a href="#cb51-449" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-450"><a href="#cb51-450" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-451"><a href="#cb51-451" aria-hidden="true" tabindex="-1"></a>鲍鱼因其生物学特征在相对较小的空间尺度上具有高度变异性而臭名昭著，因此采样地点的细节非常重要（Haddon 和 Helidoniotis，2013）。这些数据都是由同一群人在同一个月同年收集的，因此除了壳长之外，我们唯一可能认为会影响成熟度的因素就是具体地点（性别似乎在同一时间、同一个体大小成熟； @fig-5-7 ）。</span>
<span id="cb51-452"><a href="#cb51-452" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-455"><a href="#cb51-455" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb51-456"><a href="#cb51-456" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-5-7</span></span>
<span id="cb51-457"><a href="#cb51-457" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "tasab 数据集中黑唇鲍鱼成熟数据的长度成熟比例。"</span></span>
<span id="cb51-458"><a href="#cb51-458" aria-hidden="true" tabindex="-1"></a>   <span class="co">#plot the proportion mature vs shell length  Fig 5.7  </span></span>
<span id="cb51-459"><a href="#cb51-459" aria-hidden="true" tabindex="-1"></a>propm <span class="ot">&lt;-</span> <span class="fu">tapply</span>(tasab<span class="sc">$</span>mature,tasab<span class="sc">$</span>length,mean) <span class="co">#mean maturity at L  </span></span>
<span id="cb51-460"><a href="#cb51-460" aria-hidden="true" tabindex="-1"></a>lens <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(<span class="fu">names</span>(propm))            <span class="co"># lengths in the data  </span></span>
<span id="cb51-461"><a href="#cb51-461" aria-hidden="true" tabindex="-1"></a><span class="fu">plot1</span>(lens,propm,<span class="at">type=</span><span class="st">"p"</span>,<span class="at">cex=</span><span class="fl">0.9</span>,<span class="at">xlab=</span><span class="st">"Length mm"</span>,  </span>
<span id="cb51-462"><a href="#cb51-462" aria-hidden="true" tabindex="-1"></a>      <span class="at">ylab=</span><span class="st">"Proportion Mature"</span>)  </span>
<span id="cb51-463"><a href="#cb51-463" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-464"><a href="#cb51-464" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-465"><a href="#cb51-465" aria-hidden="true" tabindex="-1"></a>数据看起来相对嘈杂，虽然这很难判断，因为一些观察到的长度，其成熟比例不是 0 也不是 1，可能只有少数几次观测。例如，在长度为 100mm 处有一个成熟比例为 0.5 的点，如果你深入数据会发现该点仅由两个观测组成，一个成熟另一个不成熟。可以通过 <span class="in">`pick &lt;- which(tasab$length == 100)`</span> 查找这些长度，或者通过 <span class="in">`which(propm == 0.5)`</span> 查看数据，再使用 <span class="in">`tasab[pick,]`</span>进一步分析。</span>
<span id="cb51-466"><a href="#cb51-466" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-467"><a href="#cb51-467" aria-hidden="true" tabindex="-1"></a>使用 <span class="in">`properties(tasab)`</span> 或 <span class="in">`head(tasab,10)`</span> 查看数据集，可以告诉我们有哪些变量。虽然我们显然希望检查成熟和长度之间的关系，但请记住，最初我们还想检查站点对成熟的影响。重要的是，我们需要将站点变量转换为分类因子，否则它将被视为包含 1 和 2 的整数向量，而不是潜在的不同处理。我们不能将性别作为因子包括进来，因为所有动物最初都是未成熟状态，尽管可以始终分别分析雄性和雌性数据。然而，在更多的站点上，到目前为止，在黑唇牡蛎中，尚未发现性别在成熟速率或平均大小上的可重复差异。一旦拟合，我们会发现站点对分析无信息性（它不显著），因此我们重新进行不包括站点的分析。</span>
<span id="cb51-468"><a href="#cb51-468" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-471"><a href="#cb51-471" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb51-472"><a href="#cb51-472" aria-hidden="true" tabindex="-1"></a> <span class="co">#Use glm to estimate mature logistic  </span></span>
<span id="cb51-473"><a href="#cb51-473" aria-hidden="true" tabindex="-1"></a>binglm <span class="ot">&lt;-</span> <span class="cf">function</span>(x,<span class="at">digits=</span><span class="dv">6</span>) { <span class="co">#function to simplify printing  </span></span>
<span id="cb51-474"><a href="#cb51-474" aria-hidden="true" tabindex="-1"></a>  out <span class="ot">&lt;-</span> <span class="fu">summary</span>(x)  </span>
<span id="cb51-475"><a href="#cb51-475" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>(out<span class="sc">$</span>call)  </span>
<span id="cb51-476"><a href="#cb51-476" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>(<span class="fu">round</span>(out<span class="sc">$</span>coefficients,digits))  </span>
<span id="cb51-477"><a href="#cb51-477" aria-hidden="true" tabindex="-1"></a>  <span class="fu">cat</span>(<span class="st">"</span><span class="sc">\n</span><span class="st">Null Deviance  "</span>,out<span class="sc">$</span>null.deviance,<span class="st">"df"</span>,out<span class="sc">$</span>df.null,<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)  </span>
<span id="cb51-478"><a href="#cb51-478" aria-hidden="true" tabindex="-1"></a>  <span class="fu">cat</span>(<span class="st">"Resid.Deviance "</span>,out<span class="sc">$</span>deviance,<span class="st">"df"</span>,out<span class="sc">$</span>df.residual,<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)  </span>
<span id="cb51-479"><a href="#cb51-479" aria-hidden="true" tabindex="-1"></a>  <span class="fu">cat</span>(<span class="st">"AIC  = "</span>,out<span class="sc">$</span>aic,<span class="st">"</span><span class="sc">\n\n</span><span class="st">"</span>)  </span>
<span id="cb51-480"><a href="#cb51-480" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">invisible</span>(out)) <span class="co"># retain the full summary  </span></span>
<span id="cb51-481"><a href="#cb51-481" aria-hidden="true" tabindex="-1"></a>} <span class="co">#end of binglm  </span></span>
<span id="cb51-482"><a href="#cb51-482" aria-hidden="true" tabindex="-1"></a>tasab<span class="sc">$</span>site <span class="ot">&lt;-</span> <span class="fu">as.factor</span>(tasab<span class="sc">$</span>site) <span class="co"># site as a factor  </span></span>
<span id="cb51-483"><a href="#cb51-483" aria-hidden="true" tabindex="-1"></a>smodel <span class="ot">&lt;-</span> <span class="fu">glm</span>(mature <span class="sc">~</span> site <span class="sc">+</span> length,<span class="at">family=</span>binomial,<span class="at">data=</span>tasab) </span>
<span id="cb51-484"><a href="#cb51-484" aria-hidden="true" tabindex="-1"></a>outs <span class="ot">&lt;-</span> <span class="fu">binglm</span>(smodel)  <span class="co">#outs contains the whole summary object  </span></span>
<span id="cb51-485"><a href="#cb51-485" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb51-486"><a href="#cb51-486" aria-hidden="true" tabindex="-1"></a>model <span class="ot">&lt;-</span> <span class="fu">glm</span>(mature <span class="sc">~</span> length, <span class="at">family=</span>binomial, <span class="at">data=</span>tasab)  </span>
<span id="cb51-487"><a href="#cb51-487" aria-hidden="true" tabindex="-1"></a>outm <span class="ot">&lt;-</span> <span class="fu">binglm</span>(model)  </span>
<span id="cb51-488"><a href="#cb51-488" aria-hidden="true" tabindex="-1"></a>cof <span class="ot">&lt;-</span> outm<span class="sc">$</span>coefficients  </span>
<span id="cb51-489"><a href="#cb51-489" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"Lm50 = "</span>,<span class="sc">-</span>cof[<span class="dv">1</span>,<span class="dv">1</span>]<span class="sc">/</span>cof[<span class="dv">2</span>,<span class="dv">1</span>],<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)  </span>
<span id="cb51-490"><a href="#cb51-490" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"IQ   = "</span>,<span class="dv">2</span><span class="sc">*</span><span class="fu">log</span>(<span class="dv">3</span>)<span class="sc">/</span>cof[<span class="dv">2</span>,<span class="dv">1</span>],<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)  </span>
<span id="cb51-491"><a href="#cb51-491" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-492"><a href="#cb51-492" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-493"><a href="#cb51-493" aria-hidden="true" tabindex="-1"></a>在第一次分析中，包括了站点因素，因为我在汇总数据时确保所包含的站点相似，因此站点 2（P=0.411）与站点 1 没有显著差异，这意味着在这种情况下，站点因素对分析来说并不具有信息性。因此，我们再次进行了分析，将站点从方程中剔除。如果站点之间表现出显著差异，那么我们需要使用多个曲线来描述模型结果。无论怎样，我们还是会将它们画成不同的曲线来说明过程。额外的站点参数是对初始指数截距值的修饰。因此，ab\$length 参数在两种情况下都是 $b$ 参数，但站点 1 的曲线可以通过将截距视为 $a$ 参数来获得，而站点 2 的曲线则需要将截距和 ab\$site2 的参数值相加，作为 $a$ 参数。因此，站点 1 模型为 $a = -19.797$ 和 $b = 0.18255$ ，而站点 2 模型为 $a = -19.797 -0.3695$ 和 $b = 0.18255$ 。将最终无站点模型添加到图中表明，综合模型更接近站点 2，这反映了站点 2 的观测次数为 465 次，而站点 1 仅为 250 次。 注意，参数少一个后，残差偏差略有增加，但尽管如此，包含站点因子的模型的 AIC 值仍然大于简化模型的 AIC 值，这再次表明简化模型在复杂性和模型拟合度之间提供了更好的平衡。这与广义线性模型及其比较和操作有明显的类比。如果确实发现截距之间存在显著差异，那么测试差异是否也扩展到 $b$ 参数，以确定是否需要完全分开处理这些曲线是有意义的。共享公共参数通常是有帮助的，因为它可以增加样本量。</span>
<span id="cb51-494"><a href="#cb51-494" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-497"><a href="#cb51-497" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb51-498"><a href="#cb51-498" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-5-8</span></span>
<span id="cb51-499"><a href="#cb51-499" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "黑唇牡蛎成熟度数据（tasab 数据集）的长度成熟比例。不考虑站点的综合分析（两者）更接近站点 2（点划线）而非站点 1（划线），这反映了站点 2 样本量更大。"</span></span>
<span id="cb51-500"><a href="#cb51-500" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-501"><a href="#cb51-501" aria-hidden="true" tabindex="-1"></a> <span class="co">#Add maturity logistics to the maturity data plot Fig 5.8  </span></span>
<span id="cb51-502"><a href="#cb51-502" aria-hidden="true" tabindex="-1"></a>propm <span class="ot">&lt;-</span> <span class="fu">tapply</span>(tasab<span class="sc">$</span>mature,tasab<span class="sc">$</span>length,mean) <span class="co">#prop mature  </span></span>
<span id="cb51-503"><a href="#cb51-503" aria-hidden="true" tabindex="-1"></a>lens <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(<span class="fu">names</span>(propm))       <span class="co"># lengths in the data  </span></span>
<span id="cb51-504"><a href="#cb51-504" aria-hidden="true" tabindex="-1"></a>pick <span class="ot">&lt;-</span> <span class="fu">which</span>((lens <span class="sc">&gt;</span> <span class="dv">79</span>) <span class="sc">&amp;</span> (lens <span class="sc">&lt;</span> <span class="dv">146</span>))  </span>
<span id="cb51-505"><a href="#cb51-505" aria-hidden="true" tabindex="-1"></a><span class="fu">parset</span>()</span>
<span id="cb51-506"><a href="#cb51-506" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(lens[pick],propm[pick],<span class="at">type=</span><span class="st">"p"</span>,<span class="at">cex=</span><span class="fl">0.9</span>, <span class="co">#the data points  </span></span>
<span id="cb51-507"><a href="#cb51-507" aria-hidden="true" tabindex="-1"></a>      <span class="at">xlab=</span><span class="st">"Length mm"</span>,<span class="at">ylab=</span><span class="st">"Proportion Mature"</span>,<span class="at">pch=</span><span class="dv">1</span>)   </span>
<span id="cb51-508"><a href="#cb51-508" aria-hidden="true" tabindex="-1"></a>L <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="dv">80</span>,<span class="dv">145</span>,<span class="dv">1</span>) <span class="co"># for increased curve separation  </span></span>
<span id="cb51-509"><a href="#cb51-509" aria-hidden="true" tabindex="-1"></a>pars <span class="ot">&lt;-</span> <span class="fu">coef</span>(smodel)  </span>
<span id="cb51-510"><a href="#cb51-510" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(L,<span class="fu">mature</span>(pars[<span class="dv">1</span>],pars[<span class="dv">3</span>],L),<span class="at">lwd=</span><span class="dv">3</span>,<span class="at">col=</span><span class="dv">3</span>,<span class="at">lty=</span><span class="dv">2</span>)    </span>
<span id="cb51-511"><a href="#cb51-511" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(L,<span class="fu">mature</span>(pars[<span class="dv">1</span>]<span class="sc">+</span>pars[<span class="dv">2</span>],pars[<span class="dv">3</span>],L),<span class="at">lwd=</span><span class="dv">3</span>,<span class="at">col=</span><span class="dv">2</span>,<span class="at">lty=</span><span class="dv">4</span>)    </span>
<span id="cb51-512"><a href="#cb51-512" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(L,<span class="fu">mature</span>(<span class="fu">coef</span>(model)[<span class="dv">1</span>],<span class="fu">coef</span>(model)[<span class="dv">2</span>],L),<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">1</span>,<span class="at">lty=</span><span class="dv">1</span>)    </span>
<span id="cb51-513"><a href="#cb51-513" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">h=</span><span class="fu">c</span>(<span class="fl">0.25</span>,<span class="fl">0.5</span>,<span class="fl">0.75</span>),<span class="at">lty=</span><span class="dv">3</span>,<span class="at">col=</span><span class="st">"grey"</span>)</span>
<span id="cb51-514"><a href="#cb51-514" aria-hidden="true" tabindex="-1"></a><span class="fu">legend</span>(<span class="st">"topleft"</span>,<span class="fu">c</span>(<span class="st">"site1"</span>,<span class="st">"both"</span>,<span class="st">"site2"</span>),<span class="at">col=</span><span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>),<span class="at">lty=</span><span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">4</span>),  </span>
<span id="cb51-515"><a href="#cb51-515" aria-hidden="true" tabindex="-1"></a>       <span class="at">lwd=</span><span class="dv">3</span>,<span class="at">bty=</span><span class="st">"n"</span>)  </span>
<span id="cb51-516"><a href="#cb51-516" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-517"><a href="#cb51-517" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-518"><a href="#cb51-518" aria-hidden="true" tabindex="-1"></a>大样本量通常能提高模型拟合的质量。如果有足够的数据，当前数据所表现出的变异性可能会被充分降低，从而可以在这些站点之间找到统计学上的显著差异。然而，如果我们考虑站点 1 和站点 2 的 $Lm_{50}$ 差异约为 2 毫米（总共 110 毫米），从生物学角度来看，这种差异可能并不重要，因为两个站点之间的生长速率也可能不同。正如任何模型或统计分析一样，在关注统计显著性的同时，还应考虑生物学意义。</span>
<span id="cb51-519"><a href="#cb51-519" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-520"><a href="#cb51-520" aria-hidden="true" tabindex="-1"></a><span class="fu">### 对称性假设</span></span>
<span id="cb51-521"><a href="#cb51-521" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-522"><a href="#cb51-522" aria-hidden="true" tabindex="-1"></a>在很多情况下，标准逻辑曲线很好地描述了从未成熟到成熟（或者可能是其他生物过渡，如隐性到显性、 molt 阶段 A 到阶段 B 等）的过程。然而，经典逻辑曲线的主要限制是它在 $L_{50}$ 点对称，这可能不是对现实世界事件的最佳描述。</span>
<span id="cb51-523"><a href="#cb51-523" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-524"><a href="#cb51-524" aria-hidden="true" tabindex="-1"></a>已经提出了多种替代的非对称曲线，但幸运的是，Schnute 和 Richards（1990）提出了一种通用或统一模型，用于描述“鱼类生长、成熟和存活数据”，这种模型不仅推广了用于描述成熟度的经典逻辑斯谛模型，还推广了 Gompertz（1825）、von Bertalanffy（1938）、Richards（1959）、Chapman（1961）和 Schnute（1981）提出的生长模型，其中一些模型也可以用于描述成熟过程。</span>
<span id="cb51-525"><a href="#cb51-525" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-526"><a href="#cb51-526" aria-hidden="true" tabindex="-1"></a>Schnute 和 Richards (1990) 模型有四个参数：</span>
<span id="cb51-527"><a href="#cb51-527" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-528"><a href="#cb51-528" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-529"><a href="#cb51-529" aria-hidden="true" tabindex="-1"></a>y^{b} = 1+ \alpha \exp(-a x^c)</span>
<span id="cb51-530"><a href="#cb51-530" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_13}</span>
<span id="cb51-531"><a href="#cb51-531" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-532"><a href="#cb51-532" aria-hidden="true" tabindex="-1"></a>可以重新排列， @eq-5_14 ，以更好地展示其与经典的逻辑斯蒂曲线 <span class="co">[</span><span class="ot">@eq-5_12</span><span class="co">]</span> 的关系，如果我们将两者设置为 $b = c = 1.0$ ，则相当于经典的逻辑斯蒂曲线（例如，设置 $\alpha = 300$ 和 $a = 0.12$ ）。</span>
<span id="cb51-533"><a href="#cb51-533" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-534"><a href="#cb51-534" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-535"><a href="#cb51-535" aria-hidden="true" tabindex="-1"></a>y = \dfrac{1}{1+ \alpha \exp(-a x^c)^{1/b}}</span>
<span id="cb51-536"><a href="#cb51-536" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_14}</span>
<span id="cb51-537"><a href="#cb51-537" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-538"><a href="#cb51-538" aria-hidden="true" tabindex="-1"></a>如果使用其中一种特殊的经典情况，可能会有解析解来确定 $L_{50}$ 和 $IQ$，但通常情况下需要通过数值方法来找到它们（参见 **MQMF** 函数`bracket()`和 `linter()` ）。这条曲线可以用二项式误差来拟合成熟数据，就像之前那样，尽管可以使用 `nlm()` 或其他非线性求解器（Schnute 和 Richards, 1990 年提供了所需的似然函数）。但特殊情况可能为完整的四参数模型提供更稳定的解。从（5.14）式所示的可能曲线的不对称性，可以很容易地使用 **MQMF** <span class="in">`srug()`</span> 函数（Schnute 和 Richards 统一增长模型）来证明。在没有找到 $L_{50}$ 和 $IQ$ 的解析解时，我们可以使用两个函数 <span class="in">`bracket()`</span> 和 <span class="in">`linter()`</span>，它们界定了目标值（在这种情况下为 0.25、0.5 和 0.75），然后线性插值以生成所需的统计量的近似估计值（参见它们的帮助文件和示例）。</span>
<span id="cb51-539"><a href="#cb51-539" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-542"><a href="#cb51-542" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb51-543"><a href="#cb51-543" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-5-9</span></span>
<span id="cb51-544"><a href="#cb51-544" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "使用 Schnute 和 Richards 统一生长曲线的假设示例中达到成熟长度的比例。通过绿色虚线所示的四分位距左右两侧的差异，展示了该逻辑斯蒂曲线的不对称性。"</span></span>
<span id="cb51-545"><a href="#cb51-545" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-546"><a href="#cb51-546" aria-hidden="true" tabindex="-1"></a> <span class="co">#Asymmetrical maturity curve from Schnute and Richard's curve Fig5.9  </span></span>
<span id="cb51-547"><a href="#cb51-547" aria-hidden="true" tabindex="-1"></a>L <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">50</span>,<span class="dv">160</span>,<span class="dv">1</span>)  </span>
<span id="cb51-548"><a href="#cb51-548" aria-hidden="true" tabindex="-1"></a>p<span class="ot">=</span><span class="fu">c</span>(<span class="at">a=</span><span class="fl">0.07</span>,<span class="at">b=</span><span class="fl">0.2</span>,<span class="at">c=</span><span class="fl">1.0</span>,<span class="at">alpha=</span><span class="dv">100</span>)  </span>
<span id="cb51-549"><a href="#cb51-549" aria-hidden="true" tabindex="-1"></a>asym <span class="ot">&lt;-</span> <span class="fu">srug</span>(<span class="at">p=</span>p,<span class="at">sizeage=</span>L)  </span>
<span id="cb51-550"><a href="#cb51-550" aria-hidden="true" tabindex="-1"></a>L25 <span class="ot">&lt;-</span> <span class="fu">linter</span>(<span class="fu">bracket</span>(<span class="fl">0.25</span>,asym,L))   </span>
<span id="cb51-551"><a href="#cb51-551" aria-hidden="true" tabindex="-1"></a>L50 <span class="ot">&lt;-</span> <span class="fu">linter</span>(<span class="fu">bracket</span>(<span class="fl">0.5</span>,asym,L))   </span>
<span id="cb51-552"><a href="#cb51-552" aria-hidden="true" tabindex="-1"></a>L75 <span class="ot">&lt;-</span> <span class="fu">linter</span>(<span class="fu">bracket</span>(<span class="fl">0.75</span>,asym,L)) </span>
<span id="cb51-553"><a href="#cb51-553" aria-hidden="true" tabindex="-1"></a><span class="fu">parset</span>()</span>
<span id="cb51-554"><a href="#cb51-554" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(L,asym,<span class="at">type=</span><span class="st">"l"</span>,<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">xlab=</span><span class="st">"Length mm"</span>,<span class="at">ylab=</span><span class="st">"Proportion Mature"</span>)  </span>
<span id="cb51-555"><a href="#cb51-555" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">h=</span><span class="fu">c</span>(<span class="fl">0.25</span>,<span class="fl">0.5</span>,<span class="fl">0.75</span>),<span class="at">lty=</span><span class="dv">3</span>,<span class="at">col=</span><span class="st">"grey"</span>)  </span>
<span id="cb51-556"><a href="#cb51-556" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span><span class="fu">c</span>(L25,L50,L75),<span class="at">lwd=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>),<span class="at">col=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>))  </span>
<span id="cb51-557"><a href="#cb51-557" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-558"><a href="#cb51-558" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-559"><a href="#cb51-559" aria-hidden="true" tabindex="-1"></a>使用 @fig-5-9 中使用的参数作为基准，我们可以单独改变各个参数来确定其对结果曲线的影响。 $a$ 和 $c$ 参数相对影响四分位距，而所有四个参数都影响 $L_{50}$。</span>
<span id="cb51-560"><a href="#cb51-560" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-561"><a href="#cb51-561" aria-hidden="true" tabindex="-1"></a>Schnute（1981）的模型在文献中似乎比 Schnute 和 Richards（1990）的更通用的模型使用得更多，这在 Schnute 和 Richards 模型旨在展示所有这些不同曲线可以统一，并因此具有一定程度的共性时是自然的。这强调了这些曲线主要提供的是生物学过程的经验描述，而这些过程本身是所研究种群的涌现属性。严格地对这些参数进行生物学解释，并期望自然界总是提供合理的或有意义的参数值，这是过度推断。例如，Knight（1968）描述的情况，他讨论的是生长，但实际上是在讨论是否应该对经验模型参数进行明确解释。他指出：“更为重要的是，将 $L_{\infty}$ 视为自然事实，而不是数据分析的产物，会引发扭曲的观点。”（Knight, 1968, p 1306）。 描述性而非解释性的模型（关于过程的假设性描述）仍然是经验性描述，当尝试解释其参数时需要格外小心。</span>
<span id="cb51-562"><a href="#cb51-562" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-563"><a href="#cb51-563" aria-hidden="true" tabindex="-1"></a><span class="fu">## 补充量</span></span>
<span id="cb51-564"><a href="#cb51-564" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-565"><a href="#cb51-565" aria-hidden="true" tabindex="-1"></a><span class="fu">### 引言</span></span>
<span id="cb51-566"><a href="#cb51-566" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-567"><a href="#cb51-567" aria-hidden="true" tabindex="-1"></a>种群生物量生产的主要贡献者包括新个体对种群的补充和个体的生长（其中，种群的定义意味着我们无需考虑迁入）。再次强调，关于补充过程的文献非常丰富（Cushing，1988；Myers 和 Barrowman，1996；Myers，2001），但在这里我们将主要关注在尝试将其动态纳入模型时如何描述它。与其他生长和成熟静态模型一样，这些模型被认为随时间保持不变，尽管在种群评估模型中存在时间分段选项，可以在特定界定的时间段内使用不同的参数集（Wayte，2013）。本节中我们将重点关注简单的描述。</span>
<span id="cb51-568"><a href="#cb51-568" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-569"><a href="#cb51-569" aria-hidden="true" tabindex="-1"></a>鱼类种群的补充量自然倾向于高度变异，不同物种的变异程度有所不同。如果你觉得我在一句话中频繁使用"变异"及相关术语，或许这会强化补充量确实高度变异的观点。渔业科学家面临的主要问题是补充量是由繁殖群体资源量、环境变异或两者的某种组合决定的。这让人回想起 20 世纪 50 年代种群动态学中的争论，即种群是否受密度依赖或密度独立效应的控制（Andrewartha and Birch, 1954）。这个变异问题导致了一种普遍但错误的信念，即在一个观察到的群体规模范围内，渔业的补充量实际上与成鱼群体规模无关。这可能是一个危险的假设（Gulland, 1983）。补充量与繁殖群体资源量之间没有关系的观点认为，科学家和管理者可以忽视群体补充量关系，除非有明确证据表明补充量与群体资源量无关。 种群补充量无关系的观点源于通常情况下关于这种关系的数据显得非常分散，没有明显的特征。</span>
<span id="cb51-570"><a href="#cb51-570" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-571"><a href="#cb51-571" aria-hidden="true" tabindex="-1"></a>尽管存在争议，但在渔业模型中，对 补充过程的建模仍然具有重要意义。因为用这些模型提供从当前时间点出发的管理建议时，通常会在评估不同捕捞或努力量水平的影响时，将模型动态向前预测。通过在这些预测中包含不确定性，可以估计不同管理方案未能实现预期管理目标的相对风险（Francis，1992）。但要进行此类预测，需要了解鱼群的生产力。假设已包含了个体生长动态，那么对补充量水平的时间序列估计或某种定义的鱼群补充量关系可以用来为这些预测生成未来补充量水平的估计。</span>
<span id="cb51-572"><a href="#cb51-572" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-573"><a href="#cb51-573" aria-hidden="true" tabindex="-1"></a>在本章中，我们将仅考虑鱼类种群补充量关系的数学描述，并且大多忽略这些关系背后的生物学因素，尽管总会有例外。我们将回顾两种最常用的鱼类种群补充量数学模型，并讨论它们在复杂程度不同的种群评估模型中的应用。</span>
<span id="cb51-574"><a href="#cb51-574" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-575"><a href="#cb51-575" aria-hidden="true" tabindex="-1"></a><span class="fu">### “良好”种群补充量关系的性质</span></span>
<span id="cb51-576"><a href="#cb51-576" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-577"><a href="#cb51-577" aria-hidden="true" tabindex="-1"></a>Cushing（1988）为种群补充关系的生物学过程提供了很好的介绍，他概述了卵和幼鱼死亡的原因，并提供了丰富的实例和该主题的参考文献。与其他讨论的基本生产过程一样，关于种群补充量关系的生物学及其调节因素的文献非常丰富。</span>
<span id="cb51-578"><a href="#cb51-578" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-579"><a href="#cb51-579" aria-hidden="true" tabindex="-1"></a>已有研究已证实多种生物学和物理因素对补充量结果有影响。我们不会考虑任何真实物种的生物学细节，除非指出种群资源量与补充量之间的关系并非决定性，且可能存在多种反馈形式影响结果。已提出多种描述种群补充量关系的数学模型，但我们仅考虑 Beverton 和 Holt 以及 Ricker 的模型，而 Deriso-Schnute（Deriso, 1980; Schnute, 1985）等模型也同样重要。</span>
<span id="cb51-580"><a href="#cb51-580" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-581"><a href="#cb51-581" aria-hidden="true" tabindex="-1"></a>Ricker (1975) 列出了他认为理想的平均种群补充关系的四个特性：</span>
<span id="cb51-582"><a href="#cb51-582" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-583"><a href="#cb51-583" aria-hidden="true" tabindex="-1"></a><span class="ss">-   </span>种群补充曲线应通过原点；也就是说，当种群数量为零时，补充量应为零。这假设所考虑的观测值与总种群相关，并且不存在由移民组成的“补充”。</span>
<span id="cb51-584"><a href="#cb51-584" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-585"><a href="#cb51-585" aria-hidden="true" tabindex="-1"></a><span class="ss">-   </span>补充量不应在高种群密度时降至零。这不是一个必要条件，尽管观察到补充量随种群密度增加而下降，但并未观察到补充量降至零的情况。即使种群在最大生物量时达到平衡，补充量仍应与自然死亡率相匹配。</span>
<span id="cb51-586"><a href="#cb51-586" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-587"><a href="#cb51-587" aria-hidden="true" tabindex="-1"></a><span class="ss">-   </span>补充量率（单位繁殖群体补充量）应随着亲本群体的增加而持续减少。只有当正密度依赖机制（补偿性机制）在起作用时（例如，群体增加导致幼体死亡率增加），这种情况才是合理的。但如果负密度依赖机制（消耗性机制）在起作用（例如，捕食者饱和和 Allee 效应；Begon and Mortimer, 1986），那么这并不总是成立。</span>
<span id="cb51-588"><a href="#cb51-588" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-589"><a href="#cb51-589" aria-hidden="true" tabindex="-1"></a><span class="ss">-   </span>补充量必须超过亲代种群在亲代种群可能范围的部分。严格来说，这仅适用于在死亡前只繁殖一次的物种（例如鲑鱼）。对于寿命更长、多次繁殖的物种，应解释为补充量必须足够高，以超过因年度自然死亡率造成的损失。</span>
<span id="cb51-590"><a href="#cb51-590" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-591"><a href="#cb51-591" aria-hidden="true" tabindex="-1"></a>Hilborn 和 Walters（1992）提出了另外两种他们认为与良好种群补充关系相关的普遍特性：</span>
<span id="cb51-592"><a href="#cb51-592" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-593"><a href="#cb51-593" aria-hidden="true" tabindex="-1"></a><span class="ss">-   </span>平均繁殖群体补充量曲线应该是连续的，在群体规模的小幅变化中不应有剧烈变化。他们指的是连续性，即平均补充量应该随着群体规模平滑变化，与上述条件 3 相关。</span>
<span id="cb51-594"><a href="#cb51-594" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-595"><a href="#cb51-595" aria-hidden="true" tabindex="-1"></a><span class="ss">-   </span>平均种群补充关系的稳定性是随时间不变的。这就是平稳性，即这种关系不会随时间发生显著变化。这一假设在生态系统发生显著变化（其中被开发种群是其中一部分）的系统中可能不成立。但在模型中，可以通过使用参数时间块来处理这种情况（例如，参见 Wayte，2013 年）。</span>
<span id="cb51-596"><a href="#cb51-596" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-597"><a href="#cb51-597" aria-hidden="true" tabindex="-1"></a><span class="fu">### 补充型过度捕捞</span></span>
<span id="cb51-598"><a href="#cb51-598" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-599"><a href="#cb51-599" aria-hidden="true" tabindex="-1"></a>“过度捕捞（overfishing）”这一术语通常在两种情境下进行讨论，即生长型过度捕捞（growth overfishing）和补充型过度捕捞（recruitment overfishing）。生长型过度捕捞是指捕捞强度过大，导致最终大多数个体在相对较小时就被捕捞。这在“单位补充量渔获量”（YPR）方面是一个问题。YPR 的分析着重于平衡因总死亡率导致的种群损失与因个体生长带来的种群增长，旨在确定开始捕捞该物种的最佳个体大小和年龄（这里的“最佳”可以有多种含义）。生长型过度捕捞是指鱼群在没有时间达到这种最佳个体大小之前就被捕获。</span>
<span id="cb51-600"><a href="#cb51-600" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-601"><a href="#cb51-601" aria-hidden="true" tabindex="-1"></a>补充型过度捕捞发生时，意味着对鱼群捕捞过度，使得繁殖群体规模降低到其作为一个种群无法产生足够的新补充量来替代那些死亡（无论是自然死亡还是其他原因）的个体水平。显然，这种情况不可能持续太久，不幸的是，过度捕捞通常会导致渔业崩溃。虽然需要记住，渔业崩溃通常意味着渔业不再具有经济可行性，但这并不意味着字面意义上的灭绝。</span>
<span id="cb51-602"><a href="#cb51-602" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-603"><a href="#cb51-603" aria-hidden="true" tabindex="-1"></a>虽然生长型过度捕捞相对容易检测（如果种群处于 YPR 最佳状态？尽管当然，可能会有复杂情况）。不幸的是，对于补充型过度捕捞的检测来说，情况并非如此，这可能需要确定成熟或产卵种群资源量与补充水平之间的关系。这已被证明是许多渔业面临的艰巨任务。相反，随着正式捕捞策略的出现，人们普遍的做法是确定一个被认为对后续补充构成不可接受风险的繁殖生物量水平。一个非常常见的极限参考点是未受干扰繁殖生物量的 20%（ $0.2B_0$）。关于极限参考点耗竭水平 $20 \% B_0$ 的最早参考似乎来自 Beddington &amp; Cooke (1983)。他们以如下方式解释了他们对不同种群潜在产量分析所施加的限制：</span>
<span id="cb51-604"><a href="#cb51-604" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-605"><a href="#cb51-605" aria-hidden="true" tabindex="-1"></a>“…使用预期未开发产卵生物量 20%的逃逸水平。这个数字并非保守估计，但它代表了一个较低的限制，即在此水平下可能观察到补充量的下降。”（Beddington &amp; Cooke, 1983, 第 9-10 页）。</span>
<span id="cb51-606"><a href="#cb51-606" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-607"><a href="#cb51-607" aria-hidden="true" tabindex="-1"></a>导致产生 $B_{20\%}$（注意 $0.2B_0$ 的不同表示方式）作为潜在过度捕捞指标的一个合理捕捞强度的观念的最具影响力的文件，是一份为美国国家海洋渔业服务局准备的文件（Restrepo 等，1998）。事实上，他们推荐 $0.5B_{MSY}$，但认为 $B20\%$ 是该数值的一个可接受的替代值。然而，需要注意的是，这只是一个“经验法则”，没有实证基础将替代值 $B_{LIM} =B_{20\%}$ 或 $0.5B_{MSY}$ 联系起来。实际上，对于某些物种选择 $0.5B_{MSY}$ 可能导致 $B_{LIM}$ 远低于 $B_{20\%}$。</span>
<span id="cb51-608"><a href="#cb51-608" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-609"><a href="#cb51-609" aria-hidden="true" tabindex="-1"></a><span class="fu">### Beverton-Holt 补充量</span></span>
<span id="cb51-610"><a href="#cb51-610" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-611"><a href="#cb51-611" aria-hidden="true" tabindex="-1"></a>历史上，Beverton 和 Holt（1957）的种群补充曲线因其简单的解释而有用，也就意味着可以从基本原理推导出这种关系。对他们来说，数学上易于处理也很重要，因为当时只有解析方法可行。事实上，它持续使用似乎很大程度上源于惯性和传统。请注意，如果我们仅仅将 Beverton-Holt 曲线视为一种数学描述，那么实际上任何具有前面列出的良好性质的曲线都可以使用。然而，人们谈论“Beverton-Holt 种群补充模型”，但它有多种形式。有两种常见的使用形式：</span>
<span id="cb51-612"><a href="#cb51-612" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-613"><a href="#cb51-613" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-614"><a href="#cb51-614" aria-hidden="true" tabindex="-1"></a>R_y = \dfrac{B_{y-1}}{\alpha + \beta B_{y-1}} \exp \left(N(0, \sigma_R^2) \right)</span>
<span id="cb51-615"><a href="#cb51-615" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_15}</span>
<span id="cb51-616"><a href="#cb51-616" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-617"><a href="#cb51-617" aria-hidden="true" tabindex="-1"></a>其中 $R_y$ 代表第 $y$ 年的补充量， $B_y$ 代表第 $y$ 年的繁殖生物量， $\alpha$ 和 $\beta$ 是两个 Beverton-Holt 参数， $\exp(N(0, \sigma^2_R))$ 表示预测模型值与自然观测值之间的关系呈对数正态分布（常表示为 $e^{\varepsilon}$）。 $\beta$ 值决定渐近极限（ $=1/\beta$ ），而 $\alpha$ 的不同值与每条曲线达到渐近线的速度成反比，从而决定原点附近的相对陡峭程度（一个关键词，我们将会更多地讨论它）（ $\alpha$ 的值越小， 补充量达到最大值的速度越快）。当然，这是一种平均关系，曲线周围的散布与曲线本身同样重要。一个常见的替代重新参数化公式是：</span>
<span id="cb51-618"><a href="#cb51-618" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-619"><a href="#cb51-619" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-620"><a href="#cb51-620" aria-hidden="true" tabindex="-1"></a>R_y = \dfrac{a B_{y-1}}{b +B_{y-1}} e^{\varepsilon}</span>
<span id="cb51-621"><a href="#cb51-621" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_16}</span>
<span id="cb51-622"><a href="#cb51-622" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-623"><a href="#cb51-623" aria-hidden="true" tabindex="-1"></a>其中 $a$ 代表最大最大补充 量（即 $a = 1/\beta$），而 $b$ 代表为产生平均最大补充量一半（即 $a/2$ ）所需的产卵群体（即 $b = \alpha/\beta$ ）。使用 $y-1$ 年的生物量代表产生第 $y$ 年补充量，这会影响产卵时间。如果产卵发生在十二月，而仔稚鱼沉底发生在次年，那么这样是正确的；如果两者发生在同一年，那么显然需要更改下标。需要注意的是，生物学现实，在这种情况下与时间相关，甚至可能渗入非常简单的模型中。数学模型可以提供对自然的绝佳表征，但需要了解所建模动物的生物学特性，以避免简单的错误！</span>
<span id="cb51-624"><a href="#cb51-624" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-625"><a href="#cb51-625" aria-hidden="true" tabindex="-1"></a>从 @fig-5-11 中可以看出，Beverton–Holt 曲线的初始陡峭程度以及渐近值捕捉了该方程行为的重要方面。渐近线由参数 $a$ 的值给出，而初始陡峭程度则由( $a/b = 1/\alpha$ )的值近似表示，这发生在 $B_y$ 相对较小时。</span>
<span id="cb51-626"><a href="#cb51-626" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-629"><a href="#cb51-629" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb51-630"><a href="#cb51-630" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-5-11</span></span>
<span id="cb51-631"><a href="#cb51-631" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "有恒定 a = 1000 和五个递减的 b 值的Beverton-Holt 种群补充曲线，导致越来越高效的曲线。"</span></span>
<span id="cb51-632"><a href="#cb51-632" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-633"><a href="#cb51-633" aria-hidden="true" tabindex="-1"></a> <span class="co">#plot the MQMF bh function for Beverton-Holt recruitment  Fig 5.11  </span></span>
<span id="cb51-634"><a href="#cb51-634" aria-hidden="true" tabindex="-1"></a>B <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">3000</span>  </span>
<span id="cb51-635"><a href="#cb51-635" aria-hidden="true" tabindex="-1"></a>bhb <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">1000</span>,<span class="dv">500</span>,<span class="dv">250</span>,<span class="dv">150</span>,<span class="dv">50</span>)  </span>
<span id="cb51-636"><a href="#cb51-636" aria-hidden="true" tabindex="-1"></a><span class="fu">parset</span>()</span>
<span id="cb51-637"><a href="#cb51-637" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(B,<span class="fu">bh</span>(<span class="fu">c</span>(<span class="dv">1000</span>,bhb[<span class="dv">1</span>]),B),<span class="at">type=</span><span class="st">"l"</span>,<span class="at">ylim=</span><span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1050</span>),</span>
<span id="cb51-638"><a href="#cb51-638" aria-hidden="true" tabindex="-1"></a>      <span class="at">xlab=</span><span class="st">"Spawning Biomass"</span>,<span class="at">ylab=</span><span class="st">"Recruitment"</span>)  </span>
<span id="cb51-639"><a href="#cb51-639" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="sc">:</span><span class="dv">5</span>) <span class="fu">lines</span>(B,<span class="fu">bh</span>(<span class="fu">c</span>(<span class="dv">1000</span>,bhb[i]),B),<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span>i,<span class="at">lty=</span>i)  </span>
<span id="cb51-640"><a href="#cb51-640" aria-hidden="true" tabindex="-1"></a><span class="fu">legend</span>(<span class="st">"bottomright"</span>,<span class="at">legend=</span>bhb,<span class="at">col=</span><span class="fu">c</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>),<span class="at">lwd=</span><span class="dv">3</span>,<span class="at">bty=</span><span class="st">"n"</span>,<span class="at">lty=</span><span class="fu">c</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>))  </span>
<span id="cb51-641"><a href="#cb51-641" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">h=</span><span class="fu">c</span>(<span class="dv">500</span>,<span class="dv">1000</span>),<span class="at">col=</span><span class="dv">1</span>,<span class="at">lty=</span><span class="dv">2</span>)  </span>
<span id="cb51-642"><a href="#cb51-642" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-643"><a href="#cb51-643" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-644"><a href="#cb51-644" aria-hidden="true" tabindex="-1"></a><span class="fu">### Ricker 补充量</span></span>
<span id="cb51-645"><a href="#cb51-645" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-646"><a href="#cb51-646" aria-hidden="true" tabindex="-1"></a>由 Ricker（1954，1958）提出了 Beverton-Holt 曲线的替代方案，但这同样有多种参数化方式：</span>
<span id="cb51-647"><a href="#cb51-647" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-648"><a href="#cb51-648" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-649"><a href="#cb51-649" aria-hidden="true" tabindex="-1"></a>R_y = a S_ye^{-bS_y}e^{\varepsilon}</span>
<span id="cb51-650"><a href="#cb51-650" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_17}</span>
<span id="cb51-651"><a href="#cb51-651" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-652"><a href="#cb51-652" aria-hidden="true" tabindex="-1"></a>其中 $R_y$ 代表 $y$ 年产卵群体 $S_y$ 产生的补充量， $a$ 代表低种群水平时的单位繁殖资源量-补充量， $b$ 与单位繁殖补充量随 $S$ 增加而减少的速率相关。 $e^{\varepsilon}$ 表示关系与观测数据之间的对数正态残差误差。请注意，参数 $a$ 和 $b$ 与 Beverton–Holt 方程中的参数非常不同。该种群-补充量曲线不会达到渐近线，而是在高种群水平时表现出补充量水平的下降 <span class="co">[</span><span class="ot">@fig-5-12</span><span class="co">]</span> 。</span>
<span id="cb51-653"><a href="#cb51-653" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-656"><a href="#cb51-656" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb51-657"><a href="#cb51-657" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-5-12</span></span>
<span id="cb51-658"><a href="#cb51-658" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "两条具有相同常数 $a=10$ 但具有不同 $b$ 值的 Ricker 种群补充量曲线。请注意， $b$ 值主要影响补充量随生物量增加而下降的水平，对初始陡峭程度影响较小。"</span></span>
<span id="cb51-659"><a href="#cb51-659" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-660"><a href="#cb51-660" aria-hidden="true" tabindex="-1"></a> <span class="co">#plot the MQMF ricker function for Ricker recruitment  Fig 5.12  </span></span>
<span id="cb51-661"><a href="#cb51-661" aria-hidden="true" tabindex="-1"></a>B <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">20000</span>  </span>
<span id="cb51-662"><a href="#cb51-662" aria-hidden="true" tabindex="-1"></a>rickb <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.0002</span>,<span class="fl">0.0003</span>,<span class="fl">0.0004</span>) </span>
<span id="cb51-663"><a href="#cb51-663" aria-hidden="true" tabindex="-1"></a><span class="fu">parset</span>()</span>
<span id="cb51-664"><a href="#cb51-664" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(B,<span class="fu">ricker</span>(<span class="fu">c</span>(<span class="dv">10</span>,rickb[<span class="dv">1</span>]),B),<span class="at">type=</span><span class="st">"l"</span>,<span class="at">xlab=</span><span class="st">"Spawning Biomass"</span>,  </span>
<span id="cb51-665"><a href="#cb51-665" aria-hidden="true" tabindex="-1"></a>               <span class="at">ylab=</span><span class="st">"Recruitment"</span>)  </span>
<span id="cb51-666"><a href="#cb51-666" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="sc">:</span><span class="dv">3</span>)   </span>
<span id="cb51-667"><a href="#cb51-667" aria-hidden="true" tabindex="-1"></a>   <span class="fu">lines</span>(B,<span class="fu">ricker</span>(<span class="fu">c</span>(<span class="dv">10</span>,rickb[i]),B),<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span>i,<span class="at">lty=</span>i)  </span>
<span id="cb51-668"><a href="#cb51-668" aria-hidden="true" tabindex="-1"></a><span class="fu">legend</span>(<span class="st">"topright"</span>,<span class="at">legend=</span>rickb,<span class="at">col=</span><span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>,<span class="at">lty=</span><span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>,<span class="at">bty=</span><span class="st">"n"</span>,<span class="at">lwd=</span><span class="dv">2</span>)  </span>
<span id="cb51-669"><a href="#cb51-669" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-670"><a href="#cb51-670" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-671"><a href="#cb51-671" aria-hidden="true" tabindex="-1"></a>补充量随着繁殖生物量增加而下降背后的理念是，这与某些群体对其他群体的竞争或捕食效应（同类相食）有关。已经提出了各种机制，包括成鱼捕食幼鱼、疾病在密度依赖性传播、繁殖成鱼对彼此产卵场的损害（主要发生在像鲑鱼这样的鱼类生活的河流中），以及最终密度依赖性生长与大小依赖性捕食相结合。这些机制中的每一种都可以导致对 Ricker 曲线参数的不同解释。</span>
<span id="cb51-672"><a href="#cb51-672" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-673"><a href="#cb51-673" aria-hidden="true" tabindex="-1"></a>再次，方程是否应该被解释为对可观察世界的说明，而不仅仅是平均补充量的便利经验描述，这一点变得重要。此外，尽管参数当然可以被赋予现实世界的解释，但方程仍然倾向于过于简单，最好被视为对事件的说明，而不是经验描述（Punt and Cope, 2019）。</span>
<span id="cb51-674"><a href="#cb51-674" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-675"><a href="#cb51-675" aria-hidden="true" tabindex="-1"></a><span class="fu">### Deriso 的通用模型</span></span>
<span id="cb51-676"><a href="#cb51-676" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-677"><a href="#cb51-677" aria-hidden="true" tabindex="-1"></a>Deriso (1980) 提出了一个通用方程，其中 Beverton–Holt 和 Ricker 种群补充曲线是它的特例。Schnute (1985) 重新构建了 Deriso 的方程，产生了一个更加灵活的版本，具有更高的灵活性：</span>
<span id="cb51-678"><a href="#cb51-678" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-679"><a href="#cb51-679" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-680"><a href="#cb51-680" aria-hidden="true" tabindex="-1"></a>R_y = \alpha S_y(1-\beta \gamma S_y)^{1/\gamma}</span>
<span id="cb51-681"><a href="#cb51-681" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_18}</span>
<span id="cb51-682"><a href="#cb51-682" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-683"><a href="#cb51-683" aria-hidden="true" tabindex="-1"></a>在这个 Schnute (1985) 通用情况下有三个参数 $\alpha$ 、 $\beta$ 和 $\gamma$，前两个参数应始终为正，但 $\gamma$ 可以为正或负。通过修改 $\gamma$ 值，会出现不同的特例 <span class="co">[</span><span class="ot">@fig-5-13</span><span class="co">]</span> ：</span>
<span id="cb51-684"><a href="#cb51-684" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-685"><a href="#cb51-685" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-686"><a href="#cb51-686" aria-hidden="true" tabindex="-1"></a>\begin{split}</span>
<span id="cb51-687"><a href="#cb51-687" aria-hidden="true" tabindex="-1"></a>\gamma = -\infty \quad &amp;R_y =\alpha B_y <span class="sc">\\</span></span>
<span id="cb51-688"><a href="#cb51-688" aria-hidden="true" tabindex="-1"></a>\gamma = -1 \quad &amp;R_y = \alpha B_y/(1+\beta B_y) <span class="sc">\\</span></span>
<span id="cb51-689"><a href="#cb51-689" aria-hidden="true" tabindex="-1"></a>\gamma \to 0 \quad &amp;R_y = \alpha B_y e^{-\beta B_y} <span class="sc">\\</span></span>
<span id="cb51-690"><a href="#cb51-690" aria-hidden="true" tabindex="-1"></a>\gamma = 1 \quad &amp;R_y = \alpha B_y (1-\beta B_y)</span>
<span id="cb51-691"><a href="#cb51-691" aria-hidden="true" tabindex="-1"></a>\end{split}</span>
<span id="cb51-692"><a href="#cb51-692" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_19}</span>
<span id="cb51-693"><a href="#cb51-693" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-694"><a href="#cb51-694" aria-hidden="true" tabindex="-1"></a>第三个情况中的箭头表示“趋近”，例如 $\gamma$ 趋近于零。第一个情况是密度无关的补充率常数，也可以通过设置 $\beta= 0$ 得到。接下来的三种情况分别对应于 Beverton–Holt (1957)、Ricker (1954, 1958) 和 Schaefer (1954) 的标准种群-补充量关系，这是一种逻辑斯蒂曲线的形式。当然，在每种情况下都需要小心选择 $\alpha$ 和 $\beta$ 的适当值。</span>
<span id="cb51-695"><a href="#cb51-695" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-696"><a href="#cb51-696" aria-hidden="true" tabindex="-1"></a>Deriso–Schnute 模型存在一些数学上不稳定的特性，如果我们设 $\gamma = 0$ ，这一点应该很清楚。这会导致数学上的奇点（除以零）。参数限制应该始终为 $\gamma \to 0$ ，无论是从负方向还是正方向。使用这个方程，有许多参数组合会产生不合理的种群补充关系。这个方程的主要价值在于展示不同曲线之间的关系，虽然人们不会在拟合模型中使用 Deriso-Schnute 模型，但它可能在模拟模型中很有用。</span>
<span id="cb51-697"><a href="#cb51-697" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-700"><a href="#cb51-700" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb51-701"><a href="#cb51-701" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-5-13</span></span>
<span id="cb51-702"><a href="#cb51-702" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap:  |</span></span>
<span id="cb51-703"><a href="#cb51-703" aria-hidden="true" tabindex="-1"></a><span class="co">#|  Beverton-Holt (BH)、Ricker 和 Deriso-Schnute (DS) 种群-补充量曲线的比较，</span></span>
<span id="cb51-704"><a href="#cb51-704" aria-hidden="true" tabindex="-1"></a><span class="co">#|  这些曲线在 Deriso-Schnute 通用方程 Equ (5.19) 中实现。</span></span>
<span id="cb51-705"><a href="#cb51-705" aria-hidden="true" tabindex="-1"></a><span class="co">#|  对于 DS 曲线， $\gamma = 0.5$ 导致不切实际的结果（奇线）。</span></span>
<span id="cb51-706"><a href="#cb51-706" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-707"><a href="#cb51-707" aria-hidden="true" tabindex="-1"></a> <span class="co"># plot of three special cases from Deriso-Schnute curve  Fig. 5.13  </span></span>
<span id="cb51-708"><a href="#cb51-708" aria-hidden="true" tabindex="-1"></a>deriso <span class="ot">&lt;-</span> <span class="cf">function</span>(p,B) <span class="fu">return</span>(p[<span class="dv">1</span>] <span class="sc">*</span> B <span class="sc">*</span>(<span class="dv">1</span> <span class="sc">-</span> p[<span class="dv">2</span>]<span class="sc">*</span>p[<span class="dv">3</span>]<span class="sc">*</span>B)<span class="sc">^</span>(<span class="dv">1</span><span class="sc">/</span>p[<span class="dv">3</span>]))  </span>
<span id="cb51-709"><a href="#cb51-709" aria-hidden="true" tabindex="-1"></a>B <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">10000</span>  </span>
<span id="cb51-710"><a href="#cb51-710" aria-hidden="true" tabindex="-1"></a><span class="fu">plot1</span>(B,<span class="fu">deriso</span>(<span class="fu">c</span>(<span class="dv">10</span>,<span class="fl">0.001</span>,<span class="sc">-</span><span class="dv">1</span>),B),<span class="at">lwd=</span><span class="dv">2</span>,  </span>
<span id="cb51-711"><a href="#cb51-711" aria-hidden="true" tabindex="-1"></a>      <span class="at">xlab=</span><span class="st">"Spawning Biomass"</span>,<span class="at">ylab=</span><span class="st">"Recruitment"</span>)       <span class="co"># BH  </span></span>
<span id="cb51-712"><a href="#cb51-712" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(B,<span class="fu">deriso</span>(<span class="fu">c</span>(<span class="dv">10</span>,<span class="fl">0.0004</span>,<span class="fl">0.25</span>),B),<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">2</span>,<span class="at">lty=</span><span class="dv">2</span>)  <span class="co"># DS  </span></span>
<span id="cb51-713"><a href="#cb51-713" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(B,<span class="fu">deriso</span>(<span class="fu">c</span>(<span class="dv">10</span>,<span class="fl">0.0004</span>,<span class="fl">1e-06</span>),B),<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">3</span>,<span class="at">lty=</span><span class="dv">3</span>) <span class="co"># Ricker  </span></span>
<span id="cb51-714"><a href="#cb51-714" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(B,<span class="fu">deriso</span>(<span class="fu">c</span>(<span class="dv">10</span>,<span class="fl">0.0004</span>,<span class="fl">0.5</span>),B),<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">1</span>,<span class="at">lty=</span><span class="dv">3</span>)   <span class="co"># odd line  </span></span>
<span id="cb51-715"><a href="#cb51-715" aria-hidden="true" tabindex="-1"></a><span class="fu">legend</span>(<span class="at">x=</span><span class="dv">7000</span>,<span class="at">y=</span><span class="dv">8500</span>,<span class="at">legend=</span><span class="fu">c</span>(<span class="st">"BH"</span>,<span class="st">"DS"</span>,<span class="st">"Ricker"</span>,<span class="st">"odd line"</span>),  </span>
<span id="cb51-716"><a href="#cb51-716" aria-hidden="true" tabindex="-1"></a>       <span class="at">col=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>),<span class="at">lty=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">3</span>),<span class="at">bty=</span><span class="st">"n"</span>,<span class="at">lwd=</span><span class="dv">3</span>)  </span>
<span id="cb51-717"><a href="#cb51-717" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-718"><a href="#cb51-718" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-719"><a href="#cb51-719" aria-hidden="true" tabindex="-1"></a><span class="fu">### 重新参数化的 Beverton-Holt 方程</span></span>
<span id="cb51-720"><a href="#cb51-720" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-721"><a href="#cb51-721" aria-hidden="true" tabindex="-1"></a>在《模型参数估计》( @sec-paraestimat) 章中，对 tigers 数据集中的虎虾 Beverton-Holt 种群-补充量曲线的参数进行了估计。相对丰度的估计可以等同于短命对虾种类的补充量水平，但对于使用年龄结构模型的寿命更长的物种，估计此类参数将相对抽象。Francis（1992）对更复杂的种群评估模型做出了重要发展，他重新参数化了 Beverton-Holt 种群-补充量关系，以曲线的初始陡峭程度 $h$ 和初始补充量 $R_0$ 来表示，其中 $R_0$ 是从未捕捞或原始繁殖生物量 $B_0$ 推导出来的。他首先将这些想法应用于胸棘鲷（*Haplostethus atlanticus*）的年龄结构剩余生产模型，该模型具有捕捞数据、来自调查的相对丰度指数以及与年龄相关生长和重量的生物学数据。使用这些数据，他能够以更合理的方式拟合模型，并利用他对补充量的更有意义的参数化方法。</span>
<span id="cb51-722"><a href="#cb51-722" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-723"><a href="#cb51-723" aria-hidden="true" tabindex="-1"></a>Francis（1992）将陡峭程度，记作 $h$，定义为当成熟生物量减少到未捕捞水平的 20%时，种群产生的确定性补充量。他开始描述时使用了：</span>
<span id="cb51-724"><a href="#cb51-724" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-725"><a href="#cb51-725" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-726"><a href="#cb51-726" aria-hidden="true" tabindex="-1"></a>R_0 = \dfrac{A_0}{\alpha + \beta A_0}</span>
<span id="cb51-727"><a href="#cb51-727" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_20}</span>
<span id="cb51-728"><a href="#cb51-728" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-729"><a href="#cb51-729" aria-hidden="true" tabindex="-1"></a>因此，通过定义陡峭度， $h = 0.2 B_0$，我们得到：</span>
<span id="cb51-730"><a href="#cb51-730" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-731"><a href="#cb51-731" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-732"><a href="#cb51-732" aria-hidden="true" tabindex="-1"></a>h R_0 =\dfrac{0.2 A_0}{\alpha + \beta 0.2 A_0}</span>
<span id="cb51-733"><a href="#cb51-733" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_21}</span>
<span id="cb51-734"><a href="#cb51-734" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-735"><a href="#cb51-735" aria-hidden="true" tabindex="-1"></a>其中 $\alpha$ 和 $\beta$ 是 Beverton-Holt 参数， $A_0$ 是未受捕捞种群中稳定年龄分布的单位补充量总繁殖生物量。”单位补充“ 部分对年龄结构模型很重要，因为它允许我们独立于 Beverton-Holt 方程 <span class="co">[</span><span class="ot">@eq-5_15</span><span class="co">]</span> 来确定 $R_0$ 和 $B_0$ 之间的关系。稳定的年龄分布是由恒定的补充量水平 $R_0$ 在恒定的自然死亡率（ $M$ ）产生的 ，导致年龄组数量呈现标准指数下降。如果自然死亡率较低，则可能需要增加一个年龄组。这个稳定年龄分布可以定义为：</span>
<span id="cb51-736"><a href="#cb51-736" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-737"><a href="#cb51-737" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-738"><a href="#cb51-738" aria-hidden="true" tabindex="-1"></a>\begin{split}</span>
<span id="cb51-739"><a href="#cb51-739" aria-hidden="true" tabindex="-1"></a>n_{0,a} = \left <span class="sc">\{</span> \begin{matrix}</span>
<span id="cb51-740"><a href="#cb51-740" aria-hidden="true" tabindex="-1"></a>R_0 e^{-Ma} \quad  &amp; a &lt; t_{max} <span class="sc">\\</span></span>
<span id="cb51-741"><a href="#cb51-741" aria-hidden="true" tabindex="-1"></a>R_0 e^{-Mt_{max}}/(1-e^{-M})  \quad &amp;a = t_{max}  \end{matrix} \right.</span>
<span id="cb51-742"><a href="#cb51-742" aria-hidden="true" tabindex="-1"></a>\end{split}</span>
<span id="cb51-743"><a href="#cb51-743" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_22}</span>
<span id="cb51-744"><a href="#cb51-744" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-745"><a href="#cb51-745" aria-hidden="true" tabindex="-1"></a>其中 $n_{0,a}$ 表示年龄 $a$ 的单位补充量未被捕捞的数量，而 $t_{max}$ 表示模型中模拟的最大年龄。 $t_{max}$ 作为一组附加年龄组，因此需要除以 $(1-e^{-M})$ 以提供指数序列的和。生物量 $A_0$ 将是具有恒定补充水平为 1 时产生的种群生物量。因此，对于生物量 $A_0$，在稳定的年龄分布下，产生的补充水平将是 $R_0 = 1$（反之亦然）。</span>
<span id="cb51-746"><a href="#cb51-746" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-747"><a href="#cb51-747" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-748"><a href="#cb51-748" aria-hidden="true" tabindex="-1"></a>A_0 = \left(\sum_m n_{0,a} w_a \right)</span>
<span id="cb51-749"><a href="#cb51-749" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_23}</span>
<span id="cb51-750"><a href="#cb51-750" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-751"><a href="#cb51-751" aria-hidden="true" tabindex="-1"></a>其中 $m$ 表示成熟年龄， $n_{0,a}$ 表示年龄 $a$ 的单位补充量未被捕捞的数量， $a$ 表示年龄， $w_a$ 表示年龄 $a$ 的单位鱼体重量。人们还可以将部分自然死亡率纳入此方程，使其在一年中的某个时间点与补充量相等。 $A_0$ 作为缩放因子，因为在任何恒定的补充量水平下，未受干扰的种群都会出现稳定的年龄分布。 $A_0$ 的幅度将根据估计的初始生物量 $B_0$ 进行缩放，但其值相对于维持稳定年龄分布所需的恒定补充量 $R_0$ 将保持不变。在实践中，人们会根据生物学信息推导出 $A_0$，并在种群评估模型中估计 $R_0$。</span>
<span id="cb51-752"><a href="#cb51-752" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-753"><a href="#cb51-753" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-754"><a href="#cb51-754" aria-hidden="true" tabindex="-1"></a>B_0 = R_0 \left(\sum_m n_{0,a} w_a \right) = (R_0 A_0)</span>
<span id="cb51-755"><a href="#cb51-755" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_24}</span>
<span id="cb51-756"><a href="#cb51-756" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-757"><a href="#cb51-757" aria-hidden="true" tabindex="-1"></a>Francis（1992）随后也使用了他对补充量陡峭程度的定义来重新参数化Beverton-Holt 参数 $a$ 、 $b$ 、 $\alpha$ 和 $\beta$ （见本章附录）：</span>
<span id="cb51-758"><a href="#cb51-758" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-759"><a href="#cb51-759" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-760"><a href="#cb51-760" aria-hidden="true" tabindex="-1"></a>a = \dfrac{4hR_0}{(5h-1)} \quad b = \dfrac{B_0(1-h)}{(5h-1)} </span>
<span id="cb51-761"><a href="#cb51-761" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_25}</span>
<span id="cb51-762"><a href="#cb51-762" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-763"><a href="#cb51-763" aria-hidden="true" tabindex="-1"></a>将这些公式代入 @eq-5_16 中，得到：</span>
<span id="cb51-764"><a href="#cb51-764" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-765"><a href="#cb51-765" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-766"><a href="#cb51-766" aria-hidden="true" tabindex="-1"></a>R_y = \dfrac{\frac{4hR_0}{(5h-1)} B_y}{\frac{B_0(1-h)}{(5h-1)} + B_y}</span>
<span id="cb51-767"><a href="#cb51-767" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_26}</span>
<span id="cb51-768"><a href="#cb51-768" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-769"><a href="#cb51-769" aria-hidden="true" tabindex="-1"></a>将上层的 $(5h-1)$ 移到下层：</span>
<span id="cb51-770"><a href="#cb51-770" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-771"><a href="#cb51-771" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-772"><a href="#cb51-772" aria-hidden="true" tabindex="-1"></a>R_y = \dfrac{4hR_0 B_y}{\frac{(5h-1) B_0 (1-h)}{(5h-1)} +(5h-1)B_y}</span>
<span id="cb51-773"><a href="#cb51-773" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_27}</span>
<span id="cb51-774"><a href="#cb51-774" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-775"><a href="#cb51-775" aria-hidden="true" tabindex="-1"></a>然后，在可能的情况下消去 $(5h-1)$，可以将 Beverton-Holt 重新定义为陡峭度 $h$ 、 $B_0$ 和 $R_0$ ，这些都有更明确的解释，并且使用 @eq-5_25 或 @eq-5_28 将更容易在评估模型中进行估计：</span>
<span id="cb51-776"><a href="#cb51-776" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-777"><a href="#cb51-777" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-778"><a href="#cb51-778" aria-hidden="true" tabindex="-1"></a>R_y = \dfrac{4hR_0B_y}{B_0(1-h) + B_y(5h-1)} </span>
<span id="cb51-779"><a href="#cb51-779" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_28}</span>
<span id="cb51-780"><a href="#cb51-780" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-781"><a href="#cb51-781" aria-hidden="true" tabindex="-1"></a><span class="fu">### 重新参数化的 Ricker 方程</span></span>
<span id="cb51-782"><a href="#cb51-782" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-783"><a href="#cb51-783" aria-hidden="true" tabindex="-1"></a>类似地，Ricker 种群补充方程可以重新参数化为陡峭度 $h$、 $B_0$ 和 $R_0$ ：</span>
<span id="cb51-784"><a href="#cb51-784" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-785"><a href="#cb51-785" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-786"><a href="#cb51-786" aria-hidden="true" tabindex="-1"></a>R_y = \dfrac{R_0 B_y}{B_0} \exp \left(h \left(1-\frac{B_y}{B_0} \right) \right)</span>
<span id="cb51-787"><a href="#cb51-787" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_29}</span>
<span id="cb51-788"><a href="#cb51-788" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-789"><a href="#cb51-789" aria-hidden="true" tabindex="-1"></a>@eq-5_25 和 @eq-5_28 现在都是用于种群评估和试图包含补充量的模拟模型中更常用的参数化方法。</span>
<span id="cb51-790"><a href="#cb51-790" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-791"><a href="#cb51-791" aria-hidden="true" tabindex="-1"></a><span class="fu">## 选择性</span></span>
<span id="cb51-792"><a href="#cb51-792" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-793"><a href="#cb51-793" aria-hidden="true" tabindex="-1"></a><span class="fu">### 引言</span></span>
<span id="cb51-794"><a href="#cb51-794" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-795"><a href="#cb51-795" aria-hidden="true" tabindex="-1"></a>在种群评估模型（及模拟）中使用的另一类静态模型与渔具对特定物种的选择性有关。其核心思想是，如果一个被开发物种的种群在某个区域存在，那么如果使用特定的渔具（如拖网、丹麦围网、刺网、龙虾笼等），渔具的构造及其使用方式将影响在遇到渔具时，哪些可用的种群成员会对其变得脆弱。在年龄结构评估模型中，选择性的概念因可用性的概念而变得复杂。例如，如果某个物种的主要捕捞场所在水深超过 250 米的区域，而较浅水域中主要只有较小的幼体存在，那么如果仅使用浅水域的数据来估计渔具的选择性，其结果很可能与使用深水域数据得到的估计结果不同。实际上，在评估模型中估计的选择性曲线应该被视为选择性/可用性曲线。</span>
<span id="cb51-796"><a href="#cb51-796" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-797"><a href="#cb51-797" aria-hidden="true" tabindex="-1"></a>选择选择性曲线的形状是一个重要的决策。某些捕捞工具通常用特定的方程来描述其选择性。因此，拖网工具的选择性通常用逻辑斯蒂方程来描述，而长线工具（使用钩子）通常用拱形选择性函数来描述。</span>
<span id="cb51-798"><a href="#cb51-798" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-799"><a href="#cb51-799" aria-hidden="true" tabindex="-1"></a>只有在有捕捞年龄或大小组成数据的情况下，才能在资源评估模型中拟合选择性模型。正如我们在模型参数估计章节中所看到的，通常会用多项式似然来拟合这种组成数据。在资源评估模型中，通常会根据预期年龄数量来模拟种群动态，这会隐含某些大小数量。因此，在尝试生成预测的捕捞组成数据（无论是年龄还是大小）时，需要将可用的年龄或大小数量乘以预测的选择性。因此，在拟合过程中，组成数据会帮助估计选择性参数。</span>
<span id="cb51-800"><a href="#cb51-800" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-801"><a href="#cb51-801" aria-hidden="true" tabindex="-1"></a>本节中我们仅将说明其他选择性的方程式，并展示它们的不同特性。</span>
<span id="cb51-802"><a href="#cb51-802" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-803"><a href="#cb51-803" aria-hidden="true" tabindex="-1"></a><span class="fu">### 逻辑斯蒂选择</span></span>
<span id="cb51-804"><a href="#cb51-804" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-805"><a href="#cb51-805" aria-hidden="true" tabindex="-1"></a>描述不同渔具选择性特征的不同方程式有很多，但其中一种极其常见的是标准逻辑斯蒂曲线或 S 形曲线，这通常是拖网渔具选择性的典型特征。它意味着随着年龄或个体大小的增加，渔具的易受害性会逐渐增加，直到 100% 的个体在遇到渔具时都变得易受害（这种逐渐增加到 100% 的过程与成熟过程相同）。通常使用两个方程式，第一个由 **MQMF** 函数 <span class="in">`logist()`</span> 描述：</span>
<span id="cb51-806"><a href="#cb51-806" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-807"><a href="#cb51-807" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-808"><a href="#cb51-808" aria-hidden="true" tabindex="-1"></a>s_a = \dfrac{1}{1 + e^{-\log(19)(a-a_{50})/\delta}}</span>
<span id="cb51-809"><a href="#cb51-809" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_30}</span>
<span id="cb51-810"><a href="#cb51-810" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-811"><a href="#cb51-811" aria-hidden="true" tabindex="-1"></a>其中 $S_a$ 是年龄 $a$ 的选择性（比例）， $a_{50}$ 是选择性达到 50% 时的年龄， $\delta$ 是曲线的斜率，定义为从选择性 50%到选择性 95%之间的年数。当我们谈论年龄时，同样也可以谈论大小。 $\delta$ 的上限为 95%（实际上 $\delta$ 是 $L95-L50$ ）。另一种对数曲线，我们在《简单种群模型》<span class="co">[</span><span class="ot">@sec-simplemodel</span><span class="co">]</span> 一章的 “YPR 中的选择性” <span class="co">[</span><span class="ot">@sec-ypr_selectivity</span><span class="co">]</span> 节中已经见过，也被用来描述年龄成熟度，它在函数 <span class="in">`mature()`</span> 中定义：</span>
<span id="cb51-812"><a href="#cb51-812" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-813"><a href="#cb51-813" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-814"><a href="#cb51-814" aria-hidden="true" tabindex="-1"></a>s_a = \dfrac{1}{1+(e^{(\alpha + \beta a)})^{-1}} = \dfrac{e^{(\alpha + \beta a)}}{1+ e^{(\alpha + \beta a)}}</span>
<span id="cb51-815"><a href="#cb51-815" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_31}</span>
<span id="cb51-816"><a href="#cb51-816" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-817"><a href="#cb51-817" aria-hidden="true" tabindex="-1"></a>其中 $\alpha$ 和 $\beta$ 是逻辑斯蒂参数， $- \alpha/\beta$ 是0.5 选择性（即 50%）的年龄。四分位距（字面意思是 25%分位数到 75%分位数）定义为 $IQ = 2\log(3)/\beta$ （有关此函数的实现，请参阅 **MQMF** 函数 `mature()`）。通常，在年龄结构模型中，需要长度或年龄组成数据，以便可以直接估计渔具选择性和渔业可利用性。在进行单位补充量渔获量计算时，通常包含选择性的原因是确定开始应用捕捞死亡率的最佳年龄。出于这个原因，通常使用所谓的刀刃选择性，它本质上识别出以下没有选择性的特定年龄，以及以上 100% 选择性的年龄。这在 **MQMF** 函数 <span class="in">`logist()`</span> 中实现；尽管刀刃选择性不再倾向于用于完整的年龄结构种群评估模型，但它仍然用于延迟差分模型（Schnute，1985；Hilborn 和 Walters，1992）。</span>
<span id="cb51-818"><a href="#cb51-818" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-821"><a href="#cb51-821" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb51-822"><a href="#cb51-822" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-5-14</span></span>
<span id="cb51-823"><a href="#cb51-823" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: " logist() 和 mature() 函数的逻辑 S 形曲线示例。虚线红色和实线黑色曲线具有相同的 L50，但梯度不同。点线绿色展示了改变 `mature()` 函数的 b 参数的效果，而交叉线蓝色曲线展示了刀刃式选择。图例显示了 L50 和使用的方程。"</span></span>
<span id="cb51-824"><a href="#cb51-824" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-825"><a href="#cb51-825" aria-hidden="true" tabindex="-1"></a> <span class="co">#Selectivity curves from logist and mature functions  See Fig 5.14</span></span>
<span id="cb51-826"><a href="#cb51-826" aria-hidden="true" tabindex="-1"></a>ages <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="dv">0</span>,<span class="dv">50</span>,<span class="dv">1</span>);   in50 <span class="ot">&lt;-</span> <span class="fl">25.0</span>  </span>
<span id="cb51-827"><a href="#cb51-827" aria-hidden="true" tabindex="-1"></a>sel1 <span class="ot">&lt;-</span> <span class="fu">logist</span>(in50,<span class="dv">12</span>,ages)         <span class="co">#-3.65/0.146=L50=25.0  </span></span>
<span id="cb51-828"><a href="#cb51-828" aria-hidden="true" tabindex="-1"></a>sel2 <span class="ot">&lt;-</span> <span class="fu">mature</span>(<span class="sc">-</span><span class="fl">3.650425</span>,<span class="fl">0.146017</span>,<span class="at">sizeage=</span>ages)  </span>
<span id="cb51-829"><a href="#cb51-829" aria-hidden="true" tabindex="-1"></a>sel3 <span class="ot">&lt;-</span> <span class="fu">mature</span>(<span class="sc">-</span><span class="dv">6</span>,<span class="fl">0.2</span>,ages)  </span>
<span id="cb51-830"><a href="#cb51-830" aria-hidden="true" tabindex="-1"></a>sel4 <span class="ot">&lt;-</span> <span class="fu">logist</span>(<span class="fl">22.0</span>,<span class="dv">14</span>,ages,<span class="at">knifeedge =</span> <span class="cn">TRUE</span>)  </span>
<span id="cb51-831"><a href="#cb51-831" aria-hidden="true" tabindex="-1"></a><span class="fu">plot1</span>(ages,sel1,<span class="at">xlab=</span><span class="st">"Age Years"</span>,<span class="at">ylab=</span><span class="st">"Selectivity"</span>,<span class="at">cex=</span><span class="fl">0.75</span>,<span class="at">lwd=</span><span class="dv">2</span>)  </span>
<span id="cb51-832"><a href="#cb51-832" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(ages,sel2,<span class="at">col=</span><span class="dv">2</span>,<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">lty=</span><span class="dv">2</span>)  </span>
<span id="cb51-833"><a href="#cb51-833" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(ages,sel3,<span class="at">col=</span><span class="dv">3</span>,<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">lty=</span><span class="dv">3</span>)  </span>
<span id="cb51-834"><a href="#cb51-834" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(ages,sel4,<span class="at">col=</span><span class="dv">4</span>,<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">lty=</span><span class="dv">4</span>)  </span>
<span id="cb51-835"><a href="#cb51-835" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>in50,<span class="at">col=</span><span class="dv">1</span>,<span class="at">lty=</span><span class="dv">2</span>); <span class="fu">abline</span>(<span class="at">h=</span><span class="fl">0.5</span>,<span class="at">col=</span><span class="dv">1</span>,<span class="at">lty=</span><span class="dv">2</span>)  </span>
<span id="cb51-836"><a href="#cb51-836" aria-hidden="true" tabindex="-1"></a><span class="fu">legend</span>(<span class="st">"topleft"</span>,<span class="fu">c</span>(<span class="st">"25_eq5.30"</span>,<span class="st">"25_eq5.31"</span>,<span class="st">"30_eq5.31"</span>,<span class="st">"22_eq5.30N"</span>),  </span>
<span id="cb51-837"><a href="#cb51-837" aria-hidden="true" tabindex="-1"></a>       <span class="at">col=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>),<span class="at">lwd=</span><span class="dv">3</span>,<span class="at">cex=</span><span class="fl">1.1</span>,<span class="at">bty=</span><span class="st">"n"</span>,<span class="at">lty=</span><span class="fu">c</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>))  </span>
<span id="cb51-838"><a href="#cb51-838" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-839"><a href="#cb51-839" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-840"><a href="#cb51-840" aria-hidden="true" tabindex="-1"></a><span class="fu">### 球面选择性</span></span>
<span id="cb51-841"><a href="#cb51-841" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-842"><a href="#cb51-842" aria-hidden="true" tabindex="-1"></a>一种上升至峰值的选择性模式、可能存在平台段，然后下降的模式被称为穹顶形，这是网具（如围网）和钩具（如延绳钓）等渔具的典型特征。由于包含如此多的组成部分，选择性曲线往往更为复杂，因为上升段、平台段和下降段都需要连接在一起。现代拟合此类模型的方法倾向于使用自动微分软件，如 AD-Model Builder 或相关软件（Bull 等，2012；Fournier 等，2012；Kristensen 等，2016）。这意味着评估模型中的组件模型需要可微分，以便穹顶形选择性曲线的三个组成部分之间的连接需要连续（Methot 和 Wetzell，2013；Hurtado-Ferro 等，2014）。此类方程至少包含五个组成部分：上升段（*asc*）、选择性等于 1.0 的平台段、下降段（*des*）、以及连接这三个主要部分之间的两个连接函数、 $J_1$ 和 $J_2$， @eq-5_32 ：</span>
<span id="cb51-843"><a href="#cb51-843" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-844"><a href="#cb51-844" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-845"><a href="#cb51-845" aria-hidden="true" tabindex="-1"></a>s_L = asc(1-J_{1,L}) +J_{1,L}((1-J_{2,L})+J_{2,L} dsc)</span>
<span id="cb51-846"><a href="#cb51-846" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_32}</span>
<span id="cb51-847"><a href="#cb51-847" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-848"><a href="#cb51-848" aria-hidden="true" tabindex="-1"></a>其中 $S_L$ 表示长度 $L$ 的选择性。各种分量函数定义如下：</span>
<span id="cb51-849"><a href="#cb51-849" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-850"><a href="#cb51-850" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-851"><a href="#cb51-851" aria-hidden="true" tabindex="-1"></a>\begin{split}</span>
<span id="cb51-852"><a href="#cb51-852" aria-hidden="true" tabindex="-1"></a>asc &amp;= 1-(1-\lambda_5) \left(\dfrac{1-\exp \left((m_L - \lambda_1)^2/\lambda_3 \right)}{1-\exp \left((m_{min}-\lambda_1)^2/\lambda_3 \right)} \right) <span class="sc">\\</span></span>
<span id="cb51-853"><a href="#cb51-853" aria-hidden="true" tabindex="-1"></a>dsc &amp;= 1- \exp\left(-\left(m_L- \lambda_2)^2/\lambda_4 \right) \right) <span class="sc">\\</span></span>
<span id="cb51-854"><a href="#cb51-854" aria-hidden="true" tabindex="-1"></a>J_{1,L} &amp;=1/(1+ \exp(-(m_L-\lambda_1)/(1 +|m_L+\lambda_1|)))<span class="sc">\\</span></span>
<span id="cb51-855"><a href="#cb51-855" aria-hidden="true" tabindex="-1"></a>J_{2,L} &amp;= 1/(1+ \exp(-(m_L-\lambda_2)/(1+|m_L + \lambda_2|)))</span>
<span id="cb51-856"><a href="#cb51-856" aria-hidden="true" tabindex="-1"></a>\end{split}</span>
<span id="cb51-857"><a href="#cb51-857" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_33}</span>
<span id="cb51-858"><a href="#cb51-858" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-859"><a href="#cb51-859" aria-hidden="true" tabindex="-1"></a>其中 $m_L$ 是长度组 $L$ 的平均长度， $m_{min}$ 是最小长度组的平均长度， $\lambda_1$ 是选择性达到 1.0 的个体大小， $\lambda_2$ 是选择性从 1.0 开始下降的个体大小（如果 $\lambda_1$ 和 $\lambda_2$ 相等则没有平台期）， $\lambda_3$ 影响上升段（*asc*）的斜率， $\lambda_4$ 影响下降段（*dsc*）的斜率， $\lambda_5$ 是 $m_{min}$ 处选择性的对数， $\lambda_6$ 是 $m_{max}$ 选择性的对数， @fig-5-15 。</span>
<span id="cb51-860"><a href="#cb51-860" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-861"><a href="#cb51-861" aria-hidden="true" tabindex="-1"></a>因此，需要 $\lambda_1$ 到 $\lambda_6$ 六个参数以及所使用的长度组的平均长度来定义这种穹顶选择性曲线。</span>
<span id="cb51-862"><a href="#cb51-862" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-865"><a href="#cb51-865" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb51-866"><a href="#cb51-866" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-5-15</span></span>
<span id="cb51-867"><a href="#cb51-867" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "由函数 domed() 产生的三个拱形选择性曲线示例，改变了达到选择性 1.0 的初始年龄（10、8、9），以及停止时的年龄（11、12、10），以及最终年龄组的选择性。"</span></span>
<span id="cb51-868"><a href="#cb51-868" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-869"><a href="#cb51-869" aria-hidden="true" tabindex="-1"></a> <span class="co">#Examples of domed-shaped selectivity curves from domed. Fig.5.15  </span></span>
<span id="cb51-870"><a href="#cb51-870" aria-hidden="true" tabindex="-1"></a>L <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="dv">1</span>,<span class="dv">30</span>,<span class="dv">1</span>)  </span>
<span id="cb51-871"><a href="#cb51-871" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">10</span>,<span class="dv">11</span>,<span class="dv">16</span>,<span class="dv">33</span>,<span class="sc">-</span><span class="dv">5</span>,<span class="sc">-</span><span class="dv">2</span>)  </span>
<span id="cb51-872"><a href="#cb51-872" aria-hidden="true" tabindex="-1"></a><span class="fu">plot1</span>(L,<span class="fu">domed</span>(p,L),<span class="at">type=</span><span class="st">"l"</span>,<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">ylab=</span><span class="st">"Selectivity"</span>,<span class="at">xlab=</span><span class="st">"Age Years"</span>)  </span>
<span id="cb51-873"><a href="#cb51-873" aria-hidden="true" tabindex="-1"></a>p1 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">8</span>,<span class="dv">12</span>,<span class="dv">16</span>,<span class="dv">33</span>,<span class="sc">-</span><span class="dv">5</span>,<span class="sc">-</span><span class="dv">1</span>)  </span>
<span id="cb51-874"><a href="#cb51-874" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(L,<span class="fu">domed</span>(p1,L),<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">2</span>,<span class="at">lty=</span><span class="dv">2</span>)  </span>
<span id="cb51-875"><a href="#cb51-875" aria-hidden="true" tabindex="-1"></a>p2 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">9</span>,<span class="dv">10</span>,<span class="dv">16</span>,<span class="dv">33</span>,<span class="sc">-</span><span class="dv">5</span>,<span class="sc">-</span><span class="dv">4</span>)  </span>
<span id="cb51-876"><a href="#cb51-876" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(L,<span class="fu">domed</span>(p2,L),<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">4</span>,<span class="at">lty=</span><span class="dv">4</span>)  </span>
<span id="cb51-877"><a href="#cb51-877" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-878"><a href="#cb51-878" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-879"><a href="#cb51-879" aria-hidden="true" tabindex="-1"></a><span class="fu">## 静态模型的结论性评述</span></span>
<span id="cb51-880"><a href="#cb51-880" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-881"><a href="#cb51-881" aria-hidden="true" tabindex="-1"></a>比我们已考虑的剩余产量模型更复杂的种群评估模型，大多是混合了群体进展的动态模型和本章所说明的静态模型集合。因此，了解生长、成熟、选择性和补充模型对于理解更高级模型的结构至关重要。有时人们会在评估模型之外估计它们的参数，但通常估计会是拟合整个种群评估模型的一部分。一次性拟合所有独立模型组件的优势在于，组件之间的任何交互作用都可以自动考虑。</span>
<span id="cb51-882"><a href="#cb51-882" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-883"><a href="#cb51-883" aria-hidden="true" tabindex="-1"></a>本章为一系列静态模型提供了入门基础。目标是当你遇到其他模型时，能够像我们这里使用的方法一样使用和拟合它们。每种这样的模型都有其自身的假设。只要你知道这些假设，你应该能够为你在建模中选择使用哪种静态模型做出决策并提供辩护。</span>
<span id="cb51-884"><a href="#cb51-884" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-885"><a href="#cb51-885" aria-hidden="true" tabindex="-1"></a><span class="fu">## 附录：Fabens 变换的推导</span></span>
<span id="cb51-886"><a href="#cb51-886" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-887"><a href="#cb51-887" aria-hidden="true" tabindex="-1"></a>Fabens（1965）将 von Bertalanffy 生长曲线进行转换，使其与标记计划提供的数据相匹配（标记时的长度和日期，以及重捕时的长度和日期）。von Bertalanffy 曲线的年龄-长度版本为：</span>
<span id="cb51-888"><a href="#cb51-888" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-889"><a href="#cb51-889" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-890"><a href="#cb51-890" aria-hidden="true" tabindex="-1"></a>\hat {L_t} = L_{\infty} \left(1- e^{(-K(t-t_0))} \right) +N(0, \sigma)</span>
<span id="cb51-891"><a href="#cb51-891" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_34}</span>
<span id="cb51-892"><a href="#cb51-892" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-893"><a href="#cb51-893" aria-hidden="true" tabindex="-1"></a>在标记的背景下，它在给定时间增量（ $\Delta t$ ）后的长度定义为：</span>
<span id="cb51-894"><a href="#cb51-894" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-895"><a href="#cb51-895" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-896"><a href="#cb51-896" aria-hidden="true" tabindex="-1"></a>L_{t +\Delta t} = L_{\infty} - L_{\infty} e^{-K((t + \Delta t)-t_0)}</span>
<span id="cb51-897"><a href="#cb51-897" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_35}</span>
<span id="cb51-898"><a href="#cb51-898" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-899"><a href="#cb51-899" aria-hidden="true" tabindex="-1"></a>在指数项中，可以提取 $\Delta t$ 的贡献：</span>
<span id="cb51-900"><a href="#cb51-900" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-901"><a href="#cb51-901" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-902"><a href="#cb51-902" aria-hidden="true" tabindex="-1"></a>L_{t+\Delta t} = L_{\infty} - L_{\infty} e^{-K(t-t_0)} e^{-K \Delta t}</span>
<span id="cb51-903"><a href="#cb51-903" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_36}</span>
<span id="cb51-904"><a href="#cb51-904" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-905"><a href="#cb51-905" aria-hidden="true" tabindex="-1"></a>现在，在 $\Delta t$ 期间预期发生的生长增量 $\Delta L$ 可以定义为 $L_{t +\Delta t}$ 减去 $L_t$：</span>
<span id="cb51-906"><a href="#cb51-906" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-907"><a href="#cb51-907" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-908"><a href="#cb51-908" aria-hidden="true" tabindex="-1"></a>\Delta L = (L_{t + \Delta t}-L_t) = <span class="sc">\\</span></span>
<span id="cb51-909"><a href="#cb51-909" aria-hidden="true" tabindex="-1"></a>\left(L_{\infty}-L_{\infty}e^{-K(t-t_0)}e^{-K \Delta t} \right) - \left(L_{\infty} - L_{\infty}e^{(-K((t-t_0))} \right)</span>
<span id="cb51-910"><a href="#cb51-910" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_37}</span>
<span id="cb51-911"><a href="#cb51-911" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-912"><a href="#cb51-912" aria-hidden="true" tabindex="-1"></a>我们可以去掉括号，这将使第二项中的否定变为加号，然后重新排列分离的项。</span>
<span id="cb51-913"><a href="#cb51-913" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-914"><a href="#cb51-914" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-915"><a href="#cb51-915" aria-hidden="true" tabindex="-1"></a>\Delta L = L_{\infty}-L_{\infty}e^{-K(t-t_0)}e^{-K \Delta t}  - L_{\infty} + L_{\infty}e^{(-K((t-t_0))}</span>
<span id="cb51-916"><a href="#cb51-916" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_38}</span>
<span id="cb51-917"><a href="#cb51-917" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-918"><a href="#cb51-918" aria-hidden="true" tabindex="-1"></a>这两个孤立的 $L_{\infty}$ 项可以消去以提高证明的清晰度，但它们稍后会重新出现。此外，我们还可以重新排列剩下的两个指数项：</span>
<span id="cb51-919"><a href="#cb51-919" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-920"><a href="#cb51-920" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-921"><a href="#cb51-921" aria-hidden="true" tabindex="-1"></a>\Delta L = L_{\infty} e^{(-K(t-t_0))} -L_{\infty} e^{-K(t-t_0)}e^{-K \Delta t}</span>
<span id="cb51-922"><a href="#cb51-922" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_39}</span>
<span id="cb51-923"><a href="#cb51-923" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-924"><a href="#cb51-924" aria-hidden="true" tabindex="-1"></a>重新排列使得可以提出出 $L_{\infty}e^{(-K(t -t_0))}$ 项来简化整个方程：</span>
<span id="cb51-925"><a href="#cb51-925" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-926"><a href="#cb51-926" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-927"><a href="#cb51-927" aria-hidden="true" tabindex="-1"></a>\Delta L = L_{\infty} e^{(-K(t-t_0))}\left(1-e^{-K \Delta t}\right)</span>
<span id="cb51-928"><a href="#cb51-928" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_40}</span>
<span id="cb51-929"><a href="#cb51-929" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-930"><a href="#cb51-930" aria-hidden="true" tabindex="-1"></a>现在我们可以将 $\Delta t$ 项移至左边，并返回 $L_{\infty} - L_{\infty}$ 项</span>
<span id="cb51-931"><a href="#cb51-931" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-932"><a href="#cb51-932" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-933"><a href="#cb51-933" aria-hidden="true" tabindex="-1"></a>\frac{\Delta L}{(1-e^{-K \Delta t})} = L_{\infty} - L_{\infty} + L_{\infty} e^{(-K(t-t_0))}</span>
<span id="cb51-934"><a href="#cb51-934" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_41}</span>
<span id="cb51-935"><a href="#cb51-935" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-936"><a href="#cb51-936" aria-hidden="true" tabindex="-1"></a>如果我们添加一些括号，将加号变为减号，我们最终就能认识到哪些项的组合等于 $L_t$ ：</span>
<span id="cb51-937"><a href="#cb51-937" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-938"><a href="#cb51-938" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-939"><a href="#cb51-939" aria-hidden="true" tabindex="-1"></a>\dfrac{\Delta \hat L}{(1-e^{-K \Delta t})} = L_{\infty}-\left(L_{\infty}-L_{\infty}e^{(-K(t-t_0))} \right)</span>
<span id="cb51-940"><a href="#cb51-940" aria-hidden="true" tabindex="-1"></a>= (L_{\infty}-L_t)$$ {#eq-5_42}</span>
<span id="cb51-941"><a href="#cb51-941" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-942"><a href="#cb51-942" aria-hidden="true" tabindex="-1"></a>通过将 $\Delta t$ 项移至右侧，得到经典的 Fabens 生长增量方程：</span>
<span id="cb51-943"><a href="#cb51-943" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-944"><a href="#cb51-944" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-945"><a href="#cb51-945" aria-hidden="true" tabindex="-1"></a>\Delta L = (L_{\infty}-L_t)\left(1-e^{-K \Delta t} \right)</span>
<span id="cb51-946"><a href="#cb51-946" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_43}</span>
<span id="cb51-947"><a href="#cb51-947" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-948"><a href="#cb51-948" aria-hidden="true" tabindex="-1"></a>需要注意的是，这种转换也会转换长度-年龄方程中的正态随机残差，而这些残差当然是在参数估计时使用的。这意味着，尽管这些参数具有相同的名称，但它们并不严格可比。</span>
<span id="cb51-949"><a href="#cb51-949" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-950"><a href="#cb51-950" aria-hidden="true" tabindex="-1"></a><span class="fu">## 附录：Beverton-Holt 模型的重新参数化</span></span>
<span id="cb51-951"><a href="#cb51-951" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-952"><a href="#cb51-952" aria-hidden="true" tabindex="-1"></a>Francis（1992）以更具有生物学意义的陡峭程度（ $h$ ）、 初始成熟生物量（ $B_0$）和 初始补充量（ $R_0$ ）等术语来定义 Beverton-Holt 参数。与其使用</span>
<span id="cb51-953"><a href="#cb51-953" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-954"><a href="#cb51-954" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-955"><a href="#cb51-955" aria-hidden="true" tabindex="-1"></a>R_y = \dfrac{B_{y-1}}{\alpha + \beta B_{y-1}} </span>
<span id="cb51-956"><a href="#cb51-956" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_44}</span>
<span id="cb51-957"><a href="#cb51-957" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-958"><a href="#cb51-958" aria-hidden="true" tabindex="-1"></a>不如使用另外一种公式，尽管最后还是要回到使用关系 $\alpha = b/a$ 和 $\beta = 1/a$ 。</span>
<span id="cb51-959"><a href="#cb51-959" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-960"><a href="#cb51-960" aria-hidden="true" tabindex="-1"></a>因此，我们将使用：</span>
<span id="cb51-961"><a href="#cb51-961" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-962"><a href="#cb51-962" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-963"><a href="#cb51-963" aria-hidden="true" tabindex="-1"></a>R_y = \dfrac{a B_y}{b+ B_y}</span>
<span id="cb51-964"><a href="#cb51-964" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_45}</span>
<span id="cb51-965"><a href="#cb51-965" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-966"><a href="#cb51-966" aria-hidden="true" tabindex="-1"></a>其中 $R_y$ 是年 $y$ 的补充量， $B_y$ 是 $y$ 年繁殖资源量， $a$ 和 $b$ 是 Beverton-Holt 参数。在未受捕捞的平衡状态下，我们可以将方程表示为：</span>
<span id="cb51-967"><a href="#cb51-967" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-968"><a href="#cb51-968" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-969"><a href="#cb51-969" aria-hidden="true" tabindex="-1"></a>R_0 = \dfrac{a B_0}{b + B_0}</span>
<span id="cb51-970"><a href="#cb51-970" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_46}</span>
<span id="cb51-971"><a href="#cb51-971" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-972"><a href="#cb51-972" aria-hidden="true" tabindex="-1"></a>陡度（ $h$ ）定义为初始生物量的20% 时获得的补充量：</span>
<span id="cb51-973"><a href="#cb51-973" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-974"><a href="#cb51-974" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-975"><a href="#cb51-975" aria-hidden="true" tabindex="-1"></a>h R_0 = \dfrac{0.2 a B_0}{b + 0.2 B_0}</span>
<span id="cb51-976"><a href="#cb51-976" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_47}</span>
<span id="cb51-977"><a href="#cb51-977" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-978"><a href="#cb51-978" aria-hidden="true" tabindex="-1"></a>如果 $R_0$ 的平衡方程代入这个方程，我们将得到：</span>
<span id="cb51-979"><a href="#cb51-979" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-980"><a href="#cb51-980" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-981"><a href="#cb51-981" aria-hidden="true" tabindex="-1"></a>h \dfrac{a B_0}{b + B_0}= \dfrac{0.2 a B_0}{b + 0.2 B_0}</span>
<span id="cb51-982"><a href="#cb51-982" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_48}</span>
<span id="cb51-983"><a href="#cb51-983" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-984"><a href="#cb51-984" aria-hidden="true" tabindex="-1"></a>因此：</span>
<span id="cb51-985"><a href="#cb51-985" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-986"><a href="#cb51-986" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-987"><a href="#cb51-987" aria-hidden="true" tabindex="-1"></a>h = \dfrac{(0.2a B_0)(b+B_0)}{(b+0.2B_0)(aB_0)}= \dfrac{0.2(b + B_0)}{b + 0.2 B_0}</span>
<span id="cb51-988"><a href="#cb51-988" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_49}</span>
<span id="cb51-989"><a href="#cb51-989" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-990"><a href="#cb51-990" aria-hidden="true" tabindex="-1"></a>通过乘法得到 ：</span>
<span id="cb51-991"><a href="#cb51-991" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-992"><a href="#cb51-992" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-993"><a href="#cb51-993" aria-hidden="true" tabindex="-1"></a>h b + 0.2hB_0 = 0.2b + 0.2 B_0</span>
<span id="cb51-994"><a href="#cb51-994" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_50}</span>
<span id="cb51-995"><a href="#cb51-995" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-996"><a href="#cb51-996" aria-hidden="true" tabindex="-1"></a>通过交换项以将 $b$ 和 $B_0$ 分开，然后乘以5 以消除 0.2：</span>
<span id="cb51-997"><a href="#cb51-997" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-998"><a href="#cb51-998" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-999"><a href="#cb51-999" aria-hidden="true" tabindex="-1"></a>5hb -b = B_0- h B_0</span>
<span id="cb51-1000"><a href="#cb51-1000" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_51}</span>
<span id="cb51-1001"><a href="#cb51-1001" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-1002"><a href="#cb51-1002" aria-hidden="true" tabindex="-1"></a>简化后得到：</span>
<span id="cb51-1003"><a href="#cb51-1003" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-1004"><a href="#cb51-1004" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-1005"><a href="#cb51-1005" aria-hidden="true" tabindex="-1"></a>b(5h-1) = B_0 (1-h)</span>
<span id="cb51-1006"><a href="#cb51-1006" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_52}</span>
<span id="cb51-1007"><a href="#cb51-1007" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-1008"><a href="#cb51-1008" aria-hidden="true" tabindex="-1"></a>因此 $b$ 可重新参数为：</span>
<span id="cb51-1009"><a href="#cb51-1009" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-1010"><a href="#cb51-1010" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-1011"><a href="#cb51-1011" aria-hidden="true" tabindex="-1"></a>b = \dfrac{B_0(1-h)}{(5h-1)}</span>
<span id="cb51-1012"><a href="#cb51-1012" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_53}</span>
<span id="cb51-1013"><a href="#cb51-1013" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-1014"><a href="#cb51-1014" aria-hidden="true" tabindex="-1"></a>该版本的 $b$ 可以用于原始方程，并重新排列以对 $a$ 参数做类似处理：</span>
<span id="cb51-1015"><a href="#cb51-1015" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-1016"><a href="#cb51-1016" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-1017"><a href="#cb51-1017" aria-hidden="true" tabindex="-1"></a>R_0 = \dfrac{a B_0}{\frac{B_0(1-h)}{(5h-1)} +B_0}</span>
<span id="cb51-1018"><a href="#cb51-1018" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_54}</span>
<span id="cb51-1019"><a href="#cb51-1019" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-1020"><a href="#cb51-1020" aria-hidden="true" tabindex="-1"></a>转换为：</span>
<span id="cb51-1021"><a href="#cb51-1021" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-1022"><a href="#cb51-1022" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-1023"><a href="#cb51-1023" aria-hidden="true" tabindex="-1"></a>R_0 \dfrac{B_0(1-h)}{(5h-1)} +R_0 B_0 = a B_0</span>
<span id="cb51-1024"><a href="#cb51-1024" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_55}</span>
<span id="cb51-1025"><a href="#cb51-1025" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-1026"><a href="#cb51-1026" aria-hidden="true" tabindex="-1"></a>除以 $B_0$ ，然后将等号左侧的第二项 $R_0$ 乘以 $5h-1$，简化为：</span>
<span id="cb51-1027"><a href="#cb51-1027" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-1028"><a href="#cb51-1028" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-1029"><a href="#cb51-1029" aria-hidden="true" tabindex="-1"></a>\dfrac{R_0 -R_0h +5hR_0-R_0}{5h-1}= \dfrac{4hR_0}{5h-1} = a</span>
<span id="cb51-1030"><a href="#cb51-1030" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_56}</span>
<span id="cb51-1031"><a href="#cb51-1031" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-1032"><a href="#cb51-1032" aria-hidden="true" tabindex="-1"></a>记住 $\alpha = b/a$ 和 $\beta = 1/a$ ，所以就可以完成了：</span>
<span id="cb51-1033"><a href="#cb51-1033" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-1034"><a href="#cb51-1034" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-1035"><a href="#cb51-1035" aria-hidden="true" tabindex="-1"></a>\alpha =b \times 1/a = \dfrac{B_0(1-h)}{(5h-1)} \times \dfrac{5h-1}{4hR_0} = \dfrac{B_0(1-h)}{4hR_0}</span>
<span id="cb51-1036"><a href="#cb51-1036" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_57}</span>
<span id="cb51-1037"><a href="#cb51-1037" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-1038"><a href="#cb51-1038" aria-hidden="true" tabindex="-1"></a>以及：</span>
<span id="cb51-1039"><a href="#cb51-1039" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-1040"><a href="#cb51-1040" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-1041"><a href="#cb51-1041" aria-hidden="true" tabindex="-1"></a>b = 1/a = \dfrac{5h-1}{4hR_0}</span>
<span id="cb51-1042"><a href="#cb51-1042" aria-hidden="true" tabindex="-1"></a>$$ {#eq-5_58}</span>
<span id="cb51-1043"><a href="#cb51-1043" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-1044"><a href="#cb51-1044" aria-hidden="true" tabindex="-1"></a>如 Francis (1992) 所定义。这重新定义了 Beverton-Holt 模型参数，以 $h$、 $B_0$ 和 $R_0$ 表示。需要确定 $B_0$ 和 $R_0$ 之间的关系，但我们不能使用平衡方程来计算，因此我们假设未受捕捞的种群处于具有稳定年龄分布的平衡状态。从稳定年龄分布中每单位亲体产生的成熟生物量 ( $A_0$ ) 因此定义了 $B_0$ 和 $R_0$ 之间所需的关系。</span>
</code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->



</body></html>