<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-Hans" xml:lang="zh-Hans"><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>渔业建模与定量分析：R 实践指南 - 7&nbsp; 剩余产量模型</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>

<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./08-references.html" rel="next">
<link href="./06-uncertainty.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark"><script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "没有结果",
    "search-matching-documents-text": "匹配的文档",
    "search-copy-link-title": "复制搜索链接",
    "search-hide-matches-text": "隐藏其它匹配结果",
    "search-more-match-text": "更多匹配结果",
    "search-more-matches-text": "更多匹配结果",
    "search-clear-button-title": "清除",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "取消",
    "search-submit-button-title": "提交",
    "search-label": "搜索"
  }
}</script><script>
    MathJax ={
  tex: {
    macros: {
      bm: ["{\\boldsymbol #1}",1],
    }
  }
};
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>
</head>
<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top"><nav class="quarto-secondary-nav"><div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="切换侧边栏导航" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./07-spm.html"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">剩余产量模型</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="切换侧边栏导航" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav></header><!-- content --><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto"><div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">渔业建模与定量分析：R 实践指南</a> 
        <div class="sidebar-tools-main">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="切换深色模式"><i class="bi"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="搜索"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">中文版本说明</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./preface.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01-intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">关于建模</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-NonIntroductiontoR.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">R 语言的不完全介绍</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03-simpopmodel.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">简单种群模型</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04-application.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">模型参数估算</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05-staticModel.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">静态模型</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06-uncertainty.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">不确定性</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07-spm.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">剩余产量模型</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08-references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">参考文献</span></a>
  </div>
</li>
    </ul>
</div>
</nav><div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="2"><h2 id="toc-title">目录</h2>
   
  <ul>
<li>
<a href="#%E5%BC%95%E8%A8%80" id="toc-引言" class="nav-link active" data-scroll-target="#%E5%BC%95%E8%A8%80"><span class="header-section-number">7.1</span> 引言</a>
  <ul class="collapse">
<li><a href="#%E6%95%B0%E6%8D%AE%E9%9C%80%E6%B1%82" id="toc-数据需求" class="nav-link" data-scroll-target="#%E6%95%B0%E6%8D%AE%E9%9C%80%E6%B1%82"><span class="header-section-number">7.1.1</span> 数据需求</a></li>
  <li><a href="#%E5%AF%B9%E6%AF%94%E7%9A%84%E9%9C%80%E6%B1%82" id="toc-对比的需求" class="nav-link" data-scroll-target="#%E5%AF%B9%E6%AF%94%E7%9A%84%E9%9C%80%E6%B1%82"><span class="header-section-number">7.1.2</span> 对比的需求</a></li>
  <li><a href="#%E6%B8%94%E8%8E%B7%E7%8E%87%E4%BD%95%E6%97%B6%E5%85%B7%E6%9C%89%E5%8F%82%E8%80%83%E4%BB%B7%E5%80%BC" id="toc-渔获率何时具有参考价值" class="nav-link" data-scroll-target="#%E6%B8%94%E8%8E%B7%E7%8E%87%E4%BD%95%E6%97%B6%E5%85%B7%E6%9C%89%E5%8F%82%E8%80%83%E4%BB%B7%E5%80%BC"><span class="header-section-number">7.1.3</span> 渔获率何时具有参考价值</a></li>
  </ul>
</li>
  <li>
<a href="#%E4%B8%80%E4%BA%9B%E6%96%B9%E7%A8%8B" id="toc-一些方程" class="nav-link" data-scroll-target="#%E4%B8%80%E4%BA%9B%E6%96%B9%E7%A8%8B"><span class="header-section-number">7.2</span> 一些方程</a>
  <ul class="collapse">
<li><a href="#%E4%BA%A7%E9%87%8F%E6%96%B9%E7%A8%8B" id="toc-产量方程" class="nav-link" data-scroll-target="#%E4%BA%A7%E9%87%8F%E6%96%B9%E7%A8%8B"><span class="header-section-number">7.2.1</span> 产量方程</a></li>
  <li><a href="#schaefer-%E6%A8%A1%E5%9E%8B" id="toc-schaefer-模型" class="nav-link" data-scroll-target="#schaefer-%E6%A8%A1%E5%9E%8B"><span class="header-section-number">7.2.2</span> Schaefer 模型</a></li>
  <li><a href="#%E6%AE%8B%E5%B7%AE%E5%B9%B3%E6%96%B9%E5%92%8C" id="toc-残差平方和" class="nav-link" data-scroll-target="#%E6%AE%8B%E5%B7%AE%E5%B9%B3%E6%96%B9%E5%92%8C"><span class="header-section-number">7.2.3</span> 残差平方和</a></li>
  <li><a href="#%E4%BC%B0%E7%AE%97%E7%AE%A1%E7%90%86%E7%BB%9F%E8%AE%A1" id="toc-估算管理统计" class="nav-link" data-scroll-target="#%E4%BC%B0%E7%AE%97%E7%AE%A1%E7%90%86%E7%BB%9F%E8%AE%A1"><span class="header-section-number">7.2.4</span> 估算管理统计</a></li>
  <li><a href="#%E5%9D%87%E8%A1%A1%E7%9A%84%E9%BA%BB%E7%83%A6" id="toc-均衡的麻烦" class="nav-link" data-scroll-target="#%E5%9D%87%E8%A1%A1%E7%9A%84%E9%BA%BB%E7%83%A6"><span class="header-section-number">7.2.5</span> 均衡的麻烦</a></li>
  </ul>
</li>
  <li>
<a href="#%E6%A8%A1%E5%9E%8B%E6%8B%9F%E5%90%88" id="toc-模型拟合" class="nav-link" data-scroll-target="#%E6%A8%A1%E5%9E%8B%E6%8B%9F%E5%90%88"><span class="header-section-number">7.3</span> 模型拟合</a>
  <ul class="collapse">
<li><a href="#%E7%A7%8D%E7%BE%A4%E8%AF%84%E4%BC%B0%E7%9A%84%E5%8F%AF%E8%83%BD%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B" id="toc-种群评估的可能工作流程" class="nav-link" data-scroll-target="#%E7%A7%8D%E7%BE%A4%E8%AF%84%E4%BC%B0%E7%9A%84%E5%8F%AF%E8%83%BD%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="header-section-number">7.3.1</span> 种群评估的可能工作流程</a></li>
  <li><a href="#%E5%88%86%E6%9E%90%E6%98%AF%E5%90%A6%E7%A8%B3%E5%81%A5" id="toc-分析是否稳健" class="nav-link" data-scroll-target="#%E5%88%86%E6%9E%90%E6%98%AF%E5%90%A6%E7%A8%B3%E5%81%A5"><span class="header-section-number">7.3.2</span> 分析是否稳健？</a></li>
  <li><a href="#%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E6%95%B0%E6%8D%AE" id="toc-使用不同的数据" class="nav-link" data-scroll-target="#%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="header-section-number">7.3.3</span> 使用不同的数据？</a></li>
  </ul>
</li>
  <li>
<a href="#%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7" id="toc-不确定性" class="nav-link" data-scroll-target="#%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7"><span class="header-section-number">7.4</span> 不确定性</a>
  <ul class="collapse">
<li><a href="#%E4%BC%BC%E7%84%B6%E5%89%96%E9%9D%A2%E5%9B%BE" id="toc-似然剖面图" class="nav-link" data-scroll-target="#%E4%BC%BC%E7%84%B6%E5%89%96%E9%9D%A2%E5%9B%BE"><span class="header-section-number">7.4.1</span> 似然剖面图</a></li>
  <li><a href="#bootstrap-%E7%BD%AE%E4%BF%A1%E5%8C%BA%E9%97%B4" id="toc-bootstrap-置信区间" class="nav-link" data-scroll-target="#bootstrap-%E7%BD%AE%E4%BF%A1%E5%8C%BA%E9%97%B4"><span class="header-section-number">7.4.2</span> Bootstrap 置信区间</a></li>
  <li><a href="#%E5%8F%82%E6%95%B0%E7%9B%B8%E5%85%B3%E6%80%A7" id="toc-参数相关性" class="nav-link" data-scroll-target="#%E5%8F%82%E6%95%B0%E7%9B%B8%E5%85%B3%E6%80%A7"><span class="header-section-number">7.4.3</span> 参数相关性</a></li>
  <li><a href="#%E6%B8%90%E8%BF%91%E8%AF%AF%E5%B7%AE" id="toc-渐近误差" class="nav-link" data-scroll-target="#%E6%B8%90%E8%BF%91%E8%AF%AF%E5%B7%AE"><span class="header-section-number">7.4.4</span> 渐近误差</a></li>
  <li><a href="#%E6%9C%89%E6%97%B6%E6%B8%90%E8%BF%91%E8%AF%AF%E5%B7%AE%E8%B5%B7%E4%BD%9C%E7%94%A8" id="toc-有时渐近误差起作用" class="nav-link" data-scroll-target="#%E6%9C%89%E6%97%B6%E6%B8%90%E8%BF%91%E8%AF%AF%E5%B7%AE%E8%B5%B7%E4%BD%9C%E7%94%A8"><span class="header-section-number">7.4.5</span> 有时渐近误差起作用</a></li>
  <li><a href="#%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%90%8E%E9%AA%8C" id="toc-贝叶斯后验" class="nav-link" data-scroll-target="#%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%90%8E%E9%AA%8C"><span class="header-section-number">7.4.6</span> 贝叶斯后验</a></li>
  </ul>
</li>
  <li>
<a href="#%E7%AE%A1%E7%90%86%E5%BB%BA%E8%AE%AE" id="toc-管理建议" class="nav-link" data-scroll-target="#%E7%AE%A1%E7%90%86%E5%BB%BA%E8%AE%AE"><span class="header-section-number">7.5</span> 管理建议</a>
  <ul class="collapse">
<li><a href="#%E4%B8%A4%E7%A7%8D%E9%A3%8E%E9%99%A9%E8%A7%82" id="toc-两种风险观" class="nav-link" data-scroll-target="#%E4%B8%A4%E7%A7%8D%E9%A3%8E%E9%99%A9%E8%A7%82"><span class="header-section-number">7.5.1</span> 两种风险观</a></li>
  <li><a href="#%E6%8D%95%E6%8D%9E%E7%AD%96%E7%95%A5" id="toc-捕捞策略" class="nav-link" data-scroll-target="#%E6%8D%95%E6%8D%9E%E7%AD%96%E7%95%A5"><span class="header-section-number">7.5.2</span> 捕捞策略</a></li>
  </ul>
</li>
  <li>
<a href="#%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0%E9%A2%84%E6%B5%8B" id="toc-风险评估预测" class="nav-link" data-scroll-target="#%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0%E9%A2%84%E6%B5%8B"><span class="header-section-number">7.6</span> 风险评估预测</a>
  <ul class="collapse">
<li><a href="#%E7%A1%AE%E5%AE%9A%E6%80%A7%E9%A2%84%E6%B5%8B" id="toc-确定性预测" class="nav-link" data-scroll-target="#%E7%A1%AE%E5%AE%9A%E6%80%A7%E9%A2%84%E6%B5%8B"><span class="header-section-number">7.6.1</span> 确定性预测</a></li>
  <li><a href="#%E8%80%83%E8%99%91%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7" id="toc-考虑不确定性" class="nav-link" data-scroll-target="#%E8%80%83%E8%99%91%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7"><span class="header-section-number">7.6.2</span> 考虑不确定性</a></li>
  <li><a href="#%E4%BD%BF%E7%94%A8%E6%B8%90%E8%BF%91%E8%AF%AF%E5%B7%AE" id="toc-使用渐近误差" class="nav-link" data-scroll-target="#%E4%BD%BF%E7%94%A8%E6%B8%90%E8%BF%91%E8%AF%AF%E5%B7%AE"><span class="header-section-number">7.6.3</span> 使用渐近误差</a></li>
  <li><a href="#%E4%BD%BF%E7%94%A8-bootstrap-%E5%8F%82%E6%95%B0%E5%90%91%E9%87%8F" id="toc-使用-bootstrap-参数向量" class="nav-link" data-scroll-target="#%E4%BD%BF%E7%94%A8-bootstrap-%E5%8F%82%E6%95%B0%E5%90%91%E9%87%8F"><span class="header-section-number">7.6.4</span> 使用 Bootstrap 参数向量</a></li>
  <li><a href="#%E4%BD%BF%E7%94%A8%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%90%8E%E9%AA%8C%E6%A0%B7%E6%9C%AC" id="toc-使用贝叶斯后验样本" class="nav-link" data-scroll-target="#%E4%BD%BF%E7%94%A8%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%90%8E%E9%AA%8C%E6%A0%B7%E6%9C%AC"><span class="header-section-number">7.6.5</span> 使用贝叶斯后验样本</a></li>
  </ul>
</li>
  <li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD" id="toc-结束语" class="nav-link" data-scroll-target="#%E7%BB%93%E6%9D%9F%E8%AF%AD"><span class="header-section-number">7.7</span> 结束语</a></li>
  <li><a href="#%E9%99%84%E5%BD%95%E4%BD%BF%E7%94%A8-rcpp-%E4%BB%A3%E6%9B%BF-simpspm" id="toc-附录使用-rcpp-代替-simpspm" class="nav-link" data-scroll-target="#%E9%99%84%E5%BD%95%E4%BD%BF%E7%94%A8-rcpp-%E4%BB%A3%E6%9B%BF-simpspm"><span class="header-section-number">7.8</span> 附录：使用 Rcpp 代替 simpspm</a></li>
  </ul></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block default"><div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title"><span id="sec-surplusproduction" class="quarto-section-identifier"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">剩余产量模型</span></span></h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> 代码</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">显示所有代码</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">隐藏所有代码</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">查看源代码</a></li></ul></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header><section id="引言" class="level2" data-number="7.1"><h2 data-number="7.1" class="anchored" data-anchor-id="引言">
<span class="header-section-number">7.1</span> 引言</h2>
<p>在前面的章节中，我们已经使用并拟合了所谓的静态模型，这些模型在一段时间内是稳定的（<em>例如</em>，使用<code><a href="https://rdrr.io/pkg/MQMF/man/vB.html">vB()</a></code> 、<code><a href="https://rdrr.io/pkg/MQMF/man/Gz.html">Gz()</a></code>或<code><a href="https://rdrr.io/pkg/MQMF/man/mm.html">mm()</a></code> 的生长模型 ）。此外，在第 <a href="04-application.html" class="quarto-xref"><span>4</span></a> 章 <a href="./04-application.html">模型参数估计</a> 和第 <a href="06-uncertainty.html" class="quarto-xref"><span>6</span></a> 章<a href="./06-uncertainty.html">不确定性</a>两章中，我们已经介绍了剩余产量模型（surplus production model, spm），这些模型可用于进行资源评估（例如 Schaefer 模型），并提供了一个时间序列数据的动态模型的示例。然而，当我们专注于特定的建模方法时，此类模型的细节开发受到限制。我们将在本章深入研究剩余产量模型。</p>
<p>剩余产量模型（或者生物量动态模型）<span class="citation" data-cites="hilborn1992">(<a href="08-references.html#ref-hilborn1992" role="doc-biblioref">Hilborn 和 Walters 1992</a>)</span> 将补充、生长和死亡率（生产的所有方面）的总体效应汇集到一个单一的生产方程中，处理无差异的生物量（或数量）。“无差异的（undifferentiated）”一词意味着忽略了年龄和长度组成以及性别和其他差异的所有方面，实际上都被忽略了。</p>
<p>为了进行正式的种群评估，就必须以某种方式对已开发资源的动态行为和生产力进行建模。这些动态的主要组分是种群对不同捕捞压力随时间推移的反应方式，即其资源量增加或减少的程度。通过研究不同捕捞强度水平的影响，一般可以评估种群的生产力。剩余产量模型提供了最简单的种群评估，尝试在模型与渔业数据拟合的基础上对种群动态进行描述。</p>
<p>在20世纪50年代，<span class="citation" data-cites="schaefer1957">M. B. Schaefer (<a href="08-references.html#ref-schaefer1957" role="doc-biblioref">1957</a>)</span>; <span class="citation" data-cites="schaefer1991">M. Schaefer (<a href="08-references.html#ref-schaefer1991" role="doc-biblioref">1991</a>)</span> 描述了如何使用剩余产量模型来生成渔业种群评估。此后，这些模型得到很多发展 <span class="citation" data-cites="hilborn1992 prager1994 haddon2011 winker2018">(<a href="08-references.html#ref-hilborn1992" role="doc-biblioref">Hilborn 和 Walters 1992</a>; <a href="08-references.html#ref-prager1994" role="doc-biblioref">Prager 1994</a>; <a href="08-references.html#ref-haddon2011" role="doc-biblioref">Haddon 2011</a>; <a href="08-references.html#ref-winker2018" role="doc-biblioref">Winker, Carvalho, 和 Kapur 2018</a>)</span>，我们将在本章简要介绍这些较近期的动态模型。</p>
<section id="数据需求" class="level3" data-number="7.1.1"><h3 data-number="7.1.1" class="anchored" data-anchor-id="数据需求">
<span class="header-section-number">7.1.1</span> 数据需求</h3>
<p>估算这种模型的现代离散模型参数所需的最基本数据至少是一个相对丰度指数的时间序列和一个相关的渔获量数据时间序列。渔获量数据可以涵盖比相对丰度指数数据的年份更长。简单模型中使用的相对种群丰度指数一般是单位努力渔获量（cpue），但也可以是一些与渔业无关的丰度指数（例如，来自拖网调查、声学调查），或者两者皆具。</p>
</section><section id="对比的需求" class="level3" data-number="7.1.2"><h3 data-number="7.1.2" class="anchored" data-anchor-id="对比的需求">
<span class="header-section-number">7.1.2</span> 对比的需求</h3>
<p>尽管最近偶尔使用 <span class="citation" data-cites="elder1979 saila1979 punt1997">(<a href="08-references.html#ref-elder1979" role="doc-biblioref">Elder 1979</a>; <a href="08-references.html#ref-saila1979" role="doc-biblioref">Saila 等 1979</a>; <a href="08-references.html#ref-punt1997" role="doc-biblioref">Punt 和 Hilborn 1997</a>)</span>，但剩余产量模型在 20 世纪 80 年代似乎不再流行。可能是因为在开发这些模型的早期，须假设被评估的种群处于平衡状态 <span class="citation" data-cites="elder1979 saila1979">(<a href="08-references.html#ref-elder1979" role="doc-biblioref">Elder 1979</a>; <a href="08-references.html#ref-saila1979" role="doc-biblioref">Saila 等 1979</a>)</span>，而这往往导致过于乐观的结论，从长远来看是站不住脚的。<span class="citation" data-cites="hilborn1979">Hilborn (<a href="08-references.html#ref-hilborn1979" role="doc-biblioref">1979</a>)</span> 分析了许多此类情况，并证明使用的数据往往过于单一；他们的努力量水平上缺乏对比，因此对相关种群的动态缺乏信息。数据缺乏对比度意味着渔获量和努力量信息只能用于有限范围的种群丰度水平和有限的捕捞强度水平。有限的努力强度范围意味着对不同捕捞强度水平的反应范围也将有限。当种群动态更多地受环境因素而非渔获量的驱动时，也会出现这种对比的缺乏，因此种群似乎以意想不到的方式对渔业做出反应（例如，尽管渔获量或努力量没有变化，但种群发生了巨大变化）。</p>
<p>剩余产量模型的一个重要假设是，所使用的相对丰度度量能够提供了种群相对丰度随时间的信息指标。一般来说，假设种群丰度与 CPUE 或其他指数之间存在线性关系（尽管这不一定是 1：1 的关系）。显而易见的风险是，这个假设要么是错误的，要么可以根据情况发生变化。例如，cpue 可能会变得非常稳定，这意味着即使种群数量减少或增加，它也不会发生变化。或者，由于外部因素影响，指数的变化可能会非常大，以至于无法检测到丰度趋势。例如，可能会观察到不同年份间 CPUE 的巨大变化，但考虑到种群的生产力，这种变化在生物学上是不可能的 （Haddon，2018）。</p>
<p>一个不同但相关的假设是，努力量的质量和随后的渔获率在一段时间内保持不变。不幸的是，由于捕捞网具的技术变化、捕捞行为或方法的改变，或捕捞效率的其他变化，从而形成“努力量爬升”的概念，对于依赖 CPUE 作为相对丰度指数的评估来说，总是一个挑战或问题。努力量递增变的概念意味着努力量的有效性增加，因此任何基于名义努力量观测到的名义 cpue都会高估相对种群丰度（偏高）。cpue 的统计标准化 （Kimura，1981；Haddon，2018）可以解决其中一些问题，但显然只能考虑可获得数据的因素。例如，如果在渔业中引入 GPS 绘图仪或彩色回声测深仪，这往往会提高捕捞效率，但却没有记录哪些船只以及何时引入这些设备，那么这些设备对渔获率的正面影响将无法通过标准化来解释。</p>
</section><section id="渔获率何时具有参考价值" class="level3" data-number="7.1.3"><h3 data-number="7.1.3" class="anchored" data-anchor-id="渔获率何时具有参考价值">
<span class="header-section-number">7.1.3</span> 渔获率何时具有参考价值</h3>
<p>检验丰度与任何相对丰度指数之间的假定关系是否真实和有信息的一个可能方法是，在发达渔业中，如果允许渔获量增加，预计 cpue 会在一段时间后开始下降。同样，如果渔获量减少到小于剩余产量（可能是通过管理或营销变化），那么随着种群规模的增加，预计cpue会在一段时间后很快增加。其原理是，如果渔获量低于种群当前的产量，那么最终种群规模和 cpue 都会增加，反之亦然。如果渔获量因供应不足而下降，但仍保持或高于当前生产力，则 cpue 当然不会增加，甚至可能进一步下降，尽管渔获量可能略有减少。重点放在发达渔业上，因为当渔业开始时，生物量的任何初始枯竭都会导致 “意外”渔 获量 <span class="citation" data-cites="maccall2009">(<a href="08-references.html#ref-maccall2009" role="doc-biblioref">MacCall 2009</a>)</span>，因为种群被捕捞减少，这反过来又会导致 cpue 水平，一旦种群从未捕获水平减少，cpue 水平将无法维持。</p>
<p>因此，预计在发达渔业中，cpue 在许多情况下与渔获量呈负相关，可能在 cpue 随渔获量变化而变化之间存在时滞。如果我们能发现这种关系，通常意味着数据中存在一定程度的反差；如果我们找不到这种负相关关系，通常意味着数据中有关种群如何对渔业做出反应的信息含量太低，无法仅根据渔获量和相对丰度指数进行评估。也就是说，在渔获量的基础上，相对丰度指数几乎没有增加更多的信息。</p>
<p>我们将使用 <strong>MQMF</strong> 数据集 <em>schaef</em> 来说明这些观点。<em>Schaefer</em> 包含 <span class="citation" data-cites="schaefer1957">M. B. Schaefer (<a href="08-references.html#ref-schaefer1957" role="doc-biblioref">1957</a>)</span> 原始黄鳍金枪鱼数据的渔获量和 CPUE，这是使用剩余产量模型进行种群评估的早期范例。</p>
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb1"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Yellowfin-tuna data from Schaefer 12957</span></span>
<span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/haddonm/MQMF/">MQMF</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://tidyverse.tidyverse.org">tidyverse</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://gt.rstudio.com">gt</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://patchwork.data-imaginist.com">patchwork</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://yihui.org/knitr/">knitr</a></span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="va">schaef</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/knitr/man/kable.html">kable</a></span><span class="op">(</span><span class="va">schaef</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">11</span>,<span class="op">]</span>, digits <span class="op">=</span> <span class="fl">3</span>, row.names <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb2"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/knitr/man/kable.html">kable</a></span><span class="op">(</span><span class="va">schaef</span><span class="op">[</span><span class="fl">12</span><span class="op">:</span><span class="fl">22</span>,<span class="op">]</span>, digits <span class="op">=</span> <span class="fl">3</span>, row.names <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div id="tbl-spm1" class="quarto-layout-panel anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-spm1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
表&nbsp;7.1: 1934 - 1955年的黄鳍金枪鱼渔业数据（Schaefer，1957）。 渔获量以千磅为单位，努力量以千个标准4级剪网日为单位，cpue以千磅/日为单位。
</figcaption><div aria-describedby="tbl-spm1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<table class="do-not-create-environment cell table">
<thead><tr class="header">
<th style="text-align: right;">year</th>
<th style="text-align: right;">catch</th>
<th style="text-align: right;">effort</th>
<th style="text-align: right;">cpue</th>
</tr></thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">1934</td>
<td style="text-align: right;">60913</td>
<td style="text-align: right;">5879</td>
<td style="text-align: right;">10.361</td>
</tr>
<tr class="even">
<td style="text-align: right;">1935</td>
<td style="text-align: right;">72294</td>
<td style="text-align: right;">6295</td>
<td style="text-align: right;">11.484</td>
</tr>
<tr class="odd">
<td style="text-align: right;">1936</td>
<td style="text-align: right;">78353</td>
<td style="text-align: right;">6771</td>
<td style="text-align: right;">11.572</td>
</tr>
<tr class="even">
<td style="text-align: right;">1937</td>
<td style="text-align: right;">91522</td>
<td style="text-align: right;">8233</td>
<td style="text-align: right;">11.116</td>
</tr>
<tr class="odd">
<td style="text-align: right;">1938</td>
<td style="text-align: right;">78288</td>
<td style="text-align: right;">6830</td>
<td style="text-align: right;">11.462</td>
</tr>
<tr class="even">
<td style="text-align: right;">1939</td>
<td style="text-align: right;">110417</td>
<td style="text-align: right;">10488</td>
<td style="text-align: right;">10.528</td>
</tr>
<tr class="odd">
<td style="text-align: right;">1940</td>
<td style="text-align: right;">114590</td>
<td style="text-align: right;">10801</td>
<td style="text-align: right;">10.609</td>
</tr>
<tr class="even">
<td style="text-align: right;">1941</td>
<td style="text-align: right;">76841</td>
<td style="text-align: right;">9584</td>
<td style="text-align: right;">8.018</td>
</tr>
<tr class="odd">
<td style="text-align: right;">1942</td>
<td style="text-align: right;">41965</td>
<td style="text-align: right;">5961</td>
<td style="text-align: right;">7.040</td>
</tr>
<tr class="even">
<td style="text-align: right;">1943</td>
<td style="text-align: right;">50058</td>
<td style="text-align: right;">5930</td>
<td style="text-align: right;">8.441</td>
</tr>
<tr class="odd">
<td style="text-align: right;">1944</td>
<td style="text-align: right;">64094</td>
<td style="text-align: right;">6397</td>
<td style="text-align: right;">10.019</td>
</tr>
</tbody>
</table>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<table class="do-not-create-environment cell table">
<thead><tr class="header">
<th style="text-align: right;">year</th>
<th style="text-align: right;">catch</th>
<th style="text-align: right;">effort</th>
<th style="text-align: right;">cpue</th>
</tr></thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">1945</td>
<td style="text-align: right;">89194</td>
<td style="text-align: right;">9377</td>
<td style="text-align: right;">9.512</td>
</tr>
<tr class="even">
<td style="text-align: right;">1946</td>
<td style="text-align: right;">129701</td>
<td style="text-align: right;">13958</td>
<td style="text-align: right;">9.292</td>
</tr>
<tr class="odd">
<td style="text-align: right;">1947</td>
<td style="text-align: right;">160134</td>
<td style="text-align: right;">20381</td>
<td style="text-align: right;">7.857</td>
</tr>
<tr class="even">
<td style="text-align: right;">1948</td>
<td style="text-align: right;">200340</td>
<td style="text-align: right;">23984</td>
<td style="text-align: right;">8.353</td>
</tr>
<tr class="odd">
<td style="text-align: right;">1949</td>
<td style="text-align: right;">192458</td>
<td style="text-align: right;">23013</td>
<td style="text-align: right;">8.363</td>
</tr>
<tr class="even">
<td style="text-align: right;">1950</td>
<td style="text-align: right;">224810</td>
<td style="text-align: right;">31856</td>
<td style="text-align: right;">7.057</td>
</tr>
<tr class="odd">
<td style="text-align: right;">1951</td>
<td style="text-align: right;">183685</td>
<td style="text-align: right;">18726</td>
<td style="text-align: right;">9.809</td>
</tr>
<tr class="even">
<td style="text-align: right;">1952</td>
<td style="text-align: right;">192234</td>
<td style="text-align: right;">31529</td>
<td style="text-align: right;">6.097</td>
</tr>
<tr class="odd">
<td style="text-align: right;">1953</td>
<td style="text-align: right;">138918</td>
<td style="text-align: right;">36423</td>
<td style="text-align: right;">3.814</td>
</tr>
<tr class="even">
<td style="text-align: right;">1954</td>
<td style="text-align: right;">138623</td>
<td style="text-align: right;">24995</td>
<td style="text-align: right;">5.546</td>
</tr>
<tr class="odd">
<td style="text-align: right;">1955</td>
<td style="text-align: right;">140581</td>
<td style="text-align: right;">17806</td>
<td style="text-align: right;">7.895</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</figure>
</div>
<p>渔获量、cpue 及其关系图（<a href="#fig-spm1" class="quarto-xref">图&nbsp;<span>7.1</span></a>）仅显示 cpue 和渔获量之间微弱的负相关关系。如果我们用 <code>summary(model)</code> 检验 <code><a href="https://rdrr.io/r/stats/lm.html">lm()</a></code> 回归结果，我们发现回归仅有 <span class="math inline">\(P = 0.04575\)</span> 的显著性。但是，这反映了没有时滞的相关性，即 <span class="math inline">\(lag = 0\)</span> 。我们不知道需要经过多少年才能发现渔获量变化对 cpue 的潜在影响，因此，需要对 cpue 和渔获量之间进行时滞相关分析；为此，我们可以使用基本 R 语言的交互相关函数 <code><a href="https://rdrr.io/r/stats/acf.html">ccf()</a></code> 。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb3"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># schaef fishery data and regress cpue and catch    Fig 7.1</span></span>
<span><span class="co"># parset(plots=c(3,1),margin=c(0.35,0.4,0.05,0.05))</span></span>
<span><span class="co"># plot1(schaef[,"year"],schaef[,"catch"],ylab="Catch",xlab="Year",</span></span>
<span><span class="co">#       defpar=FALSE,lwd=2)</span></span>
<span><span class="co"># plot1(schaef[,"year"],schaef[,"cpue"],ylab="CPUE",xlab="Year",</span></span>
<span><span class="co">#       defpar=FALSE,lwd=2)</span></span>
<span><span class="co"># plot1(schaef[,"catch"],schaef[,"cpue"],type="p",ylab="CPUE",</span></span>
<span><span class="co">#       xlab="Catch",defpar=FALSE,pch=16,cex=1.0)</span></span>
<span><span class="co"># model &lt;- lm(schaef[,"cpue"] ~ schaef[,"catch"])</span></span>
<span><span class="co"># abline(model,lwd=2,col=2)   # summary(model)</span></span>
<span></span>
<span></span>
<span><span class="va">p1</span><span class="op">&lt;-</span> <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html">ggplot</a></span><span class="op">(</span>data <span class="op">=</span> <span class="va">schaef</span>, <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html">aes</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">year</span>, y <span class="op">=</span> <span class="va">catch</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_path.html">geom_line</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/labs.html">labs</a></span><span class="op">(</span>x <span class="op">=</span> <span class="st">"Year"</span>, y <span class="op">=</span> <span class="st">"Catch"</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggtheme.html">theme_bw</a></span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="va">p2</span><span class="op">&lt;-</span> <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html">ggplot</a></span><span class="op">(</span>data <span class="op">=</span> <span class="va">schaef</span>, <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html">aes</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">year</span>, y <span class="op">=</span> <span class="va">cpue</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_path.html">geom_line</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/labs.html">labs</a></span><span class="op">(</span>x <span class="op">=</span> <span class="st">"Year"</span>, y <span class="op">=</span> <span class="st">"CPUE"</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggtheme.html">theme_bw</a></span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="va">p3</span><span class="op">&lt;-</span> <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html">ggplot</a></span><span class="op">(</span>data <span class="op">=</span> <span class="va">schaef</span>, <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html">aes</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">catch</span>, y <span class="op">=</span> <span class="va">cpue</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_point.html">geom_point</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_smooth.html">geom_smooth</a></span><span class="op">(</span>method <span class="op">=</span> <span class="st">"lm"</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/labs.html">labs</a></span><span class="op">(</span>x <span class="op">=</span> <span class="st">"Catch"</span>, y <span class="op">=</span> <span class="st">"CPUE"</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggtheme.html">theme_bw</a></span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span>  <span class="va">p1</span><span class="op">/</span><span class="va">p2</span><span class="op">/</span><span class="va">p3</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-spm1" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-spm1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="07-spm_files/figure-html/fig-spm1-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spm1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;7.1: Schaefer（1957）黄鳍金枪鱼渔业数据的各年渔获量和捕获量， 以及它们之间的回归关系。
</figcaption></figure>
</div>
</div>
</div>
<p>如前所述，有迹象表明 <span class="math inline">\(\text{time-lag} = 0\)</span> 只是刚刚显著。然而，在时滞2年时，CPUE与渔获量呈显著负相关（<a href="#fig-spm2" class="quarto-xref">图&nbsp;<span>7.2</span></a>），表明黄鳍金枪鱼数据中有足够的对比度来为剩余产量模型提供信息（在 1 年、3 年和 4 年也有显著影响）。如果我们将 CPUE 数据物理滞后两年，这种相关性应该会变得更加明显（ <a href="#fig-spm3" class="quarto-xref">图&nbsp;<span>7.3</span></a>）。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb4"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># cross correlation between cpue and catch in schaef Fig 7.2</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/parset.html">parset</a></span><span class="op">(</span>cex <span class="op">=</span> <span class="fl">0.85</span><span class="op">)</span> <span class="co"># sets par parameters for a tidy base graphic</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/stats/acf.html">ccf</a></span><span class="op">(</span></span>
<span>    x <span class="op">=</span> <span class="va">schaef</span><span class="op">[</span>, <span class="st">"catch"</span><span class="op">]</span>, y <span class="op">=</span> <span class="va">schaef</span><span class="op">[</span>, <span class="st">"cpue"</span><span class="op">]</span>, type <span class="op">=</span> <span class="st">"correlation"</span>,</span>
<span>    ylab <span class="op">=</span> <span class="st">"Correlation"</span>, plot <span class="op">=</span> <span class="cn">TRUE</span></span>
<span><span class="op">)</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-spm2" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-spm2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="07-spm_files/figure-html/fig-spm2-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spm2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;7.2: 使用 R 中的 <code><a href="https://rdrr.io/r/stats/acf.html">ccf()</a></code> 函数获得的 Schaefer（1957）黄鳍金枪鱼渔业数据 (schaef) 的渔获量与 cpue 之间的交叉相关性。
</figcaption></figure>
</div>
</div>
</div>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb5"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># now plot schaef data with timelag of 2 years on cpue   Fig 7.3</span></span>
<span><span class="va">model2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html">lm</a></span><span class="op">(</span><span class="va">schaef</span><span class="op">[</span><span class="fl">3</span><span class="op">:</span><span class="fl">22</span>, <span class="st">"cpue"</span><span class="op">]</span> <span class="op">~</span> <span class="va">schaef</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">20</span>, <span class="st">"catch"</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="co"># parset(plots=c(3,1),margin=c(0.35,0.4,0.05,0.05))</span></span>
<span><span class="co"># plot1(schaef[1:20,"year"],schaef[1:20,"catch"],ylab="Catch",</span></span>
<span><span class="co">#       xlab="Year",defpar=FALSE,lwd=2)</span></span>
<span><span class="co"># plot1(schaef[3:22,"year"],schaef[3:22,"cpue"],ylab="CPUE",</span></span>
<span><span class="co">#       xlab="Year",defpar=FALSE,lwd=2)</span></span>
<span><span class="co"># plot(schaef[1:20,"catch"],schaef[3:22,"cpue"],type="p",</span></span>
<span><span class="co">#       ylab="CPUE",xlab="Catch",defpar=FALSE,cex=1.0,pch=16)</span></span>
<span><span class="co">#</span></span>
<span><span class="co"># abline(model2,lwd=2,col=2)</span></span>
<span></span>
<span><span class="va">p1</span> <span class="op">&lt;-</span> <span class="va">schaef</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://dplyr.tidyverse.org/reference/filter.html">filter</a></span><span class="op">(</span><span class="va">year</span> <span class="op">&lt;=</span> <span class="fl">1953</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html">ggplot</a></span><span class="op">(</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html">aes</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">year</span>, y <span class="op">=</span> <span class="va">catch</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_path.html">geom_line</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggtheme.html">theme_bw</a></span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="va">p2</span> <span class="op">&lt;-</span> <span class="va">schaef</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://dplyr.tidyverse.org/reference/filter.html">filter</a></span><span class="op">(</span><span class="va">year</span> <span class="op">&gt;</span> <span class="fl">1935</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html">ggplot</a></span><span class="op">(</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html">aes</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">year</span>, y <span class="op">=</span> <span class="va">cpue</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_path.html">geom_line</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggtheme.html">theme_bw</a></span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="va">l</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">schaef</span><span class="op">)</span></span>
<span><span class="va">schaef1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span></span>
<span>    catch <span class="op">=</span> <span class="va">schaef</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="op">(</span><span class="va">l</span> <span class="op">-</span> <span class="fl">2</span><span class="op">)</span>, <span class="st">"catch"</span><span class="op">]</span>,</span>
<span>    cpue <span class="op">=</span> <span class="va">schaef</span><span class="op">[</span><span class="fl">3</span><span class="op">:</span><span class="va">l</span>, <span class="st">"cpue"</span><span class="op">]</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">p3</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html">ggplot</a></span><span class="op">(</span>data <span class="op">=</span> <span class="va">schaef1</span>, <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html">aes</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">catch</span>, y <span class="op">=</span> <span class="va">cpue</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_point.html">geom_point</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_smooth.html">geom_smooth</a></span><span class="op">(</span>method <span class="op">=</span> <span class="st">"lm"</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggtheme.html">theme_bw</a></span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="va">p1</span><span class="op">/</span><span class="va">p2</span><span class="op">/</span><span class="va">p3</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-spm3" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-spm3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="07-spm_files/figure-html/fig-spm3-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spm3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;7.3: Schaefer （1957）黄鳍金枪鱼渔业数据中的渔获量和 cpue 及其关系。当 cpue 时间序列的负滞后期为 2 年时，负相关或反相关关系变得更加明显。
</figcaption></figure>
</div>
</div>
</div>
<p><span class="citation" data-cites="schaefer1957">M. B. Schaefer (<a href="08-references.html#ref-schaefer1957" role="doc-biblioref">1957</a>)</span> 的黄鳍金枪鱼渔业数据中 cpue 与渔获量之间的关系，对 cpue 时间序列施加了2年的负时滞后（第3：22行与第1：20行）。极小的梯度反映了以千磅为单位报告的渔获量。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb6"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># write out a summary of he regression model2</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html">summary</a></span><span class="op">(</span><span class="va">model2</span><span class="op">)</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>
Call:
lm(formula = schaef[3:22, "cpue"] ~ schaef[1:20, "catch"])

Residuals:
     Min       1Q   Median       3Q      Max 
-3.10208 -0.92239 -0.06399  1.04280  3.11900 

Coefficients:
                        Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept)            1.165e+01  7.863e-01  14.814 1.59e-11 ***
schaef[1:20, "catch"] -2.576e-05  6.055e-06  -4.255 0.000477 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 1.495 on 18 degrees of freedom
Multiple R-squared:  0.5014,    Adjusted R-squared:  0.4737 
F-statistic:  18.1 on 1 and 18 DF,  p-value: 0.0004765</code></pre>
</div>
</div>
</section></section><section id="一些方程" class="level2" data-number="7.2"><h2 data-number="7.2" class="anchored" data-anchor-id="一些方程">
<span class="header-section-number">7.2</span> 一些方程</h2>
<p>使用相对丰度指数来描述评估种群的动态。该指数无论如何得到，都假定其反映了用于估算该指数的方法（渔业相关的 cpue 或独立调查）所能获得的生物量，并且假定该生物量受到捕捞渔获量的影响。这意味着，如果我们使用商业单位努力量渔获量（cpue），严格来说，我们处理的是可开发生物量，而不是繁殖生物量（这是种群评估更常见的目标）。不过，一般假设捕捞的选择性接近成熟度曲线，因此所使用的指数仍是繁殖生物量指数，至少是近似指数。即便如此，在得出这样的结论之前，仍应明确考虑究竟指的是什么。</p>
<p>一般来讲，动态变化是指年 <span class="math inline">\(t\)</span> 起始时的生物量方程，尽管根据定义，它可以指一年中的不同日期。请记住，一年的结束日期与下一年的起始日期实际上是相同的，但具体使用哪个日期会影响分析的开始和结束（例如，从哪个生物量年去除特定年份的渔获量）：</p>
<p><span id="eq-spm1"><span class="math display">\[
\begin{aligned}
B_0 &amp;= B_{init} \\
B_{t+1} &amp;= B_t + rB_t \left(1-\dfrac{B_t}{K} \right) - C_t
\end{aligned}
\qquad(7.1)\]</span></span></p>
<p>其中 <span class="math inline">\(B_{init}\)</span> 为数据开始时的初始生物量。如果数据从捕捞开始就有，那么<span class="math inline">\(B_{init} = K\)</span> ， <span class="math inline">\(K\)</span> 是承载能力或未捕捞时的生物量。<span class="math inline">\(B_t\)</span> 表示<span class="math inline">\(t\)</span> 年初的种群生物量，<span class="math inline">\(r\)</span> 表示种群的内禀生长率，以及 <span class="math inline">\(rB_t\left(1-\dfrac{B_t}{K} \right)\)</span> 表示种群生物量的生产函数，该函数考虑了新个体的补充、现存个体生物量的任何增长、自然死亡率，并假设密度对种群增长率的线性影响。最后的项，<span class="math inline">\(C_t\)</span> 是年 <span class="math inline">\(t\)</span> 的渔获量，表示了捕捞死亡率。每一项所指的年份非常重要，因为它决定了方程中的动态建模方式以及随后的 R 代码。</p>
<p>为了将这种评估模型的动态与现实世界进行比较和拟合，还利用模型动态生成每年相对丰度指数的预测值：</p>
<p><span id="eq-spm2"><span class="math display">\[
\hat {I}_{t}=\frac{{C}_{t}}{{E}_{t}}=q{B}_{t}  
\qquad(7.2)\]</span></span></p>
<p>式中 <span class="math inline">\(\hat I_t\)</span> 是年 <span class="math inline">\(t\)</span> 相对丰度指数的预测或估计平均值，与观测到的指数进行比较，使模型与数据相匹配。<span class="math inline">\(E_t\)</span> 是年 <span class="math inline">\(t\)</span> 的捕捞努力量，<span class="math inline">\(q\)</span> 是可捕系数（定义为生物量/单位努力量的渔获量）。这种关系还提出了一个强有力的假设，即种群生物量就是所谓的动态库。这意味着，无论地理距离如何，渔业或环境对种群动态的任何影响都会在所用的每个时间段内（通常为一年，但可能更短）对整个种群产生影响。这是一个强有力的假设，特别是如果一个种群中出现任何一致的空间结构，或者渔业的地理规模使得一个区域的鱼需要大量时间才能到达另一个区域。同样，需要了解这些假设，才能理解其局限性并适当地解释任何此类分析。</p>
<section id="产量方程" class="level3" data-number="7.2.1"><h3 data-number="7.2.1" class="anchored" data-anchor-id="产量方程">
<span class="header-section-number">7.2.1</span> 产量方程</h3>
<p>已经提出了大量的方程形式来描述种群的生产力以及如何响应资源量。我们将考虑两个形式，即 Schaefer 模型和 Fox （1970） 模型的修改形式，以及包含这两种模型的概括：</p>
<p>Schaefer（1954,1957）模型的产量方程为：</p>
<p><span id="eq-spm3"><span class="math display">\[
f\left( {B}_{t}\right)=r{B}_{t}\left( 1-\frac{{B}_{t}}{K} \right)  
\qquad(7.3)\]</span></span></p>
<p>而 Fox(1970) 模型的修改版本使用：</p>
<p><span id="eq-spm4"><span class="math display">\[
f\left( {B_t}\right)=\log({K})r{B}_{t}\left( 1-\frac{\log({B_t})}{\log({K})}\right)  
\qquad(7.4)\]</span></span></p>
<p>该修改版本将 <span class="math inline">\(\log(K)\)</span> 作为第一项，其作用仅仅是将最大生产率保持在 Schaefer 模型中类似参数大致相当的水平。</p>
<p>Pella和Tomlinson（1969）提出了一个广义产量方程，其中包括了 Schaefer 和 Fox 模型作为特例的情况。在此，我们将使用 <span class="citation" data-cites="polacheck1993">Polacheck, Hilborn, 和 Punt (<a href="08-references.html#ref-polacheck1993" role="doc-biblioref">1993</a>)</span> 提出的替代公式，它提供了种群动态的一般方程，可用于 Schaefer 和 Fox 模型，以及两者之间的渐变，具体取决于单个参数 <span class="math inline">\(p\)</span> 的值。</p>
<p><span id="eq-spm5"><span class="math display">\[
B_{t+1}=B_t + rB_t \frac{1}{p}\left(1-\left(\dfrac{B_t}{K} \right)^p \right)-C_t
\qquad(7.5)\]</span></span></p>
<p>其中第一项，<span class="math inline">\(B_t\)</span>，是时间 <span class="math inline">\(t\)</span> 的种群生物量，最后一项 <span class="math inline">\(C_t\)</span>，是时间 <span class="math inline">\(t\)</span> 的渔获量。中间项是比较复杂的部分，定义了产量曲线。它由种群的瞬时增长率 <span class="math inline">\(r\)</span> 、时间 <span class="math inline">\(t\)</span> 的现存生物量 <span class="math inline">\(B_t\)</span>、环境容纳量或最大种群数量 <span class="math inline">\(K\)</span>，以及控制产量曲线任何不对称性的项 <span class="math inline">\(p\)</span> 组成。如果将 <span class="math inline">\(p\)</span> 设置为 1.0（<strong>MQMF</strong> 中 <code><a href="https://rdrr.io/pkg/MQMF/man/discretelogistic.html">discretelogistic()</a></code> 函数的默认值），该公式简化为经典的 Schaefer 模型 （Schaefer， 1954， 1957）。<span class="citation" data-cites="polacheck1993">Polacheck, Hilborn, 和 Punt (<a href="08-references.html#ref-polacheck1993" role="doc-biblioref">1993</a>)</span> 引入了上述公式，但往往称之为 Pella-Tomlinson（1969）剩余产量模型（尽管他们的公式不同，但具有非常相似的性质）。</p>
<p>子项 <span class="math inline">\(rB_t\)</span> 表示不受约束的指数种群增长（因为在该差分方程中，将其加到 <span class="math inline">\(B_t\)</span> 中），只要 <span class="math inline">\(r&gt;0.0\)</span> ，将导致在没有渔获物的情况下种群持续正增长（尽管 14 世纪的瘟疫曾在一段短暂但特别不愉快的时期内扭转了这一趋势，但世界人口的正指数增长仍然是这一趋势的例证）。子项 <span class="math inline">\((1/p)(1-B_t/K)^p\)</span> 为指数增长项提供了约束条件，因为随着种群数量的增加，指数增长项的值趋于零。这被称为密度依赖（density-dependent）效应。</p>
<p>当将 <span class="math inline">\(p\)</span> 设置为 <span class="math inline">\(1.0\)</span> 时，该公式将与 Schaefer 模型相同（线性密度依赖性）。但是当 <span class="math inline">\(p\)</span> 设置为一个很小的数值时，比如 <span class="math inline">\(1e-08\)</span>，那么公式就等价于 Fox 模型的动力学公式。<span class="math inline">\(p&gt;1.0\)</span> 的值会导致生产曲线向左倾斜，而模位于中心偏右。当 <span class="math inline">\(p&gt;1\)</span> 或 <span class="math inline">\(&lt;1\)</span> 时，密度依赖性将不再是线性的。一般我们会固定 <span class="math inline">\(p\)</span> 值，而不会尝试使用数据来拟合。仅凭渔获量和相对丰度指数通常不足以估算相对种群数量对产量的详细影响。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb8"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># plot productivity and density-dependence functions Fig7.4</span></span>
<span><span class="va">prodfun</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">r</span>, <span class="va">Bt</span>, <span class="va">K</span>, <span class="va">p</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="op">(</span><span class="va">r</span> <span class="op">*</span> <span class="va">Bt</span> <span class="op">/</span> <span class="va">p</span><span class="op">)</span> <span class="op">*</span> <span class="op">(</span><span class="fl">1</span> <span class="op">-</span> <span class="op">(</span><span class="va">Bt</span> <span class="op">/</span> <span class="va">K</span><span class="op">)</span><span class="op">^</span><span class="va">p</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="va">densdep</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">Bt</span>, <span class="va">K</span>, <span class="va">p</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="op">(</span><span class="fl">1</span> <span class="op">/</span> <span class="va">p</span><span class="op">)</span> <span class="op">*</span> <span class="op">(</span><span class="fl">1</span> <span class="op">-</span> <span class="op">(</span><span class="va">Bt</span> <span class="op">/</span> <span class="va">K</span><span class="op">)</span><span class="op">^</span><span class="va">p</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="va">r</span> <span class="op">&lt;-</span> <span class="fl">0.75</span></span>
<span><span class="va">K</span> <span class="op">&lt;-</span> <span class="fl">1000.0</span></span>
<span><span class="va">Bt</span> <span class="op">&lt;-</span> <span class="fl">1</span><span class="op">:</span><span class="fl">1000</span></span>
<span><span class="va">sp</span> <span class="op">&lt;-</span> <span class="fu">prodfun</span><span class="op">(</span><span class="va">r</span>, <span class="va">Bt</span>, <span class="va">K</span>, <span class="fl">1.0</span><span class="op">)</span> <span class="co"># Schaefer equivalent</span></span>
<span><span class="va">sp0</span> <span class="op">&lt;-</span> <span class="fu">prodfun</span><span class="op">(</span><span class="va">r</span>, <span class="va">Bt</span>, <span class="va">K</span>, p <span class="op">=</span> <span class="fl">1e-08</span><span class="op">)</span> <span class="co"># Fox equivalent</span></span>
<span><span class="va">sp3</span> <span class="op">&lt;-</span> <span class="fu">prodfun</span><span class="op">(</span><span class="va">r</span>, <span class="va">Bt</span>, <span class="va">K</span>, <span class="fl">3</span><span class="op">)</span> <span class="co"># left skewed production, marine mammal?</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/parset.html">parset</a></span><span class="op">(</span>plots <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">1</span><span class="op">)</span>, margin <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.35</span>, <span class="fl">0.4</span>, <span class="fl">0.1</span>, <span class="fl">0.05</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/plot1.html">plot1</a></span><span class="op">(</span><span class="va">Bt</span>, <span class="va">sp</span>,</span>
<span>    type <span class="op">=</span> <span class="st">"l"</span>, lwd <span class="op">=</span> <span class="fl">2</span>, xlab <span class="op">=</span> <span class="st">"Stock Size"</span>,</span>
<span>    ylab <span class="op">=</span> <span class="st">"Surplus Production"</span>, maxy <span class="op">=</span> <span class="fl">200</span>, defpar <span class="op">=</span> <span class="cn">FALSE</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">Bt</span>, <span class="va">sp0</span> <span class="op">*</span> <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">max</a></span><span class="op">(</span><span class="va">sp</span><span class="op">)</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">max</a></span><span class="op">(</span><span class="va">sp0</span><span class="op">)</span><span class="op">)</span>, lwd <span class="op">=</span> <span class="fl">2</span>, col <span class="op">=</span> <span class="fl">2</span>, lty <span class="op">=</span> <span class="fl">2</span><span class="op">)</span> <span class="co"># rescale</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">Bt</span>, <span class="va">sp3</span> <span class="op">*</span> <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">max</a></span><span class="op">(</span><span class="va">sp</span><span class="op">)</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">max</a></span><span class="op">(</span><span class="va">sp3</span><span class="op">)</span><span class="op">)</span>, lwd <span class="op">=</span> <span class="fl">3</span>, col <span class="op">=</span> <span class="fl">3</span>, lty <span class="op">=</span> <span class="fl">3</span><span class="op">)</span> <span class="co"># production</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/legend.html">legend</a></span><span class="op">(</span><span class="fl">275</span>, <span class="fl">100</span>, cex <span class="op">=</span> <span class="fl">1.1</span>, lty <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fl">3</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span></span>
<span>    <span class="st">"p = 1.0 Schaefer"</span>, <span class="st">"p = 1e-08 Fox"</span>,</span>
<span>    <span class="st">"p = 3 LeftSkewed"</span></span>
<span><span class="op">)</span>, col <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span>, <span class="fl">3</span><span class="op">)</span>, lwd <span class="op">=</span> <span class="fl">3</span>, bty <span class="op">=</span> <span class="st">"n"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/plot1.html">plot1</a></span><span class="op">(</span><span class="va">Bt</span>, <span class="fu">densdep</span><span class="op">(</span><span class="va">Bt</span>, <span class="va">K</span>, p <span class="op">=</span> <span class="fl">1</span><span class="op">)</span>,</span>
<span>    xlab <span class="op">=</span> <span class="st">"Stock Size"</span>, defpar <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>    ylab <span class="op">=</span> <span class="st">"Density-Dependence"</span>, maxy <span class="op">=</span> <span class="fl">2.5</span>, lwd <span class="op">=</span> <span class="fl">2</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">Bt</span>, <span class="fu">densdep</span><span class="op">(</span><span class="va">Bt</span>, <span class="va">K</span>, <span class="fl">1e-08</span><span class="op">)</span>, lwd <span class="op">=</span> <span class="fl">2</span>, col <span class="op">=</span> <span class="fl">2</span>, lty <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">Bt</span>, <span class="fu">densdep</span><span class="op">(</span><span class="va">Bt</span>, <span class="va">K</span>, <span class="fl">3</span><span class="op">)</span>, lwd <span class="op">=</span> <span class="fl">3</span>, col <span class="op">=</span> <span class="fl">3</span>, lty <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-spm4" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-spm4-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="07-spm_files/figure-html/fig-spm4-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spm4-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;7.4: p 参数对 Polacheck 等（1993） 生产函数的影响（上图）和对密度依赖项的影响（下图）。注意生产力的重新缩放，以符合 Schaefer 曲线的结果。种群规模可以是生物量或数量。
</figcaption></figure>
</div>
</div>
</div>
<p>Schaefer 模型假设生产曲线对称，在 <span class="math inline">\(0.5K\)</span> 处具有最大剩余生产或最大持续产量（MSY），密度依赖项的线性变化趋势是，当种群数量非常小时密度依赖项为1.0，当 <span class="math inline">\(B_t\)</span> 趋于<span class="math inline">\(K\)</span> 时密度依赖项为0 。当 <span class="math inline">\(p\)</span> 的值很小时，比如说 <span class="math inline">\(p=1e-08\)</span> ，该模型近似为Fox 模型，这会产生一条不对称的生产曲线，在某个较低的消耗水平下（本例中使用 <code>bt[which.max(sp0)]</code> 发现为 <span class="math inline">\(0.368K\)</span>,），会形成最大产量。密度相关项是非线性的，最大持续产量（MSY）出现在密度相关项 = 1.0 的地方。如果不对<a href="#fig-spm4" class="quarto-xref">图&nbsp;<span>7.4</span></a> 中进行重新缩放，Fox模型通常比 Schaefer 模型更有效率，因为当种群数量低于最大持续产量生物量 <span class="math inline">\(B_{MSY}\)</span> 时，密度相关项在大于1.0。<span class="math inline">\(p&gt;1.0\)</span> 时，最大产量出现在较高的种群数量处，当种群数量较低时，种群增长率几乎呈线性增长，而只有在种群数量相当大时，才会出现密度依赖下降的情况。只发生在相当高的种群水平上。与鱼类相比，这种动态在海洋哺乳动物中更为典型。</p>
<p>可以认为 Schaefer 模型比 Fox 模型更保守，因为它需要更高的种群数量才能达到最大产量，并且通常会导致较低水平的渔获量，由于 Fox 类型模型的产量通常较高，可能会出现例外情况。</p>
</section><section id="schaefer-模型" class="level3" data-number="7.2.2"><h3 data-number="7.2.2" class="anchored" data-anchor-id="schaefer-模型">
<span class="header-section-number">7.2.2</span> Schaefer 模型</h3>
<p>对于 Schaefer 模型，我们通过设置 <span class="math inline">\(p=1.0\)</span> 得到：</p>
<p><span id="eq-spm6"><span class="math display">\[
B_{t+1} = B_t + rB_t \left(1-\dfrac{B_t}{K} \right) -C_t
\qquad(7.6)\]</span></span></p>
<p>给定渔业数据的时间序列，总会有一个初始生物量，可能是 <span class="math inline">\(B_{init} =K\)</span> 或 <span class="math inline">\(B_{init}\)</span> 是 <span class="math inline">\(K\)</span> 的某个分数，取决于在首次获得渔业数据时是否认为该种群已经枯竭。<span class="math inline">\(B_{init}\)</span> 不可能高于 <span class="math inline">\(K\)</span> ，因为实际种群往往不会表现出稳定的平衡。</p>
<p>根据数据拟合模型至少需要3个参数，即 <span class="math inline">\(r\)</span> 、<span class="math inline">\(K\)</span> 、可捕系数 <span class="math inline">\(q\)</span> （可能还需要 <span class="math inline">\(B_{init}\)</span> ）。但是，可以使用所谓的“封闭形式”方法来估计可捕获性系数 <span class="math inline">\(q\)</span>:</p>
<p><span id="eq-spm7"><span class="math display">\[
\hat q =\exp \left(\frac{1}{n}\sum \log\left(\frac{I_t}{\hat B_t} \right) \right)
\qquad(7.7)\]</span></span></p>
<p>即观测到的渔获量除以预测的可开发生物量的反演几何平均数 <span class="citation" data-cites="polacheck1993">(<a href="08-references.html#ref-polacheck1993" role="doc-biblioref">Polacheck, Hilborn, 和 Punt 1993</a>)</span>。这样就得到了时间序列的平均可捕量。如果渔业发生了重大变化，CPUE 的质量也发生了变化，则有可能对时间序列的不同部分产生不同的可捕量估计值。然而，需要注意为这种建议的模型规格进行有力的辩护，特别是用于估算的时间序列越 短，就越需要注意。 <span class="math inline">\(q\)</span> 的不确定性就越大。</p>
</section><section id="残差平方和" class="level3" data-number="7.2.3"><h3 data-number="7.2.3" class="anchored" data-anchor-id="残差平方和">
<span class="header-section-number">7.2.3</span> 残差平方和</h3>
<p>该模型可以使用最小二乘法进行拟合，或者更准确地说，可以使用残差误差的平方和进行拟合：</p>
<p><span id="eq-spm8"><span class="math display">\[
ssq = \sum \left(\log(I_t)-\log(\hat I_t) \right)^2
\qquad(7.8)\]</span></span></p>
<p>由于 CPUE 一般呈对数正态分布，而最小二乘法意味着正态随机误差，因此需要进行对数变换。最小二乘法在首先寻找一组参数，使模型与现有数据相匹配时，往往相对稳健。然而，一旦接近解决方案，如果使用最大似然法，就会有更多建模选择。全对数正态对数似然为：</p>
<p><span id="eq-spm9"><span class="math display">\[
L(data|B_{init},r,K,q)=\prod_t\dfrac{1}{I_t\sqrt{2\pi \hat \sigma}}e^{\frac{-(\log I_t-\log \hat I_t)^2}{2\hat \sigma^2}}
\qquad(7.9)\]</span></span></p>
<p>除了对数变换之外，这与插在 <span class="math inline">\(\sqrt{2\pi\hat \sigma}\)</span> 项之前相关变量（此处为 <span class="math inline">\(I_t\)</span> ）的正态 PDF 似然不同。幸运的是，如第 <a href="04-application.html" class="quarto-xref"><span>4</span></a> 章”模型参数估算“ 所示，可以对负对数似然简化 <span class="citation" data-cites="haddon2011">(<a href="08-references.html#ref-haddon2011" role="doc-biblioref">Haddon 2011</a>)</span>，变为：</p>
<p><span id="eq-spm10"><span class="math display">\[
-veLL = \frac{n}{2}(\log(2\pi)+2\log(\hat\sigma)+1)
\qquad(7.10)\]</span></span></p>
<p>其中，标准差（<span class="math inline">\(\hat \sigma\)</span>）的最大似然估计，由下式得到：</p>
<p><span id="eq-spm11"><span class="math display">\[
\hat \sigma=\sqrt{\dfrac{\sum \left(\log(I_t)-\log(\hat I_t)\right)^2}{n}}
\qquad(7.11)\]</span></span></p>
<p>注意除以 <span class="math inline">\(n\)</span> 而不是<em>除以</em> <span class="math inline">\(n-1\)</span> 。严格来讲，对于对数正态（<a href="#eq-spm10" class="quarto-xref">公式&nbsp;<span>7.10</span></a> 中），<span class="math inline">\(-veLL\)</span> 后面应该跟着一个附加项：</p>
<p><span id="eq-spm12"><span class="math display">\[
-\sum \log(I_t)
\qquad(7.12)\]</span></span></p>
<p>对数转换后的观测捕获率之和。但是，由于该项是恒量，因此通常会省略。当然，当使用 R 时，我们总是可以使用内置的概率密度函数实现（参见 <code><a href="https://rdrr.io/pkg/MQMF/man/negLL.html">negLL()</a></code> 和 <code><a href="https://rdrr.io/pkg/MQMF/man/negLL1.html">negLL1()</a></code> ），因此这种简化并不是绝对必要的，但是当人们希望使用 <strong>Rcpp</strong> 加快分析速度时，它们仍然有用，尽管 <em>Rcpp-syntactic-sugar</em>，导致 C++ 代码看起来非常像 R 代码，现在包括 <code><a href="https://rdrr.io/r/stats/Normal.html">dnorm()</a></code> 版本和相关的分布函数。</p>
</section><section id="估算管理统计" class="level3" data-number="7.2.4"><h3 data-number="7.2.4" class="anchored" data-anchor-id="估算管理统计">
<span class="header-section-number">7.2.4</span> 估算管理统计</h3>
<p>只需使用以下方法即可计算 Schaefer 模型的最大可持续产量：</p>
<p><span id="eq-spm13"><span class="math display">\[
MSY =\dfrac{rK}{4}
\qquad(7.13)\]</span></span></p>
<p>然而，对于使用 <span class="citation" data-cites="polacheck1993">(<a href="08-references.html#ref-polacheck1993" role="doc-biblioref">Polacheck, Hilborn, 和 Punt 1993</a>)</span> 的 <em>p</em> 参数的更一般方程，需要使用：</p>
<p><span id="eq-spm14"><span class="math display">\[
MSY = \dfrac{rK}{(p+1)^{\frac{(p+1)}{p}}}
\qquad(7.14)\]</span></span></p>
<p>当<span class="math inline">\(p=1.0\)</span> 时，上式可以简化为<a href="#eq-spm13" class="quarto-xref">公式&nbsp;<span>7.13</span></a>。我们可以使用 <strong>MQMF</strong> 函数<code><a href="https://rdrr.io/pkg/MQMF/man/getMSY.html">getMSY()</a></code> 来计算 <a href="#eq-spm14" class="quarto-xref">公式&nbsp;<span>7.14</span></a> ，这也说明了Fox 模型比 Schaefer 模型具有更高的生产力。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb9"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># compare Schaefer and Fox MSY estimates for same parameters</span></span>
<span><span class="va">param</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span>r <span class="op">=</span> <span class="fl">1.1</span>, K <span class="op">=</span> <span class="fl">1000.0</span>, Binit <span class="op">=</span> <span class="fl">800.0</span>, sigma <span class="op">=</span> <span class="fl">0.075</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"MSY Schaefer = "</span>, <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/getMSY.html">getMSY</a></span><span class="op">(</span><span class="va">param</span>, p <span class="op">=</span> <span class="fl">1.0</span><span class="op">)</span>, <span class="st">"\n"</span><span class="op">)</span> <span class="co"># p=1 is default</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>MSY Schaefer =  275 </code></pre>
</div>
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb11"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"MSY Fox      = "</span>, <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/getMSY.html">getMSY</a></span><span class="op">(</span><span class="va">param</span>, p <span class="op">=</span> <span class="fl">1e-08</span><span class="op">)</span>, <span class="st">"\n"</span><span class="op">)</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>MSY Fox      =  404.6674 </code></pre>
</div>
</div>
<p>当然，如果将两个模型与实际数据进行拟合，通常会为每个模型生成不同的参数，因此得到的 MSY 值可能更接近。</p>
<p>还可以生成基于努力量的管理统计数据。如果努力量水平一直持续下去，使种群达到平衡时<em>MSY</em> 的努力水平称为<span class="math inline">\(E_{MSY}\)</span> :</p>
<p><span id="eq-spm15"><span class="math display">\[
E_{MSY} =\dfrac{r}{q(1+p)}
\qquad(7.15)\]</span></span></p>
<p>其中Schaefer模型中<span class="math inline">\(E_{MSY}=r/2q\)</span> 时种群将衰竭，但对于参数 <em>p</em> 的其他值仍具有普遍性。也可以估计平衡渔获率（每年捕获的种群比例），从而得到<span class="math inline">\(B_{MSY}\)</span> ，即MSY<em>剩余</em>产量时的生物量：</p>
<p><span id="eq-spm16"><span class="math display">\[
H_{MSY}=qE_{MSY}=q\dfrac{r}{q+qp}= \dfrac{r}{1+p}
\qquad(7.16)\]</span></span></p>
<p>可以经常看到将<a href="#eq-spm16" class="quarto-xref">公式&nbsp;<span>7.16</span></a> 写为 <span class="math inline">\(F_{MSY}=qE_{MSY}\)</span> ，但这可能会产生误导，因为通常将 <span class="math inline">\(F_{MSY}\)</span> 解释为瞬时捕捞死亡率，而在这种情况下，实际上是成比例的捕捞率。出于这个原因，我明确使用了<span class="math inline">\(H_{MSY}\)</span> 。</p>
</section><section id="均衡的麻烦" class="level3" data-number="7.2.5"><h3 data-number="7.2.5" class="anchored" data-anchor-id="均衡的麻烦">
<span class="header-section-number">7.2.5</span> 均衡的麻烦</h3>
<p>现实世界中对管理目标的解释并不总是直截了当的。现在，人们认为大多数捕捞种群不可能达到平衡，因此，如果种群以最佳方式捕捞，MSY 的解释更像是平均的、长期的预期潜在产量；动态平衡可能是更好的描述。如果一直应用，<span class="math inline">\(E_{MSY}\)</span> 是到得MSY的努力量，但前提是种群生物量达到 <span class="math inline">\(B_{MSY}\)</span>，即产生最大剩余产量的生物量。每种管理统计都源自均衡思想。显然，应当通过将努力量限制在 <span class="math inline">\(E_{MSY}\)</span> 处来管理渔业，但如果种群生物量开始严重枯竭，那么将不会产生平均长期产量。事实上，<span class="math inline">\(E_{MSY}\)</span> 努力量程度可能太高，无法在这个非平衡的世界中重建种群。同样地，但仅当种群生物量为 <span class="math inline">\(B_{MSY}\)</span> 的情况下， <span class="math inline">\(H_{MSY}\)</span> 将按预期运行。可以估计导致种群恢复到 <span class="math inline">\(B_{MSY}\)</span> 的渔获量或努力量水平，可以称之为 <span class="math inline">\(F_{MSY}\)</span> ，但这需要进行种群预测并寻找最终达到预期结果的渔获量水平。我们将在后面的章节中研究如何预测种群。</p>
<p>需要强调的是，MSY观点及其相关统计是以平衡思想为基础的，在现实世界中是罕见的。充其量，动态平衡是可以实现的，但无论如何，使用这种平衡统计都存在风险。当首次提出时，大家者认为 𝑀𝑆𝑌 概念是管理渔业的合适目标。现在，尽管这一概念已作为渔业管理的总体目标纳入了一些国家渔业法案和法律，但更安全的做法是将 𝑀𝑆𝑌 作为捕捞死亡率（渔获量）的上限，是一个极限参考点，而不是目标参考点。</p>
<p>理想情况下，评估结果需要通过捕捞控制规则（HCR）传递，该规则根据估计的种群状况（捕捞死亡率和种群枯竭水平）就未来渔获量或努力量提供正式的管理建议。然而，如果不对其数值的不确定性有所了解，这些潜在的管理产出中几乎没有价值。正如我们已经指出的那样，能够将这些模型预测到未来，以便对替代管理战略进行风险评估，也将非常有用。但首先，我们需要利用模型拟合数据。</p>
</section></section><section id="模型拟合" class="level2" data-number="7.3"><h2 data-number="7.3" class="anchored" data-anchor-id="模型拟合">
<span class="header-section-number">7.3</span> 模型拟合</h2>
<p>模型参数和与模型相关的其他详细信息也可以在每个函数的帮助文件中找到（试着使用 <code><a href="https://rdrr.io/pkg/MQMF/man/spm.html">?spm</a></code> 或 <code>simpspm</code> ）。简而言之，模型参数 <span class="math inline">\(r\)</span> 为种群净增长率（综合了重量、补充和自然死亡率等方面的个体生长），<span class="math inline">\(K\)</span> 为种群环境容纳量或未捕捞时的生物量，<span class="math inline">\(B_{init}\)</span> 是第一年的生物量。只有当相对丰度数据指数（通常是 cpue）在渔业实施了几年后才可获得，这意味着种群已经在某种程度上枯竭时，才需要此参数。如果假设没有初始损耗，则参数列表中不需要 <span class="math inline">\(B_{init}\)</span> ，并且在函数中设置为等于 <span class="math inline">\(K\)</span> 。最后一个参数是 <span class="math inline">\(\sigma\)</span> ，即用于描述残差的对数正态分布的标准差。为了用最大似然法而编写了 <code><a href="https://rdrr.io/pkg/MQMF/man/simpspm.html">simpspm()</a></code> 和 <code><a href="https://rdrr.io/pkg/MQMF/man/spm.html">spm()</a></code> ，因此即使使用 <code><a href="https://rdrr.io/pkg/MQMF/man/ssq.html">ssq()</a></code> 作为最佳拟合标准，参数向量中也需要 <span class="math inline">\(\sigma\)</span> 值。</p>
<p>在澳大利亚，相对种群丰度指数通常是单位努力量渔获量（cpue），但也可以是一些与渔业无关的丰度指数（例如，来自拖网调查、声学调查），或者在某一分析中都使用两者（见 <code>simspm()</code>）。通过分析，可以提出持续管理的产量建议以及确定种群状况。</p>
<p>在本节中，我们将详细介绍如何进行剩余产量分析、如何从分析中提取结果以及如何绘制这些结果的图解。</p>
<section id="种群评估的可能工作流程" class="level3" data-number="7.3.1"><h3 data-number="7.3.1" class="anchored" data-anchor-id="种群评估的可能工作流程">
<span class="header-section-number">7.3.1</span> 种群评估的可能工作流程</h3>
<p>根据剩余产量模型进行种群评估时，可能的工作流程包括:</p>
<ol type="1">
<li><p>读取渔获量和相对丰度数据的时间序列。拥有检查数据完整性、缺失值和其他潜在问题的功能会有所帮助，但最好还是了解自己的数据及其局限性。</p></li>
<li><p>使用<code><a href="https://rdrr.io/r/stats/acf.html">ccf()</a></code> 分析以确定 cpue 数据相对于渔获量数据是否具有参考价值。 如果发现明显的负相关关系，这将增强分析的防御力。</p></li>
<li><p>定义/估计初始参数集，包括了<span class="math inline">\(r\)</span> 和 <span class="math inline">\(K\)</span> ，以及可选 <span class="math inline">\(B_{init}=\)</span> 初始生物量，如果怀疑渔业数据是在种群某种程度上消耗后才开始的，则使用该值。</p></li>
<li><p>使用函数 <code><a href="https://rdrr.io/pkg/MQMF/man/plotspmmod.html">plotspmmod()</a></code> 绘制假定的初始参数集对动力学的影响。这在寻找可信的初始参数集时非常有用。</p></li>
<li><p>使用<code><a href="https://rdrr.io/r/stats/nlm.html">nlm()</a></code> 或 <code><a href="https://rdrr.io/pkg/MQMF/man/fitSPM.html">fitSPM()</a></code> 在输入可能可行的初始参数集后，搜索最佳参数。参见讨论。</p></li>
<li><p>使用<code><a href="https://rdrr.io/pkg/MQMF/man/plotspmmod.html">plotspmmod()</a></code> 用最佳参数来说明最佳模型及其相对拟合的影响（尤其是使用残差图）。</p></li>
<li><p>理想情况下，应通过使用多个不同的初始参数集作为模型拟合过程的起点来检查模型拟合的鲁棒性，见 <code><a href="https://rdrr.io/pkg/MQMF/man/robustSPM.html">robustSPM()</a></code></p></li>
<li><p>一旦对模型拟合的鲁棒性感到满意，就可以使用<code><a href="https://rdrr.io/pkg/MQMF/man/spmphaseplot.html">spmphaseplot()</a></code> 绘制出生物量与渔获率的相图，以便直观地确定和说明种群状况。</p></li>
<li><p>使用 <code><a href="https://rdrr.io/pkg/MQMF/man/spmboot.html">spmboot()</a></code>，用渐近标准误差或 <em>On Uncertainty</em> （第 <a href="06-uncertainty.html" class="quarto-xref"><span>6</span></a> 章）中的贝叶斯方法来描述模型拟合和输出中的不确定性。将此类输出制成表格并绘制成图表。请参阅稍后内容。</p></li>
<li><p>记录并捍卫得出的任何结论。</p></li>
</ol>
<p>目前 <strong>MQMF</strong> 有两种常见的动力模型：经典的 Schaefer 模型（Schaefer，1954）和近似的 Fox 模型（Fox，1970；Polacheck等，1993），Haddon（2011）对两种模型都有描述。Prager（1994）提供了许多其他形式的分析，这些分析可以使用剩余产量模型进行，Haddon（2011）也提供了实际应用。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb13"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Initial model 'fit' to the initial parameter guess  Fig 7.5</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="va">schaef</span><span class="op">)</span></span>
<span><span class="va">schaef</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">as.matrix</a></span><span class="op">(</span><span class="va">schaef</span><span class="op">)</span></span>
<span><span class="va">param</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span>r <span class="op">=</span> <span class="fl">0.1</span>, K <span class="op">=</span> <span class="fl">2250000</span>, Binit <span class="op">=</span> <span class="fl">2250000</span>, sigma <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">negatL</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/negLL.html">negLL</a></span><span class="op">(</span><span class="va">param</span>, <span class="va">simpspm</span>, <span class="va">schaef</span>, logobs <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">schaef</span><span class="op">[</span>, <span class="st">"cpue"</span><span class="op">]</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">ans</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/plotspmmod.html">plotspmmod</a></span><span class="op">(</span></span>
<span>    inp <span class="op">=</span> <span class="va">param</span>, indat <span class="op">=</span> <span class="va">schaef</span>, schaefer <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>    addrmse <span class="op">=</span> <span class="cn">TRUE</span>, plotprod <span class="op">=</span> <span class="cn">FALSE</span></span>
<span><span class="op">)</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-spm5" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-spm5-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="07-spm_files/figure-html/fig-spm5-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spm5-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;7.5: 使用初始参数值将剩余产量模型与 schaef 数据集的暂定拟合。CPUE 图中的绿色虚线是简单的loess 拟合，而实线是猜测的输入参数所隐含的拟合。渔获量图中的水平红线是预测的 MSY。残差图中的数字是对数正态残差的均方根误差。
</figcaption></figure>
</div>
</div>
</div>
<p><span class="math inline">\(r= 0.1\)</span> 时得到 <span class="math inline">\(negatL= 8.2877\)</span> ，并且在 1950 年之前所有残差都低于1.0，之后有 4 个较大的正残差。将 <span class="math inline">\(K\)</span> 值设置为最大渔获量的10倍左右，这一数量级（10倍到20倍）的生物量通常会得到足够的生物量，使种群生物量和CPUE轨迹偏离x轴，以便进入最小化/优化程序。我们使用了<code>plotprod = FALSE</code> 选项（默认值），因为在用模型拟合数据之前，查看预测的产量曲线几乎没有意义。</p>
<p>用数值方法拟合数据模型时，通常需要采取措施确保获得稳健的且生物学上合理的拟合模型。稳健性的一个方法是对模型拟合两次，第二次拟合的输入参数来自第一次拟合。我们将使用<code><a href="https://rdrr.io/r/stats/optim.html">optim()</a></code> 和 <code><a href="https://rdrr.io/r/stats/nlm.html">nlm()</a></code>以及<code><a href="https://rdrr.io/pkg/MQMF/man/negLL1.html">negLL1()</a></code> 的组合来估计每次迭代期间的负对数似然（这是<code><a href="https://rdrr.io/pkg/MQMF/man/fitSPM.html">fitSPM()</a></code>实现的方式）。在<strong>MQMF</strong>中，我们有一个函数 <code><a href="https://rdrr.io/pkg/MQMF/man/spm.html">spm()</a></code> ，根据生物量、CPUE、消耗和渔获率的预测变化来计算所有的动态变化。虽然这样做相对较快，但为了加快迭代模型拟合过程，我们未使用<code><a href="https://rdrr.io/pkg/MQMF/man/spm.html">spm()</a></code>，而是使用<code>simspm()</code> ，仅输出预测的 CPUE 的对数，以便最小化，而不是每次都计算完整的动态。当我们只有相对丰度指数的单一时间序列时，我们使用<code>simspm()</code> 。如果我们有多个指数序列，我们将使用 <code>simpsmpM()</code> 、<code><a href="https://rdrr.io/pkg/MQMF/man/spmCE.html">spmCE()</a></code> 以及<code><a href="https://rdrr.io/pkg/MQMF/man/negLLM.html">negLLM()</a></code> ；参阅帮助文件（<code>?simpsmpM</code>、<code><a href="https://rdrr.io/pkg/MQMF/man/spmCE.html">?spmCE</a></code>、<code><a href="https://rdrr.io/pkg/MQMF/man/negLLM.html">?negLLM</a></code> ）及其代码，查阅每个示例的运行情况。除了使用 <code>simpsmpM()</code> 、<code><a href="https://rdrr.io/pkg/MQMF/man/spmCE.html">spmCE()</a></code> 和 <code><a href="https://rdrr.io/pkg/MQMF/man/negLLM.html">negLLM()</a></code> 外，对于多个时间序列的指数，它还用于说明模型拟合有时会产生生物学上难以置信的解决方案，便在数学上却是最优的解。以及第一个参数<span class="math inline">\(r\)</span> 施加惩罚，以防止其小于0.0，在多指数函数示例中使用了极端渔获量历史记录，根据起始参数，我们还需要对年渔获率进行惩罚，以确保其保持小于 1.0（见 <code><a href="https://rdrr.io/pkg/MQMF/man/penalty1.html">penalty1()</a></code>）。从生物学角度看，渔获量显然不可能超过生物量，但如果我们不对模型进行数学限制，那么渔获率非常大在数学上也没有什么问题。</p>
<p>随着我们所使用模型的复杂性增加，或者我们开始使用计算机密集型方法，对速度的考虑就变得更加重要。我们的参数都不应该变为负值，而且它们的大小差别很大，因此我们在这里使用的是自然对数转换的参数。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb14"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Fit the model first using optim then nlm in sequence</span></span>
<span><span class="va">param</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.1</span>, <span class="fl">2250000</span>, <span class="fl">2250000</span>, <span class="fl">0.5</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">pnams</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"r"</span>, <span class="st">"K"</span>, <span class="st">"Binit"</span>, <span class="st">"sigma"</span><span class="op">)</span></span>
<span><span class="va">best</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/optim.html">optim</a></span><span class="op">(</span></span>
<span>    par <span class="op">=</span> <span class="va">param</span>, fn <span class="op">=</span> <span class="va">negLL</span>, funk <span class="op">=</span> <span class="va">simpspm</span>, indat <span class="op">=</span> <span class="va">schaef</span>,</span>
<span>    logobs <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">schaef</span><span class="op">[</span>, <span class="st">"cpue"</span><span class="op">]</span><span class="op">)</span>, method <span class="op">=</span> <span class="st">"BFGS"</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/outfit.html">outfit</a></span><span class="op">(</span><span class="va">best</span>, digits <span class="op">=</span> <span class="fl">4</span>, title <span class="op">=</span> <span class="st">"Optim"</span>, parnames <span class="op">=</span> <span class="va">pnams</span><span class="op">)</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>optim solution:  Optim 
minimum     :  -7.934055 
iterations  :  41 19  iterations, gradient
code        :  0 
            par     transpar
r     -1.448503       0.2349
K     14.560701 2106842.7734
Binit 14.629939 2257885.3255
sigma -1.779578       0.1687
message     :  </code></pre>
</div>
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb16"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"\n"</span><span class="op">)</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb17"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">best2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/nlm.html">nlm</a></span><span class="op">(</span><span class="va">negLL</span>, <span class="va">best</span><span class="op">$</span><span class="va">par</span>,</span>
<span>    funk <span class="op">=</span> <span class="va">simpspm</span>, indat <span class="op">=</span> <span class="va">schaef</span>,</span>
<span>    logobs <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">schaef</span><span class="op">[</span>, <span class="st">"cpue"</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/outfit.html">outfit</a></span><span class="op">(</span><span class="va">best2</span>, digits <span class="op">=</span> <span class="fl">4</span>, title <span class="op">=</span> <span class="st">"nlm"</span>, parnames <span class="op">=</span> <span class="va">pnams</span><span class="op">)</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>nlm solution:  nlm 
minimum     :  -7.934055 
iterations  :  2 
code        :  2 &gt;1 iterates in tolerance, probably solution 
            par      gradient     transpar
r     -1.448508  6.030001e-04       0.2349
K     14.560692 -2.007053e-04 2106824.2701
Binit 14.629939  2.545064e-04 2257884.5480
sigma -1.779578 -3.688185e-05       0.1687</code></pre>
</div>
</div>
<p>数值优化程序两次应用的输出结果表明，我们不需要进行两次处理，但为了谨慎起见，还是不要太相信数值方法。无论如何都要进行单一模型拟合，但要自担风险（或许我不得不比许多人处理更多质量较差或一般的数据！）。</p>
<p>现在，我们可以从 <em>best2</em> 拟合中获取最佳参数，并将其输入<code><a href="https://rdrr.io/pkg/MQMF/man/plotspmmod.html">plotspmmod()</a></code>函数中，可直观显示模型拟合结果。这样我们获得了最佳参数，因此可以通过将 <em>plotprod</em> 参数设置为 <em>TRUE</em> 来绘制包含生产力曲线。 <code><a href="https://rdrr.io/pkg/MQMF/man/plotspmmod.html">plotspmmod()</a></code> 的作用不仅仅是图示结果，还隐形返回一个大的列表对象，因此，如果我们想要它，就需要将其赋值给变量或对象（在本例中<em>为 ans</em>）。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb19"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># optimum fit. Defaults used in plotprod and schaefer Fig 7.6</span></span>
<span><span class="va">ans</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/plotspmmod.html">plotspmmod</a></span><span class="op">(</span></span>
<span>    inp <span class="op">=</span> <span class="va">best2</span><span class="op">$</span><span class="va">estimate</span>, indat <span class="op">=</span> <span class="va">schaef</span>, addrmse <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>    plotprod <span class="op">=</span> <span class="cn">TRUE</span></span>
<span><span class="op">)</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-spm6" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-spm6-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="07-spm_files/figure-html/fig-spm6-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spm6-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;7.6: 根据 nlm() 最终拟合的最优参数，将剩余产量模型与 schaef 数据集进行拟合的摘要。在 CPUE 图中，绿色虚线为简单的黄土曲线拟合，红色实线为最优模型拟合。
</figcaption></figure>
</div>
</div>
</div>
<p><code><a href="https://rdrr.io/pkg/MQMF/man/plotspmmod.html">plotspmmod()</a></code>返回的对象是包含结果集合的对象列表，包括最优参数、包含预测最优动态预测的矩阵 （<em>ans$Dynamics$outmat</em>）、产量曲线和大量汇总结果。一旦分配给工作环境中的特定对象，就可以快速提取这些对象以用于其他函数。在不使用 <em>max.level=1</em> 参数或将其设置为2的情况下尝试运行 <code><a href="https://rdrr.io/r/utils/str.html">str()</a></code> ，以查看更多详细信息。很多函数会生成大量信息丰富的对象，您应该熟悉探索这些对象，以确保了解不同分析中产生的结果。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb20"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># the high-level structure of ans; try str(ans$Dynamics)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/str.html">str</a></span><span class="op">(</span><span class="va">ans</span>, width <span class="op">=</span> <span class="fl">65</span>, strict.width <span class="op">=</span> <span class="st">"cut"</span>, max.level <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>List of 12
 $ Dynamics :List of 5
 $ BiomProd : num [1:200, 1:2] 100 10687 21273 31860 42446 ...
  ..- attr(*, "dimnames")=List of 2
 $ rmseresid: num 1.03
 $ MSY      : num 123731
 $ Bmsy     : num 1048169
 $ Dmsy     : num 0.498
 $ Blim     : num 423562
 $ Btarg    : num 1016409
 $ Ctarg    : num 123581
 $ Dcurr    : Named num 0.528
  ..- attr(*, "names")= chr "1956"
 $ rmse     :List of 1
 $ sigma    : num 0.169</code></pre>
</div>
</div>
<p>还有一些 <strong>MQMF</strong> 函数可以帮助提取此类结果或使用 <code><a href="https://rdrr.io/pkg/MQMF/man/plotspmmod.html">plotspmmod()</a></code> 的结果（参见 <code><a href="https://rdrr.io/pkg/MQMF/man/summspm.html">summspm()</a></code> 和 <code><a href="https://rdrr.io/pkg/MQMF/man/spmphaseplot.html">spmphaseplot()</a></code> ），这就是为什么该函数包含参数 <em>plotout = TRUE，</em>因此不需要生成绘图。但是，在许多情况下，只需在高级对象（在本例中<em>为 ans</em>）中指向所需的对象即可。请注意，从生成的生产率曲线获得的 MSY 与从最优参数计算得出的 MSY 相差很小。这是因为生产力曲线是通过计算不同生物量水平向量的生产率数值得出的。因此，其分辨率受到用于生成生物量向量的步骤限制。其估计值将始终略小于参数派生值。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb22"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># compare the parameteric MSY with the numerical MSY</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">ans</span><span class="op">$</span><span class="va">Dynamics</span><span class="op">$</span><span class="va">sumout</span>, <span class="fl">3</span><span class="op">)</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>        msy           p   FinalDepl    InitDepl      FinalB 
 123734.068       1.000       0.528       1.072 1113328.480 </code></pre>
</div>
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb24"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"\n Productivity Statistics \n"</span><span class="op">)</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>
 Productivity Statistics </code></pre>
</div>
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb26"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/summspm.html">summspm</a></span><span class="op">(</span><span class="va">ans</span><span class="op">)</span> <span class="co"># the q parameter needs more significantr digits</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>      Index    Statistic
q         1       0.0000
MSY       2  123731.0026
Bmsy      3 1048168.8580
Dmsy      4       0.4975
Blim      5  423562.1648
Btarg     6 1016409.1956
Ctarg     7  123581.3940
Dcurr     8       0.5284</code></pre>
</div>
</div>
<p>最后，为了简化此双模型拟合过程的未来使用，有一个 <strong>MQMF</strong> 函数 <code><a href="https://rdrr.io/pkg/MQMF/man/fitSPM.html">fitSPM()</a></code> 来实现该过程。您可以使用该函数（查看其代码等），也可以重复原始代码的内容，以方便使用。</p>
</section><section id="分析是否稳健" class="level3" data-number="7.3.2"><h3 data-number="7.3.2" class="anchored" data-anchor-id="分析是否稳健">
<span class="header-section-number">7.3.2</span> 分析是否稳健？</h3>
<p>尽管我多次警告，但您可能想知道为什么我们要费力地对模型进行两次拟合，而第二次拟合的起点就是第一次拟合的最优估计值。我们应该始终记住，在拟合这些模型时，我们使用的是数值方法。这种方法并非万无一失，可能会发现错误的最小值。如果模型参数之间存在相互作用或相关性，那么稍有不同的组合就会导致非常相似的负对数似然值。最佳模型拟合在 cpue 时间序列的末尾仍显示出三个相对较大的残差，如 <a href="#fig-spm6" class="quarto-xref">图&nbsp;<span>7.6</span></a> 。这些残差没有表现出任何特定的模式，因此我们认为它们只代表不确定性，这应该让人怀疑模型拟合的好坏以及分析输出统计量的可靠性。我们可以通过检查初始模型参数对模型拟合的影响来检查模型拟合的稳健性。</p>
<p>稳健性测试的一种实现使用 <strong>MQMF</strong> 函数 <code><a href="https://rdrr.io/pkg/MQMF/man/robustSPM.html">robustSPM()</a></code>。 该函数将生成 𝑁 个随机初始值，是通过将最佳对数刻度参数值作为某些正态随机变量的相应平均值，其各自的标准差值通过将这些均值除以<em>缩放器</em>参数值获得（有关完整详细信息，请参阅 <code><a href="https://rdrr.io/pkg/MQMF/man/robustSPM.html">robustSPM()</a></code>代码和帮助）。<code><a href="https://rdrr.io/pkg/MQMF/man/robustSPM.html">robustSPM()</a></code> 输出的对象包括 <em>N</em> 随机变化的初始参数值的向量，这允许说明和表征它们的变化。当然，作为除数，<em>标度值</em>越小，初始参数向量的可变性就越大，也就越容易导致模型拟合无法找到最小值。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb28"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># conduct a robustness test on the Schaefer model fit</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="va">schaef</span><span class="op">)</span></span>
<span><span class="va">schaef</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">as.matrix</a></span><span class="op">(</span><span class="va">schaef</span><span class="op">)</span></span>
<span><span class="va">reps</span> <span class="op">&lt;-</span> <span class="fl">12</span></span>
<span><span class="va">param</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span>r <span class="op">=</span> <span class="fl">0.15</span>, K <span class="op">=</span> <span class="fl">2250000</span>, Binit <span class="op">=</span> <span class="fl">2250000</span>, sigma <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">ansS</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/fitSPM.html">fitSPM</a></span><span class="op">(</span></span>
<span>    pars <span class="op">=</span> <span class="va">param</span>, fish <span class="op">=</span> <span class="va">schaef</span>, schaefer <span class="op">=</span> <span class="cn">TRUE</span>, <span class="co"># use</span></span>
<span>    maxiter <span class="op">=</span> <span class="fl">1000</span>, funk <span class="op">=</span> <span class="va">simpspm</span>, funkone <span class="op">=</span> <span class="cn">FALSE</span></span>
<span><span class="op">)</span> <span class="co"># fitSPM</span></span>
<span><span class="co"># getseed() #generates random seed for repeatable results</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">777852</span><span class="op">)</span> <span class="co"># sets random number generator with a known seed</span></span>
<span><span class="va">robout</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/robustSPM.html">robustSPM</a></span><span class="op">(</span></span>
<span>    inpar <span class="op">=</span> <span class="va">ansS</span><span class="op">$</span><span class="va">estimate</span>, fish <span class="op">=</span> <span class="va">schaef</span>, N <span class="op">=</span> <span class="va">reps</span>,</span>
<span>    scaler <span class="op">=</span> <span class="fl">40</span>, verbose <span class="op">=</span> <span class="cn">FALSE</span>, schaefer <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>    funk <span class="op">=</span> <span class="va">simpspm</span>, funkone <span class="op">=</span> <span class="cn">FALSE</span></span>
<span><span class="op">)</span></span>
<span><span class="co"># use str(robout) to see the components included in the output</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-layout-nrow="2">
<div id="tbl-spm2" class="quarto-layout-panel anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-spm2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
表&nbsp;7.2: A robustness test of the fit to the schaef data-set. By examining the results object we can see the individual variation. The top columns relate to the initial parameters and the bottom columns, perhaps of more interest, to the model fits.
</figcaption><div aria-describedby="tbl-spm2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 100.0%;justify-content: center;">
<table class="do-not-create-environment cell table table-sm table-striped small">
<thead><tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: right;">ir</th>
<th style="text-align: right;">iK</th>
<th style="text-align: right;">iBinit</th>
<th style="text-align: right;">isigma</th>
<th style="text-align: right;">iLike</th>
<th style="text-align: right;">r</th>
</tr></thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">6</td>
<td style="text-align: right;">0.232</td>
<td style="text-align: right;">2521208</td>
<td style="text-align: right;">2394188</td>
<td style="text-align: right;">0.173</td>
<td style="text-align: right;">-5.765</td>
<td style="text-align: right;">0.235</td>
</tr>
<tr class="even">
<td style="text-align: left;">10</td>
<td style="text-align: right;">0.242</td>
<td style="text-align: right;">2564306</td>
<td style="text-align: right;">1386181</td>
<td style="text-align: right;">0.166</td>
<td style="text-align: right;">14.306</td>
<td style="text-align: right;">0.235</td>
</tr>
<tr class="odd">
<td style="text-align: left;">11</td>
<td style="text-align: right;">0.237</td>
<td style="text-align: right;">2189281</td>
<td style="text-align: right;">2032237</td>
<td style="text-align: right;">0.181</td>
<td style="text-align: right;">-7.025</td>
<td style="text-align: right;">0.235</td>
</tr>
<tr class="even">
<td style="text-align: left;">1</td>
<td style="text-align: right;">0.239</td>
<td style="text-align: right;">2351319</td>
<td style="text-align: right;">3401753</td>
<td style="text-align: right;">0.169</td>
<td style="text-align: right;">-6.351</td>
<td style="text-align: right;">0.235</td>
</tr>
<tr class="odd">
<td style="text-align: left;">8</td>
<td style="text-align: right;">0.244</td>
<td style="text-align: right;">2201215</td>
<td style="text-align: right;">2934055</td>
<td style="text-align: right;">0.180</td>
<td style="text-align: right;">-7.078</td>
<td style="text-align: right;">0.235</td>
</tr>
<tr class="even">
<td style="text-align: left;">3</td>
<td style="text-align: right;">0.233</td>
<td style="text-align: right;">3164529</td>
<td style="text-align: right;">1632687</td>
<td style="text-align: right;">0.170</td>
<td style="text-align: right;">22.093</td>
<td style="text-align: right;">0.235</td>
</tr>
<tr class="odd">
<td style="text-align: left;">12</td>
<td style="text-align: right;">0.237</td>
<td style="text-align: right;">3492106</td>
<td style="text-align: right;">1895315</td>
<td style="text-align: right;">0.165</td>
<td style="text-align: right;">23.789</td>
<td style="text-align: right;">0.235</td>
</tr>
<tr class="even">
<td style="text-align: left;">2</td>
<td style="text-align: right;">0.247</td>
<td style="text-align: right;">2359029</td>
<td style="text-align: right;">2137751</td>
<td style="text-align: right;">0.179</td>
<td style="text-align: right;">-5.575</td>
<td style="text-align: right;">0.235</td>
</tr>
<tr class="odd">
<td style="text-align: left;">5</td>
<td style="text-align: right;">0.234</td>
<td style="text-align: right;">3057512</td>
<td style="text-align: right;">1502916</td>
<td style="text-align: right;">0.171</td>
<td style="text-align: right;">23.720</td>
<td style="text-align: right;">0.235</td>
</tr>
<tr class="even">
<td style="text-align: left;">7</td>
<td style="text-align: right;">0.242</td>
<td style="text-align: right;">1671149</td>
<td style="text-align: right;">2512111</td>
<td style="text-align: right;">0.169</td>
<td style="text-align: right;">4.228</td>
<td style="text-align: right;">0.235</td>
</tr>
<tr class="odd">
<td style="text-align: left;">4</td>
<td style="text-align: right;">0.233</td>
<td style="text-align: right;">3482370</td>
<td style="text-align: right;">1584633</td>
<td style="text-align: right;">0.168</td>
<td style="text-align: right;">34.534</td>
<td style="text-align: right;">0.235</td>
</tr>
<tr class="even">
<td style="text-align: left;">9</td>
<td style="text-align: right;">0.230</td>
<td style="text-align: right;">1391893</td>
<td style="text-align: right;">1753155</td>
<td style="text-align: right;">0.175</td>
<td style="text-align: right;">138.808</td>
<td style="text-align: right;">0.235</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 100.0%;justify-content: center;">
<table class="do-not-create-environment cell table table-sm table-striped small">
<thead><tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: right;">K</th>
<th style="text-align: right;">Binit</th>
<th style="text-align: right;">sigma</th>
<th style="text-align: right;">-veLL</th>
<th style="text-align: right;">MSY</th>
<th style="text-align: right;">Iters</th>
</tr></thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">6</td>
<td style="text-align: right;">2107069</td>
<td style="text-align: right;">2258144</td>
<td style="text-align: right;">0.169</td>
<td style="text-align: right;">-7.934</td>
<td style="text-align: right;">123724.7</td>
<td style="text-align: right;">5</td>
</tr>
<tr class="even">
<td style="text-align: left;">10</td>
<td style="text-align: right;">2107034</td>
<td style="text-align: right;">2258103</td>
<td style="text-align: right;">0.169</td>
<td style="text-align: right;">-7.934</td>
<td style="text-align: right;">123726.0</td>
<td style="text-align: right;">8</td>
</tr>
<tr class="odd">
<td style="text-align: left;">11</td>
<td style="text-align: right;">2107243</td>
<td style="text-align: right;">2258322</td>
<td style="text-align: right;">0.169</td>
<td style="text-align: right;">-7.934</td>
<td style="text-align: right;">123717.4</td>
<td style="text-align: right;">7</td>
</tr>
<tr class="even">
<td style="text-align: left;">1</td>
<td style="text-align: right;">2107178</td>
<td style="text-align: right;">2258293</td>
<td style="text-align: right;">0.169</td>
<td style="text-align: right;">-7.934</td>
<td style="text-align: right;">123721.9</td>
<td style="text-align: right;">17</td>
</tr>
<tr class="odd">
<td style="text-align: left;">8</td>
<td style="text-align: right;">2107119</td>
<td style="text-align: right;">2258218</td>
<td style="text-align: right;">0.169</td>
<td style="text-align: right;">-7.934</td>
<td style="text-align: right;">123720.1</td>
<td style="text-align: right;">4</td>
</tr>
<tr class="even">
<td style="text-align: left;">3</td>
<td style="text-align: right;">2107386</td>
<td style="text-align: right;">2258484</td>
<td style="text-align: right;">0.169</td>
<td style="text-align: right;">-7.934</td>
<td style="text-align: right;">123713.3</td>
<td style="text-align: right;">4</td>
</tr>
<tr class="odd">
<td style="text-align: left;">12</td>
<td style="text-align: right;">2107417</td>
<td style="text-align: right;">2258533</td>
<td style="text-align: right;">0.169</td>
<td style="text-align: right;">-7.934</td>
<td style="text-align: right;">123712.5</td>
<td style="text-align: right;">27</td>
</tr>
<tr class="even">
<td style="text-align: left;">2</td>
<td style="text-align: right;">2106866</td>
<td style="text-align: right;">2257912</td>
<td style="text-align: right;">0.169</td>
<td style="text-align: right;">-7.934</td>
<td style="text-align: right;">123728.2</td>
<td style="text-align: right;">6</td>
</tr>
<tr class="odd">
<td style="text-align: left;">5</td>
<td style="text-align: right;">2107294</td>
<td style="text-align: right;">2258319</td>
<td style="text-align: right;">0.169</td>
<td style="text-align: right;">-7.934</td>
<td style="text-align: right;">123712.7</td>
<td style="text-align: right;">10</td>
</tr>
<tr class="even">
<td style="text-align: left;">7</td>
<td style="text-align: right;">2107319</td>
<td style="text-align: right;">2258401</td>
<td style="text-align: right;">0.169</td>
<td style="text-align: right;">-7.934</td>
<td style="text-align: right;">123712.2</td>
<td style="text-align: right;">9</td>
</tr>
<tr class="odd">
<td style="text-align: left;">4</td>
<td style="text-align: right;">2106799</td>
<td style="text-align: right;">2257706</td>
<td style="text-align: right;">0.169</td>
<td style="text-align: right;">-7.934</td>
<td style="text-align: right;">123732.1</td>
<td style="text-align: right;">28</td>
</tr>
<tr class="even">
<td style="text-align: left;">9</td>
<td style="text-align: right;">2106435</td>
<td style="text-align: right;">2257279</td>
<td style="text-align: right;">0.169</td>
<td style="text-align: right;">-7.934</td>
<td style="text-align: right;">123739.1</td>
<td style="text-align: right;">30</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</figure>
</div>
</div>
<p>通过使用 <em>set.seed</em> 函数，用于生成分散初始参数向量的伪随机数的结果是可重复的。在 <a href="#tbl-spm2" class="quarto-xref">表&nbsp;<span>7.2</span></a> 中，我们可以看到，在 12 次试验中，我们得到了 12 个相同的最终负对数似然（精确到小数点后 5 位），尽管与实际的 <span class="math inline">\(r\)</span> 、<span class="math inline">\(K\)</span> 和 <span class="math inline">\(B_{init}\)</span> 略有不同，这导致估计的 MSY 值的微小变化。如果我们增加试验的次数，最终会发现一些试验结果与最佳结果略有不同。</p>
<p>通常情况下，我们会尝试 12 次以上的试验，并检查标度参数的效果。因此，我们现在将使用相同的最佳拟合和随机种子重复该分析100次。<code><a href="https://rdrr.io/pkg/MQMF/man/robustSPM.html">robustSPM()</a></code>输出<em>结果</em>表按最终的 -ve 对数似然排序，但即使是相同的小数点后五位，也会发现参数估计值略有不同。这只是使用数值方法的反映。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb29"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Repeat robustness test on fit to schaef data 100 times</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">777854</span><span class="op">)</span></span>
<span><span class="va">robout2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/robustSPM.html">robustSPM</a></span><span class="op">(</span></span>
<span>    inpar <span class="op">=</span> <span class="va">ansS</span><span class="op">$</span><span class="va">estimate</span>, fish <span class="op">=</span> <span class="va">schaef</span>, N <span class="op">=</span> <span class="fl">100</span>,</span>
<span>    scaler <span class="op">=</span> <span class="fl">25</span>, verbose <span class="op">=</span> <span class="cn">FALSE</span>, schaefer <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>    funk <span class="op">=</span> <span class="va">simpspm</span>, funkone <span class="op">=</span> <span class="cn">TRUE</span>, steptol <span class="op">=</span> <span class="fl">1e-06</span></span>
<span><span class="op">)</span></span>
<span><span class="va">lastbits</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/utils/head.html">tail</a></span><span class="op">(</span><span class="va">robout2</span><span class="op">$</span><span class="va">results</span><span class="op">[</span>, <span class="fl">6</span><span class="op">:</span><span class="fl">11</span><span class="op">]</span>, <span class="fl">10</span><span class="op">)</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<div id="tbl-spm3" class="cell quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-spm3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
表&nbsp;7.3: The last 10 trials from the 100 illustrating that the last three trials deviated a little from the optimum negative log-likelihood of -7.93406.
</figcaption><div aria-describedby="tbl-spm3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell-output-display">
<div id="uyucezhwpr" style="padding-left:0px;padding-right:0px;padding-top:10px;padding-bottom:10px;overflow-x:auto;overflow-y:auto;width:auto;height:auto;">
<style>#uyucezhwpr table {
  font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

#uyucezhwpr thead, #uyucezhwpr tbody, #uyucezhwpr tfoot, #uyucezhwpr tr, #uyucezhwpr td, #uyucezhwpr th {
  border-style: none;
}

#uyucezhwpr p {
  margin: 0;
  padding: 0;
}

#uyucezhwpr .gt_table {
  display: table;
  border-collapse: collapse;
  line-height: normal;
  margin-left: auto;
  margin-right: auto;
  color: #333333;
  font-size: 16px;
  font-weight: normal;
  font-style: normal;
  background-color: #FFFFFF;
  width: auto;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #A8A8A8;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #A8A8A8;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
}

#uyucezhwpr .gt_caption {
  padding-top: 4px;
  padding-bottom: 4px;
}

#uyucezhwpr .gt_title {
  color: #333333;
  font-size: 125%;
  font-weight: initial;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 5px;
  padding-right: 5px;
  border-bottom-color: #FFFFFF;
  border-bottom-width: 0;
}

#uyucezhwpr .gt_subtitle {
  color: #333333;
  font-size: 85%;
  font-weight: initial;
  padding-top: 3px;
  padding-bottom: 5px;
  padding-left: 5px;
  padding-right: 5px;
  border-top-color: #FFFFFF;
  border-top-width: 0;
}

#uyucezhwpr .gt_heading {
  background-color: #FFFFFF;
  text-align: center;
  border-bottom-color: #FFFFFF;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
}

#uyucezhwpr .gt_bottom_border {
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

#uyucezhwpr .gt_col_headings {
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
}

#uyucezhwpr .gt_col_heading {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: normal;
  text-transform: inherit;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: bottom;
  padding-top: 5px;
  padding-bottom: 6px;
  padding-left: 5px;
  padding-right: 5px;
  overflow-x: hidden;
}

#uyucezhwpr .gt_column_spanner_outer {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: normal;
  text-transform: inherit;
  padding-top: 0;
  padding-bottom: 0;
  padding-left: 4px;
  padding-right: 4px;
}

#uyucezhwpr .gt_column_spanner_outer:first-child {
  padding-left: 0;
}

#uyucezhwpr .gt_column_spanner_outer:last-child {
  padding-right: 0;
}

#uyucezhwpr .gt_column_spanner {
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  vertical-align: bottom;
  padding-top: 5px;
  padding-bottom: 5px;
  overflow-x: hidden;
  display: inline-block;
  width: 100%;
}

#uyucezhwpr .gt_spanner_row {
  border-bottom-style: hidden;
}

#uyucezhwpr .gt_group_heading {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: middle;
  text-align: left;
}

#uyucezhwpr .gt_empty_group_heading {
  padding: 0.5px;
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  vertical-align: middle;
}

#uyucezhwpr .gt_from_md > :first-child {
  margin-top: 0;
}

#uyucezhwpr .gt_from_md > :last-child {
  margin-bottom: 0;
}

#uyucezhwpr .gt_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  margin: 10px;
  border-top-style: solid;
  border-top-width: 1px;
  border-top-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: middle;
  overflow-x: hidden;
}

#uyucezhwpr .gt_stub {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-right-style: solid;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  padding-left: 5px;
  padding-right: 5px;
}

#uyucezhwpr .gt_stub_row_group {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-right-style: solid;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  padding-left: 5px;
  padding-right: 5px;
  vertical-align: top;
}

#uyucezhwpr .gt_row_group_first td {
  border-top-width: 2px;
}

#uyucezhwpr .gt_row_group_first th {
  border-top-width: 2px;
}

#uyucezhwpr .gt_summary_row {
  color: #333333;
  background-color: #FFFFFF;
  text-transform: inherit;
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
}

#uyucezhwpr .gt_first_summary_row {
  border-top-style: solid;
  border-top-color: #D3D3D3;
}

#uyucezhwpr .gt_first_summary_row.thick {
  border-top-width: 2px;
}

#uyucezhwpr .gt_last_summary_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

#uyucezhwpr .gt_grand_summary_row {
  color: #333333;
  background-color: #FFFFFF;
  text-transform: inherit;
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
}

#uyucezhwpr .gt_first_grand_summary_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-top-style: double;
  border-top-width: 6px;
  border-top-color: #D3D3D3;
}

#uyucezhwpr .gt_last_grand_summary_row_top {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-bottom-style: double;
  border-bottom-width: 6px;
  border-bottom-color: #D3D3D3;
}

#uyucezhwpr .gt_striped {
  background-color: rgba(128, 128, 128, 0.05);
}

#uyucezhwpr .gt_table_body {
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

#uyucezhwpr .gt_footnotes {
  color: #333333;
  background-color: #FFFFFF;
  border-bottom-style: none;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
}

#uyucezhwpr .gt_footnote {
  margin: 0px;
  font-size: 90%;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 5px;
  padding-right: 5px;
}

#uyucezhwpr .gt_sourcenotes {
  color: #333333;
  background-color: #FFFFFF;
  border-bottom-style: none;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
}

#uyucezhwpr .gt_sourcenote {
  font-size: 90%;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 5px;
  padding-right: 5px;
}

#uyucezhwpr .gt_left {
  text-align: left;
}

#uyucezhwpr .gt_center {
  text-align: center;
}

#uyucezhwpr .gt_right {
  text-align: right;
  font-variant-numeric: tabular-nums;
}

#uyucezhwpr .gt_font_normal {
  font-weight: normal;
}

#uyucezhwpr .gt_font_bold {
  font-weight: bold;
}

#uyucezhwpr .gt_font_italic {
  font-style: italic;
}

#uyucezhwpr .gt_super {
  font-size: 65%;
}

#uyucezhwpr .gt_footnote_marks {
  font-size: 75%;
  vertical-align: 0.4em;
  position: initial;
}

#uyucezhwpr .gt_asterisk {
  font-size: 100%;
  vertical-align: 0;
}

#uyucezhwpr .gt_indent_1 {
  text-indent: 5px;
}

#uyucezhwpr .gt_indent_2 {
  text-indent: 10px;
}

#uyucezhwpr .gt_indent_3 {
  text-indent: 15px;
}

#uyucezhwpr .gt_indent_4 {
  text-indent: 20px;
}

#uyucezhwpr .gt_indent_5 {
  text-indent: 25px;
}

#uyucezhwpr .katex-display {
  display: inline-flex !important;
  margin-bottom: 0.75em !important;
}

#uyucezhwpr div.Reactable > div.rt-table > div.rt-thead > div.rt-tr.rt-tr-group-header > div.rt-th-group:after {
  height: 0px !important;
}
</style>
<table class="gt_table do-not-create-environment cell table table-sm table-striped small" data-quarto-postprocess="true" data-quarto-disable-processing="false" data-quarto-bootstrap="false">
<thead><tr class="header gt_col_headings">
<th id="r" class="gt_col_heading gt_columns_bottom_border gt_right" data-quarto-table-cell-role="th" scope="col">r</th>
<th id="K" class="gt_col_heading gt_columns_bottom_border gt_right" data-quarto-table-cell-role="th" scope="col">K</th>
<th id="Binit" class="gt_col_heading gt_columns_bottom_border gt_right" data-quarto-table-cell-role="th" scope="col">Binit</th>
<th id="sigma" class="gt_col_heading gt_columns_bottom_border gt_right" data-quarto-table-cell-role="th" scope="col">sigma</th>
<th id="a-veLL" class="gt_col_heading gt_columns_bottom_border gt_right" data-quarto-table-cell-role="th" scope="col">-veLL</th>
<th id="MSY" class="gt_col_heading gt_columns_bottom_border gt_right" data-quarto-table-cell-role="th" scope="col">MSY</th>
</tr></thead>
<tbody class="gt_table_body">
<tr class="odd">
<td class="gt_row gt_right" headers="r">0.235</td>
<td class="gt_row gt_right" headers="K">2105553</td>
<td class="gt_row gt_right" headers="Binit">2256358</td>
<td class="gt_row gt_right" headers="sigma">0.169</td>
<td class="gt_row gt_right" headers="-veLL">−7.934</td>
<td class="gt_row gt_right" headers="MSY">123770.0</td>
</tr>
<tr class="even">
<td class="gt_row gt_right" headers="r">0.235</td>
<td class="gt_row gt_right" headers="K">2105553</td>
<td class="gt_row gt_right" headers="Binit">2256358</td>
<td class="gt_row gt_right" headers="sigma">0.169</td>
<td class="gt_row gt_right" headers="-veLL">−7.934</td>
<td class="gt_row gt_right" headers="MSY">123770.0</td>
</tr>
<tr class="odd">
<td class="gt_row gt_right" headers="r">0.235</td>
<td class="gt_row gt_right" headers="K">2105553</td>
<td class="gt_row gt_right" headers="Binit">2256358</td>
<td class="gt_row gt_right" headers="sigma">0.169</td>
<td class="gt_row gt_right" headers="-veLL">−7.934</td>
<td class="gt_row gt_right" headers="MSY">123770.0</td>
</tr>
<tr class="even">
<td class="gt_row gt_right" headers="r">0.235</td>
<td class="gt_row gt_right" headers="K">2105553</td>
<td class="gt_row gt_right" headers="Binit">2256358</td>
<td class="gt_row gt_right" headers="sigma">0.169</td>
<td class="gt_row gt_right" headers="-veLL">−7.934</td>
<td class="gt_row gt_right" headers="MSY">123770.0</td>
</tr>
<tr class="odd">
<td class="gt_row gt_right" headers="r">0.235</td>
<td class="gt_row gt_right" headers="K">2105553</td>
<td class="gt_row gt_right" headers="Binit">2256358</td>
<td class="gt_row gt_right" headers="sigma">0.169</td>
<td class="gt_row gt_right" headers="-veLL">−7.934</td>
<td class="gt_row gt_right" headers="MSY">123770.0</td>
</tr>
<tr class="even">
<td class="gt_row gt_right" headers="r">0.235</td>
<td class="gt_row gt_right" headers="K">2105553</td>
<td class="gt_row gt_right" headers="Binit">2256358</td>
<td class="gt_row gt_right" headers="sigma">0.169</td>
<td class="gt_row gt_right" headers="-veLL">−7.934</td>
<td class="gt_row gt_right" headers="MSY">123770.0</td>
</tr>
<tr class="odd">
<td class="gt_row gt_right" headers="r">0.235</td>
<td class="gt_row gt_right" headers="K">2105553</td>
<td class="gt_row gt_right" headers="Binit">2256358</td>
<td class="gt_row gt_right" headers="sigma">0.169</td>
<td class="gt_row gt_right" headers="-veLL">−7.934</td>
<td class="gt_row gt_right" headers="MSY">123770.0</td>
</tr>
<tr class="even">
<td class="gt_row gt_right" headers="r">0.235</td>
<td class="gt_row gt_right" headers="K">2105553</td>
<td class="gt_row gt_right" headers="Binit">2256358</td>
<td class="gt_row gt_right" headers="sigma">0.169</td>
<td class="gt_row gt_right" headers="-veLL">−7.934</td>
<td class="gt_row gt_right" headers="MSY">123770.0</td>
</tr>
<tr class="odd">
<td class="gt_row gt_right" headers="r">0.235</td>
<td class="gt_row gt_right" headers="K">2105527</td>
<td class="gt_row gt_right" headers="Binit">2256328</td>
<td class="gt_row gt_right" headers="sigma">0.169</td>
<td class="gt_row gt_right" headers="-veLL">−7.934</td>
<td class="gt_row gt_right" headers="MSY">123770.8</td>
</tr>
<tr class="even">
<td class="gt_row gt_right" headers="r">0.235</td>
<td class="gt_row gt_right" headers="K">2105510</td>
<td class="gt_row gt_right" headers="Binit">2256327</td>
<td class="gt_row gt_right" headers="sigma">0.169</td>
<td class="gt_row gt_right" headers="-veLL">−7.934</td>
<td class="gt_row gt_right" headers="MSY">123772.4</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</figure>
</div>
</div>
<p><a href="#tbl-spm3" class="quarto-xref">表&nbsp;<span>7.3</span></a> 只列出了排序后 100 个重复样本中的后 10 条记录，这表明所有重复样本的负对数似然值相同（精确到小数点后 5 位）。同样，如果仔细观察 <span class="math inline">\(r\)</span>、 <span class="math inline">\(K\)</span>、 <span class="math inline">\(Binit\)</span> 和 MSY 的值，就会发现它们之间的差异。如果我们将最终拟合的参数值用图显示，变化的标度就会很明显，如<a href="#fig-spm7" class="quarto-xref">图&nbsp;<span>7.7</span></a>。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb30"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># replicates from the robustness test        Fig 7.7</span></span>
<span><span class="va">result</span> <span class="op">&lt;-</span> <span class="va">robout2</span><span class="op">$</span><span class="va">results</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/parset.html">parset</a></span><span class="op">(</span>plots <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">2</span><span class="op">)</span>, margin <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.35</span>, <span class="fl">0.45</span>, <span class="fl">0.05</span>, <span class="fl">0.05</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html">hist</a></span><span class="op">(</span><span class="va">result</span><span class="op">[</span>, <span class="st">"r"</span><span class="op">]</span>, breaks <span class="op">=</span> <span class="fl">15</span>, col <span class="op">=</span> <span class="fl">2</span>, main <span class="op">=</span> <span class="st">""</span>, xlab <span class="op">=</span> <span class="st">"r"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html">hist</a></span><span class="op">(</span><span class="va">result</span><span class="op">[</span>, <span class="st">"K"</span><span class="op">]</span>, breaks <span class="op">=</span> <span class="fl">15</span>, col <span class="op">=</span> <span class="fl">2</span>, main <span class="op">=</span> <span class="st">""</span>, xlab <span class="op">=</span> <span class="st">"K"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html">hist</a></span><span class="op">(</span><span class="va">result</span><span class="op">[</span>, <span class="st">"Binit"</span><span class="op">]</span>, breaks <span class="op">=</span> <span class="fl">15</span>, col <span class="op">=</span> <span class="fl">2</span>, main <span class="op">=</span> <span class="st">""</span>, xlab <span class="op">=</span> <span class="st">"Binit"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html">hist</a></span><span class="op">(</span><span class="va">result</span><span class="op">[</span>, <span class="st">"MSY"</span><span class="op">]</span>, breaks <span class="op">=</span> <span class="fl">15</span>, col <span class="op">=</span> <span class="fl">2</span>, main <span class="op">=</span> <span class="st">""</span>, xlab <span class="op">=</span> <span class="st">"MSY"</span><span class="op">)</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-spm7" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-spm7-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="07-spm_files/figure-html/fig-spm7-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spm7-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;7.7: 对 schaef 数据集模型拟合的稳健性测试中 100 次试验的主要参数和 MSY 的直方图。参数估计值都很接近，但仍存在差异，这反映了估计的不确定性。为了改善这种情况，可以尝试使用较小的 steptol，默认值为 1e-06，但并不总是能得到稳定的解决方案。如果使用 steptol = 1e-07，整个变量的取值范围会变得更小，但仍会有一些微小的变化，这也是使用数值方法时的预期结果。这也是为什么参数估计的特定值在我们也有变化或不确定性估计值时最有意义的另一个原因。
</figcaption></figure>
</div>
</div>
</div>
<p>即使负对数似然值非常接近（精确到小数点后五位）（<a href="#fig-spm7" class="quarto-xref">图&nbsp;<span>7.7</span></a>），也可能与最常出现的最佳值略有偏差。这强调了仔细检查分析中的不确定性的必要性。鉴于大多数试验得出相同的最佳值，所有试验的中值可以确定最佳值。</p>
<p>另一种可视化稳健性检验参数估计值最终变化的方法是使用 R 函数 <code><a href="https://rdrr.io/r/graphics/pairs.html">pairs()</a></code> 绘制各参数与模型输出值的对比图，如 <a href="#fig-spm8" class="quarto-xref">图&nbsp;<span>7.8</span></a> 所示，该图说明了参数之间的强相关性。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb31"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># robustSPM parameters against each other  Fig 7.8</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/pairs.html">pairs</a></span><span class="op">(</span><span class="va">result</span><span class="op">[</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"r"</span>, <span class="st">"K"</span>, <span class="st">"Binit"</span>, <span class="st">"MSY"</span><span class="op">)</span><span class="op">]</span>, upper.panel <span class="op">=</span> <span class="cn">NULL</span>, pch <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-spm8" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-spm8-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="07-spm_files/figure-html/fig-spm8-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spm8-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;7.8: 100 个最优解决方案中参数之间的关系图，这些解源于将剩余产量模型拟合到 <em>schaef</em> 数据集。参数之间的相关性是显而易见的，尽管需要强调的是，估计值之间的比例差异非常小，约为0.2-0.3%。
</figcaption></figure>
</div>
</div>
</div>
</section><section id="使用不同的数据" class="level3" data-number="7.3.3"><h3 data-number="7.3.3" class="anchored" data-anchor-id="使用不同的数据">
<span class="header-section-number">7.3.3</span> 使用不同的数据？</h3>
<p><em>schaef</em> 数据集得出的结果相对稳健。在继续分析之前，使用 <em>dataspm</em> 数据集进行重复分析会更有启发，因为该数据集的结果更多变。希望这些发现能鼓励今后的建模者阅读本文时，不要相信数值优化程序给出的第一个解决方案。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb32"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Now use the dataspm data-set, which is noisier</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">777854</span><span class="op">)</span> <span class="co"># other random seeds give different results</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="va">dataspm</span><span class="op">)</span></span>
<span><span class="va">fish</span> <span class="op">&lt;-</span> <span class="va">dataspm</span> <span class="co"># to generalize the code</span></span>
<span><span class="va">param</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span>r <span class="op">=</span> <span class="fl">0.24</span>, K <span class="op">=</span> <span class="fl">5174</span>, Binit <span class="op">=</span> <span class="fl">2846</span>, sigma <span class="op">=</span> <span class="fl">0.164</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">ans</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/fitSPM.html">fitSPM</a></span><span class="op">(</span></span>
<span>    pars <span class="op">=</span> <span class="va">param</span>, fish <span class="op">=</span> <span class="va">fish</span>, schaefer <span class="op">=</span> <span class="cn">TRUE</span>, maxiter <span class="op">=</span> <span class="fl">1000</span>,</span>
<span>    funkone <span class="op">=</span> <span class="cn">TRUE</span></span>
<span><span class="op">)</span></span>
<span><span class="va">out</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/robustSPM.html">robustSPM</a></span><span class="op">(</span><span class="va">ans</span><span class="op">$</span><span class="va">estimate</span>, <span class="va">fish</span>,</span>
<span>    N <span class="op">=</span> <span class="fl">100</span>, scaler <span class="op">=</span> <span class="fl">15</span>, <span class="co"># making</span></span>
<span>    verbose <span class="op">=</span> <span class="cn">FALSE</span>, funkone <span class="op">=</span> <span class="cn">TRUE</span></span>
<span><span class="op">)</span> <span class="co"># scaler=10 gives</span></span>
<span><span class="va">result</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/utils/head.html">tail</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">results</span><span class="op">[</span>, <span class="fl">6</span><span class="op">:</span><span class="fl">11</span><span class="op">]</span>, <span class="fl">10</span><span class="op">)</span> <span class="co"># 16 sub-optimal results</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<div id="tbl-spm4" class="cell quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-spm4-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
表&nbsp;7.4: The last 10 trials from 100 used with dataspm. The last six trials deviate markedly from the optimum negative log-likelihood of -12.1288, and five gave consistent sub-optimal optima. Variation across parameter estimates with the optimum log-likelihood remained minor, but was large for the false optima.
</figcaption><div aria-describedby="tbl-spm4-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell-output-display">
<div id="uyucezhwpr" style="padding-left:0px;padding-right:0px;padding-top:10px;padding-bottom:10px;overflow-x:auto;overflow-y:auto;width:auto;height:auto;">
<style>#uyucezhwpr table {
  font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

#uyucezhwpr thead, #uyucezhwpr tbody, #uyucezhwpr tfoot, #uyucezhwpr tr, #uyucezhwpr td, #uyucezhwpr th {
  border-style: none;
}

#uyucezhwpr p {
  margin: 0;
  padding: 0;
}

#uyucezhwpr .gt_table {
  display: table;
  border-collapse: collapse;
  line-height: normal;
  margin-left: auto;
  margin-right: auto;
  color: #333333;
  font-size: 16px;
  font-weight: normal;
  font-style: normal;
  background-color: #FFFFFF;
  width: auto;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #A8A8A8;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #A8A8A8;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
}

#uyucezhwpr .gt_caption {
  padding-top: 4px;
  padding-bottom: 4px;
}

#uyucezhwpr .gt_title {
  color: #333333;
  font-size: 125%;
  font-weight: initial;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 5px;
  padding-right: 5px;
  border-bottom-color: #FFFFFF;
  border-bottom-width: 0;
}

#uyucezhwpr .gt_subtitle {
  color: #333333;
  font-size: 85%;
  font-weight: initial;
  padding-top: 3px;
  padding-bottom: 5px;
  padding-left: 5px;
  padding-right: 5px;
  border-top-color: #FFFFFF;
  border-top-width: 0;
}

#uyucezhwpr .gt_heading {
  background-color: #FFFFFF;
  text-align: center;
  border-bottom-color: #FFFFFF;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
}

#uyucezhwpr .gt_bottom_border {
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

#uyucezhwpr .gt_col_headings {
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
}

#uyucezhwpr .gt_col_heading {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: normal;
  text-transform: inherit;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: bottom;
  padding-top: 5px;
  padding-bottom: 6px;
  padding-left: 5px;
  padding-right: 5px;
  overflow-x: hidden;
}

#uyucezhwpr .gt_column_spanner_outer {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: normal;
  text-transform: inherit;
  padding-top: 0;
  padding-bottom: 0;
  padding-left: 4px;
  padding-right: 4px;
}

#uyucezhwpr .gt_column_spanner_outer:first-child {
  padding-left: 0;
}

#uyucezhwpr .gt_column_spanner_outer:last-child {
  padding-right: 0;
}

#uyucezhwpr .gt_column_spanner {
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  vertical-align: bottom;
  padding-top: 5px;
  padding-bottom: 5px;
  overflow-x: hidden;
  display: inline-block;
  width: 100%;
}

#uyucezhwpr .gt_spanner_row {
  border-bottom-style: hidden;
}

#uyucezhwpr .gt_group_heading {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: middle;
  text-align: left;
}

#uyucezhwpr .gt_empty_group_heading {
  padding: 0.5px;
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  vertical-align: middle;
}

#uyucezhwpr .gt_from_md > :first-child {
  margin-top: 0;
}

#uyucezhwpr .gt_from_md > :last-child {
  margin-bottom: 0;
}

#uyucezhwpr .gt_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  margin: 10px;
  border-top-style: solid;
  border-top-width: 1px;
  border-top-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: middle;
  overflow-x: hidden;
}

#uyucezhwpr .gt_stub {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-right-style: solid;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  padding-left: 5px;
  padding-right: 5px;
}

#uyucezhwpr .gt_stub_row_group {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-right-style: solid;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  padding-left: 5px;
  padding-right: 5px;
  vertical-align: top;
}

#uyucezhwpr .gt_row_group_first td {
  border-top-width: 2px;
}

#uyucezhwpr .gt_row_group_first th {
  border-top-width: 2px;
}

#uyucezhwpr .gt_summary_row {
  color: #333333;
  background-color: #FFFFFF;
  text-transform: inherit;
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
}

#uyucezhwpr .gt_first_summary_row {
  border-top-style: solid;
  border-top-color: #D3D3D3;
}

#uyucezhwpr .gt_first_summary_row.thick {
  border-top-width: 2px;
}

#uyucezhwpr .gt_last_summary_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

#uyucezhwpr .gt_grand_summary_row {
  color: #333333;
  background-color: #FFFFFF;
  text-transform: inherit;
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
}

#uyucezhwpr .gt_first_grand_summary_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-top-style: double;
  border-top-width: 6px;
  border-top-color: #D3D3D3;
}

#uyucezhwpr .gt_last_grand_summary_row_top {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-bottom-style: double;
  border-bottom-width: 6px;
  border-bottom-color: #D3D3D3;
}

#uyucezhwpr .gt_striped {
  background-color: rgba(128, 128, 128, 0.05);
}

#uyucezhwpr .gt_table_body {
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

#uyucezhwpr .gt_footnotes {
  color: #333333;
  background-color: #FFFFFF;
  border-bottom-style: none;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
}

#uyucezhwpr .gt_footnote {
  margin: 0px;
  font-size: 90%;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 5px;
  padding-right: 5px;
}

#uyucezhwpr .gt_sourcenotes {
  color: #333333;
  background-color: #FFFFFF;
  border-bottom-style: none;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
}

#uyucezhwpr .gt_sourcenote {
  font-size: 90%;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 5px;
  padding-right: 5px;
}

#uyucezhwpr .gt_left {
  text-align: left;
}

#uyucezhwpr .gt_center {
  text-align: center;
}

#uyucezhwpr .gt_right {
  text-align: right;
  font-variant-numeric: tabular-nums;
}

#uyucezhwpr .gt_font_normal {
  font-weight: normal;
}

#uyucezhwpr .gt_font_bold {
  font-weight: bold;
}

#uyucezhwpr .gt_font_italic {
  font-style: italic;
}

#uyucezhwpr .gt_super {
  font-size: 65%;
}

#uyucezhwpr .gt_footnote_marks {
  font-size: 75%;
  vertical-align: 0.4em;
  position: initial;
}

#uyucezhwpr .gt_asterisk {
  font-size: 100%;
  vertical-align: 0;
}

#uyucezhwpr .gt_indent_1 {
  text-indent: 5px;
}

#uyucezhwpr .gt_indent_2 {
  text-indent: 10px;
}

#uyucezhwpr .gt_indent_3 {
  text-indent: 15px;
}

#uyucezhwpr .gt_indent_4 {
  text-indent: 20px;
}

#uyucezhwpr .gt_indent_5 {
  text-indent: 25px;
}

#uyucezhwpr .katex-display {
  display: inline-flex !important;
  margin-bottom: 0.75em !important;
}

#uyucezhwpr div.Reactable > div.rt-table > div.rt-thead > div.rt-tr.rt-tr-group-header > div.rt-th-group:after {
  height: 0px !important;
}
</style>
<table class="gt_table do-not-create-environment cell table table-sm table-striped small" data-quarto-postprocess="true" data-quarto-disable-processing="false" data-quarto-bootstrap="false">
<thead><tr class="header gt_col_headings">
<th id="r" class="gt_col_heading gt_columns_bottom_border gt_right" data-quarto-table-cell-role="th" scope="col">r</th>
<th id="K" class="gt_col_heading gt_columns_bottom_border gt_right" data-quarto-table-cell-role="th" scope="col">K</th>
<th id="Binit" class="gt_col_heading gt_columns_bottom_border gt_right" data-quarto-table-cell-role="th" scope="col">Binit</th>
<th id="sigma" class="gt_col_heading gt_columns_bottom_border gt_right" data-quarto-table-cell-role="th" scope="col">sigma</th>
<th id="a-veLL" class="gt_col_heading gt_columns_bottom_border gt_right" data-quarto-table-cell-role="th" scope="col">-veLL</th>
<th id="MSY" class="gt_col_heading gt_columns_bottom_border gt_right" data-quarto-table-cell-role="th" scope="col">MSY</th>
</tr></thead>
<tbody class="gt_table_body">
<tr class="odd">
<td class="gt_row gt_right" headers="r">0.243</td>
<td class="gt_row gt_right" headers="K">5,171.268</td>
<td class="gt_row gt_right" headers="Binit">2,844.290</td>
<td class="gt_row gt_right" headers="sigma">0.164</td>
<td class="gt_row gt_right" headers="-veLL">−12.129</td>
<td class="gt_row gt_right" headers="MSY">313.537</td>
</tr>
<tr class="even">
<td class="gt_row gt_right" headers="r">0.243</td>
<td class="gt_row gt_right" headers="K">5,171.509</td>
<td class="gt_row gt_right" headers="Binit">2,843.699</td>
<td class="gt_row gt_right" headers="sigma">0.164</td>
<td class="gt_row gt_right" headers="-veLL">−12.129</td>
<td class="gt_row gt_right" headers="MSY">313.528</td>
</tr>
<tr class="odd">
<td class="gt_row gt_right" headers="r">0.243</td>
<td class="gt_row gt_right" headers="K">5,171.805</td>
<td class="gt_row gt_right" headers="Binit">2,846.729</td>
<td class="gt_row gt_right" headers="sigma">0.164</td>
<td class="gt_row gt_right" headers="-veLL">−12.129</td>
<td class="gt_row gt_right" headers="MSY">313.545</td>
</tr>
<tr class="even">
<td class="gt_row gt_right" headers="r">0.243</td>
<td class="gt_row gt_right" headers="K">5,169.358</td>
<td class="gt_row gt_right" headers="Binit">2,842.830</td>
<td class="gt_row gt_right" headers="sigma">0.164</td>
<td class="gt_row gt_right" headers="-veLL">−12.129</td>
<td class="gt_row gt_right" headers="MSY">313.555</td>
</tr>
<tr class="odd">
<td class="gt_row gt_right" headers="r">3.561</td>
<td class="gt_row gt_right" headers="K">149.623</td>
<td class="gt_row gt_right" headers="Binit">50.741</td>
<td class="gt_row gt_right" headers="sigma">0.223</td>
<td class="gt_row gt_right" headers="-veLL">−2.524</td>
<td class="gt_row gt_right" headers="MSY">133.201</td>
</tr>
<tr class="even">
<td class="gt_row gt_right" headers="r">0.032</td>
<td class="gt_row gt_right" headers="K">36,059.563</td>
<td class="gt_row gt_right" headers="Binit">49.720</td>
<td class="gt_row gt_right" headers="sigma">0.233</td>
<td class="gt_row gt_right" headers="-veLL">−1.178</td>
<td class="gt_row gt_right" headers="MSY">289.163</td>
</tr>
<tr class="odd">
<td class="gt_row gt_right" headers="r">40.310</td>
<td class="gt_row gt_right" headers="K">0.257</td>
<td class="gt_row gt_right" headers="Binit">49.720</td>
<td class="gt_row gt_right" headers="sigma">0.233</td>
<td class="gt_row gt_right" headers="-veLL">−1.178</td>
<td class="gt_row gt_right" headers="MSY">2.592</td>
</tr>
<tr class="even">
<td class="gt_row gt_right" headers="r">22.194</td>
<td class="gt_row gt_right" headers="K">0.003</td>
<td class="gt_row gt_right" headers="Binit">49.720</td>
<td class="gt_row gt_right" headers="sigma">0.233</td>
<td class="gt_row gt_right" headers="-veLL">−1.178</td>
<td class="gt_row gt_right" headers="MSY">0.016</td>
</tr>
<tr class="odd">
<td class="gt_row gt_right" headers="r">1.186</td>
<td class="gt_row gt_right" headers="K">6,062.637</td>
<td class="gt_row gt_right" headers="Binit">49.720</td>
<td class="gt_row gt_right" headers="sigma">0.233</td>
<td class="gt_row gt_right" headers="-veLL">−1.178</td>
<td class="gt_row gt_right" headers="MSY">1,797.041</td>
</tr>
<tr class="even">
<td class="gt_row gt_right" headers="r">0.595</td>
<td class="gt_row gt_right" headers="K">4,058.965</td>
<td class="gt_row gt_right" headers="Binit">49.720</td>
<td class="gt_row gt_right" headers="sigma">0.233</td>
<td class="gt_row gt_right" headers="-veLL">−1.178</td>
<td class="gt_row gt_right" headers="MSY">604.180</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</figure>
</div>
</div>
<p>在与 <em>dataspm</em> 进行拟合的底部六个模型中，我们可以看到 <span class="math inline">\(r\)</span> 值非常大而 <span class="math inline">\(K\)</span> 值非常小的情况，以及 <span class="math inline">\(K\)</span> 值非常大而 <span class="math inline">\(r\)</span> 值非常小的情况，此外，在最后两行中，<span class="math inline">\(r\)</span> 和 <span class="math inline">\(K\)</span> 的值几乎是合理的，但 <em>Binit</em> 值却非常小。</p>
</section></section><section id="不确定性" class="level2" data-number="7.4"><h2 data-number="7.4" class="anchored" data-anchor-id="不确定性">
<span class="header-section-number">7.4</span> 不确定性</h2>
<p>当我们测试一些模型拟合对初始条件的稳健性时，我们发现当拟合多个参数时，可以从略微不同的参数值中获得基本相同的数值拟合（达到给定的精度）。虽然这些值往往相差不大，但这一观察结果仍然证实，当使用数值方法估计一组参数时，特定参数值并不是唯一重要的结果。我们还需要知道这些估计的精确程度，我们需要知道与它们的估计相关的任何不确定性。有许多方法可以用来探索模型拟合中的不确定性。在这里，我们将使用 R 检查四个的实现：1）似然剖面，2）自举重采样，3） 渐近误差，以及 4）贝叶斯后验分布。</p>
<section id="似然剖面图" class="level3" data-number="7.4.1"><h3 data-number="7.4.1" class="anchored" data-anchor-id="似然剖面图">
<span class="header-section-number">7.4.1</span> 似然剖面图</h3>
<p>似然剖面顾名思义，就是让人了解如果使用的参数稍有不同，模型拟合的质量会发生怎样的变化。使用最大似然法（最小化对数似然）对模型进行最佳拟合，然后在将一个或多个参数固定为预定值（保持不变）的同时，只对其余未固定的参数进行拟合。这样，在给定一个或多个参数固定值的情况下，就可以获得最佳拟合结果。因此，我们可以确定当所选参数在一系列不同值上保持固定时，模型拟合的总可能性将如何变化。通过一个实例，我们可以更清楚地了解这一过程。我们可以使用 abdat 数据集，该数据集对观测数据进行了合理拟合，但最优拟合的残差模式适中，最优解的最终梯度相对较大（尝试 <code>outfit(ans)</code> 查看结果）。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb33"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Fig 7.9 Fit of optimum to the abdat data-set</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="va">abdat</span><span class="op">)</span></span>
<span><span class="va">fish</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">as.matrix</a></span><span class="op">(</span><span class="va">abdat</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html">colnames</a></span><span class="op">(</span><span class="va">fish</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/chartr.html">tolower</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html">colnames</a></span><span class="op">(</span><span class="va">fish</span><span class="op">)</span><span class="op">)</span> <span class="co"># just in case</span></span>
<span><span class="va">pars</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span>r <span class="op">=</span> <span class="fl">0.4</span>, K <span class="op">=</span> <span class="fl">9400</span>, Binit <span class="op">=</span> <span class="fl">3400</span>, sigma <span class="op">=</span> <span class="fl">0.05</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">ans</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/fitSPM.html">fitSPM</a></span><span class="op">(</span><span class="va">pars</span>, <span class="va">fish</span>, schaefer <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span> <span class="co"># Schaefer</span></span>
<span><span class="va">answer</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/plotspmmod.html">plotspmmod</a></span><span class="op">(</span><span class="va">ans</span><span class="op">$</span><span class="va">estimate</span>, <span class="va">abdat</span>, schaefer <span class="op">=</span> <span class="cn">TRUE</span>, addrmse <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-spm9" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-spm9-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="07-spm_files/figure-html/fig-spm9-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spm9-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;7.9: 描述最佳参数与 <em>abdat</em> 数据集拟合的汇总图。拟合和 cpue 数据之间的对数正态残差中的剩余模式如右下角所示。
</figcaption></figure>
</div>
</div>
</div>
<p>在 <em>“不确定性”</em> 一章中，我们研究了围绕单个参数的似然剖面，在这里我们将更深入地探讨与似然剖面的使用相关的一些问题。我们已经有了对 <em>abdat</em> 数据集的最佳拟合，可以以此为起点。反过来，如果我们考虑 𝑟 和 𝐾 参数时，编写一个简单的函数拟合每种情形下的剖面会更有效，以避免代码重复。和以前一样，我们使用 <code><a href="https://rdrr.io/pkg/MQMF/man/negLLP.html">negLLP()</a></code> 函数固定某些参数，同时改变其他参数。如 “<em>不确定性”</em> 一章所述，对于一个参数，95% 的置信边界的近似值为一个自由度的最小对数似然加上一个自由度 （=1.92） 的卡方值一半的参数范围。</p>
<p><span id="eq-spm17"><span class="math display">\[
min(-LL) + \dfrac{\chi_{1,1-\alpha}^2}{2}
\qquad(7.17)\]</span></span></p>
<p>在绘制每个剖面时，我们可以包括这个阈值，以查看它与似然剖面相交的位置，<a href="#fig-spm10" class="quarto-xref">图&nbsp;<span>7.10</span></a>。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb34"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># likelihood profiles for r and K for fit to abdat  Fig 7.10</span></span>
<span><span class="co"># doprofile input terms are vector of values, fixed parameter</span></span>
<span><span class="co"># location, starting parameters, and free parameter locations.</span></span>
<span><span class="co"># all other input are assumed to be in the calling environment</span></span>
<span><span class="va">doprofile</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">val</span>, <span class="va">loc</span>, <span class="va">startest</span>, <span class="va">indat</span>, <span class="va">notfix</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span><span class="op">:</span><span class="fl">4</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="va">pname</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"r"</span>, <span class="st">"K"</span>, <span class="st">"Binit"</span>, <span class="st">"sigma"</span>, <span class="st">"-veLL"</span><span class="op">)</span></span>
<span>    <span class="va">numv</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="va">val</span><span class="op">)</span></span>
<span>    <span class="va">outpar</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="cn">NA</span>, nrow <span class="op">=</span> <span class="va">numv</span>, ncol <span class="op">=</span> <span class="fl">5</span>, dimnames <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="va">val</span>, <span class="va">pname</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">numv</span><span class="op">)</span> <span class="op">{</span> <span class="co">#</span></span>
<span>        <span class="va">param</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">startest</span><span class="op">)</span> <span class="co"># reset the parameters</span></span>
<span>        <span class="va">param</span><span class="op">[</span><span class="va">loc</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">val</span><span class="op">[</span><span class="va">i</span><span class="op">]</span><span class="op">)</span> <span class="co"># insert new fixed value</span></span>
<span>        <span class="va">parinit</span> <span class="op">&lt;-</span> <span class="va">param</span> <span class="co"># copy revised parameter vector</span></span>
<span>        <span class="va">bestmod</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/nlm.html">nlm</a></span><span class="op">(</span></span>
<span>            f <span class="op">=</span> <span class="va">negLLP</span>, p <span class="op">=</span> <span class="va">param</span>, funk <span class="op">=</span> <span class="va">simpspm</span>, initpar <span class="op">=</span> <span class="va">parinit</span>,</span>
<span>            indat <span class="op">=</span> <span class="va">indat</span>, logobs <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">indat</span><span class="op">[</span>, <span class="st">"cpue"</span><span class="op">]</span><span class="op">)</span>,</span>
<span>            notfixed <span class="op">=</span> <span class="va">notfix</span></span>
<span>        <span class="op">)</span></span>
<span>        <span class="va">outpar</span><span class="op">[</span><span class="va">i</span>, <span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">bestmod</span><span class="op">$</span><span class="va">estimate</span><span class="op">)</span>, <span class="va">bestmod</span><span class="op">$</span><span class="va">minimum</span><span class="op">)</span></span>
<span>    <span class="op">}</span></span>
<span>    <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="va">outpar</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="va">rval</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fl">0.32</span>, <span class="fl">0.46</span>, <span class="fl">0.001</span><span class="op">)</span></span>
<span><span class="va">outr</span> <span class="op">&lt;-</span> <span class="fu">doprofile</span><span class="op">(</span><span class="va">rval</span>,</span>
<span>    loc <span class="op">=</span> <span class="fl">1</span>, startest <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">rval</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>, <span class="fl">11500</span>, <span class="fl">5000</span>, <span class="fl">0.25</span><span class="op">)</span>,</span>
<span>    indat <span class="op">=</span> <span class="va">fish</span>, notfix <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span><span class="op">:</span><span class="fl">4</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="va">Kval</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fl">7200</span>, <span class="fl">11500</span>, <span class="fl">200</span><span class="op">)</span></span>
<span><span class="va">outk</span> <span class="op">&lt;-</span> <span class="fu">doprofile</span><span class="op">(</span><span class="va">Kval</span>,</span>
<span>    loc <span class="op">=</span> <span class="fl">2</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.4</span>, <span class="fl">7200</span>, <span class="fl">6500</span>, <span class="fl">0.3</span><span class="op">)</span>, indat <span class="op">=</span> <span class="va">fish</span>,</span>
<span>    notfix <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">3</span>, <span class="fl">4</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/parset.html">parset</a></span><span class="op">(</span>plots <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">1</span><span class="op">)</span>, cex <span class="op">=</span> <span class="fl">0.85</span>, outmargin <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.5</span>, <span class="fl">0.5</span>, <span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/plotprofile.html">plotprofile</a></span><span class="op">(</span><span class="va">outr</span>, var <span class="op">=</span> <span class="st">"r"</span>, defpar <span class="op">=</span> <span class="cn">FALSE</span>, lwd <span class="op">=</span> <span class="fl">2</span><span class="op">)</span> <span class="co"># MQMF function</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/plotprofile.html">plotprofile</a></span><span class="op">(</span><span class="va">outk</span>, var <span class="op">=</span> <span class="st">"K"</span>, defpar <span class="op">=</span> <span class="cn">FALSE</span>, lwd <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-spm10" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-spm10-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="07-spm_files/figure-html/fig-spm10-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spm10-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;7.10: Schaefer 模型的 r 和 K 参数的似然分布与 abdat 数据集拟合。水平红线将最小 -veLL 与界定 95% 置信区间的似然值分开。垂直绿线与最小值和 95% CI 相交。这些数字是围绕平均最佳值的 95% 置信区间。
</figcaption></figure>
</div>
</div>
</div>
<p>估计这种置信度边界的一个问题是，如果只考虑单个参数，就会忽略参数之间的相互关系和相关性，而 Schaefer 模型对此是众所周知的。但是，<span class="math inline">\(r\)</span> 和 <span class="math inline">\(K\)</span> 参数之间的强相关性意味着，通过组合沿 <span class="math inline">\(r\)</span> 和 <span class="math inline">\(K\)</span> 的两个单独的单独搜索而获得的方形网格搜索将导致许多组合甚至超出模型的近似拟合范围。创建二维似然剖面（实际上是曲面）或跨更多参数的剖面并非不可能，但即使是两个参数，通常也需要一次仔细搜索曲面的一小部分，或者以其他方式处理一些极差的模型拟合，这些拟合将通过简单的网格搜索获得。</p>
<p>在资源评估具有一个或多个固定值参数的情况下，跨单个参数的似然分布仍然有用。在 Schaefer 剩余产量模型等简单模型中不会发生这种情况，但在处理更复杂的种群评估模型时，这种情况并不少见，因为生物参数，如自然死亡率、种群招募曲线的陡峭程度，甚至生长参数可能未知或假定其值与相关物种相同。在评估中获得最佳模型拟合后，其中某些参数采用固定值，就可以重新运行模型拟合，同时更改其中一个固定参数的假设值，以生成该参数的似然剖面。这样，就可以看出模型拟合与固定参数的假设值的一致性。以这种方式生成似然剖面比仅仅进行敏感性分析更可取，在敏感性分析中，我们可以将这些固定参数更改为高于假设值的水平和低于假设值的水平，以查看效果。似然剖面提供了对建模对各个参数的敏感性的更详细的探索。</p>
<p>对于更简单的模型，例如我们在这里处理的模型，还有其他方法可以检查建模中固有的不确定性，这些方法可以尝试考虑参数之间的相关性。</p>
</section><section id="bootstrap-置信区间" class="level3" data-number="7.4.2"><h3 data-number="7.4.2" class="anchored" data-anchor-id="bootstrap-置信区间">
<span class="header-section-number">7.4.2</span> Bootstrap 置信区间</h3>
<p>表征模型拟合不确定性的一种方法是通过对与 cpue 相关的对数正态残差进行自举取样，生成新的 bootstrap cpue 样本来替换原始 cpue 时间序列，从而围绕参数和模型输出（<em>MSY</em> 等）生成百分位数置信区间（Haddon，2011）。每次制作这样的自举样本时，都会重新拟合模型并存储解决方案以供进一步分析。要对剩余产量模型进行这样的分析，可以使用 <strong>MQMF</strong> 函数 <code><a href="https://rdrr.io/pkg/MQMF/man/spmboot.html">spmboot()</a></code>。一旦我们找到了合适的起始参数，我们就可以使用函数 <code><a href="https://rdrr.io/pkg/MQMF/man/fitSPM.html">fitSPM()</a></code> 来获得最佳拟合，并且引导的是与该最佳拟合相关的对数正态残差。在这里，我们将使用噪声相对较大的 <em>dataspm</em> 数据集来说明这些观点</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb35"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#find optimum Schaefer model fit to dataspm data-set Fig 7.11  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="va">dataspm</span><span class="op">)</span>  </span>
<span><span class="va">fish</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">as.matrix</a></span><span class="op">(</span><span class="va">dataspm</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html">colnames</a></span><span class="op">(</span><span class="va">fish</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/chartr.html">tolower</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html">colnames</a></span><span class="op">(</span><span class="va">fish</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="va">pars</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span>r<span class="op">=</span><span class="fl">0.25</span>,K<span class="op">=</span><span class="fl">5500</span>,Binit<span class="op">=</span><span class="fl">3000</span>,sigma<span class="op">=</span><span class="fl">0.25</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="va">ans</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/fitSPM.html">fitSPM</a></span><span class="op">(</span><span class="va">pars</span>,<span class="va">fish</span>,schaefer<span class="op">=</span><span class="cn">TRUE</span>,maxiter<span class="op">=</span><span class="fl">1000</span><span class="op">)</span> <span class="co">#Schaefer  </span></span>
<span><span class="va">answer</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/plotspmmod.html">plotspmmod</a></span><span class="op">(</span><span class="va">ans</span><span class="op">$</span><span class="va">estimate</span>,<span class="va">fish</span>,schaefer<span class="op">=</span><span class="cn">TRUE</span>,addrmse<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-spm11" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-spm11-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="07-spm_files/figure-html/fig-spm11-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spm11-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;7.11: 描述最佳参数与 <em>dataspm</em> 数据集拟合的汇总图。拟合和 cpue 数据之间的对数正态残差如右下角所示。这些是自举的，每个自举样本乘以最佳预测的 cpue 时间序列，以获得每个自举 cpue 时间序列。
</figcaption></figure>
</div>
</div>
</div>
<p>一旦我们获得了最佳拟合，我们就可以继续进行 bootstrap 分析。通常会运行至少 1000 次重复，甚至更多，即使这可能需要几分钟才能完成。在这种情况下，即使在最佳拟合状态下，对数正态残差中也存在模式，这表明模型结构缺少一些影响渔业的近似周期性事件。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb36"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co">#bootstrap the log-normal residuals from optimum model fit  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">210368</span><span class="op">)</span>  </span>
<span><span class="va">reps</span> <span class="op">&lt;-</span> <span class="fl">1000</span> <span class="co"># can take 10 sec on a large Desktop. Be patient  </span></span>
<span> <span class="co">#startime &lt;- Sys.time()  # schaefer=TRUE is the default  </span></span>
<span><span class="va">boots</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/spmboot.html">spmboot</a></span><span class="op">(</span><span class="va">ans</span><span class="op">$</span><span class="va">estimate</span>,fishery<span class="op">=</span><span class="va">fish</span>,iter<span class="op">=</span><span class="va">reps</span><span class="op">)</span>  </span>
<span> <span class="co">#print(Sys.time() - startime) # how long did it take?  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/str.html">str</a></span><span class="op">(</span><span class="va">boots</span>,max.level<span class="op">=</span><span class="fl">1</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>List of 2
 $ dynam  : num [1:1000, 1:31, 1:5] 2846 3555 2459 3020 1865 ...
  ..- attr(*, "dimnames")=List of 3
 $ bootpar: num [1:1000, 1:8] 0.242 0.236 0.192 0.23 0.361 ...
  ..- attr(*, "dimnames")=List of 2</code></pre>
</div>
</div>
<p>输出结果包含每个运行的动态预测模型生物量、每个自举样本的 cpue、每个自举样本的预测 cpue、耗竭时间序列和年收获率时间序列（存储 5 个变量的 31 年运行 <span class="math inline">\(reps=1000\)</span> 次）。每项分析都可用于说明和总结分析结果和不确定性。鉴于 <a href="#fig-spm11" class="quarto-xref">图&nbsp;<span>7.11</span></a> 中的残差相对较大，可以预计不确定性相对较高，见 <a href="#tbl-spm5" class="quarto-xref">表&nbsp;<span>7.5</span></a> 。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb38"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span>  <span class="co">#Summarize bootstrapped parameter estimates as quantiles  Table 7.6 </span></span>
<span><span class="va">bootpar</span> <span class="op">&lt;-</span> <span class="va">boots</span><span class="op">$</span><span class="va">bootpar</span>  </span>
<span><span class="va">rows</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/colnames.html">colnames</a></span><span class="op">(</span><span class="va">bootpar</span><span class="op">)</span>  </span>
<span><span class="va">columns</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.025</span>,<span class="fl">0.05</span>,<span class="fl">0.5</span>,<span class="fl">0.95</span>,<span class="fl">0.975</span><span class="op">)</span>,<span class="st">"Mean"</span><span class="op">)</span>  </span>
<span><span class="va">bootCI</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="cn">NA</span>,nrow<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="va">rows</span><span class="op">)</span>,ncol<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="va">columns</span><span class="op">)</span>,  </span>
<span>                 dimnames<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="va">rows</span>,<span class="va">columns</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="va">rows</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span>  </span>
<span>   <span class="va">tmp</span> <span class="op">&lt;-</span> <span class="va">bootpar</span><span class="op">[</span>,<span class="va">i</span><span class="op">]</span>  </span>
<span>   <span class="va">qtil</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/quantile.html">quantile</a></span><span class="op">(</span><span class="va">tmp</span>,probs<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.025</span>,<span class="fl">0.05</span>,<span class="fl">0.5</span>,<span class="fl">0.95</span>,<span class="fl">0.975</span><span class="op">)</span>,na.rm<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span>  </span>
<span>   <span class="va">bootCI</span><span class="op">[</span><span class="va">i</span>,<span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">qtil</span>,<span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="va">tmp</span>,na.rm<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="op">}</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<div id="tbl-spm5" class="cell quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-spm5-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
表&nbsp;7.5: The quantiles for the Schaefer model parameters and some model outputs, plus the arithmetic mean. The 0.5 values are the median values.
</figcaption><div aria-describedby="tbl-spm5-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell-output-display">
<table class="do-not-create-environment cell table table-sm table-striped small">
<thead><tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: right;">0.025</th>
<th style="text-align: right;">0.05</th>
<th style="text-align: right;">0.5</th>
<th style="text-align: right;">0.95</th>
<th style="text-align: right;">0.975</th>
<th style="text-align: right;">Mean</th>
</tr></thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">r</td>
<td style="text-align: right;">0.132</td>
<td style="text-align: right;">0.149</td>
<td style="text-align: right;">0.246</td>
<td style="text-align: right;">0.354</td>
<td style="text-align: right;">0.373</td>
<td style="text-align: right;">0.248</td>
</tr>
<tr class="even">
<td style="text-align: left;">K</td>
<td style="text-align: right;">3676.357</td>
<td style="text-align: right;">3840.696</td>
<td style="text-align: right;">5184.224</td>
<td style="text-align: right;">7965.332</td>
<td style="text-align: right;">8997.495</td>
<td style="text-align: right;">5481.514</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Binit</td>
<td style="text-align: right;">1727.198</td>
<td style="text-align: right;">1845.846</td>
<td style="text-align: right;">2829.008</td>
<td style="text-align: right;">4935.752</td>
<td style="text-align: right;">5603.287</td>
<td style="text-align: right;">3041.688</td>
</tr>
<tr class="even">
<td style="text-align: left;">sigma</td>
<td style="text-align: right;">0.139</td>
<td style="text-align: right;">0.142</td>
<td style="text-align: right;">0.157</td>
<td style="text-align: right;">0.163</td>
<td style="text-align: right;">0.163</td>
<td style="text-align: right;">0.155</td>
</tr>
<tr class="odd">
<td style="text-align: left;">-veLL</td>
<td style="text-align: right;">-17.232</td>
<td style="text-align: right;">-16.465</td>
<td style="text-align: right;">-13.479</td>
<td style="text-align: right;">-12.316</td>
<td style="text-align: right;">-12.238</td>
<td style="text-align: right;">-13.815</td>
</tr>
<tr class="even">
<td style="text-align: left;">MSY</td>
<td style="text-align: right;">280.370</td>
<td style="text-align: right;">289.467</td>
<td style="text-align: right;">318.420</td>
<td style="text-align: right;">352.719</td>
<td style="text-align: right;">366.242</td>
<td style="text-align: right;">319.546</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Depl</td>
<td style="text-align: right;">0.338</td>
<td style="text-align: right;">0.367</td>
<td style="text-align: right;">0.529</td>
<td style="text-align: right;">0.669</td>
<td style="text-align: right;">0.699</td>
<td style="text-align: right;">0.524</td>
</tr>
<tr class="even">
<td style="text-align: left;">Harv</td>
<td style="text-align: right;">0.051</td>
<td style="text-align: right;">0.058</td>
<td style="text-align: right;">0.088</td>
<td style="text-align: right;">0.116</td>
<td style="text-align: right;">0.124</td>
<td style="text-align: right;">0.087</td>
</tr>
</tbody>
</table>
</div>
</div>
</figure>
</div>
</div>
<p>可以使用直方图可视化此类百分位置信区间，并包括相应的选定百分位置信区间。</p>
<p>人们期望 1000 次重复将提供平滑的响应和具有代表性的置信范围，但有时，尤其是在嘈杂的数据中，需要更多的重复才能获得不确定性的平滑表示。2000 次重复需要 20 秒可能看起来很长，但考虑到这样的事情过去需要数小时甚至数天，大约 20 秒是了不起的。请注意，置信边界在均值或中位数估计值附近不一定是对称的。另请注意，在最后一年的消耗估计中，第 5 个百分位的置信区间远高于 <span class="math inline">\(0.2B_0\)</span>，这意味着即使这种分析是不确定的，目前的消耗水平也高于大多数地方使用的生物量消耗的默认极限参考点，可能性超过 95%。我们需要中央第 80 个百分位数才能找到下限 10%，但它必然高于第 5 个百分位数。<span class="math inline">\(K\)</span> 和 <span class="math inline">\(Binit\)</span> 值所显示的中位数和均值比其他参数和模型输出的差异更大，这表明存在一些偏差证据（<a href="#fig-spm12" class="quarto-xref">图&nbsp;<span>7.12</span></a>） 。由于某些图仍然存在粗糙度，因此可以通过增加重复次数来改善粗糙度。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb39"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co">#boostrap CI. Note use of uphist to expand scale  Fig 7.12 </span></span>
<span><span class="op">{</span><span class="va">colf</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">4</span><span class="op">)</span>; <span class="va">lwdf</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">3</span>,<span class="fl">1</span>,<span class="fl">3</span><span class="op">)</span>; <span class="va">ltyf</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">2</span><span class="op">)</span>  </span>
<span><span class="va">colsf</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">3</span>,<span class="fl">4</span>,<span class="fl">6</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/parset.html">parset</a></span><span class="op">(</span>plots<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">3</span>,<span class="fl">2</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html">hist</a></span><span class="op">(</span><span class="va">bootpar</span><span class="op">[</span>,<span class="st">"r"</span><span class="op">]</span>,breaks<span class="op">=</span><span class="fl">25</span>,main<span class="op">=</span><span class="st">""</span>,xlab<span class="op">=</span><span class="st">"r"</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html">abline</a></span><span class="op">(</span>v<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">bootCI</span><span class="op">[</span><span class="st">"r"</span>,<span class="va">colsf</span><span class="op">]</span><span class="op">)</span>,col<span class="op">=</span><span class="va">colf</span>,lwd<span class="op">=</span><span class="va">lwdf</span>,lty<span class="op">=</span><span class="va">ltyf</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/uphist.html">uphist</a></span><span class="op">(</span><span class="va">bootpar</span><span class="op">[</span>,<span class="st">"K"</span><span class="op">]</span>,maxval<span class="op">=</span><span class="fl">14000</span>,breaks<span class="op">=</span><span class="fl">25</span>,main<span class="op">=</span><span class="st">""</span>,xlab<span class="op">=</span><span class="st">"K"</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html">abline</a></span><span class="op">(</span>v<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">bootCI</span><span class="op">[</span><span class="st">"K"</span>,<span class="va">colsf</span><span class="op">]</span><span class="op">)</span>,col<span class="op">=</span><span class="va">colf</span>,lwd<span class="op">=</span><span class="va">lwdf</span>,lty<span class="op">=</span><span class="va">ltyf</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html">hist</a></span><span class="op">(</span><span class="va">bootpar</span><span class="op">[</span>,<span class="st">"Binit"</span><span class="op">]</span>,breaks<span class="op">=</span><span class="fl">25</span>,main<span class="op">=</span><span class="st">""</span>,xlab<span class="op">=</span><span class="st">"Binit"</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html">abline</a></span><span class="op">(</span>v<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">bootCI</span><span class="op">[</span><span class="st">"Binit"</span>,<span class="va">colsf</span><span class="op">]</span><span class="op">)</span>,col<span class="op">=</span><span class="va">colf</span>,lwd<span class="op">=</span><span class="va">lwdf</span>,lty<span class="op">=</span><span class="va">ltyf</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/uphist.html">uphist</a></span><span class="op">(</span><span class="va">bootpar</span><span class="op">[</span>,<span class="st">"MSY"</span><span class="op">]</span>,breaks<span class="op">=</span><span class="fl">25</span>,main<span class="op">=</span><span class="st">""</span>,xlab<span class="op">=</span><span class="st">"MSY"</span>,maxval<span class="op">=</span><span class="fl">450</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html">abline</a></span><span class="op">(</span>v<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">bootCI</span><span class="op">[</span><span class="st">"MSY"</span>,<span class="va">colsf</span><span class="op">]</span><span class="op">)</span>,col<span class="op">=</span><span class="va">colf</span>,lwd<span class="op">=</span><span class="va">lwdf</span>,lty<span class="op">=</span><span class="va">ltyf</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html">hist</a></span><span class="op">(</span><span class="va">bootpar</span><span class="op">[</span>,<span class="st">"Depl"</span><span class="op">]</span>,breaks<span class="op">=</span><span class="fl">25</span>,main<span class="op">=</span><span class="st">""</span>,xlab<span class="op">=</span><span class="st">"Final Depletion"</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html">abline</a></span><span class="op">(</span>v<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">bootCI</span><span class="op">[</span><span class="st">"Depl"</span>,<span class="va">colsf</span><span class="op">]</span><span class="op">)</span>,col<span class="op">=</span><span class="va">colf</span>,lwd<span class="op">=</span><span class="va">lwdf</span>,lty<span class="op">=</span><span class="va">ltyf</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html">hist</a></span><span class="op">(</span><span class="va">bootpar</span><span class="op">[</span>,<span class="st">"Harv"</span><span class="op">]</span>,breaks<span class="op">=</span><span class="fl">25</span>,main<span class="op">=</span><span class="st">""</span>,xlab<span class="op">=</span><span class="st">"End Harvest Rate"</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html">abline</a></span><span class="op">(</span>v<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">bootCI</span><span class="op">[</span><span class="st">"Harv"</span>,<span class="va">colsf</span><span class="op">]</span><span class="op">)</span>,col<span class="op">=</span><span class="va">colf</span>,lwd<span class="op">=</span><span class="va">lwdf</span>,lty<span class="op">=</span><span class="va">ltyf</span><span class="op">)</span> <span class="op">}</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-spm12" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-spm12-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="07-spm_files/figure-html/fig-spm12-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spm12-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;7.12: The 1000 bootstrap replicates from the optimum spm fit to the dataspm data-set. The vertical lines, in each case, are the median and 90th percentile confidence intervals and the dashed vertical blue lines are the mean values. The function uphist() is used to expand the x-axis in K, Binit, and MSY.
</figcaption></figure>
</div>
</div>
</div>
<p>存储在 <em>boots$dynam</em> 中的拟合轨迹也可以直观地指示分析的不确定性。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb40"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span>  <span class="co">#Fig7.13 1000 bootstrap trajectories for dataspm model fit   </span></span>
<span><span class="va">dynam</span> <span class="op">&lt;-</span> <span class="va">boots</span><span class="op">$</span><span class="va">dynam</span>  </span>
<span><span class="va">years</span> <span class="op">&lt;-</span> <span class="va">fish</span><span class="op">[</span>,<span class="st">"year"</span><span class="op">]</span>  </span>
<span><span class="va">nyrs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="va">years</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/parset.html">parset</a></span><span class="op">(</span><span class="op">)</span>  </span>
<span><span class="va">ymax</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/getmax.html">getmax</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">dynam</span><span class="op">[</span>,,<span class="st">"predCE"</span><span class="op">]</span>,<span class="va">fish</span><span class="op">[</span>,<span class="st">"cpue"</span><span class="op">]</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">fish</span><span class="op">[</span>,<span class="st">"year"</span><span class="op">]</span>,<span class="va">fish</span><span class="op">[</span>,<span class="st">"cpue"</span><span class="op">]</span>,type<span class="op">=</span><span class="st">"n"</span>,ylim<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="va">ymax</span><span class="op">)</span>,  </span>
<span>     xlab<span class="op">=</span><span class="st">"Year"</span>,ylab<span class="op">=</span><span class="st">"CPUE"</span>,yaxs<span class="op">=</span><span class="st">"i"</span>,panel.first <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/graphics/grid.html">grid</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">reps</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">years</span>,<span class="va">dynam</span><span class="op">[</span><span class="va">i</span>,,<span class="st">"predCE"</span><span class="op">]</span>,lwd<span class="op">=</span><span class="fl">1</span>,col<span class="op">=</span><span class="fl">8</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">years</span>,<span class="va">answer</span><span class="op">$</span><span class="va">Dynamics</span><span class="op">$</span><span class="va">outmat</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="va">nyrs</span>,<span class="st">"predCE"</span><span class="op">]</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">0</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html">points</a></span><span class="op">(</span><span class="va">years</span>,<span class="va">fish</span><span class="op">[</span>,<span class="st">"cpue"</span><span class="op">]</span>,cex<span class="op">=</span><span class="fl">1.2</span>,pch<span class="op">=</span><span class="fl">16</span>,col<span class="op">=</span><span class="fl">1</span><span class="op">)</span>  </span>
<span><span class="va">percs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/apply.html">apply</a></span><span class="op">(</span><span class="va">dynam</span><span class="op">[</span>,,<span class="st">"predCE"</span><span class="op">]</span>,<span class="fl">2</span>,<span class="va">quants</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/arrows.html">arrows</a></span><span class="op">(</span>x0<span class="op">=</span><span class="va">years</span>,y0<span class="op">=</span><span class="va">percs</span><span class="op">[</span><span class="st">"5%"</span>,<span class="op">]</span>,y1<span class="op">=</span><span class="va">percs</span><span class="op">[</span><span class="st">"95%"</span>,<span class="op">]</span>,length<span class="op">=</span><span class="fl">0.03</span>,  </span>
<span>       angle<span class="op">=</span><span class="fl">90</span>,code<span class="op">=</span><span class="fl">3</span>,col<span class="op">=</span><span class="fl">0</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-spm13" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-spm13-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="07-spm_files/figure-html/fig-spm13-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spm13-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;7.13: A plot of the original observed CPUE (black dots), the optimum predicted CPUE (solid line), the 1000 bootstrap predicted CPUE (the grey lines), and the 90th percentile confidence intervals around those predicted values (the vertical bars).
</figcaption></figure>
</div>
</div>
</div>
<p>预测 CPUE 值与观测 CPUE 值之间存在明显偏差（<a href="#fig-spm13" class="quarto-xref">图&nbsp;<span>7.13</span></a>）,但估计值的中位数及其周围的置信区间仍然十分明确。</p>
<p>请记住，无论何时在时间序列数据上使用自举法，其中时刻 <span class="math inline">\(t + 1\)</span> 的值与时刻 <span class="math inline">\(t\)</span> 的值相关，都有必要自举任何拟合模型的残差值，并将它们与最优拟合值联系起来。对于CPUE 数据，我们通常使用对数正态残差误差，因此一旦找到最优解，这些残差定义为:</p>
<p><span id="eq-spm18"><span class="math display">\[
\hat{I}_{t,resid} = \frac{I_t}{\hat{I_t}}  
\qquad(7.18)\]</span></span></p>
<p>其中<span class="math inline">\(I_t\)</span> 是年<span class="math inline">\(t\)</span>中的观测 CPUE，<span class="math inline">\(I_t/\hat I_t\)</span> 是年 <span class="math inline">\(t\)</span> 中观测 CPUE 除以预测 CPUE（对数正态残差 <span class="math inline">\(\hat I_{t, resid}\)</span>。这种残差会有一个时间序列，自举法的生成包括从时间序列中随机抽取数值，并进行替换， 从而得到一个对数正态残差的自举样本。然后将这些值乘以原始的最优预测 cpue 值，生成不同时间序列的自举 cpue。</p>
<p><span id="eq-spm19"><span class="math display">\[
{I_t}^* = \hat{I_t} * \left [ \frac{I}{\hat{I}} \right ]^*
\qquad(7.19)\]</span></span></p>
<p>其中上标 ∗ 表示自举样本，<span class="math inline">\(I_t^*\)</span> 表示年 <span class="math inline">\(t\)</span> 的 Bootstrap CPUE，<span class="math inline">\(\left [ \frac{I}{\hat{I}} \right ]^*\)</span> 表示来自对数正态残差的单个随机样本，然后将其乘以当年的预测 CPUE。这些方程反映了 <strong>MQMF</strong> 函数 <code><a href="https://rdrr.io/pkg/MQMF/man/spmboot.html">spmboot()</a></code> 中的特定代码行。</p>
<p>值得一做的是重复上述分析，但将 <em>schaefer = TRUE</em> 处改为 <em>FALSE</em> ，以便用 Fox 剩余产量模型来拟合模型。这样就可以比较两个模型的不确定性。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb41"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span>  <span class="co">#Fit the Fox model to dataspm; note different parameters  </span></span>
<span><span class="va">pars</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span>r<span class="op">=</span><span class="fl">0.15</span>,K<span class="op">=</span><span class="fl">6500</span>,Binit<span class="op">=</span><span class="fl">3000</span>,sigma<span class="op">=</span><span class="fl">0.20</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="va">ansF</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/fitSPM.html">fitSPM</a></span><span class="op">(</span><span class="va">pars</span>,<span class="va">fish</span>,schaefer<span class="op">=</span><span class="cn">FALSE</span>,maxiter<span class="op">=</span><span class="fl">1000</span><span class="op">)</span> <span class="co">#Fox version  </span></span>
<span><span class="va">bootsF</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/spmboot.html">spmboot</a></span><span class="op">(</span><span class="va">ansF</span><span class="op">$</span><span class="va">estimate</span>,fishery<span class="op">=</span><span class="va">fish</span>,iter<span class="op">=</span><span class="va">reps</span>,schaefer<span class="op">=</span><span class="cn">FALSE</span><span class="op">)</span>  </span>
<span><span class="va">dynamF</span> <span class="op">&lt;-</span> <span class="va">bootsF</span><span class="op">$</span><span class="va">dynam</span>   </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb42"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span>  <span class="co"># bootstrap trajectories from both model fits  Fig 7.14  </span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/parset.html">parset</a></span><span class="op">(</span><span class="op">)</span>  </span>
<span><span class="va">ymax</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/getmax.html">getmax</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">dynam</span><span class="op">[</span>,,<span class="st">"predCE"</span><span class="op">]</span>,<span class="va">fish</span><span class="op">[</span>,<span class="st">"cpue"</span><span class="op">]</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">fish</span><span class="op">[</span>,<span class="st">"year"</span><span class="op">]</span>,<span class="va">fish</span><span class="op">[</span>,<span class="st">"cpue"</span><span class="op">]</span>,type<span class="op">=</span><span class="st">"n"</span>,ylim<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="va">ymax</span><span class="op">)</span>,  </span>
<span>     xlab<span class="op">=</span><span class="st">"Year"</span>,ylab<span class="op">=</span><span class="st">"CPUE"</span>,yaxs<span class="op">=</span><span class="st">"i"</span>,panel.first <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/graphics/grid.html">grid</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">reps</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">years</span>,<span class="va">dynamF</span><span class="op">[</span><span class="va">i</span>,,<span class="st">"predCE"</span><span class="op">]</span>,lwd<span class="op">=</span><span class="fl">1</span>,col<span class="op">=</span><span class="fl">1</span>,lty<span class="op">=</span><span class="fl">1</span><span class="op">)</span>  </span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">reps</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">years</span>,<span class="va">dynam</span><span class="op">[</span><span class="va">i</span>,,<span class="st">"predCE"</span><span class="op">]</span>,lwd<span class="op">=</span><span class="fl">1</span>,col<span class="op">=</span><span class="fl">8</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">years</span>,<span class="va">answer</span><span class="op">$</span><span class="va">Dynamics</span><span class="op">$</span><span class="va">outmat</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="va">nyrs</span>,<span class="st">"predCE"</span><span class="op">]</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">0</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html">points</a></span><span class="op">(</span><span class="va">years</span>,<span class="va">fish</span><span class="op">[</span>,<span class="st">"cpue"</span><span class="op">]</span>,cex<span class="op">=</span><span class="fl">1.1</span>,pch<span class="op">=</span><span class="fl">16</span>,col<span class="op">=</span><span class="fl">1</span><span class="op">)</span>  </span>
<span><span class="va">percs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/apply.html">apply</a></span><span class="op">(</span><span class="va">dynam</span><span class="op">[</span>,,<span class="st">"predCE"</span><span class="op">]</span>,<span class="fl">2</span>,<span class="va">quants</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/arrows.html">arrows</a></span><span class="op">(</span>x0<span class="op">=</span><span class="va">years</span>,y0<span class="op">=</span><span class="va">percs</span><span class="op">[</span><span class="st">"5%"</span>,<span class="op">]</span>,y1<span class="op">=</span><span class="va">percs</span><span class="op">[</span><span class="st">"95%"</span>,<span class="op">]</span>,length<span class="op">=</span><span class="fl">0.03</span>,  </span>
<span>       angle<span class="op">=</span><span class="fl">90</span>,code<span class="op">=</span><span class="fl">3</span>,col<span class="op">=</span><span class="fl">0</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/legend.html">legend</a></span><span class="op">(</span><span class="fl">1985</span>,<span class="fl">0.35</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Schaefer"</span>,<span class="st">"Fox"</span><span class="op">)</span>,col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">8</span>,<span class="fl">1</span><span class="op">)</span>,bty<span class="op">=</span><span class="st">"n"</span>,lwd<span class="op">=</span><span class="fl">3</span><span class="op">)</span>    </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-spm14" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-spm14-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="07-spm_files/figure-html/fig-spm14-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spm14-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;7.14: A plot of the original observed CPUE (dots), the optimum predicted CPUE (solid white line) with the 90th percentile confidence intervals (the white bars). The black lines are the Fox model bootstrap replicates while the grey lines over the black are those from the Schaefer model.
</figcaption></figure>
</div>
</div>
</div>
<p>可以说，Fox 模型在捕捉这些数据的变异性方面更成功，因为黑线的扩散范围略大于灰色线（<a href="#fig-spm14" class="quarto-xref">图&nbsp;<span>7.14</span></a>）。或者，可以说 Fox 模型不太确定。总体而言，Schaefer 和 Fox 模型的输出之间没有太大差异，甚至像他们预测的那样 <span class="math inline">\(MSY\)</span> 值非常相似（313.512 吨与 311.661 吨）。然而，最终，Fox 模型中密度依赖性的非线性似乎赋予了它更大的灵活性，因此它能够比更严格的 Schaefer 模型更好地捕获原始数据的变异性（因此它的 -ve 对数似然性更小，参见 <code>outfit(ansF)</code>）。但这两个模型都无法捕获残差中表现出的循环特性，意味着建模动力学中未包含某些过程，即模型错误规范。这两种模型都不完全充分，尽管它们都可以提供足够的近似动态，可以用来产生管理建议（关于周期过程随时间保持不变的警告，等等）。</p>
</section><section id="参数相关性" class="level3" data-number="7.4.3"><h3 data-number="7.4.3" class="anchored" data-anchor-id="参数相关性">
<span class="header-section-number">7.4.3</span> 参数相关性</h3>
<p>组合的 bootstrap 样本和相关估计值提供了反映数据和拟合模型的参数之间变异性的表征。如果我们将各种参数相互绘制，任何参数相关性都会变得明显。之间强烈的负曲线-线性关系 <span class="math inline">\(r\)</span> 和 <span class="math inline">\(K\)</span> 非常明显，而与其他参数之间的关系也既不是随机的，也不是平滑正态的。在极端值下有一些点，但它们仍然很少见，但是，这些图确实说明了该分析中的变化形式。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb43"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co"># plot variables against each other, use MQMF panel.cor  Fig 7.15  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/pairs.html">pairs</a></span><span class="op">(</span><span class="va">boots</span><span class="op">$</span><span class="va">bootpar</span><span class="op">[</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">4</span>,<span class="fl">6</span>,<span class="fl">7</span><span class="op">)</span><span class="op">]</span>,lower.panel<span class="op">=</span><span class="va">panel.smooth</span>,   </span>
<span>      upper.panel<span class="op">=</span><span class="va">panel.cor</span>,gap<span class="op">=</span><span class="fl">0</span>,lwd<span class="op">=</span><span class="fl">2</span>,cex<span class="op">=</span><span class="fl">0.5</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-spm15" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-spm15-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="07-spm_files/figure-html/fig-spm15-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spm15-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;7.15: 模型参数与 Schaefer 模型（ Fox 模型使用 <code>bootsF$bootpar</code>）的一些输出之间的关系。下方面板在数据中具有一条红色的平滑线，用于说明任何趋势，而上方面板具有线性相关系数。少数极值会扭曲绘图。The relationships between the model parameters and some outputs for the Schaefer model (use bootsF$bootpar for the Fox model ). The lower panels have a red smoother line through the data illustrating any trends, while the upper panels have the linear correlation coefficient. The few extreme values distort the plots.
</figcaption></figure>
</div>
</div>
</div>
</section><section id="渐近误差" class="level3" data-number="7.4.4"><h3 data-number="7.4.4" class="anchored" data-anchor-id="渐近误差">
<span class="header-section-number">7.4.4</span> 渐近误差</h3>
<p>如<em>“不确定性”</em>一章所述，在模型拟合过程中，描述与参数估计相关的不确定性的经典方法是使用所谓的渐近误差。渐近误差源自方差-协方差矩阵，可用于描述模型参数之间的变异性和交互作用。在自举法的章节中，可以 <code><a href="https://rdrr.io/r/graphics/pairs.html">pairs()</a></code> 函数直观显示参数之间的关系， 而这些关系显然不是很好的多变量正态关系。尽管如此，仍然可以使用从方差-协方差矩阵 （<em>vcov</em>） 得出的多变量正态来描述模型的不确定性。在使用<code><a href="https://rdrr.io/r/stats/optim.html">optim()</a></code> 或 <code><a href="https://rdrr.io/r/stats/nlm.html">nlm()</a></code> 拟合模型时，我们可以将 <em>vcov</em> 估计为一个选项来估计。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb44"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span>  <span class="co">#Start the SPM analysis using asymptotic errors.  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="va">dataspm</span><span class="op">)</span>    <span class="co"># Note the use of hess=TRUE in call to fitSPM   </span></span>
<span><span class="va">fish</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">as.matrix</a></span><span class="op">(</span><span class="va">dataspm</span><span class="op">)</span>     <span class="co"># using as.matrix for more speed  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html">colnames</a></span><span class="op">(</span><span class="va">fish</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/chartr.html">tolower</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html">colnames</a></span><span class="op">(</span><span class="va">fish</span><span class="op">)</span><span class="op">)</span>  <span class="co"># just in case</span></span>
<span><span class="va">pars</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span>r<span class="op">=</span><span class="fl">0.25</span>,K<span class="op">=</span><span class="fl">5200</span>,Binit<span class="op">=</span><span class="fl">2900</span>,sigma<span class="op">=</span><span class="fl">0.20</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="va">ans</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/fitSPM.html">fitSPM</a></span><span class="op">(</span><span class="va">pars</span>,<span class="va">fish</span>,schaefer<span class="op">=</span><span class="cn">TRUE</span>,maxiter<span class="op">=</span><span class="fl">1000</span>,hess<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span>    </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>通过使用 <code><a href="https://rdrr.io/pkg/MQMF/man/outfit.html">outfit()</a></code> 函数，我们可以看到在 <em>hess</em> 参数设置为 “TRUE”的情况下，Schaefer 剩余产量模型与 <em>dataspm</em> 数据集的拟合结果。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb45"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#The hessian matrix from the Schaefer fit to the dataspm data   </span></span>
<span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/outfit.html">outfit</a></span><span class="op">(</span><span class="va">ans</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>nlm solution:   
minimum     :  -12.12879 
iterations  :  2 
code        :  2 &gt;1 iterates in tolerance, probably solution 
        par      gradient   transpar
1 -1.417080  0.0031126661    0.24242
2  8.551232 -0.0017992364 5173.12308
3  7.953564 -0.0009892147 2845.69834
4 -1.810225 -0.0021756288    0.16362
hessian     : 
             [,1]        [,2]          [,3]        [,4]
[1,] 1338.3568627 1648.147068  -74.39814471 -0.14039276
[2,] 1648.1470677 2076.777078 -115.32342460 -1.80063349
[3,]  -74.3981447 -115.323425   25.48912486 -0.01822396
[4,]   -0.1403928   -1.800633   -0.01822396 61.99195077</code></pre>
</div>
</div>
<p><code><a href="https://rdrr.io/pkg/MQMF/man/fitSPM.html">fitSPM()</a></code> 中的最终最小化使用的是最大似然法（实际上是最小负对数似然），因此我们需要反演赫斯方差以获得方差-协方差矩阵。对角线的平方根也给出了每个参数的标准误差估计值（参见 “不确定性”一章）。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb47"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#calculate the var-covar matrix and the st errors  </span></span>
<span><span class="va">vcov</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/solve.html">solve</a></span><span class="op">(</span><span class="va">ans</span><span class="op">$</span><span class="va">hessian</span><span class="op">)</span> <span class="co"># calculate variance-covariance matrix  </span></span>
<span><span class="va">label</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"r"</span>,<span class="st">"K"</span>, <span class="st">"Binit"</span>,<span class="st">"sigma"</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html">colnames</a></span><span class="op">(</span><span class="va">vcov</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="va">label</span>; <span class="fu"><a href="https://rdrr.io/r/base/colnames.html">rownames</a></span><span class="op">(</span><span class="va">vcov</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="va">label</span>  </span>
<span><span class="va">outvcov</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span><span class="op">(</span><span class="va">vcov</span>,<span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">sqrt</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/diag.html">diag</a></span><span class="op">(</span><span class="va">vcov</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html">rownames</a></span><span class="op">(</span><span class="va">outvcov</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">label</span>,<span class="st">"StErr"</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<div id="tbl-spm6" class="cell quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-spm6-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
表&nbsp;7.6: The variance-covariance (vcov) matrix is the inverse of the Hessian and the parameter standard errors are the square-root of the diagonal of the vcov matrix.
</figcaption><div aria-describedby="tbl-spm6-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell-output-display">
<table class="do-not-create-environment cell table table-sm table-striped small">
<thead><tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: right;">r</th>
<th style="text-align: right;">K</th>
<th style="text-align: right;">Binit</th>
<th style="text-align: right;">sigma</th>
</tr></thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">r</td>
<td style="text-align: right;">0.0668</td>
<td style="text-align: right;">-0.0563</td>
<td style="text-align: right;">-0.0599</td>
<td style="text-align: right;">-0.0015</td>
</tr>
<tr class="even">
<td style="text-align: left;">K</td>
<td style="text-align: right;">-0.0563</td>
<td style="text-align: right;">0.0481</td>
<td style="text-align: right;">0.0534</td>
<td style="text-align: right;">0.0013</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Binit</td>
<td style="text-align: right;">-0.0599</td>
<td style="text-align: right;">0.0534</td>
<td style="text-align: right;">0.1062</td>
<td style="text-align: right;">0.0014</td>
</tr>
<tr class="even">
<td style="text-align: left;">sigma</td>
<td style="text-align: right;">-0.0015</td>
<td style="text-align: right;">0.0013</td>
<td style="text-align: right;">0.0014</td>
<td style="text-align: right;">0.0162</td>
</tr>
<tr class="odd">
<td style="text-align: left;">StErr</td>
<td style="text-align: right;">0.2584</td>
<td style="text-align: right;">0.2194</td>
<td style="text-align: right;">0.3258</td>
<td style="text-align: right;">0.1271</td>
</tr>
</tbody>
</table>
</div>
</div>
</figure>
</div>
</div>
<p>现在我们有了最优解和方差-协方差矩阵，可以使用多变量正态分布来获得多个参数的合理组合，这些参数组合可以用来计算输出，如 <span class="math inline">\(MSY\)</span> ，并描述预期动态。基本 R 不包括从多变量正态分布中采样的方法，但有一些免费提供的软件包可以做到。我们将使用可从 CRAN 下载的 mvtnorm 软件包。在使用这种软件包时，可以通过 <code><a href="https://rdrr.io/r/utils/packageDescription.html">packageDescription()</a></code> 函数确定编写者和其他重要信息。另外，在查看软件包中某个函数的帮助文件时，如果滚动到页面底部并点击索引超链接，就可以直接阅读描述文件。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb48"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span>  <span class="co">#generate 1000 parameter vectors from multi-variate normal  </span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="http://mvtnorm.R-forge.R-project.org">mvtnorm</a></span><span class="op">)</span>   <span class="co"># use RStudio, or install.packages("mvtnorm")  </span></span>
<span><span class="va">N</span> <span class="op">&lt;-</span> <span class="fl">1000</span> <span class="co"># number of parameter vectors, use vcov from above  </span></span>
<span><span class="va">mvn</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="va">fish</span><span class="op">[</span>,<span class="st">"year"</span><span class="op">]</span><span class="op">)</span> <span class="co">#matrix to store cpue trajectories  </span></span>
<span><span class="va">mvncpue</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">0</span>,nrow<span class="op">=</span><span class="va">N</span>,ncol<span class="op">=</span><span class="va">mvn</span>,dimnames<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">N</span>,<span class="va">fish</span><span class="op">[</span>,<span class="st">"year"</span><span class="op">]</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="va">columns</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"r"</span>,<span class="st">"K"</span>,<span class="st">"Binit"</span>,<span class="st">"sigma"</span><span class="op">)</span>  </span>
<span><span class="va">optpar</span> <span class="op">&lt;-</span> <span class="va">ans</span><span class="op">$</span><span class="va">estimate</span> <span class="co"># Fill matrix with mvn parameter vectors   </span></span>
<span><span class="va">mvnpar</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/mvtnorm/man/Mvnorm.html">rmvnorm</a></span><span class="op">(</span><span class="va">N</span>,mean<span class="op">=</span><span class="va">optpar</span>,sigma<span class="op">=</span><span class="va">vcov</span><span class="op">)</span><span class="op">)</span>,nrow<span class="op">=</span><span class="va">N</span>,  </span>
<span>                 ncol<span class="op">=</span><span class="fl">4</span>,dimnames<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">N</span>,<span class="va">columns</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="va">msy</span> <span class="op">&lt;-</span> <span class="va">mvnpar</span><span class="op">[</span>,<span class="st">"r"</span><span class="op">]</span><span class="op">*</span><span class="va">mvnpar</span><span class="op">[</span>,<span class="st">"K"</span><span class="op">]</span><span class="op">/</span><span class="fl">4</span>  </span>
<span><span class="va">nyr</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="va">fish</span><span class="op">[</span>,<span class="st">"year"</span><span class="op">]</span><span class="op">)</span>  </span>
<span><span class="va">depletion</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html">numeric</a></span><span class="op">(</span><span class="va">N</span><span class="op">)</span> <span class="co">#now calculate N cpue series in linear space  </span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">N</span><span class="op">)</span> <span class="op">{</span> <span class="co"># calculate dynamics for each parameter set  </span></span>
<span>  <span class="va">dynamA</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/spm.html">spm</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">mvnpar</span><span class="op">[</span><span class="va">i</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">4</span><span class="op">]</span><span class="op">)</span>,<span class="va">fish</span><span class="op">)</span>  </span>
<span>  <span class="va">mvncpue</span><span class="op">[</span><span class="va">i</span>,<span class="op">]</span> <span class="op">&lt;-</span> <span class="va">dynamA</span><span class="op">$</span><span class="va">outmat</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="va">nyr</span>,<span class="st">"predCE"</span><span class="op">]</span>  </span>
<span>  <span class="va">depletion</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">dynamA</span><span class="op">$</span><span class="va">outmat</span><span class="op">[</span><span class="st">"2016"</span>,<span class="st">"Depletion"</span><span class="op">]</span>  </span>
<span><span class="op">}</span>  </span>
<span><span class="va">mvnpar</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span><span class="va">mvnpar</span>,<span class="va">msy</span>,<span class="va">depletion</span><span class="op">)</span> <span class="co"># try head(mvnpar,10)  </span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><a href="#fig-spm13" class="quarto-xref">图&nbsp;<span>7.13</span></a> 和 <a href="#fig-spm14" class="quarto-xref">图&nbsp;<span>7.14</span></a> 通过自举法绘制出隐含的 CPUE 轨迹，结果似乎是可信的。另一方面，利用渐近误差，当我们绘制隐含的动态图时，如 <a href="#fig-spm16" class="quarto-xref">图&nbsp;<span>7.16</span></a> ，有一定比例的鱼类在第 90 个百分位数置信区间之外，而置信区间本身是极不对称的，会产生剧烈波动的动态，甚至可能意味着鱼类灭绝。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb49"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span>  <span class="co">#data and trajectories from 1000 MVN parameter vectors   Fig 7.16  </span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/plot1.html">plot1</a></span><span class="op">(</span><span class="va">fish</span><span class="op">[</span>,<span class="st">"year"</span><span class="op">]</span>,<span class="va">fish</span><span class="op">[</span>,<span class="st">"cpue"</span><span class="op">]</span>,type<span class="op">=</span><span class="st">"p"</span>,xlab<span class="op">=</span><span class="st">"Year"</span>,ylab<span class="op">=</span><span class="st">"CPUE"</span>,  </span>
<span>      maxy<span class="op">=</span><span class="fl">2.0</span><span class="op">)</span>  </span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">N</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">fish</span><span class="op">[</span>,<span class="st">"year"</span><span class="op">]</span>,<span class="va">mvncpue</span><span class="op">[</span><span class="va">i</span>,<span class="op">]</span>,col<span class="op">=</span><span class="st">"grey"</span>,lwd<span class="op">=</span><span class="fl">1</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html">points</a></span><span class="op">(</span><span class="va">fish</span><span class="op">[</span>,<span class="st">"year"</span><span class="op">]</span>,<span class="va">fish</span><span class="op">[</span>,<span class="st">"cpue"</span><span class="op">]</span>,pch<span class="op">=</span><span class="fl">1</span>,cex<span class="op">=</span><span class="fl">1.3</span>,col<span class="op">=</span><span class="fl">1</span>,lwd<span class="op">=</span><span class="fl">2</span><span class="op">)</span> <span class="co"># data  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">fish</span><span class="op">[</span>,<span class="st">"year"</span><span class="op">]</span>,<span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/simpspm.html">simpspm</a></span><span class="op">(</span><span class="va">optpar</span>,<span class="va">fish</span><span class="op">)</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">1</span><span class="op">)</span><span class="co"># pred   </span></span>
<span><span class="va">percs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/apply.html">apply</a></span><span class="op">(</span><span class="va">mvncpue</span>,<span class="fl">2</span>,<span class="va">quants</span><span class="op">)</span>  <span class="co"># obtain the quantiles  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/arrows.html">arrows</a></span><span class="op">(</span>x0<span class="op">=</span><span class="va">fish</span><span class="op">[</span>,<span class="st">"year"</span><span class="op">]</span>,y0<span class="op">=</span><span class="va">percs</span><span class="op">[</span><span class="st">"5%"</span>,<span class="op">]</span>,y1<span class="op">=</span><span class="va">percs</span><span class="op">[</span><span class="st">"95%"</span>,<span class="op">]</span>,length<span class="op">=</span><span class="fl">0.03</span>,  </span>
<span>       angle<span class="op">=</span><span class="fl">90</span>,code<span class="op">=</span><span class="fl">3</span>,col<span class="op">=</span><span class="fl">1</span><span class="op">)</span> <span class="co">#add 90% quantiles  </span></span>
<span><span class="va">msy</span> <span class="op">&lt;-</span> <span class="va">mvnpar</span><span class="op">[</span>,<span class="st">"r"</span><span class="op">]</span><span class="op">*</span><span class="va">mvnpar</span><span class="op">[</span>,<span class="st">"K"</span><span class="op">]</span><span class="op">/</span><span class="fl">4</span>  <span class="co"># 1000 MSY estimates  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/text.html">text</a></span><span class="op">(</span><span class="fl">2010</span>,<span class="fl">1.75</span>,<span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste0</a></span><span class="op">(</span><span class="st">"MSY "</span>,<span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="va">msy</span><span class="op">)</span>,<span class="fl">3</span><span class="op">)</span><span class="op">)</span>,cex<span class="op">=</span><span class="fl">1.25</span>,font<span class="op">=</span><span class="fl">7</span><span class="op">)</span>   </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-spm16" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-spm16-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="07-spm_files/figure-html/fig-spm16-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spm16-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;7.16: 从最优参数及其相关方差-协方差矩阵定义的多变量正态分布中采样的随机参数向量得出的 1000 条 cpue 预测轨迹。The 1000 predicted cpue trajectories derived from random parameter vectors sampled from the multi-variate normal distribution defined by the optimum parameters and their related variance-covariance matrix.
</figcaption></figure>
</div>
</div>
</div>
<p>使用渐近误差估计的平均 <span class="math inline">\(MSY\)</span> 与自举估计值非常相似（319.546，<a href="#tbl-spm5" class="quarto-xref">表&nbsp;<span>7.5</span></a>），第90 分位置信区间看起来也很有意义，尽管比自举分析更加偏斜。然而，使用多变量正态分布显然会导致一些难以置信的参数组合，进而导致难以置信的 cpue 轨迹，与观测 cpue 相差甚远。这并不意味着不应该使用渐近误差，而是说如果确实使用了渐近误差，就应该对其影响的合理性进行研究。</p>
<p>在这种情况下，我们可以通过查找最终 cpue 值小于 0.4 的记录来搜索导致极端结果的参数组合。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb50"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#Isolate errant cpue trajectories Fig 7.17  </span></span>
<span><span class="va">pickd</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/which.html">which</a></span><span class="op">(</span><span class="va">mvncpue</span><span class="op">[</span>,<span class="st">"2016"</span><span class="op">]</span> <span class="op">&lt;</span> <span class="fl">0.40</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/plot1.html">plot1</a></span><span class="op">(</span><span class="va">fish</span><span class="op">[</span>,<span class="st">"year"</span><span class="op">]</span>,<span class="va">fish</span><span class="op">[</span>,<span class="st">"cpue"</span><span class="op">]</span>,type<span class="op">=</span><span class="st">"n"</span>,xlab<span class="op">=</span><span class="st">"Year"</span>,ylab<span class="op">=</span><span class="st">"CPUE"</span>,  </span>
<span>      maxy<span class="op">=</span><span class="fl">6.25</span><span class="op">)</span>  </span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="va">pickd</span><span class="op">)</span><span class="op">)</span>   </span>
<span>  <span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">fish</span><span class="op">[</span>,<span class="st">"year"</span><span class="op">]</span>,<span class="va">mvncpue</span><span class="op">[</span><span class="va">pickd</span><span class="op">[</span><span class="va">i</span><span class="op">]</span>,<span class="op">]</span>,col<span class="op">=</span><span class="fl">1</span>,lwd<span class="op">=</span><span class="fl">1</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html">points</a></span><span class="op">(</span><span class="va">fish</span><span class="op">[</span>,<span class="st">"year"</span><span class="op">]</span>,<span class="va">fish</span><span class="op">[</span>,<span class="st">"cpue"</span><span class="op">]</span>,pch<span class="op">=</span><span class="fl">16</span>,cex<span class="op">=</span><span class="fl">1.25</span>,col<span class="op">=</span><span class="fl">4</span><span class="op">)</span>   </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">fish</span><span class="op">[</span>,<span class="st">"year"</span><span class="op">]</span>,<span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/simpspm.html">simpspm</a></span><span class="op">(</span><span class="va">optpar</span>,<span class="va">fish</span><span class="op">)</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">3</span>,col<span class="op">=</span><span class="fl">2</span>,lty<span class="op">=</span><span class="fl">2</span><span class="op">)</span>   </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-spm17" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-spm17-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="07-spm_files/figure-html/fig-spm17-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spm17-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;7.17: 预测 2016 年 cpue &lt; 0.4 的 34 个渐近误差 cpue 轨迹。圆点为原始数据，虚线为最佳拟合模型。The 34 asymptotic error cpue trajectories that were predicted to have a cpue &lt; 0.4 in 2016. The dots are the original data and the dashed line the optimum model fit.
</figcaption></figure>
</div>
</div>
</div>
<p>现在，我们已经确定了大多数错误轨迹及其各自的参数矢量，我们可以通过绘图来比较我们认为的非错误轨迹，这样我们就可以确定谁是谁了（<a href="#fig-spm18" class="quarto-xref">图&nbsp;<span>7.18</span></a>）。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb51"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#Use adhoc function to plot errant parameters Fig 7.18  </span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/parset.html">parset</a></span><span class="op">(</span>plots<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span>,cex<span class="op">=</span><span class="fl">0.85</span><span class="op">)</span>  </span>
<span><span class="va">outplot</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">var1</span>,<span class="va">var2</span>,<span class="va">pickdev</span><span class="op">)</span> <span class="op">{</span>  </span>
<span>  <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/plot1.html">plot1</a></span><span class="op">(</span><span class="va">mvnpar</span><span class="op">[</span>,<span class="va">var1</span><span class="op">]</span>,<span class="va">mvnpar</span><span class="op">[</span>,<span class="va">var2</span><span class="op">]</span>,type<span class="op">=</span><span class="st">"p"</span>,pch<span class="op">=</span><span class="fl">16</span>,cex<span class="op">=</span><span class="fl">1.0</span>,  </span>
<span>        defpar<span class="op">=</span><span class="cn">FALSE</span>,xlab<span class="op">=</span><span class="va">var1</span>,ylab<span class="op">=</span><span class="va">var2</span>,col<span class="op">=</span><span class="fl">8</span><span class="op">)</span>  </span>
<span>  <span class="fu"><a href="https://rdrr.io/r/graphics/points.html">points</a></span><span class="op">(</span><span class="va">mvnpar</span><span class="op">[</span><span class="va">pickdev</span>,<span class="va">var1</span><span class="op">]</span>,<span class="va">mvnpar</span><span class="op">[</span><span class="va">pickdev</span>,<span class="va">var2</span><span class="op">]</span>,pch<span class="op">=</span><span class="fl">16</span>,cex<span class="op">=</span><span class="fl">1.0</span><span class="op">)</span>  </span>
<span><span class="op">}</span>  </span>
<span><span class="fu">outplot</span><span class="op">(</span><span class="st">"r"</span>,<span class="st">"K"</span>,<span class="va">pickd</span><span class="op">)</span> <span class="co"># assumes mvnpar in working environment  </span></span>
<span><span class="fu">outplot</span><span class="op">(</span><span class="st">"sigma"</span>,<span class="st">"Binit"</span>,<span class="va">pickd</span><span class="op">)</span>  </span>
<span><span class="fu">outplot</span><span class="op">(</span><span class="st">"r"</span>,<span class="st">"Binit"</span>,<span class="va">pickd</span><span class="op">)</span>  </span>
<span><span class="fu">outplot</span><span class="op">(</span><span class="st">"K"</span>,<span class="st">"Binit"</span>,<span class="va">pickd</span><span class="op">)</span>    </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-spm18" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-spm18-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="07-spm_files/figure-html/fig-spm18-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spm18-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;7.18: 渐近误差样本中参数值的分布，黑色部分为预测最终 cpue &lt; 0.4 的参数值。看来，Binit 的低值是造成难以置信轨迹的主要原因。The spread of parameter values from the asymptotic error samples with the values that predicted final cpue &lt; 0.4 highlighted in black. It appears that low values of Binit are mostly behind the implausible trajectories.
</figcaption></figure>
</div>
</div>
</div>
<p>当我们绘制模型变量之间的相互关系时（<a href="#fig-spm19" class="quarto-xref">图&nbsp;<span>7.19</span></a>），对于正态分布或多变量正态分布变量，预期 <em>simga</em> 和其他参数之间缺乏关系。然而，这与从自举法样本中获得的关系明显不同（<a href="#fig-spm15" class="quarto-xref">图&nbsp;<span>7.15</span></a>）。此外，三个主要参数 <span class="math inline">\(r\)</span>、<span class="math inline">\(K\)</span> 和<span class="math inline">\(B_{init}\)</span> 之间的关系远比在自举抽样中看到的平滑得多。在我们看来，这种对称性和界限的清晰度似乎比自举样本中的关系更容易接受（<a href="#fig-spm19" class="quarto-xref">图&nbsp;<span>7.19</span></a>）。尽管如此，损耗图显示一些轨迹似乎已经消失。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb52"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#asymptotically sampled parameter vectors  Fig 7.19 </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/pairs.html">pairs</a></span><span class="op">(</span><span class="va">mvnpar</span>,lower.panel<span class="op">=</span><span class="va">panel.smooth</span>, upper.panel<span class="op">=</span><span class="va">panel.cor</span>,       </span>
<span>      gap<span class="op">=</span><span class="fl">0</span>,cex<span class="op">=</span><span class="fl">0.25</span>,lwd<span class="op">=</span><span class="fl">2</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-spm19" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-spm19-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="07-spm_files/figure-html/fig-spm19-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spm19-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;7.19: 使用多变量正态分布生成参数组合时 Schaefer 模型参数之间的关系。r - K 之间的关系比自举样本紧密得多，而 sigma 与其他参数之间几乎没有关系。损耗图显示一些轨迹已经消失。The relationships between the model parameters for the Schaefer model when using the multi-variate normal distribution to generate the parameter combinations. The relationship between r - K is much tighter than in the bootstrap samples and there is almost no relationship between sigma and the other parameters. The depletion plots indicate some trajectories go extinct.
</figcaption></figure>
</div>
</div>
</div>
<p>我们可以比较自举抽样和渐近误差抽样的参数值范围。来自渐近误差分布的参数样本比来自自举法的样本偏度小，但自举法对于 <span class="math inline">\(B_{init}\)</span> 和 <span class="math inline">\(K\)</span> 的值没有那么低。需要记住的是，使用多元正态分布来描述围绕最优参数集的似然曲面的形状仍然只是一个近似值。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb53"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co"># Get the ranges of parameters from bootstrap and asymptotic  </span></span>
<span><span class="va">bt</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/apply.html">apply</a></span><span class="op">(</span><span class="va">bootpar</span>,<span class="fl">2</span>,<span class="va">range</span><span class="op">)</span><span class="op">[</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">4</span>,<span class="fl">6</span>,<span class="fl">7</span><span class="op">)</span><span class="op">]</span>     </span>
<span><span class="va">ay</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/apply.html">apply</a></span><span class="op">(</span><span class="va">mvnpar</span>,<span class="fl">2</span>,<span class="va">range</span><span class="op">)</span>  </span>
<span><span class="va">out</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span><span class="op">(</span><span class="va">bt</span>,<span class="va">ay</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html">rownames</a></span><span class="op">(</span><span class="va">out</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"MinBoot"</span>,<span class="st">"MaxBoot"</span>,<span class="st">"MinAsym"</span>,<span class="st">"MaxAsym"</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<div id="tbl-spm7" class="cell quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-spm7-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
表&nbsp;7.7: 自举取样与渐近误差取样的参数值范围对比。The range of parameter values from the bootstrap sampling compared with those from the Asymptotic Error sampling.
</figcaption><div aria-describedby="tbl-spm7-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell-output-display">
<table class="do-not-create-environment cell table table-sm table-striped small">
<thead><tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: right;">r</th>
<th style="text-align: right;">K</th>
<th style="text-align: right;">Binit</th>
<th style="text-align: right;">sigma</th>
<th style="text-align: right;">MSY</th>
<th style="text-align: right;">Depl</th>
</tr></thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">MinBoot</td>
<td style="text-align: right;">0.0653</td>
<td style="text-align: right;">3139.827</td>
<td style="text-align: right;">1357.264</td>
<td style="text-align: right;">0.1125</td>
<td style="text-align: right;">217.1636</td>
<td style="text-align: right;">0.0953</td>
</tr>
<tr class="even">
<td style="text-align: left;">MaxBoot</td>
<td style="text-align: right;">0.4958</td>
<td style="text-align: right;">25666.568</td>
<td style="text-align: right;">8000.087</td>
<td style="text-align: right;">0.1636</td>
<td style="text-align: right;">530.6523</td>
<td style="text-align: right;">0.7699</td>
</tr>
<tr class="odd">
<td style="text-align: left;">MinAsym</td>
<td style="text-align: right;">0.1185</td>
<td style="text-align: right;">2055.714</td>
<td style="text-align: right;">1003.558</td>
<td style="text-align: right;">0.1069</td>
<td style="text-align: right;">271.9012</td>
<td style="text-align: right;">0.0054</td>
</tr>
<tr class="even">
<td style="text-align: left;">MaxAsym</td>
<td style="text-align: right;">0.7287</td>
<td style="text-align: right;">9581.273</td>
<td style="text-align: right;">9917.274</td>
<td style="text-align: right;">0.2344</td>
<td style="text-align: right;">374.5219</td>
<td style="text-align: right;">0.6820</td>
</tr>
</tbody>
</table>
</div>
</div>
</figure>
</div>
</div>
</section><section id="有时渐近误差起作用" class="level3" data-number="7.4.5"><h3 data-number="7.4.5" class="anchored" data-anchor-id="有时渐近误差起作用">
<span class="header-section-number">7.4.5</span> 有时渐近误差起作用</h3>
<p>在某些情况下，渐近误差法得到的结果与自举法的结果非常相似。如果我们使用的是 <em>abdat</em> 数据而不是 <em>dataspm</em> 数据，我们得到的结果与使用自举法得到的结果似乎没有什么区别（比较见 “不确定 性”一章中的自举法部分）。生成的轨迹看起来非常相似（<a href="#fig-spm20" class="quarto-xref">图&nbsp;<span>7.20</span></a>），而且成对图几乎没有区别。与 “关于不确定性”的自举示例一样，我们使用了 <code><a href="https://rdrr.io/r/grDevices/rgb.html">rgb()</a></code> 着色以方便比较（<a href="#fig-spm21" class="quarto-xref">图&nbsp;<span>7.21</span></a>）。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb54"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co">#repeat asymptotice errors using abdat data-set Figure 7.20  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="va">abdat</span><span class="op">)</span>  </span>
<span><span class="va">fish</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">as.matrix</a></span><span class="op">(</span><span class="va">abdat</span><span class="op">)</span>  </span>
<span><span class="va">pars</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span>r<span class="op">=</span><span class="fl">0.4</span>,K<span class="op">=</span><span class="fl">9400</span>,Binit<span class="op">=</span><span class="fl">3400</span>,sigma<span class="op">=</span><span class="fl">0.05</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="va">ansA</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/fitSPM.html">fitSPM</a></span><span class="op">(</span><span class="va">pars</span>,<span class="va">fish</span>,schaefer<span class="op">=</span><span class="cn">TRUE</span>,maxiter<span class="op">=</span><span class="fl">1000</span>,hess<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span>   </span>
<span><span class="va">vcovA</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/solve.html">solve</a></span><span class="op">(</span><span class="va">ansA</span><span class="op">$</span><span class="va">hessian</span><span class="op">)</span> <span class="co"># calculate var-covar matrix  </span></span>
<span><span class="va">mvn</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="va">fish</span><span class="op">[</span>,<span class="st">"year"</span><span class="op">]</span><span class="op">)</span>  </span>
<span><span class="va">N</span> <span class="op">&lt;-</span> <span class="fl">1000</span>   <span class="co"># replicates  </span></span>
<span><span class="va">mvncpueA</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">0</span>,nrow<span class="op">=</span><span class="va">N</span>,ncol<span class="op">=</span><span class="va">mvn</span>,dimnames<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">N</span>,<span class="va">fish</span><span class="op">[</span>,<span class="st">"year"</span><span class="op">]</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="va">columns</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"r"</span>,<span class="st">"K"</span>,<span class="st">"Binit"</span>,<span class="st">"sigma"</span><span class="op">)</span>  </span>
<span><span class="va">optparA</span> <span class="op">&lt;-</span> <span class="va">ansA</span><span class="op">$</span><span class="va">estimate</span>  <span class="co"># Fill matrix of parameter vectors   </span></span>
<span><span class="va">mvnparA</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/mvtnorm/man/Mvnorm.html">rmvnorm</a></span><span class="op">(</span><span class="va">N</span>,mean<span class="op">=</span><span class="va">optparA</span>,sigma<span class="op">=</span><span class="va">vcovA</span><span class="op">)</span><span class="op">)</span>,  </span>
<span>                  nrow<span class="op">=</span><span class="va">N</span>,ncol<span class="op">=</span><span class="fl">4</span>,dimnames<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">N</span>,<span class="va">columns</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="va">msy</span> <span class="op">&lt;-</span> <span class="va">mvnparA</span><span class="op">[</span>,<span class="st">"r"</span><span class="op">]</span><span class="op">*</span><span class="va">mvnparA</span><span class="op">[</span>,<span class="st">"K"</span><span class="op">]</span><span class="op">/</span><span class="fl">4</span>  </span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">N</span><span class="op">)</span> <span class="va">mvncpueA</span><span class="op">[</span><span class="va">i</span>,<span class="op">]</span><span class="op">&lt;-</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/simpspm.html">simpspm</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">mvnparA</span><span class="op">[</span><span class="va">i</span>,<span class="op">]</span><span class="op">)</span>,<span class="va">fish</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="va">mvnparA</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span><span class="va">mvnparA</span>,<span class="va">msy</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/plot1.html">plot1</a></span><span class="op">(</span><span class="va">fish</span><span class="op">[</span>,<span class="st">"year"</span><span class="op">]</span>,<span class="va">fish</span><span class="op">[</span>,<span class="st">"cpue"</span><span class="op">]</span>,type<span class="op">=</span><span class="st">"p"</span>,xlab<span class="op">=</span><span class="st">"Year"</span>,ylab<span class="op">=</span><span class="st">"CPUE"</span>,  </span>
<span>      maxy<span class="op">=</span><span class="fl">2.5</span><span class="op">)</span>  </span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">N</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">fish</span><span class="op">[</span>,<span class="st">"year"</span><span class="op">]</span>,<span class="va">mvncpueA</span><span class="op">[</span><span class="va">i</span>,<span class="op">]</span>,col<span class="op">=</span><span class="fl">8</span>,lwd<span class="op">=</span><span class="fl">1</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html">points</a></span><span class="op">(</span><span class="va">fish</span><span class="op">[</span>,<span class="st">"year"</span><span class="op">]</span>,<span class="va">fish</span><span class="op">[</span>,<span class="st">"cpue"</span><span class="op">]</span>,pch<span class="op">=</span><span class="fl">16</span>,cex<span class="op">=</span><span class="fl">1.0</span><span class="op">)</span> <span class="co">#orig data  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">fish</span><span class="op">[</span>,<span class="st">"year"</span><span class="op">]</span>,<span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/simpspm.html">simpspm</a></span><span class="op">(</span><span class="va">optparA</span>,<span class="va">fish</span><span class="op">)</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">0</span><span class="op">)</span>     </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-spm20" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-spm20-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="07-spm_files/figure-html/fig-spm20-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spm20-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;7.20: 利用渐近误差为 abdat 数据集生成可信的参数集及其隐含的 cpue 轨迹。最佳拟合模型以白线表示。The use of asymptotic errors to generate plausible parameter sets and their implied cpue trajectories for the abdat data-set. The optimum model fit is shown as a white line.
</figcaption></figure>
</div>
</div>
</div>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb55"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#plot asymptotically sampled parameter vectors Figure 7.21  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/pairs.html">pairs</a></span><span class="op">(</span><span class="va">mvnparA</span>,lower.panel<span class="op">=</span><span class="va">panel.smooth</span>, upper.panel<span class="op">=</span><span class="va">panel.cor</span>,  </span>
<span>      gap<span class="op">=</span><span class="fl">0</span>,pch<span class="op">=</span><span class="fl">16</span>,col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/grDevices/rgb.html">rgb</a></span><span class="op">(</span>red<span class="op">=</span><span class="fl">0</span>,green<span class="op">=</span><span class="fl">0</span>,blue<span class="op">=</span><span class="fl">0</span>,alpha <span class="op">=</span> <span class="fl">1</span><span class="op">/</span><span class="fl">10</span><span class="op">)</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-spm21" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-spm21-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="07-spm_files/figure-html/fig-spm21-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spm21-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;7.21: 将 Schaefer 模型拟合到 abdat 数据并使用多变量正态分布生成后续参数组合时的模型参数关系。这与 “不确定性”一章中的自举法非常相似。Model parameter relationships when fitting the Schaefer model to the abdat data and using the multi-variate normal distribution to generate subsequent parameter combinations. These are very similar to the bootstrap equivalent in the On Uncertainty chapter.
</figcaption></figure>
</div>
</div>
</div>
</section><section id="贝叶斯后验" class="level3" data-number="7.4.6"><h3 data-number="7.4.6" class="anchored" data-anchor-id="贝叶斯后验">
<span class="header-section-number">7.4.6</span> 贝叶斯后验</h3>
<p>在 <em>“不确定性”</em> 一章中，我们已经看到可以使用马尔可夫链蒙特卡罗（MCMC）分析来描述给定分析中固有的不确定性。在这里，我们将再次使用 <em>abdat</em> 数据集，因为它提供了一个表现良好的数据实例，该数据集导致了一个相对紧密拟合的模型和一个表现良好的 MCMC 分析。关于<em>“不确定性”</em>一章中给出了吉布斯-内大都会-哈斯丁（Gibbs-within-Metropolis-Hastings）（或单分量大都会-哈斯丁Metropolis-Hastings）策略背后的方程式。这些都在 <code><a href="https://rdrr.io/pkg/MQMF/man/do_MCMC.html">do_MCMC()</a></code> 函数中实现。要使用该函数，首先要有一个基于最大似然法的最优拟合模型。这次我们将使用 Fox 模型选项。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb56"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span>  <span class="co">#Fit the Fox Model to the abdat data Figure 7.22  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="va">abdat</span><span class="op">)</span>; <span class="va">fish</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">as.matrix</a></span><span class="op">(</span><span class="va">abdat</span><span class="op">)</span>  </span>
<span><span class="va">param</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span>r<span class="op">=</span><span class="fl">0.3</span>,K<span class="op">=</span><span class="fl">11500</span>,Binit<span class="op">=</span><span class="fl">3300</span>,sigma<span class="op">=</span><span class="fl">0.05</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="va">foxmod</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/nlm.html">nlm</a></span><span class="op">(</span>f<span class="op">=</span><span class="va">negLL1</span>,p<span class="op">=</span><span class="va">param</span>,funk<span class="op">=</span><span class="va">simpspm</span>,indat<span class="op">=</span><span class="va">fish</span>,  </span>
<span>              logobs<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">fish</span><span class="op">[</span>,<span class="st">"cpue"</span><span class="op">]</span><span class="op">)</span>,iterlim<span class="op">=</span><span class="fl">1000</span>,schaefer<span class="op">=</span><span class="cn">FALSE</span><span class="op">)</span>  </span>
<span><span class="va">optpar</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">foxmod</span><span class="op">$</span><span class="va">estimate</span><span class="op">)</span>  </span>
<span><span class="va">ans</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/plotspmmod.html">plotspmmod</a></span><span class="op">(</span>inp<span class="op">=</span><span class="va">foxmod</span><span class="op">$</span><span class="va">estimate</span>,indat<span class="op">=</span><span class="va">fish</span>,schaefer<span class="op">=</span><span class="cn">FALSE</span>,  </span>
<span>                 addrmse<span class="op">=</span><span class="cn">TRUE</span>, plotprod<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-spm22" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-spm22-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="07-spm_files/figure-html/fig-spm22-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spm22-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;7.22: 使用 Fox 模型和对数正态误差拟合的 abdat 数据集最佳模型。绿色虚线是较平滑的曲线，红线是最佳预测模型拟合。请注意对数正态残差的模式，这表明该模型在该数据方面存在微小不足。The optimum model fit for the abdat data-set using the Fox model and log-normal errors. The green dashed line is a smoother curve while the red line is the optimum predicted model fit. Note the pattern in the log-normal residuals indicating that the model has small inadequacies with regard to this data.
</figcaption></figure>
</div>
</div>
</div>
<p>由于最优解将接近后验模式，我们不再需要说明预演期的概念，但理想情况下，我们并不希望完全从最大似然解出发。因此，我们可以舍弃最优解，对马尔可夫链进行预烧，使参数集序列进入可信组合的范围。我们知道 <span class="math inline">\(r\)</span> 和 <span class="math inline">\(K\)</span> 参数之间有很强的相关性，因此我们可以使用 128（<span class="math inline">\(4 \times 128 = 512\)</span>）的初始步长来减少任何连续接受值之间的自相关性，但这也会受到参数迭代之间跳跃的相对比例的影响。在这里，我们从 1% 到 2%之间的值开始，并尝试使用这些值，直到接受率介于 0.2 和 0.4 之间。最好使用较小的 N 值（使用 512 的稀疏度，即使 1000 也是 50 万次迭代）。只有当刻度设置得当时，才能将重复次数 N 扩大到更大的数目，以获得更清晰的结果。我们将继续使用 <strong>MQMF</strong> 函数 <code><a href="https://rdrr.io/pkg/MQMF/man/calcprior.html">calcprior()</a></code>，对每组可信参数设置同等权重，为了获得可重复的结果，需要在每条链上调用 <code><a href="https://rdrr.io/r/base/Random.html">set.seed()</a></code>，但一般情况下我们不会这样做。在 R 中，所有操作系统都使用相同的随机数生成器，因此这应该可以在不同的计算机上运行，但我还没有在所有版本上都试过。为了提高计算速度，最好能有类似于 <em>“不确定性”</em>一章中描述的使用 <strong>Rcpp</strong> 的 <code>simpspmC()</code> 函数。在运行下面的 MCMC 之前，你需要编译本章的附录，或者在使用 <code><a href="https://rdrr.io/pkg/MQMF/man/do_MCMC.html">do_MCMC()</a></code> 时调用 <code><a href="https://rdrr.io/pkg/MQMF/man/simpspm.html">simpspm()</a></code>，注意为了使用 Fox 模型，需要加入 <em>schaefer=FALSE</em> 参数。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb57"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co">#|echo: false</span></span>
<span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://www.rcpp.org">Rcpp</a></span><span class="op">)</span>  </span>
<span>  </span>
<span><span class="fu"><a href="https://rdrr.io/pkg/Rcpp/man/cppFunction.html">cppFunction</a></span><span class="op">(</span><span class="st">'NumericVector simpspmC(NumericVector pars,   </span></span>
<span><span class="st">             NumericMatrix indat, LogicalVector schaefer) {  </span></span>
<span><span class="st">   int nyrs = indat.nrow();  </span></span>
<span><span class="st">   NumericVector predce(nyrs);  </span></span>
<span><span class="st">   NumericVector biom(nyrs+1);  </span></span>
<span><span class="st">   double Bt, qval;  </span></span>
<span><span class="st">   double sumq = 0.0;  </span></span>
<span><span class="st">   double p = 0.00000001;  </span></span>
<span><span class="st">   if (schaefer(0) == TRUE) {  </span></span>
<span><span class="st">     p = 1.0;  </span></span>
<span><span class="st">   }  </span></span>
<span><span class="st">   NumericVector ep = exp(pars);  </span></span>
<span><span class="st">   biom[0] = ep[2];  </span></span>
<span><span class="st">   for (int i = 0; i &lt; nyrs; i++) {  </span></span>
<span><span class="st">      Bt = biom[i];  </span></span>
<span><span class="st">      biom[(i+1)] = Bt + (ep[0]/p)*Bt*(1 - pow((Bt/ep[1]),p)) -   </span></span>
<span><span class="st">                          indat(i,1);  </span></span>
<span><span class="st">      if (biom[(i+1)] &lt; 40.0) biom[(i+1)] = 40.0;  </span></span>
<span><span class="st">      sumq += log(indat(i,2)/biom[i]);  </span></span>
<span><span class="st">    }  </span></span>
<span><span class="st">    qval = exp(sumq/nyrs);  </span></span>
<span><span class="st">    for (int i = 0; i &lt; nyrs; i++) {  </span></span>
<span><span class="st">      predce[i] = log(biom[i] * qval);  </span></span>
<span><span class="st">    }  </span></span>
<span><span class="st">    return predce;  </span></span>
<span><span class="st">}'</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb58"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># eval: false</span></span>
<span> <span class="co"># Conduct an MCMC using simpspmC on the abdat Fox SPM  </span></span>
<span> <span class="co"># This means you will need to compile simpspmC from appendix  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">698381</span><span class="op">)</span> <span class="co">#for repeatability, possibly only on Windows10  </span></span>
<span><span class="va">begin</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/gettime.html">gettime</a></span><span class="op">(</span><span class="op">)</span>  <span class="co"># to enable the time taken to be calculated  </span></span>
<span><span class="va">inscale</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.07</span>,<span class="fl">0.05</span>,<span class="fl">0.09</span>,<span class="fl">0.45</span><span class="op">)</span> <span class="co">#note large value for sigma  </span></span>
<span><span class="va">pars</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span>r<span class="op">=</span><span class="fl">0.205</span>,K<span class="op">=</span><span class="fl">11300</span>,Binit<span class="op">=</span><span class="fl">3200</span>,sigma<span class="op">=</span><span class="fl">0.044</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="va">result</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/do_MCMC.html">do_MCMC</a></span><span class="op">(</span>chains<span class="op">=</span><span class="fl">1</span>,burnin<span class="op">=</span><span class="fl">50</span>,N<span class="op">=</span><span class="fl">2000</span>,thinstep<span class="op">=</span><span class="fl">512</span>,  </span>
<span>                  inpar<span class="op">=</span><span class="va">pars</span>,infunk<span class="op">=</span><span class="va">negLL</span>,calcpred<span class="op">=</span><span class="va">simpspm</span>,  </span>
<span>                  obsdat<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">fish</span><span class="op">[</span>,<span class="st">"cpue"</span><span class="op">]</span><span class="op">)</span>,calcdat<span class="op">=</span><span class="va">fish</span>,  </span>
<span>                  priorcalc<span class="op">=</span><span class="va">calcprior</span>,scales<span class="op">=</span><span class="va">inscale</span>,schaefer<span class="op">=</span><span class="cn">FALSE</span><span class="op">)</span>  </span>
<span> <span class="co"># alternatively, use simpspm, but that will take longer.   </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"acceptance rate = "</span>,<span class="va">result</span><span class="op">$</span><span class="va">arate</span>,<span class="st">" \n"</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>acceptance rate =  0.3136629 0.3337832 0.3789844 0.3660627  </code></pre>
</div>
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb60"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"time = "</span>,<span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/gettime.html">gettime</a></span><span class="op">(</span><span class="op">)</span> <span class="op">-</span> <span class="va">begin</span>,<span class="st">"\n"</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>time =  65.57628 </code></pre>
</div>
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb62"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">post1</span> <span class="op">&lt;-</span> <span class="va">result</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>  </span>
<span><span class="va">p</span> <span class="op">&lt;-</span> <span class="fl">1e-08</span>  </span>
<span><span class="va">msy</span> <span class="op">&lt;-</span> <span class="va">post1</span><span class="op">[</span>,<span class="st">"r"</span><span class="op">]</span><span class="op">*</span><span class="va">post1</span><span class="op">[</span>,<span class="st">"K"</span><span class="op">]</span><span class="op">/</span><span class="op">(</span><span class="op">(</span><span class="va">p</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span><span class="op">^</span><span class="op">(</span><span class="op">(</span><span class="va">p</span><span class="op">+</span><span class="fl">1</span><span class="op">)</span><span class="op">/</span><span class="va">p</span><span class="op">)</span><span class="op">)</span>   </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Fox 模型 MCMC 目前设置为 512 的稀释率、2000 次重复和 50 次老化，这意味着将有 <span class="math inline">\(512 \times 2050 = 1049600\)</span> 次迭代用于生成所需的参数跟踪。在用于编写此内容的计算机上，即使使用 ，这大约需要 15 秒;使用 <code><a href="https://rdrr.io/pkg/MQMF/man/simpspm.html">simpspm()</a></code> 可能预计大约需要 75 秒。一旦知道了自己的系统的情况，显然可以计划分析，并对稀释速率和重复做出明确的选择（不要忘记使用最新版本的 R 以获得最快的时间）。</p>
<p>分析完成后，我们可以使用 <code><a href="https://rdrr.io/r/graphics/pairs.html">pairs()</a></code> 函数绘制每个变量与其他变量的对比图（<a href="#fig-spm23" class="quarto-xref">图&nbsp;<span>7.23</span></a>）。此外，我们还可以绘制每个主要参数的边际后验分布图和推导出的模型输出（MSY）。由于我们使用了 2000 个重复样本，并采用了 512 的样本链稀疏率（<a href="#fig-spm24" class="quarto-xref">图&nbsp;<span>7.24</span></a>），因此后验分布相对平滑。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb63"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#pairwise comparison for MCMC of Fox model on abdat  Fig 7.23   </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/pairs.html">pairs</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span><span class="va">post1</span><span class="op">[</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">4</span><span class="op">]</span>,<span class="va">msy</span><span class="op">)</span>,upper.panel <span class="op">=</span> <span class="va">panel.cor</span>,lwd<span class="op">=</span><span class="fl">2</span>,cex<span class="op">=</span><span class="fl">0.2</span>,    </span>
<span>      lower.panel<span class="op">=</span><span class="va">panel.smooth</span>,col<span class="op">=</span><span class="fl">1</span>,gap<span class="op">=</span><span class="fl">0.1</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-spm23" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-spm23-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="07-spm_files/figure-html/fig-spm23-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spm23-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;7.23: MCMC 输出的成对散点图。实线是表示趋势的塬平滑线，上半部分的数字是成对散点图之间的相关系数。r、K 和 Binit 之间，以及 K、Binit 和 MSY 之间都有很强的相关性，而 sigma 与其他参数或 msy 与 r 之间的关系较小或没有关系。MCMC output as paired scattergrams. The solid lines are loess smoothers indicating trends and the numbers in the upper half are the correlation coefficients between the pairs. Strong correlations are indicated between r, K, and Binit, and between K, Binit, and MSY, with only minor or no relationships between sigma the other parameters or between msy and r.
</figcaption></figure>
</div>
</div>
</div>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb64"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span>  <span class="co"># marginal distributions of 3 parameters and msy  Figure 7.24  </span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/parset.html">parset</a></span><span class="op">(</span>plots<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span>, cex<span class="op">=</span><span class="fl">0.85</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/density.html">density</a></span><span class="op">(</span><span class="va">post1</span><span class="op">[</span>,<span class="st">"r"</span><span class="op">]</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">2</span>,main<span class="op">=</span><span class="st">""</span>,xlab<span class="op">=</span><span class="st">"r"</span><span class="op">)</span> <span class="co">#plot has a method  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/density.html">density</a></span><span class="op">(</span><span class="va">post1</span><span class="op">[</span>,<span class="st">"K"</span><span class="op">]</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">2</span>,main<span class="op">=</span><span class="st">""</span>,xlab<span class="op">=</span><span class="st">"K"</span><span class="op">)</span>   <span class="co">#for output from  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/density.html">density</a></span><span class="op">(</span><span class="va">post1</span><span class="op">[</span>,<span class="st">"Binit"</span><span class="op">]</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">2</span>,main<span class="op">=</span><span class="st">""</span>,xlab<span class="op">=</span><span class="st">"Binit"</span><span class="op">)</span>  <span class="co"># density  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/density.html">density</a></span><span class="op">(</span><span class="va">msy</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">2</span>,main<span class="op">=</span><span class="st">""</span>,xlab<span class="op">=</span><span class="st">"MSY"</span><span class="op">)</span>   <span class="co">#try str(density(msy))   </span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-spm24" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-spm24-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="07-spm_files/figure-html/fig-spm24-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spm24-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;7.24: 将 Fox 模型应用于鳕鱼数据的 2000 次 MCMC 重复计算得出的三个参数的边际分布和隐含的 MSY。曲线的块状表明需要进行 2000 次以上的迭代。The marginal distributions for three parameters and the implied MSY from 2000 MCMC replicates for the Fox model applied to the abdat data. The lumpiness of the curves suggests more than 2000 iterations are needed.
</figcaption></figure>
</div>
</div>
</div>
<p>需要注意的是，要将 <em>sigma</em> 的接受率降到 0.4 以下，需要施加一个相对较大的比例因子。其他参数要求的值在 5% 到 9% 之间。如果使用 500 次重复来寻找合适的比例因子，然后将重复次数重设为 2000 次，那么整个过程所需的时间将是原来的四倍。如果再将步长增加到 1024 倍，那么所需的时间又会增加一倍。需要寻找适当的比例因子，以确保马尔可夫链在合理的时间内充分探索后验空间。如果比例因子太小，接受率就会增加，因为每次试验实际上都会非常接近原始试验，因此只能采取小步试验。静态分布最终仍会被发现，但可能需要大量的重复。在稀疏率为 512 的情况下，如果使用 <code><a href="https://rdrr.io/r/stats/acf.html">acf()</a></code> 函数绘制任何迹线的自相关图，如 <code>acf(post1[, “r”])</code>，就会发现在步长为 1 和 2 时仍然存在显著的相关性。要减少这种相关性，至少需要将步长增加到 1024 步。</p>
<p>随着重复次数的增加，观测到的潜在参数组合的分布范围也在扩大。但是，如果我们检查第 90 分位数等值线的边界，这些边界会保持相对稳定。我们可以使用 <strong>MQMF</strong> 函数 <code><a href="https://rdrr.io/pkg/MQMF/man/addcontours.html">addcontours()</a></code> 在二维范围内进行检查，该函数可以为任意 x-y 数据点云生成等值线（任意但理想的平滑分布）。 2000 个观测点的第 50 和第 90 分位数等值线并不特别平滑，但即使是这样，<span class="math inline">\(K\)</span> 的边界也大约在 9500 - 14000 之间，<span class="math inline">\(r\)</span> 的边界大约在 0.17 - 0.24 之间（<a href="#fig-spm25" class="quarto-xref">图&nbsp;<span>7.25</span></a>）。随着数值的增加，等值线变得更加平滑，但其边界大致保持不变，即使在两种情况下 x 轴和 y 轴都有所延长。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb65"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span>  <span class="co">#MCMC r and K parameters, approx 50 + 90% contours. Fig7.25  </span></span>
<span><span class="va">puttxt</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">xs</span>,<span class="va">xvar</span>,<span class="va">ys</span>,<span class="va">yvar</span>,<span class="va">lvar</span>,<span class="va">lab</span><span class="op">=</span><span class="st">""</span>,<span class="va">sigd</span><span class="op">=</span><span class="fl">0</span><span class="op">)</span> <span class="op">{</span>  </span>
<span>  <span class="fu"><a href="https://rdrr.io/r/graphics/text.html">text</a></span><span class="op">(</span><span class="va">xs</span><span class="op">*</span><span class="va">xvar</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span>,<span class="va">ys</span><span class="op">*</span><span class="va">yvar</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span>,<span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/makelabel.html">makelabel</a></span><span class="op">(</span><span class="va">lab</span>,<span class="va">lvar</span>,sep<span class="op">=</span><span class="st">"  "</span>,  </span>
<span>       sigdig<span class="op">=</span><span class="va">sigd</span><span class="op">)</span>,cex<span class="op">=</span><span class="fl">1.2</span>,font<span class="op">=</span><span class="fl">7</span>,pos<span class="op">=</span><span class="fl">4</span><span class="op">)</span>  </span>
<span><span class="op">}</span> <span class="co"># end of puttxt - a quick utility function  </span></span>
<span><span class="va">kran</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/range.html">range</a></span><span class="op">(</span><span class="va">post1</span><span class="op">[</span>,<span class="st">"K"</span><span class="op">]</span><span class="op">)</span>;  <span class="va">rran</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/range.html">range</a></span><span class="op">(</span><span class="va">post1</span><span class="op">[</span>,<span class="st">"r"</span><span class="op">]</span><span class="op">)</span>  </span>
<span><span class="va">mran</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/range.html">range</a></span><span class="op">(</span><span class="va">msy</span><span class="op">)</span>         <span class="co">#ranges used in the plots  </span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/parset.html">parset</a></span><span class="op">(</span>plots<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">2</span><span class="op">)</span>,margin<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.35</span>,<span class="fl">0.35</span>,<span class="fl">0.05</span>,<span class="fl">0.1</span><span class="op">)</span><span class="op">)</span> <span class="co">#plot r vs K  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">post1</span><span class="op">[</span>,<span class="st">"K"</span><span class="op">]</span>,<span class="va">post1</span><span class="op">[</span>,<span class="st">"r"</span><span class="op">]</span>,type<span class="op">=</span><span class="st">"p"</span>,cex<span class="op">=</span><span class="fl">0.5</span>,xlim<span class="op">=</span><span class="va">kran</span>,  </span>
<span>     ylim<span class="op">=</span><span class="va">rran</span>,col<span class="op">=</span><span class="st">"grey"</span>,xlab<span class="op">=</span><span class="st">"K"</span>,ylab<span class="op">=</span><span class="st">"r"</span>,panel.first<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/graphics/grid.html">grid</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html">points</a></span><span class="op">(</span><span class="va">optpar</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span>,<span class="va">optpar</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>,pch<span class="op">=</span><span class="fl">16</span>,col<span class="op">=</span><span class="fl">1</span>,cex<span class="op">=</span><span class="fl">1.75</span><span class="op">)</span> <span class="co"># center  </span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/addcontours.html">addcontours</a></span><span class="op">(</span><span class="va">post1</span><span class="op">[</span>,<span class="st">"K"</span><span class="op">]</span>,<span class="va">post1</span><span class="op">[</span>,<span class="st">"r"</span><span class="op">]</span>,<span class="va">kran</span>,<span class="va">rran</span>,  <span class="co">#if fails make  </span></span>
<span>            contval<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.5</span>,<span class="fl">0.9</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">1</span><span class="op">)</span>   <span class="co">#contval smaller  </span></span>
<span><span class="fu">puttxt</span><span class="op">(</span><span class="fl">0.7</span>,<span class="va">kran</span>,<span class="fl">0.97</span>,<span class="va">rran</span>,<span class="va">kran</span>,<span class="st">"K= "</span>,sigd<span class="op">=</span><span class="fl">0</span><span class="op">)</span>  </span>
<span><span class="fu">puttxt</span><span class="op">(</span><span class="fl">0.7</span>,<span class="va">kran</span>,<span class="fl">0.94</span>,<span class="va">rran</span>,<span class="va">rran</span>,<span class="st">"r= "</span>,sigd<span class="op">=</span><span class="fl">4</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">post1</span><span class="op">[</span>,<span class="st">"K"</span><span class="op">]</span>,<span class="va">msy</span>,type<span class="op">=</span><span class="st">"p"</span>,cex<span class="op">=</span><span class="fl">0.5</span>,xlim<span class="op">=</span><span class="va">kran</span>,  <span class="co"># K vs msy  </span></span>
<span>     ylim<span class="op">=</span><span class="va">mran</span>,col<span class="op">=</span><span class="st">"grey"</span>,xlab<span class="op">=</span><span class="st">"K"</span>,ylab<span class="op">=</span><span class="st">"MSY"</span>,panel.first<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/graphics/grid.html">grid</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html">points</a></span><span class="op">(</span><span class="va">optpar</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span>,<span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/getMSY.html">getMSY</a></span><span class="op">(</span><span class="va">optpar</span>,<span class="va">p</span><span class="op">)</span>,pch<span class="op">=</span><span class="fl">16</span>,col<span class="op">=</span><span class="fl">1</span>,cex<span class="op">=</span><span class="fl">1.75</span><span class="op">)</span><span class="co">#center  </span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/addcontours.html">addcontours</a></span><span class="op">(</span><span class="va">post1</span><span class="op">[</span>,<span class="st">"K"</span><span class="op">]</span>,<span class="va">msy</span>,<span class="va">kran</span>,<span class="va">mran</span>,contval<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.5</span>,<span class="fl">0.9</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">1</span><span class="op">)</span>  </span>
<span><span class="fu">puttxt</span><span class="op">(</span><span class="fl">0.6</span>,<span class="va">kran</span>,<span class="fl">0.99</span>,<span class="va">mran</span>,<span class="va">kran</span>,<span class="st">"K= "</span>,sigd<span class="op">=</span><span class="fl">0</span><span class="op">)</span>  </span>
<span><span class="fu">puttxt</span><span class="op">(</span><span class="fl">0.6</span>,<span class="va">kran</span>,<span class="fl">0.97</span>,<span class="va">mran</span>,<span class="va">mran</span>,<span class="st">"MSY= "</span>,sigd<span class="op">=</span><span class="fl">3</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-spm25" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-spm25-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="07-spm_files/figure-html/fig-spm25-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spm25-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;7.25: MCMC 边际分布输出为 r 和 K 参数以及 K 和 MSY 值的散点图。灰点是成功的候选参数向量，等值线是近似的第 50 和第 90 分位数。文中给出了全部可接受的参数迹线范围。MCMC marginal distributions output as a scattergram of the r and K parameters, and the K and MSY values. The grey dots are from successful candidate parameter vectors, while the contours are approximate 50th and 90th percentiles. The text give the full range of the accepted parameter traces.
</figcaption></figure>
</div>
</div>
</div>
<p>最后，我们可以绘制 2000 个重复中每个重复的单个迹线。这表明，即使具有平滑的边际分布，偶尔也会出现参数值的峰值，以说明主要参数之间的强负相关。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb66"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span>  <span class="co">#Traces for the Fox model parameters from the MCMC  Fig7.26  </span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/parset.html">parset</a></span><span class="op">(</span>plots<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">4</span>,<span class="fl">1</span><span class="op">)</span>,margin<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.3</span>,<span class="fl">0.45</span>,<span class="fl">0.05</span>,<span class="fl">0.05</span><span class="op">)</span>,  </span>
<span>       outmargin <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span><span class="op">)</span>,cex<span class="op">=</span><span class="fl">0.85</span><span class="op">)</span>  </span>
<span><span class="va">label</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/colnames.html">colnames</a></span><span class="op">(</span><span class="va">post1</span><span class="op">)</span>  </span>
<span><span class="va">N</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/dim.html">dim</a></span><span class="op">(</span><span class="va">post1</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>  </span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">3</span><span class="op">)</span> <span class="op">{</span>  </span>
<span>  <span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">N</span>,<span class="va">post1</span><span class="op">[</span>,<span class="va">i</span><span class="op">]</span>,type<span class="op">=</span><span class="st">"l"</span>,lwd<span class="op">=</span><span class="fl">1</span>,ylab<span class="op">=</span><span class="va">label</span><span class="op">[</span><span class="va">i</span><span class="op">]</span>,xlab<span class="op">=</span><span class="st">""</span><span class="op">)</span>  </span>
<span>  <span class="fu"><a href="https://rdrr.io/r/graphics/abline.html">abline</a></span><span class="op">(</span>h<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/stats/median.html">median</a></span><span class="op">(</span><span class="va">post1</span><span class="op">[</span>,<span class="va">i</span><span class="op">]</span><span class="op">)</span>,col<span class="op">=</span><span class="fl">2</span><span class="op">)</span>  </span>
<span><span class="op">}</span>  </span>
<span><span class="va">msy</span> <span class="op">&lt;-</span> <span class="va">post1</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span><span class="op">*</span><span class="va">post1</span><span class="op">[</span>,<span class="fl">2</span><span class="op">]</span><span class="op">/</span><span class="fl">4</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">N</span>,<span class="va">msy</span>,type<span class="op">=</span><span class="st">"l"</span>,lwd<span class="op">=</span><span class="fl">1</span>,ylab<span class="op">=</span><span class="st">"MSY"</span>,xlab<span class="op">=</span><span class="st">""</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html">abline</a></span><span class="op">(</span>h<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/stats/median.html">median</a></span><span class="op">(</span><span class="va">msy</span><span class="op">)</span>,col<span class="op">=</span><span class="fl">2</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/mtext.html">mtext</a></span><span class="op">(</span><span class="st">"Step"</span>,side<span class="op">=</span><span class="fl">1</span>,outer<span class="op">=</span><span class="cn">T</span>,line<span class="op">=</span><span class="fl">0.0</span>,font<span class="op">=</span><span class="fl">7</span>,cex<span class="op">=</span><span class="fl">1.1</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure"><p><img src="07-spm_files/figure-html/fit-spm26-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption>三个主要 Schaefer 模型参数和 MSY 估计值的迹线。如果细化步长增加到 1024 步或更长，迹线内剩余的自相关性应得到改善。The traces for the three main Schaefer model parameters and the MSY estimates. The remaining auto-correlation within traces should be improved if the thinning step were increased to 1024 or longer.</figcaption></figure>
</div>
</div>
</div>
<p>当然，理想情况下，我们会用多条链进行这样的分析，以确保每条链都收敛于相同的后验分布。此外，随着 MCMC 的进展，还有许多诊断性统计数据可以用来检查收敛程度的速率。同样理想的情况是，每条链都从不同的位置开始，但即使从同一位置开始，随机数序列最终也会将链引向截然不同的方向。我们可以使用与 <code><a href="https://rdrr.io/pkg/MQMF/man/robustSPM.html">robustSPM()</a></code> 函数相同的方法来选择不同的随机起点。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb67"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#Do five chains of the same length for the Fox model  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">6396679</span><span class="op">)</span>  <span class="co"># Note all chains start from same place, which is   </span></span>
<span><span class="va">inscale</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.07</span>,<span class="fl">0.05</span>,<span class="fl">0.09</span>,<span class="fl">0.45</span><span class="op">)</span>  <span class="co"># suboptimal, but still the chains  </span></span>
<span><span class="va">pars</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span>r<span class="op">=</span><span class="fl">0.205</span>,K<span class="op">=</span><span class="fl">11300</span>,Binit<span class="op">=</span><span class="fl">3220</span>,sigma<span class="op">=</span><span class="fl">0.044</span><span class="op">)</span><span class="op">)</span>  <span class="co"># differ  </span></span>
<span><span class="va">result</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/do_MCMC.html">do_MCMC</a></span><span class="op">(</span>chains<span class="op">=</span><span class="fl">5</span>,burnin<span class="op">=</span><span class="fl">50</span>,N<span class="op">=</span><span class="fl">2000</span>,thinstep<span class="op">=</span><span class="fl">512</span>,  </span>
<span>                  inpar<span class="op">=</span><span class="va">pars</span>,infunk<span class="op">=</span><span class="va">negLL1</span>,calcpred<span class="op">=</span><span class="va">simpspmC</span>,  </span>
<span>                  obsdat<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">fish</span><span class="op">[</span>,<span class="st">"cpue"</span><span class="op">]</span><span class="op">)</span>,calcdat<span class="op">=</span><span class="va">fish</span>,  </span>
<span>                  priorcalc<span class="op">=</span><span class="va">calcprior</span>,scales<span class="op">=</span><span class="va">inscale</span>,  </span>
<span>                  schaefer<span class="op">=</span><span class="cn">FALSE</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"acceptance rate = "</span>,<span class="va">result</span><span class="op">$</span><span class="va">arate</span>,<span class="st">" \n"</span><span class="op">)</span> <span class="co"># always check this    </span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>acceptance rate =  0.3140023 0.3327271 0.3801893 0.36673  </code></pre>
</div>
</div>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb69"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span>  <span class="co">#Now plot marginal posteriors from 5 Fox model chains    Fig7.27  </span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/parset.html">parset</a></span><span class="op">(</span>plots<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">)</span>,cex<span class="op">=</span><span class="fl">0.85</span>,margin<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.4</span>,<span class="fl">0.4</span>,<span class="fl">0.05</span>,<span class="fl">0.05</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="va">post</span> <span class="op">&lt;-</span> <span class="va">result</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/density.html">density</a></span><span class="op">(</span><span class="va">post</span><span class="op">[</span>,<span class="st">"K"</span><span class="op">]</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">1</span>,main<span class="op">=</span><span class="st">""</span>,xlab<span class="op">=</span><span class="st">"K"</span>,  </span>
<span>     ylim<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">4.4e-04</span><span class="op">)</span>,panel.first<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/graphics/grid.html">grid</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="fl">5</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/density.html">density</a></span><span class="op">(</span><span class="va">result</span><span class="op">$</span><span class="va">result</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span><span class="op">[</span>,<span class="st">"K"</span><span class="op">]</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="va">i</span><span class="op">)</span>  </span>
<span><span class="va">p</span> <span class="op">&lt;-</span> <span class="fl">1e-08</span>  </span>
<span><span class="va">post</span> <span class="op">&lt;-</span> <span class="va">result</span><span class="op">$</span><span class="va">result</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>  </span>
<span><span class="va">msy</span> <span class="op">&lt;-</span>  <span class="va">post</span><span class="op">[</span>,<span class="st">"r"</span><span class="op">]</span><span class="op">*</span><span class="va">post</span><span class="op">[</span>,<span class="st">"K"</span><span class="op">]</span><span class="op">/</span><span class="op">(</span><span class="op">(</span><span class="va">p</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span><span class="op">^</span><span class="op">(</span><span class="op">(</span><span class="va">p</span><span class="op">+</span><span class="fl">1</span><span class="op">)</span><span class="op">/</span><span class="va">p</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/density.html">density</a></span><span class="op">(</span><span class="va">msy</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="fl">1</span>,main<span class="op">=</span><span class="st">""</span>,xlab<span class="op">=</span><span class="st">"MSY"</span>,type<span class="op">=</span><span class="st">"l"</span>,  </span>
<span>     ylim<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">0.0175</span><span class="op">)</span>,panel.first<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/graphics/grid.html">grid</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="fl">5</span><span class="op">)</span> <span class="op">{</span>  </span>
<span>  <span class="va">post</span> <span class="op">&lt;-</span> <span class="va">result</span><span class="op">$</span><span class="va">result</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span>  </span>
<span>  <span class="va">msy</span> <span class="op">&lt;-</span>  <span class="va">post</span><span class="op">[</span>,<span class="st">"r"</span><span class="op">]</span><span class="op">*</span><span class="va">post</span><span class="op">[</span>,<span class="st">"K"</span><span class="op">]</span><span class="op">/</span><span class="op">(</span><span class="op">(</span><span class="va">p</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span><span class="op">^</span><span class="op">(</span><span class="op">(</span><span class="va">p</span><span class="op">+</span><span class="fl">1</span><span class="op">)</span><span class="op">/</span><span class="va">p</span><span class="op">)</span><span class="op">)</span>  </span>
<span>  <span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/density.html">density</a></span><span class="op">(</span><span class="va">msy</span><span class="op">)</span>,lwd<span class="op">=</span><span class="fl">2</span>,col<span class="op">=</span><span class="va">i</span><span class="op">)</span>  </span>
<span><span class="op">}</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-spm27" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-spm27-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="07-spm_files/figure-html/fig-spm27-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spm27-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;7.26: K 参数的边际后验值和 5 链 2000 次重复（512 * 2000 = 1049600 次迭代）得出的隐含 MSY。分布之间仍存在一些差异，尤其是在模式处，这表明更多的重复和更高的稀疏率可能会改善结果。the marginal posterior for the K parameter and the implied MSY from five chains of 2000 replicates (512 * 2000 = 1049600 iterations). Some variation remains between the distributions, especially at the mode, suggesting that more replicates and potentially a higher thinning rate would improve the outcome.
</figcaption></figure>
</div>
</div>
</div>
<p>然而，尽管五条链在视觉上存在差异（<a href="#fig-spm27" class="quarto-xref">图&nbsp;<span>7.26</span></a>），如果我们检查 <span class="math inline">\(K\)</span> 在不同的分位数上，我们发现差异很小（<a href="#tbl-spm8" class="quarto-xref">表&nbsp;<span>7.8</span></a>）。事实上，中值 <span class="math inline">\(K\)</span> 对于每条链，彼此之间的距离在1.1%左右是令人鼓舞的，最大百分比变化为 2.7%。作为实验，使用相同的 random.seed，但每条链运行 4000 步（总共 <span class="math inline">\(5 \times 512 \times 4050 = 10,368\)</span> 万次迭代，但仍然不到 5 分钟），最大变异下降到 1.48%，同样是 0.975 分位数，其他分位数都低于 1%。在这种情况下，由于模型非常简单，而且每个链只需要很短的时间，因此增加步数是值得的。对于参数更多，更复杂的似然计算，在评估小组的最后期限内，这些分析的时间安排可能变得至关重要。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb70"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># get qunatiles of each chain  </span></span>
<span><span class="va">probs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.025</span>,<span class="fl">0.05</span>,<span class="fl">0.5</span>,<span class="fl">0.95</span>,<span class="fl">0.975</span><span class="op">)</span>  </span>
<span><span class="va">storeQ</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">0</span>,nrow<span class="op">=</span><span class="fl">6</span>,ncol<span class="op">=</span><span class="fl">5</span>,dimnames<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">6</span>,<span class="va">probs</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">5</span><span class="op">)</span> <span class="va">storeQ</span><span class="op">[</span><span class="va">i</span>,<span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/quants.html">quants</a></span><span class="op">(</span><span class="va">result</span><span class="op">$</span><span class="va">result</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span><span class="op">[</span>,<span class="st">"K"</span><span class="op">]</span><span class="op">)</span>  </span>
<span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/apply.html">apply</a></span><span class="op">(</span><span class="va">storeQ</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">5</span>,<span class="op">]</span>,<span class="fl">2</span>,<span class="va">range</span><span class="op">)</span>  </span>
<span><span class="va">storeQ</span><span class="op">[</span><span class="fl">6</span>,<span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">100</span><span class="op">*</span><span class="op">(</span><span class="va">x</span><span class="op">[</span><span class="fl">2</span>,<span class="op">]</span> <span class="op">-</span> <span class="va">x</span><span class="op">[</span><span class="fl">1</span>,<span class="op">]</span><span class="op">)</span><span class="op">/</span><span class="va">x</span><span class="op">[</span><span class="fl">2</span>,<span class="op">]</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb71"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">knitr</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/knitr/man/kable.html">kable</a></span><span class="op">(</span><span class="va">storeQ</span>, digits <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div id="tbl-spm8" class="cell quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-spm8-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
表&nbsp;7.8: 针对 abdat 数据的 Fox 模型运行的五条 MCMC 链中 K 参数的五个量化值。最后一行是各链数值范围的百分比差异，显示它们的中位数相差略高于 1%。Five quantiles on the K parameter from the five MCMC chains run on the Fox model applied to the abdat data. The last row is the percent difference in the range of the values across the chains, which shows their medians differ by slightly more than 1%.
</figcaption><div aria-describedby="tbl-spm8-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell-output-display">
<table class="do-not-create-environment cell table table-sm table-striped small">
<thead><tr class="header">
<th style="text-align: right;">0.025</th>
<th style="text-align: right;">0.05</th>
<th style="text-align: right;">0.5</th>
<th style="text-align: right;">0.95</th>
<th style="text-align: right;">0.975</th>
</tr></thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">9859.157</td>
<td style="text-align: right;">10160.471</td>
<td style="text-align: right;">11633.376</td>
<td style="text-align: right;">13740.430</td>
<td style="text-align: right;">14124.828</td>
</tr>
<tr class="even">
<td style="text-align: right;">9893.256</td>
<td style="text-align: right;">10162.570</td>
<td style="text-align: right;">11541.118</td>
<td style="text-align: right;">13689.079</td>
<td style="text-align: right;">14302.523</td>
</tr>
<tr class="odd">
<td style="text-align: right;">9922.313</td>
<td style="text-align: right;">10157.503</td>
<td style="text-align: right;">11564.236</td>
<td style="text-align: right;">13620.369</td>
<td style="text-align: right;">14150.819</td>
</tr>
<tr class="even">
<td style="text-align: right;">9875.521</td>
<td style="text-align: right;">10107.843</td>
<td style="text-align: right;">11541.843</td>
<td style="text-align: right;">13533.356</td>
<td style="text-align: right;">13908.780</td>
</tr>
<tr class="odd">
<td style="text-align: right;">9835.652</td>
<td style="text-align: right;">10088.899</td>
<td style="text-align: right;">11504.845</td>
<td style="text-align: right;">13640.376</td>
<td style="text-align: right;">14087.693</td>
</tr>
<tr class="even">
<td style="text-align: right;">0.873</td>
<td style="text-align: right;">0.725</td>
<td style="text-align: right;">1.105</td>
<td style="text-align: right;">1.507</td>
<td style="text-align: right;">2.753</td>
</tr>
</tbody>
</table>
</div>
</div>
</figure>
</div>
</div>
<pre><code>                                                                                                                                                |</code></pre>
</section></section><section id="管理建议" class="level2" data-number="7.5"><h2 data-number="7.5" class="anchored" data-anchor-id="管理建议">
<span class="header-section-number">7.5</span> 管理建议</h2>
<section id="两种风险观" class="level3" data-number="7.5.1"><h3 data-number="7.5.1" class="anchored" data-anchor-id="两种风险观">
<span class="header-section-number">7.5.1</span> 两种风险观</h3>
<p>正式的资源评估，即使是使用剩余产量模型的简单评估，也可以说明所评估的渔业的种群状况，但问题仍然是如何利用这种评估来提出渔业管理建议。当然，这种建议将取决于有关渔业的管理目标。但是，即使没有正式的渔业政策，也应该能够就未来采用不同渔获量的影响提供咨询意见。我们可以使用最优模型拟合来预测模型动态到未来，这种预测是管理建议的基础，这些建议来自大多数非纯粹经验的资源评估。一旦知道（或假设）了渔业目标，那么，使用模型预测，就可以对未来的努力或捕捞水平进行估计，从而有望引导种群实现选定的目标。</p>
<p>一个共同的目标是努力将渔业维持在平均可以产生最大可持续产量的生物量水平，即 <span class="math inline">\(B_{MSY}\)</span> 。这种目标将被称为目标参考点，因为它源自讨论生物学参考点的文献（Garcia，1994；FAO，1995，1997）。可将 <span class="math inline">\(B_{MSY}\)</span> 视为目标，但相关渔获量 （MSY） 实际上应该作为渔获量的上限。除了目标参考点之外，通常还有一个极限参考点，它定义了要避免的资源状态。这通常从被认为对后续补充量构成风险的资源水平的角度进行讨论，尽管这通常只是一个准则。通常，极限参考点 <span class="math inline">\(B_{MSY}/2\)</span>，或者将通用代理设置为 <span class="math inline">\(0.2B_0\)</span>。 这种限度和目标参考点通常是在正式收获战略的背景下确定的。</p>
</section><section id="捕捞策略" class="level3" data-number="7.5.2"><h3 data-number="7.5.2" class="anchored" data-anchor-id="捕捞策略">
<span class="header-section-number">7.5.2</span> 捕捞策略</h3>
<p>在一个管辖区内，捕捞战略确定了决策框架，用于实现不同鱼类种群的既定生物目标，有时还包括经济和社会目标。一般来说，捕捞战略由三部分组成（FAO，1995、1997；Haddon，2007；Smith 等，2008）：</p>
<p>1.监测和收集有关每个相关渔业数据的手段。</p>
<p>2.评估每种渔业的明确方式，通常相对于预先选择的生物（或其他）参考点，例如捕捞死亡率、生物量水平或其替代物。</p>
<p>3.预先确定的捕捞控制规则或决策规则，用于将种群评估或种群状况转化为与未来努力量或捕捞水平相关的管理建议。</p>
<p>理想情况下，这种捕捞策略将经过模拟测试，以确定它们有效的条件，并摒弃无法实现预期目标的方案（Smith，1993；Punt 等，2016）</p>
<p>有许多众所周知的例子明确说明了辖区内渔业的管理目标（DAFF，2007；Deroba 和 Bence，2008；Magnuson-Stevens，2007）。例如，在澳大利亚联邦海洋管辖区，选定的目标是管理主要经济鱼类种群，使其生物量达到最大经济产量（<span class="math inline">\(B_{MEY}\)</span>）（DAFF, 2007; DAWR, 2018）；事实上，由于可用的信息不足，无法可靠地估算 <span class="math inline">\(B_{mEY}\)</span>，大多数物种使用 <span class="math inline">\(0.48 B_0\)</span> 的代用值。同样，将 <span class="math inline">\(0.2B_0\)</span> 定义为大多数物种的极限参考点，“其中没有支持选择特定种群的极限参考点[<span class="math inline">\(B_{MSY} / 2\)</span>]的信息……”(DAWR, 2018，第10页)。如果估计种群数量低于极限参考点，则停止有针对性的捕捞，尽管在混合渔业中仍可能出现副渔获物。如果鱼量高于极限参考点，则进行预测，以确定未来的渔获量应能促使鱼量顺利增加到目标生物量水平。</p>
</section></section><section id="风险评估预测" class="level2" data-number="7.6"><h2 data-number="7.6" class="anchored" data-anchor-id="风险评估预测">
<span class="header-section-number">7.6</span> 风险评估预测</h2>
<p>当然，对资源评估模型进行前瞻性预测的想法背后有许多重要的假设。首先，模型能成功捕捉到控制种群生物量的重要动态部分。在剩余产量模型中，这相当于假设对种群生产力的估计在未来将保持不变。请记住，在使用数据集 <em>dataspm</em> 时，残差保留了相对较大的振荡模式，这表明该模型在动态变化中遗漏了一些重要内容。尽管有这样的遗漏，模型仍可能保留对近似平均动态的充分估计，以进行有用的预测，但这就假定影响模型拟合的其他因素将继续以过去的方式运行。如果评估具有高度不确定性，那么未来的预测也将具有高度不确定性，这就降低了其在提供建议时的价值。</p>
<p>最简单的预测是使用最优参数估计，并采用恒定渔获量或努力量。我们需要当前种群的生物量和可捕量，以使用渔获量方程将指定的努力量水平转换为渔获量水平：</p>
<p><span id="eq-spm20"><span class="math display">\[
C_t=qE_tB_t  
\qquad(7.20)\]</span></span></p>
<p>然后，就可以使用带有最佳参数的标准动力学方程来预测预测渔获量下的生物量水平。如果使用指定的渔获量，则只需使用动力学方程（此处使用 Polacheck 等（1993）的版本）：</p>
<p><span id="eq-spm21"><span class="math display">\[
B_{t+1}=B_t+\frac{r}{p}B_t \left(1-\left(\frac{B_t}{K}\right)^p \right)-C_t
\qquad(7.21)\]</span></span></p>
<section id="确定性预测" class="level3" data-number="7.6.1"><h3 data-number="7.6.1" class="anchored" data-anchor-id="确定性预测">
<span class="header-section-number">7.6.1</span> 确定性预测</h3>
<p>如果我们使用最优的模型参数，那么对于一系列不同的前向预测渔获量，我们会得到不同的生物量和 cpue 轨迹。为了说明这一点，我们可以再次使用 <em>abdat</em> 数据集（注意，我们已将 <em>hessian</em> 选项设置为 “true”，因为我们将在后面使用）。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb73"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#Prepare Fox model on abdat data for future projections Fig7.28  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="va">abdat</span><span class="op">)</span>; <span class="va">fish</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">as.matrix</a></span><span class="op">(</span><span class="va">abdat</span><span class="op">)</span>  </span>
<span><span class="va">param</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span>r<span class="op">=</span><span class="fl">0.3</span>,K<span class="op">=</span><span class="fl">11500</span>,Binit<span class="op">=</span><span class="fl">3300</span>,sigma<span class="op">=</span><span class="fl">0.05</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="va">bestmod</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/nlm.html">nlm</a></span><span class="op">(</span>f<span class="op">=</span><span class="va">negLL1</span>,p<span class="op">=</span><span class="va">param</span>,funk<span class="op">=</span><span class="va">simpspm</span>,schaefer<span class="op">=</span><span class="cn">FALSE</span>,</span>
<span>               logobs<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">fish</span><span class="op">[</span>,<span class="st">"cpue"</span><span class="op">]</span><span class="op">)</span>,indat<span class="op">=</span><span class="va">fish</span>,hessian<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span>  </span>
<span><span class="va">optpar</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">bestmod</span><span class="op">$</span><span class="va">estimate</span><span class="op">)</span>  </span>
<span><span class="va">ans</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/plotspmmod.html">plotspmmod</a></span><span class="op">(</span>inp<span class="op">=</span><span class="va">bestmod</span><span class="op">$</span><span class="va">estimate</span>,indat<span class="op">=</span><span class="va">fish</span>,schaefer<span class="op">=</span><span class="cn">FALSE</span>,  </span>
<span>                 target<span class="op">=</span><span class="fl">0.4</span>,addrmse<span class="op">=</span><span class="cn">TRUE</span>, plotprod<span class="op">=</span><span class="cn">FALSE</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-spm28" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-spm28-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="07-spm_files/figure-html/fig-spm28-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spm28-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;7.27: 使用 Fox 模型和对数正态误差拟合的 abdat 数据集最佳模型。绿色虚线为黄土曲线，红色实线为最佳预测拟合模型。请注意对数正态残差的模式，这表明该模型在该数据方面存在一些不足。The optimum model fit for the abdat data-set using the Fox model and log-normal errors. The green dashed line is a loess curve while the solid red line is the optimum predicted model fit. Note the pattern in the log-normal residuals indicating that the model has some inadequacies with regard to this data.
</figcaption></figure>
</div>
</div>
</div>
<p>MSY估计约为 854 吨，资源似乎略高于 <span class="math inline">\(0.4B_0\)</span> 目标水平，通常用作表示 <span class="math inline">\(B_MSY\)</span>。从图中，并检查初始 <em>abdat</em> 数据框，我们可以看到 2000 年至 2008 年的渔获量每年 都在910 - 1030 吨之间，这导致模型预测 cpue 和生物量将下降。因此，我们可以探索700-1000吨的十年渔获量预测，或许以50吨为步长。鉴于分析中的不确定性以及这些预测是确定性的，因此对未来太多年的预测研究意义不大。长期预测对于说明不同渔获量的影响可能很有价值，但出于实际目的，十年往往绰绰有余，这取决于被评估物种的寿命（预计寿命较长的物种比寿命短的物种表现出较慢的动态变化）。函数 <code><a href="https://rdrr.io/pkg/MQMF/man/plotspmmod.html">plotspmmod()</a></code> 绘制的动态细节是通过使用具有最佳参数的函数 <code><a href="https://rdrr.io/pkg/MQMF/man/spm.html">spm()</a></code> 生成的（查看 <code><a href="https://rdrr.io/pkg/MQMF/man/plotspmmod.html">plotspmmod()</a></code> 代码，以了解这些详细信息）。当使用最佳参数运行 <code><a href="https://rdrr.io/pkg/MQMF/man/spm.html">spm()</a></code> 时，其输出包括 <em>动态（Dynamics）</em> 对象中 <em>outmat</em> 表中的预测动态。这里我们将使用 Fox 模型而不是 Schaefer 运行模型。</p>
<p>函数 <code><a href="https://rdrr.io/pkg/MQMF/man/spm.html">spm()</a></code> 输出的对象是一个由五个部分组成的列表。模型参数，包括 q 值；<em>outmat</em> 是一个矩阵，包含随时间变化的动态信息；<em>msy</em>；<em>sumout</em> 包含五个关键统计量的汇总；<em>schaefer</em> 用于识别是 Schaefer 模型还是 Fox 模型。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb74"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#   </span></span>
<span><span class="va">out</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/spm.html">spm</a></span><span class="op">(</span><span class="va">bestmod</span><span class="op">$</span><span class="va">estimate</span>,indat<span class="op">=</span><span class="va">fish</span>,schaefer<span class="op">=</span><span class="cn">FALSE</span><span class="op">)</span>   </span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/str.html">str</a></span><span class="op">(</span><span class="va">out</span>, width<span class="op">=</span><span class="fl">65</span>, strict.width<span class="op">=</span><span class="st">"cut"</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>List of 5
 $ parameters: Named num [1:5] 2.06e-01 1.13e+04 3.23e+03 4.38e..
  ..- attr(*, "names")= chr [1:5] "r" "K" "Binit" "Sigma" ...
 $ outmat    : num [1:25, 1:7] 1985 1986 1987 1988 1989 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : chr [1:25] "1985" "1986" "1987" "1988" ...
  .. ..$ : chr [1:7] "Year" "ModelB" "Catch" "Depletion" ...
 $ msy       : num 856
 $ sumout    : Named num [1:5] 8.56e+02 1.00e-08 4.34e-01 2.86e..
  ..- attr(*, "names")= chr [1:5] "msy" "p" "FinalDepl" "InitD"..
 $ schaefer  : logi FALSE</code></pre>
</div>
</div>
<p><em>outmat</em> 中的动态包括年份、生物量、cpue、预测的 cpue 和其他变量的详细信息（<a href="#tbl-spm9" class="quarto-xref">表&nbsp;<span>7.9</span></a>）。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb76"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">knitr</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/knitr/man/kable.html">kable</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">outmat</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">10</span>,<span class="op">]</span>, digits <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div id="tbl-spm9" class="cell quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-spm9-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
表&nbsp;7.9: 前十行为 abdat 数据集所代表的种群动态预测值和最佳 Fox 模型拟合值。The first ten rows of the predicted dynamics of the stock represented by the abdat data-set and the optimal Fox model fit.
</figcaption><div aria-describedby="tbl-spm9-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell-output-display">
<table class="do-not-create-environment cell table table-sm table-striped small">
<thead><tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: right;">Year</th>
<th style="text-align: right;">ModelB</th>
<th style="text-align: right;">Catch</th>
<th style="text-align: right;">Depletion</th>
<th style="text-align: right;">Harvest</th>
<th style="text-align: right;">CPUE</th>
<th style="text-align: right;">predCE</th>
</tr></thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">1985</td>
<td style="text-align: right;">1985</td>
<td style="text-align: right;">3231.056</td>
<td style="text-align: right;">1020</td>
<td style="text-align: right;">0.286</td>
<td style="text-align: right;">0.316</td>
<td style="text-align: right;">1.000</td>
<td style="text-align: right;">1.126</td>
</tr>
<tr class="even">
<td style="text-align: left;">1986</td>
<td style="text-align: right;">1986</td>
<td style="text-align: right;">3043.801</td>
<td style="text-align: right;">743</td>
<td style="text-align: right;">0.269</td>
<td style="text-align: right;">0.244</td>
<td style="text-align: right;">1.096</td>
<td style="text-align: right;">1.061</td>
</tr>
<tr class="odd">
<td style="text-align: left;">1987</td>
<td style="text-align: right;">1987</td>
<td style="text-align: right;">3122.663</td>
<td style="text-align: right;">867</td>
<td style="text-align: right;">0.276</td>
<td style="text-align: right;">0.278</td>
<td style="text-align: right;">1.130</td>
<td style="text-align: right;">1.088</td>
</tr>
<tr class="even">
<td style="text-align: left;">1988</td>
<td style="text-align: right;">1988</td>
<td style="text-align: right;">3082.389</td>
<td style="text-align: right;">724</td>
<td style="text-align: right;">0.272</td>
<td style="text-align: right;">0.235</td>
<td style="text-align: right;">1.147</td>
<td style="text-align: right;">1.074</td>
</tr>
<tr class="odd">
<td style="text-align: left;">1989</td>
<td style="text-align: right;">1989</td>
<td style="text-align: right;">3182.683</td>
<td style="text-align: right;">586</td>
<td style="text-align: right;">0.281</td>
<td style="text-align: right;">0.184</td>
<td style="text-align: right;">1.187</td>
<td style="text-align: right;">1.109</td>
</tr>
<tr class="even">
<td style="text-align: left;">1990</td>
<td style="text-align: right;">1990</td>
<td style="text-align: right;">3426.836</td>
<td style="text-align: right;">532</td>
<td style="text-align: right;">0.303</td>
<td style="text-align: right;">0.155</td>
<td style="text-align: right;">1.202</td>
<td style="text-align: right;">1.194</td>
</tr>
<tr class="odd">
<td style="text-align: left;">1991</td>
<td style="text-align: right;">1991</td>
<td style="text-align: right;">3736.575</td>
<td style="text-align: right;">567</td>
<td style="text-align: right;">0.330</td>
<td style="text-align: right;">0.152</td>
<td style="text-align: right;">1.265</td>
<td style="text-align: right;">1.302</td>
</tr>
<tr class="even">
<td style="text-align: left;">1992</td>
<td style="text-align: right;">1992</td>
<td style="text-align: right;">4020.891</td>
<td style="text-align: right;">609</td>
<td style="text-align: right;">0.355</td>
<td style="text-align: right;">0.151</td>
<td style="text-align: right;">1.320</td>
<td style="text-align: right;">1.401</td>
</tr>
<tr class="odd">
<td style="text-align: left;">1993</td>
<td style="text-align: right;">1993</td>
<td style="text-align: right;">4267.332</td>
<td style="text-align: right;">548</td>
<td style="text-align: right;">0.377</td>
<td style="text-align: right;">0.128</td>
<td style="text-align: right;">1.428</td>
<td style="text-align: right;">1.487</td>
</tr>
<tr class="even">
<td style="text-align: left;">1994</td>
<td style="text-align: right;">1994</td>
<td style="text-align: right;">4574.992</td>
<td style="text-align: right;">498</td>
<td style="text-align: right;">0.404</td>
<td style="text-align: right;">0.109</td>
<td style="text-align: right;">1.477</td>
<td style="text-align: right;">1.594</td>
</tr>
</tbody>
</table>
</div>
</div>
</figure>
</div>
</div>
<p>预测是将建模结果的时间序列（<a href="#tbl-spm9" class="quarto-xref">表&nbsp;<span>7.9</span></a> ）按顺序加入任何新的固定渔获量，并进行计算以填入所需列，从而继续进行动态计算。我们可以使用 <strong>MQMF</strong> 函数 <code><a href="https://rdrr.io/pkg/MQMF/man/spmprojDet.html">spmprojDet()</a></code>，它接收来自 <code><a href="https://rdrr.io/pkg/MQMF/man/spm.html">spm()</a></code> 函数的列表输出以及与确定性预测相关的一些细节，并为我们生成预测动态。您应该查看 <code><a href="https://rdrr.io/pkg/MQMF/man/spmproj.html">spmproj()</a></code> 代码，了解年份是如何设置的，代码之简短令人惊讶。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb77"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#  Fig 7.29  </span></span>
<span><span class="va">catches</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fl">700</span>,<span class="fl">1000</span>,<span class="fl">50</span><span class="op">)</span>   <span class="co"># projyr=10 is the default  </span></span>
<span><span class="va">projans</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/spmprojDet.html">spmprojDet</a></span><span class="op">(</span>spmobj<span class="op">=</span><span class="va">out</span>,projcatch<span class="op">=</span><span class="va">catches</span>,plotout<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-spm29" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-spm29-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="07-spm_files/figure-html/fig-spm29-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spm29-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;7.28: 根据 abdat 数据集拟合的最佳 Fox 模型的确定性恒定渔获量预测。垂直绿线是可用数据的极限，其右侧的红线是主要预测。数字是施加的恒定渔获量。Deterministic constant catch projections of the optimum Fox model fit to the abdat data-set. the vertical green line is the limit of the data available and the red lines to the right of that are the main projections. The numbers are the constant catches imposed.
</figcaption></figure>
</div>
</div>
</div>
<p>利用确定性恒定渔获量预测（<a href="#fig-spm29" class="quarto-xref">图&nbsp;<span>7.28</span></a>），可以看出 850 吨的恒定渔获量（接近 <span class="math inline">\(MSY\)</span> 估计值）是预测未来种群状况相对稳定的最接近的渔获量。</p>
</section><section id="考虑不确定性" class="level3" data-number="7.6.2"><h3 data-number="7.6.2" class="anchored" data-anchor-id="考虑不确定性">
<span class="header-section-number">7.6.2</span> 考虑不确定性</h3>
<p>确定性预测的一个明显问题就在于它们是确定性的。它们没有考虑到即使在最佳模型拟合中仍然存在的不确定性。理想情况下，我们在进行模型预测时应考虑到估计的不确定性。我们可以采用渐近误差法、自举法模型拟合或贝叶斯法等三种方法来预测不确定性。在每种情况下，不同分析的输出结果都是可信参数组合列表。这些参数可用于描述模型拟合中包含的可信动态范围，并以与确定性预测相同的方式对每个单独的生物量轨迹进行预测。</p>
<p>在拟合最优模型时，我们已经计算了 <em>Hessian</em> 矩阵，因此我们将从一个例子开始，利用渐近误差生成一个可信参数集矩阵，然后再向前推算。</p>
</section><section id="使用渐近误差" class="level3" data-number="7.6.3"><h3 data-number="7.6.3" class="anchored" data-anchor-id="使用渐近误差">
<span class="header-section-number">7.6.3</span> 使用渐近误差</h3>
<p>一旦我们有了一个最佳拟合模型，如果我们还计算了 Hessian 矩阵（如前所述），我们就可以利用估计的渐近误差生成一个充满可信参数向量的矩阵。然后就可以利用这些参数来生成复制的生物量轨迹，并绘制和总结这些轨迹。</p>
<p>在避免极限参考点方面，渔业管理成功的概率标准并不少见。根据不同的可信参数向量，通过大量重复的生物量轨迹，可以估算出有多大比例的预测会达到预期结果。通过将这些预测结果列表，管理者可以选择他们认为合适的风险水平。例如，澳大利亚联邦渔业政策中对可接受风险的明确定义是：“捕捞策略至少在 90% 的时间内将所有商业种群的生物量维持在极限参考点之上”。对这一点的解释是：“种群应在至少 90% 的时间内保持在极限生物量水平之上（即种群在 10 年中有 1 年的时间会低于极限生物量水平 <span class="math inline">\(B_{LIM}\)</span> 的风险）”（DAWR, 2018a, p10）。</p>
<p>在上一节中，我们已经利用 Fox 剩余产量模型（Polacheck 等，1993）对 <em>abdat</em> 数据集进行了最佳模型拟合。正如我们在利用渐近误差描述不确定性时能够生成生物量轨迹一样，我们可以在给定恒定渔获量的条件下，将这些轨迹逐一向前推算，并寻找能产生理想结果的渔获量水平。首先要做的是从最优模型拟合生成多个可信参数向量。我们可以使用函数 <code><a href="https://rdrr.io/pkg/MQMF/man/parasympt.html">parasympt()</a></code> 来做到这一点。一旦生成了可信参数向量矩阵，我们就可以使用 <code><a href="https://rdrr.io/pkg/MQMF/man/spmproj.html">spmproj()</a></code> 函数对给定年份数和给定渔获量常数进行动态预测（通过检查代码再次确认其工作原理）。<code><a href="https://rdrr.io/pkg/MQMF/man/parasympt.html">parasympt()</a></code> 函数只是一个方便的包装，用于调用 <code><a href="https://rdrr.io/pkg/mvtnorm/man/Mvnorm.html">rmvnorm()</a></code> 函数（<strong>mvtnorm</strong> 软件包的一部分）并将结果返回为一个带标记的矩阵，而 <code><a href="https://rdrr.io/pkg/MQMF/man/spmproj.html">spmproj()</a></code> 函数则稍微复杂一些。为了简化预测，该函数首先扩展了输入鱼类矩阵，以包括预测年份及其恒定渔获量（用 NA 填充未来 cpue）。<code><a href="https://rdrr.io/pkg/MQMF/man/spmproj.html">spmproj()</a></code> 使用 <code><a href="https://rdrr.io/pkg/MQMF/man/spm.html">spm()</a></code> 函数计算动态变化，而仅以矩阵形式返回模拟生物量。使用 <code><a href="https://rdrr.io/pkg/MQMF/man/spm.html">spm()</a></code> 可能看起来效率不高，但这意味着可以很容易地修改 <code><a href="https://rdrr.io/pkg/MQMF/man/spmproj.html">spmproj()</a></code> 函数，以返回动力学估算的任何变量。这些变量包括模型生物量、耗竭水平、捕获率和预测的 cpue（当然也可以只从生物量、预测 cpue 和原始数据中得出其他变量）。运行以下代码并检查两个输出对象：<em>matpar</em> 包含参数向量，<em>projs</em> 包含生物量轨迹行。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb78"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co"># generate parameter vectors from a multivariate normal     </span></span>
<span><span class="co"># project dynamics under a constant catch of 900t   </span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="http://mvtnorm.R-forge.R-project.org">mvtnorm</a></span><span class="op">)</span>   </span>
<span><span class="va">matpar</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/parasympt.html">parasympt</a></span><span class="op">(</span><span class="va">bestmod</span>,N<span class="op">=</span><span class="fl">1000</span><span class="op">)</span> <span class="co">#generate parameter vectors   </span></span>
<span><span class="va">projs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/spmproj.html">spmproj</a></span><span class="op">(</span><span class="va">matpar</span>,<span class="va">fish</span>,projyr<span class="op">=</span><span class="fl">10</span>,constC<span class="op">=</span><span class="fl">900</span><span class="op">)</span><span class="co">#do dynamics  </span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>计算完成后，我们可以总结预测的结果。首先，我们可以使用函数 <code><a href="https://rdrr.io/pkg/MQMF/man/plotproj.html">plotproj()</a></code> 绘制 1000 个预测。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb79"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co"># Fig 7.30  1000 replicate projections asymptotic errors   </span></span>
<span><span class="va">outp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/plotproj.html">plotproj</a></span><span class="op">(</span><span class="va">projs</span>,<span class="va">out</span>,qprob<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.1</span>,<span class="fl">0.5</span><span class="op">)</span>,refpts<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.2</span>,<span class="fl">0.4</span><span class="op">)</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-spm30" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-spm30-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="07-spm_files/figure-html/fig-spm30-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spm30-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;7.29: 1000 个预测值，通过使用反向哈希值和平均参数估计值生成 1000 个可信参数向量，并将每 个向量与 10 年不变的 900 吨渔获量后的渔获量向前推算得出。虚线为极限和目标参考点。蓝色垂直线是渔业数据的极限，黑色粗线是最优拟合，与最优线平行的红色细线是各年的第 10 和第 50 个量值。1000 projections derived from the using the inverse hessian and mean parameter estimates to generate 1000 plausible parameter vectors and projecting each vector forward with the fisheries catches followed by 10 years of a constant catch of 900t. The dashed lines are the limit and target reference points. The blue vertical line is the limit of fisheries data, the thick black line is the optimum fit and the thin red lines parallel to the optimum line are the 10th and 50th quantiles across years.
</figcaption></figure>
</div>
</div>
</div>
<p>很明显，10年后，假设动态保持不变，平均900吨的渔获量会导致种群从目前的状态有所下降，但使中值结果接近目标（上虚线），并且10年后不超过10%的轨迹越过极限参考点（LRP）（下细线高于 <span class="math inline">\(0.2B_0\)</span> 限制）。通过探索不同的恒定渔获量，将能够发现，如果渔获量增加到 1000 吨，那么 10 年后，第 10 分位数几乎违反了 LRP。将跨越 LRP 的轨迹比例制成表格以生成风险表，将澄清不同拟议的常数渔获量的影响，并有助于选择更具防御性的管理决策。</p>
</section><section id="使用-bootstrap-参数向量" class="level3" data-number="7.6.4"><h3 data-number="7.6.4" class="anchored" data-anchor-id="使用-bootstrap-参数向量">
<span class="header-section-number">7.6.4</span> 使用 Bootstrap 参数向量</h3>
<p>预测的本质是通过最佳模型拟合，结合分析中固有的不确定性估计，生成一个可信的参数向量矩阵。我们也可以不使用假定为多元正态分布的渐近误差，而使用自举法过程来生成所需的参数向量矩阵。就像在分析中描述不确定性一样，我们可以使用 <code><a href="https://rdrr.io/pkg/MQMF/man/spmboot.html">spmboot()</a></code> 函数来创建所需的参数向量。如果该函数耗时过长，我们可以使用基于 <strong>Rcpp</strong> 的 <code>simpspmC()</code> 函数来加快 1000（或更多）次模型拟合的速度。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb80"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#bootstrap generation of plausible parameter vectors for Fox   </span></span>
<span><span class="va">reps</span> <span class="op">&lt;-</span> <span class="fl">1000</span>    </span>
<span><span class="va">boots</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/spmboot.html">spmboot</a></span><span class="op">(</span><span class="va">bestmod</span><span class="op">$</span><span class="va">estimate</span>,fishery<span class="op">=</span><span class="va">fish</span>,iter<span class="op">=</span><span class="va">reps</span>,   </span>
<span>                 schaefer<span class="op">=</span><span class="cn">FALSE</span><span class="op">)</span>   </span>
<span><span class="va">matparb</span> <span class="op">&lt;-</span> <span class="va">boots</span><span class="op">$</span><span class="va">bootpar</span><span class="op">[</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">4</span><span class="op">]</span> <span class="co">#examine using head(matparb,20)  </span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>就象以前一样，我们可以使用这些参数向量来预测渔业的未来，并确定不同恒定捕捞水平对可持续性的任何风险（<a href="#fig-spm31" class="quarto-xref">图&nbsp;<span>7.30</span></a>）。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb81"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#bootstrap projections. Lower case b for boostrap  Fig7.31   </span></span>
<span><span class="va">projb</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/spmproj.html">spmproj</a></span><span class="op">(</span><span class="va">matparb</span>,<span class="va">fish</span>,projyr<span class="op">=</span><span class="fl">10</span>,constC<span class="op">=</span><span class="fl">900</span><span class="op">)</span>   </span>
<span><span class="va">outb</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/plotproj.html">plotproj</a></span><span class="op">(</span><span class="va">projb</span>,<span class="va">out</span>,qprob<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.1</span>,<span class="fl">0.5</span><span class="op">)</span>,refpts<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.2</span>,<span class="fl">0.4</span><span class="op">)</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-spm31" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-spm31-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="07-spm_files/figure-html/fig-spm31-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spm31-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;7.30: 1000 个预测值（灰色）来自使用自举过程生成的 1000 个可信参数向量，并将每个向量与 10 年 900 吨恒定渔获量之后的渔获量进行向前预测。虚线为极限和目标参考点。蓝色垂直线为渔业数据的极限，黑色粗线为最佳拟合，红线为各年的第 10 和第 50 个量值。
</figcaption></figure>
</div>
</div>
</div>
<p>投影的灰线与使用渐近误差生成的灰线不同（在中位数附近看起来更紧密），但第 10 和第 50 分位数看起来非常相似。当然，汇总结果基本相同，不过在这种情况下，没有一个预测低于极限参考点（试试 <em>outb</em><span class="math inline">\(ltLRP* 并与 *outp\)</span>ltLRP 进行比较）。</p>
</section><section id="使用贝叶斯后验样本" class="level3" data-number="7.6.5"><h3 data-number="7.6.5" class="anchored" data-anchor-id="使用贝叶斯后验样本">
<span class="header-section-number">7.6.5</span> 使用贝叶斯后验样本</h3>
<p>正如我们利用渐近误差和自举法获取样本一样，我们也可以从贝叶斯后验中获取样本，生成可信的参数向量。在这种情况下，我们可以使用 <code><a href="https://rdrr.io/pkg/MQMF/man/do_MCMC.html">do_MCMC()</a></code> 函数来进行 MCMC。我们只需要 1000 个可信参数向量，因此我们将从接近最大似然最大值的点开始进行合理的预烧，并使用较大的稀疏率来避免后验分布的连续抽样之间的序列相关性。如前所述，最好使用 <strong>Rcpp</strong> 派生函数 <code>simpspmC()</code> 进行 MCMC，因为我们仍在运行 214.5 万次迭代。由于我们使用的是 Fox 运行的剩余产量模型，其比例因子与 Schaefer 版本使用的比例因子有很大不同。如果您尚未编译 <code>simpspmC()</code> 函数（见附录），请修改以下代码以使用 <code><a href="https://rdrr.io/pkg/MQMF/man/simpspm.html">simpspm()</a></code>，为提高速度，您可以保留 <code>as.matrix(fish)</code>。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb82"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span>  <span class="co">#Generate 1000 parameter vectors from Bayesian posterior  </span></span>
<span><span class="va">param</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span>r<span class="op">=</span><span class="fl">0.3</span>,K<span class="op">=</span><span class="fl">11500</span>,Binit<span class="op">=</span><span class="fl">3300</span>,sigma<span class="op">=</span><span class="fl">0.05</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">444608</span><span class="op">)</span>  </span>
<span><span class="va">N</span> <span class="op">&lt;-</span> <span class="fl">1000</span>  </span>
<span><span class="va">result</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/do_MCMC.html">do_MCMC</a></span><span class="op">(</span>chains<span class="op">=</span><span class="fl">1</span>,burnin<span class="op">=</span><span class="fl">100</span>,N<span class="op">=</span><span class="va">N</span>,thinstep<span class="op">=</span><span class="fl">2048</span>,  </span>
<span>                  inpar<span class="op">=</span><span class="va">param</span>,infunk<span class="op">=</span><span class="va">negLL</span>,calcpred<span class="op">=</span><span class="va">simpspmC</span>,  </span>
<span>                  calcdat<span class="op">=</span><span class="va">fish</span>,obsdat<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">fish</span><span class="op">[</span>,<span class="st">"cpue"</span><span class="op">]</span><span class="op">)</span>,  </span>
<span>                  priorcalc<span class="op">=</span><span class="va">calcprior</span>,schaefer<span class="op">=</span><span class="cn">FALSE</span>,  </span>
<span>                  scales<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.065</span>,<span class="fl">0.055</span>,<span class="fl">0.1</span>,<span class="fl">0.475</span><span class="op">)</span><span class="op">)</span>  </span>
<span><span class="va">parB</span> <span class="op">&lt;-</span> <span class="va">result</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span> <span class="co">#capital B for Bayesian  </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"Acceptance Rate = "</span>,<span class="va">result</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span>,<span class="st">"\n"</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output cell-output-stdout">
<pre><code>Acceptance Rate =  0.3341834 0.3087928 0.3504304 0.3506508 </code></pre>
</div>
</div>
<p>为了证明生成的 1000 个重复已经失去了它们的序列相关性，并代表了对稳态分布的合理近似，我们可以绘制自相关图和 <span class="math inline">\(K\)</span> 参数 1000 个重复估计值的轨迹（<a href="#fig-spm32" class="quarto-xref">图&nbsp;<span>7.31</span></a>）。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb84"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co"># auto-correlation, or lack of, and the K trace Fig 7.32   </span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/parset.html">parset</a></span><span class="op">(</span>plots<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">)</span>,cex<span class="op">=</span><span class="fl">0.85</span><span class="op">)</span>    </span>
<span><span class="fu"><a href="https://rdrr.io/r/stats/acf.html">acf</a></span><span class="op">(</span><span class="va">parB</span><span class="op">[</span>,<span class="fl">2</span><span class="op">]</span>,lwd<span class="op">=</span><span class="fl">2</span><span class="op">)</span>   </span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">N</span>,<span class="va">parB</span><span class="op">[</span>,<span class="fl">2</span><span class="op">]</span>,type<span class="op">=</span><span class="st">"l"</span>,ylab<span class="op">=</span><span class="st">"K"</span>,ylim<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">8000</span>,<span class="fl">19000</span><span class="op">)</span>,xlab<span class="op">=</span><span class="st">""</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-spm32" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-spm32-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="07-spm_files/figure-html/fig-spm32-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spm32-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;7.31: 从上图可以明显看出，过剩产量模型福克斯版本的 K 参数后验分布的 1000 次抽样中缺乏自相关性。下图中的迹线显示了典型的分散值，但保留了一些更极端的峰值。
</figcaption></figure>
</div>
</div>
</div>
<p>可以从 MCMC 输出中提取这 1000 个可信参数向量，并通过与之前相同的 <code><a href="https://rdrr.io/pkg/MQMF/man/spmproj.html">spmproj()</a></code> 和 <code><a href="https://rdrr.io/pkg/MQMF/man/plotproj.html">plotproj()</a></code> 函数进行处理（<a href="#fig-spm33" class="quarto-xref">图&nbsp;<span>7.32</span></a>）。</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb85"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span> <span class="co">#  Fig 7.33   </span></span>
<span><span class="va">matparB</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">as.matrix</a></span><span class="op">(</span><span class="va">parB</span><span class="op">[</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">4</span><span class="op">]</span><span class="op">)</span> <span class="co"># B for Bayesian   </span></span>
<span><span class="va">projs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/spmproj.html">spmproj</a></span><span class="op">(</span><span class="va">matparB</span>,<span class="va">fish</span>,constC<span class="op">=</span><span class="fl">900</span>,projyr<span class="op">=</span><span class="fl">10</span><span class="op">)</span> <span class="co"># project them  </span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MQMF/man/plotproj.html">plotproj</a></span><span class="op">(</span><span class="va">projs</span>,<span class="va">out</span>,qprob<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.1</span>,<span class="fl">0.5</span><span class="op">)</span>,refpts<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.2</span>,<span class="fl">0.4</span><span class="op">)</span><span class="op">)</span> <span class="co">#projections  </span></span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details><div class="cell-output-display">
<div id="fig-spm33" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-spm33-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="07-spm_files/figure-html/fig-spm33-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spm33-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
图&nbsp;7.32: 利用贝叶斯后验的 1000 个样本得出的 900 吨恒定渔获量的 1000 个预测值（灰色）。虚线为极限和目标参考点。蓝色垂直线为渔业数据的极限，黑色粗线为最佳拟合，红线为各年的第 10 和第 50 分位数。
</figcaption></figure>
</div>
</div>
</div>
<p>请注意，<a href="#fig-spm33" class="quarto-xref">图&nbsp;<span>7.32</span></a> 中的中值细红线（第 50 分位数）略微偏离最大似然最佳模型拟合线（黑色）。但是，第 10 分位数相对于 LRP 保持在大致相同的位置，就像在使用渐近误差和自举的分析中观察到的那样。在这里，生物量轨迹的分布范围更广，但管理结果与前两种方法非常相似。</p>
</section></section><section id="结束语" class="level2" data-number="7.7"><h2 data-number="7.7" class="anchored" data-anchor-id="结束语">
<span class="header-section-number">7.7</span> 结束语</h2>
<p>我们已经比较详细研究了如何使用剩余产量模型为渔业提供管理建议。输出结果可能是未来三至五年不同渔获量或努力量制度下的预期种群结果列表。假设相关管辖区存在某种管理目标，管理者可以做出决定，渔业评估科学家也可以为其结果辩护。当然，鉴于任何渔业数据固有的不确定性和补充量动态的变幻莫测，不可能有确切的保证，但假设种群动态至少与以前的经验相似，那么对结果进行辩护是可能的。</p>
<p>随着气候变化引起的生物生长和成熟过程的改变，我们也可以预料到补充量也会发生变化，因此显然需要更加谨慎。但是，如果大规模的变化是由单一的风暴或其他事件引起的，那将构成一种新的不确定性，而这种不确定性在评估中是没有考虑到的。这就强调了评估科学家必须了解种群所在区域的情况。任何评估，哪怕是简单的评估，都不应仅仅是分析性的，或主要是自动化的。</p>
<p>现实情况是，评估的复杂性和先进性往往与其相对价值相关。只有在渔业可用数据大量增加的情况下，才有可能使用更复杂的模型。因此，鱼类种群有一个自然排序，最有价值的种群通常最受关注。然而，目前在世界各地，人们对为数据贫乏的鱼种提供管理建议的兴趣大增，这通常是受法律要求的驱动。因此，尽管我们只回顾了相对简单的评估方法，但这些方法不应被唾弃或忽视。</p>
</section><section id="附录使用-rcpp-代替-simpspm" class="level2" data-number="7.8"><h2 data-number="7.8" class="anchored" data-anchor-id="附录使用-rcpp-代替-simpspm">
<span class="header-section-number">7.8</span> 附录：使用 Rcpp 代替 simpspm</h2>
<p>在贝叶斯分析中，我们希望使用 Fox 剩余产量模型。这当然可以使用函数 <code><a href="https://rdrr.io/pkg/MQMF/man/simpspm.html">simpspm()</a></code>，通过修改 <em>schaefer</em> 参数来实现。但是</p>
<div class="cell">
<details class="code-fold"><summary>代码</summary><div class="sourceCode" id="cb86"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://www.rcpp.org">Rcpp</a></span><span class="op">)</span>  </span>
<span>  </span>
<span><span class="fu"><a href="https://rdrr.io/pkg/Rcpp/man/cppFunction.html">cppFunction</a></span><span class="op">(</span><span class="st">'NumericVector simpspmC(NumericVector pars,   </span></span>
<span><span class="st">             NumericMatrix indat, LogicalVector schaefer) {  </span></span>
<span><span class="st">   int nyrs = indat.nrow();  </span></span>
<span><span class="st">   NumericVector predce(nyrs);  </span></span>
<span><span class="st">   NumericVector biom(nyrs+1);  </span></span>
<span><span class="st">   double Bt, qval;  </span></span>
<span><span class="st">   double sumq = 0.0;  </span></span>
<span><span class="st">   double p = 0.00000001;  </span></span>
<span><span class="st">   if (schaefer(0) == TRUE) {  </span></span>
<span><span class="st">     p = 1.0;  </span></span>
<span><span class="st">   }  </span></span>
<span><span class="st">   NumericVector ep = exp(pars);  </span></span>
<span><span class="st">   biom[0] = ep[2];  </span></span>
<span><span class="st">   for (int i = 0; i &lt; nyrs; i++) {  </span></span>
<span><span class="st">      Bt = biom[i];  </span></span>
<span><span class="st">      biom[(i+1)] = Bt + (ep[0]/p)*Bt*(1 - pow((Bt/ep[1]),p)) -   </span></span>
<span><span class="st">                          indat(i,1);  </span></span>
<span><span class="st">      if (biom[(i+1)] &lt; 40.0) biom[(i+1)] = 40.0;  </span></span>
<span><span class="st">      sumq += log(indat(i,2)/biom[i]);  </span></span>
<span><span class="st">    }  </span></span>
<span><span class="st">    qval = exp(sumq/nyrs);  </span></span>
<span><span class="st">    for (int i = 0; i &lt; nyrs; i++) {  </span></span>
<span><span class="st">      predce[i] = log(biom[i] * qval);  </span></span>
<span><span class="st">    }  </span></span>
<span><span class="st">    return predce;  </span></span>
<span><span class="st">}'</span><span class="op">)</span>  </span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>


<!-- -->

<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-elder1979" class="csl-entry" role="listitem">
Elder, R. D. 1979. <span>《Equilibrium Yield for the Hauraki Gulf Snapper Fishery Estimated from Catch and Effort Figures, 1960<span></span>74》</span>. <em>New Zealand Journal of Marine and Freshwater Research</em> 13 (1): 31–38. <a href="https://doi.org/10.1080/00288330.1979.9515778">https://doi.org/10.1080/00288330.1979.9515778</a>.
</div>
<div id="ref-haddon2011" class="csl-entry" role="listitem">
Haddon, Malcolm. 2011. <em>Modelling and Quantitative Methods in Fisheries</em>. Chapman; Hall/CRC. <a href="https://doi.org/10.1201/9781439894170">https://doi.org/10.1201/9781439894170</a>.
</div>
<div id="ref-hilborn1979" class="csl-entry" role="listitem">
Hilborn, Ray. 1979. <span>《Comparison of Fisheries Control Systems That Utilize Catch and Effort Data》</span>. <em>Journal of the Fisheries Research Board of Canada</em> 36 (12): 1477–89. <a href="https://doi.org/10.1139/f79-215">https://doi.org/10.1139/f79-215</a>.
</div>
<div id="ref-hilborn1992" class="csl-entry" role="listitem">
Hilborn, Ray, 和 Carl J. Walters. 1992. <em>Quantitative Fisheries Stock Assessment</em>. Springer US. <a href="https://doi.org/10.1007/978-1-4615-3598-0">https://doi.org/10.1007/978-1-4615-3598-0</a>.
</div>
<div id="ref-maccall2009" class="csl-entry" role="listitem">
MacCall, Alec D. 2009. <span>《Depletion-Corrected Average Catch: A Simple Formula for Estimating Sustainable Yields in Data-Poor Situations》</span>. <em>ICES Journal of Marine Science</em> 66 (10): 2267–71. <a href="https://doi.org/10.1093/icesjms/fsp209">https://doi.org/10.1093/icesjms/fsp209</a>.
</div>
<div id="ref-polacheck1993" class="csl-entry" role="listitem">
Polacheck, Tom, Ray Hilborn, 和 Andre E. Punt. 1993. <span>《Fitting Surplus Production Models: Comparing Methods and Measuring Uncertainty》</span>. <em>Canadian Journal of Fisheries and Aquatic Sciences</em> 50 (12): 2597–607. <a href="https://doi.org/10.1139/f93-284">https://doi.org/10.1139/f93-284</a>.
</div>
<div id="ref-prager1994" class="csl-entry" role="listitem">
Prager, Michael. 1994. <span>《A suite of extensions to a nonequilibrium surplus-production model》</span>. <em>Fishery Bulletin</em> 92 (一月): 374–89.
</div>
<div id="ref-punt1997" class="csl-entry" role="listitem">
Punt, Andre E., 和 Ray Hilborn. 1997. <span>《Fisheries Stock Assessment and Decision Analysis: The Bayesian Approach》</span>. <em>Reviews in Fish Biology and Fisheries</em> 7 (1): 35–63. <a href="https://doi.org/10.1023/A:1018419207494">https://doi.org/10.1023/A:1018419207494</a>.
</div>
<div id="ref-saila1979" class="csl-entry" role="listitem">
Saila, S. B., J. H. Annala, J. L. McKoy, 和 J. D. Booth. 1979. <span>《Application of Yield Models to the New Zealand Rock Lobster Fishery》</span>. <em>New Zealand Journal of Marine and Freshwater Research</em> 13 (1): 1–11. <a href="https://doi.org/10.1080/00288330.1979.9515775">https://doi.org/10.1080/00288330.1979.9515775</a>.
</div>
<div id="ref-schaefer1991" class="csl-entry" role="listitem">
Schaefer, M. 1991. <span>《Some Aspects of the Dynamics of Populations Important to the Management of the Commercial Marine Fisheries》</span>. <em>Bulletin of Mathematical Biology</em> 53 (1-2): 253–79. <a href="https://doi.org/10.1016/s0092-8240(05)80049-7">https://doi.org/10.1016/s0092-8240(05)80049-7</a>.
</div>
<div id="ref-schaefer1957" class="csl-entry" role="listitem">
Schaefer, M. B. 1957. <span>《A study of the dynamics of the fishery for yellowfin tuna in the eastern tropical pacific ocean》</span>. 收入. <a href="https://www.semanticscholar.org/paper/A-study-of-the-dynamics-of-the-fishery-for-tuna-in-Schaefer/29677d4a85d251d68d645584b2505c51c1ef1728">https://www.semanticscholar.org/paper/A-study-of-the-dynamics-of-the-fishery-for-tuna-in-Schaefer/29677d4a85d251d68d645584b2505c51c1ef1728</a>.
</div>
<div id="ref-winker2018" class="csl-entry" role="listitem">
Winker, Henning, Felipe Carvalho, 和 Maia Kapur. 2018. <span>《JABBA: Just Another Bayesian Biomass Assessment》</span>. <em>Fisheries Research</em> 204 (八月): 275–88. <a href="https://doi.org/10.1016/j.fishres.2018.03.010">https://doi.org/10.1016/j.fishres.2018.03.010</a>.
</div>
</div>
</section></main><!-- /main --><script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "已复制");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "已复制");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><nav class="page-navigation"><div class="nav-page nav-page-previous">
      <a href="./06-uncertainty.html" class="pagination-link  aria-label=">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">不确定性</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./08-references.html" class="pagination-link" aria-label="参考文献">
        <span class="nav-page-text">参考文献</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">源代码</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb87" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="fu"># 剩余产量模型 {#sec-surplusproduction}</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a><span class="fu">## 引言</span></span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a>在前面的章节中，我们已经使用并拟合了所谓的静态模型，这些模型在一段时间内是稳定的（*例如*，使用<span class="in">`vB()`</span> 、<span class="in">`Gz()`</span>或<span class="in">`mm()`</span> 的生长模型 ）。此外，在第 <span class="co">[</span><span class="ot">-@sec-paraestimat</span><span class="co">]</span> 章 <span class="co">[</span><span class="ot">模型参数估计</span><span class="co">](04-application.qmd)</span> 和第 <span class="co">[</span><span class="ot">-@sec-uncertainty</span><span class="co">]</span> 章<span class="co">[</span><span class="ot">不确定性</span><span class="co">](06-uncertainty.qmd)</span>两章中，我们已经介绍了剩余产量模型（surplus production model, spm），这些模型可用于进行资源评估（例如 Schaefer 模型），并提供了一个时间序列数据的动态模型的示例。然而，当我们专注于特定的建模方法时，此类模型的细节开发受到限制。我们将在本章深入研究剩余产量模型。</span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a>剩余产量模型（或者生物量动态模型）<span class="co">[</span><span class="ot">@hilborn1992</span><span class="co">]</span> 将补充、生长和死亡率（生产的所有方面）的总体效应汇集到一个单一的生产方程中，处理无差异的生物量（或数量）。“无差异的（undifferentiated）”一词意味着忽略了年龄和长度组成以及性别和其他差异的所有方面，实际上都被忽略了。</span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-9"><a href="#cb87-9" aria-hidden="true" tabindex="-1"></a>为了进行正式的种群评估，就必须以某种方式对已开发资源的动态行为和生产力进行建模。这些动态的主要组分是种群对不同捕捞压力随时间推移的反应方式，即其资源量增加或减少的程度。通过研究不同捕捞强度水平的影响，一般可以评估种群的生产力。剩余产量模型提供了最简单的种群评估，尝试在模型与渔业数据拟合的基础上对种群动态进行描述。</span>
<span id="cb87-10"><a href="#cb87-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-11"><a href="#cb87-11" aria-hidden="true" tabindex="-1"></a>在20世纪50年代，@schaefer1957; @schaefer1991 描述了如何使用剩余产量模型来生成渔业种群评估。此后，这些模型得到很多发展 <span class="co">[</span><span class="ot">@hilborn1992; @prager1994; @haddon2011; @winker2018</span><span class="co">]</span>，我们将在本章简要介绍这些较近期的动态模型。</span>
<span id="cb87-12"><a href="#cb87-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-13"><a href="#cb87-13" aria-hidden="true" tabindex="-1"></a><span class="fu">### 数据需求</span></span>
<span id="cb87-14"><a href="#cb87-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-15"><a href="#cb87-15" aria-hidden="true" tabindex="-1"></a>估算这种模型的现代离散模型参数所需的最基本数据至少是一个相对丰度指数的时间序列和一个相关的渔获量数据时间序列。渔获量数据可以涵盖比相对丰度指数数据的年份更长。简单模型中使用的相对种群丰度指数一般是单位努力渔获量（cpue），但也可以是一些与渔业无关的丰度指数（例如，来自拖网调查、声学调查），或者两者皆具。</span>
<span id="cb87-16"><a href="#cb87-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-17"><a href="#cb87-17" aria-hidden="true" tabindex="-1"></a><span class="fu">### 对比的需求</span></span>
<span id="cb87-18"><a href="#cb87-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-19"><a href="#cb87-19" aria-hidden="true" tabindex="-1"></a>尽管最近偶尔使用 <span class="co">[</span><span class="ot">@elder1979; @saila1979; @punt1997</span><span class="co">]</span>，但剩余产量模型在 20 世纪 80 年代似乎不再流行。可能是因为在开发这些模型的早期，须假设被评估的种群处于平衡状态 <span class="co">[</span><span class="ot">@elder1979; @saila1979</span><span class="co">]</span>，而这往往导致过于乐观的结论，从长远来看是站不住脚的。@hilborn1979 分析了许多此类情况，并证明使用的数据往往过于单一；他们的努力量水平上缺乏对比，因此对相关种群的动态缺乏信息。数据缺乏对比度意味着渔获量和努力量信息只能用于有限范围的种群丰度水平和有限的捕捞强度水平。有限的努力强度范围意味着对不同捕捞强度水平的反应范围也将有限。当种群动态更多地受环境因素而非渔获量的驱动时，也会出现这种对比的缺乏，因此种群似乎以意想不到的方式对渔业做出反应（例如，尽管渔获量或努力量没有变化，但种群发生了巨大变化）。</span>
<span id="cb87-20"><a href="#cb87-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-21"><a href="#cb87-21" aria-hidden="true" tabindex="-1"></a>剩余产量模型的一个重要假设是，所使用的相对丰度度量能够提供了种群相对丰度随时间的信息指标。一般来说，假设种群丰度与 CPUE 或其他指数之间存在线性关系（尽管这不一定是 1：1 的关系）。显而易见的风险是，这个假设要么是错误的，要么可以根据情况发生变化。例如，cpue 可能会变得非常稳定，这意味着即使种群数量减少或增加，它也不会发生变化。或者，由于外部因素影响，指数的变化可能会非常大，以至于无法检测到丰度趋势。例如，可能会观察到不同年份间 CPUE 的巨大变化，但考虑到种群的生产力，这种变化在生物学上是不可能的 （Haddon，2018）。</span>
<span id="cb87-22"><a href="#cb87-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-23"><a href="#cb87-23" aria-hidden="true" tabindex="-1"></a>一个不同但相关的假设是，努力量的质量和随后的渔获率在一段时间内保持不变。不幸的是，由于捕捞网具的技术变化、捕捞行为或方法的改变，或捕捞效率的其他变化，从而形成“努力量爬升”的概念，对于依赖 CPUE 作为相对丰度指数的评估来说，总是一个挑战或问题。努力量递增变的概念意味着努力量的有效性增加，因此任何基于名义努力量观测到的名义 cpue都会高估相对种群丰度（偏高）。cpue 的统计标准化 （Kimura，1981；Haddon，2018）可以解决其中一些问题，但显然只能考虑可获得数据的因素。例如，如果在渔业中引入 GPS 绘图仪或彩色回声测深仪，这往往会提高捕捞效率，但却没有记录哪些船只以及何时引入这些设备，那么这些设备对渔获率的正面影响将无法通过标准化来解释。</span>
<span id="cb87-24"><a href="#cb87-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-25"><a href="#cb87-25" aria-hidden="true" tabindex="-1"></a><span class="fu">### 渔获率何时具有参考价值</span></span>
<span id="cb87-26"><a href="#cb87-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-27"><a href="#cb87-27" aria-hidden="true" tabindex="-1"></a>检验丰度与任何相对丰度指数之间的假定关系是否真实和有信息的一个可能方法是，在发达渔业中，如果允许渔获量增加，预计 cpue 会在一段时间后开始下降。同样，如果渔获量减少到小于剩余产量（可能是通过管理或营销变化），那么随着种群规模的增加，预计cpue会在一段时间后很快增加。其原理是，如果渔获量低于种群当前的产量，那么最终种群规模和 cpue 都会增加，反之亦然。如果渔获量因供应不足而下降，但仍保持或高于当前生产力，则 cpue 当然不会增加，甚至可能进一步下降，尽管渔获量可能略有减少。重点放在发达渔业上，因为当渔业开始时，生物量的任何初始枯竭都会导致 “意外”渔 获量 <span class="co">[</span><span class="ot">@maccall2009</span><span class="co">]</span>，因为种群被捕捞减少，这反过来又会导致 cpue 水平，一旦种群从未捕获水平减少，cpue 水平将无法维持。</span>
<span id="cb87-28"><a href="#cb87-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-29"><a href="#cb87-29" aria-hidden="true" tabindex="-1"></a>因此，预计在发达渔业中，cpue 在许多情况下与渔获量呈负相关，可能在 cpue 随渔获量变化而变化之间存在时滞。如果我们能发现这种关系，通常意味着数据中存在一定程度的反差；如果我们找不到这种负相关关系，通常意味着数据中有关种群如何对渔业做出反应的信息含量太低，无法仅根据渔获量和相对丰度指数进行评估。也就是说，在渔获量的基础上，相对丰度指数几乎没有增加更多的信息。</span>
<span id="cb87-30"><a href="#cb87-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-31"><a href="#cb87-31" aria-hidden="true" tabindex="-1"></a>我们将使用 **MQMF** 数据集 *schaef* 来说明这些观点。*Schaefer* 包含 @schaefer1957 原始黄鳍金枪鱼数据的渔获量和 CPUE，这是使用剩余产量模型进行种群评估的早期范例。</span>
<span id="cb87-32"><a href="#cb87-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-35"><a href="#cb87-35" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-36"><a href="#cb87-36" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-spm1</span></span>
<span id="cb87-37"><a href="#cb87-37" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: |</span></span>
<span id="cb87-38"><a href="#cb87-38" aria-hidden="true" tabindex="-1"></a><span class="co">#|   1934 - 1955年的黄鳍金枪鱼渔业数据（Schaefer，1957）。</span></span>
<span id="cb87-39"><a href="#cb87-39" aria-hidden="true" tabindex="-1"></a><span class="co">#|   渔获量以千磅为单位，努力量以千个标准4级剪网日为单位，cpue以千磅/日为单位。 </span></span>
<span id="cb87-40"><a href="#cb87-40" aria-hidden="true" tabindex="-1"></a><span class="co">#| layout-ncol: 2</span></span>
<span id="cb87-41"><a href="#cb87-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-42"><a href="#cb87-42" aria-hidden="true" tabindex="-1"></a><span class="co"># Yellowfin-tuna data from Schaefer 12957</span></span>
<span id="cb87-43"><a href="#cb87-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-44"><a href="#cb87-44" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(MQMF)</span>
<span id="cb87-45"><a href="#cb87-45" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span>
<span id="cb87-46"><a href="#cb87-46" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(gt)</span>
<span id="cb87-47"><a href="#cb87-47" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(patchwork)</span>
<span id="cb87-48"><a href="#cb87-48" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(knitr)</span>
<span id="cb87-49"><a href="#cb87-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-50"><a href="#cb87-50" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(schaef)</span>
<span id="cb87-51"><a href="#cb87-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-52"><a href="#cb87-52" aria-hidden="true" tabindex="-1"></a><span class="fu">kable</span>(schaef[<span class="dv">1</span><span class="sc">:</span><span class="dv">11</span>,], <span class="at">digits =</span> <span class="dv">3</span>, <span class="at">row.names =</span> <span class="cn">FALSE</span>)</span>
<span id="cb87-53"><a href="#cb87-53" aria-hidden="true" tabindex="-1"></a><span class="fu">kable</span>(schaef[<span class="dv">12</span><span class="sc">:</span><span class="dv">22</span>,], <span class="at">digits =</span> <span class="dv">3</span>, <span class="at">row.names =</span> <span class="cn">FALSE</span>)</span>
<span id="cb87-54"><a href="#cb87-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-55"><a href="#cb87-55" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-56"><a href="#cb87-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-57"><a href="#cb87-57" aria-hidden="true" tabindex="-1"></a>渔获量、cpue 及其关系图（<span class="co">[</span><span class="ot">@fig-spm1</span><span class="co">]</span>）仅显示 cpue 和渔获量之间微弱的负相关关系。如果我们用 <span class="in">`summary(model)`</span> 检验 <span class="in">`lm()`</span> 回归结果，我们发现回归仅有 $P = 0.04575$ 的显著性。但是，这反映了没有时滞的相关性，即 $lag = 0$ 。我们不知道需要经过多少年才能发现渔获量变化对 cpue 的潜在影响，因此，需要对 cpue 和渔获量之间进行时滞相关分析；为此，我们可以使用基本 R 语言的交互相关函数 <span class="in">`ccf()`</span> 。</span>
<span id="cb87-58"><a href="#cb87-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-61"><a href="#cb87-61" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-62"><a href="#cb87-62" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-spm1</span></span>
<span id="cb87-63"><a href="#cb87-63" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: |</span></span>
<span id="cb87-64"><a href="#cb87-64" aria-hidden="true" tabindex="-1"></a><span class="co">#|   Schaefer（1957）黄鳍金枪鱼渔业数据的各年渔获量和捕获量，</span></span>
<span id="cb87-65"><a href="#cb87-65" aria-hidden="true" tabindex="-1"></a><span class="co">#|   以及它们之间的回归关系。</span></span>
<span id="cb87-66"><a href="#cb87-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-67"><a href="#cb87-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-68"><a href="#cb87-68" aria-hidden="true" tabindex="-1"></a><span class="co"># schaef fishery data and regress cpue and catch    Fig 7.1</span></span>
<span id="cb87-69"><a href="#cb87-69" aria-hidden="true" tabindex="-1"></a><span class="co"># parset(plots=c(3,1),margin=c(0.35,0.4,0.05,0.05))</span></span>
<span id="cb87-70"><a href="#cb87-70" aria-hidden="true" tabindex="-1"></a><span class="co"># plot1(schaef[,"year"],schaef[,"catch"],ylab="Catch",xlab="Year",</span></span>
<span id="cb87-71"><a href="#cb87-71" aria-hidden="true" tabindex="-1"></a><span class="co">#       defpar=FALSE,lwd=2)</span></span>
<span id="cb87-72"><a href="#cb87-72" aria-hidden="true" tabindex="-1"></a><span class="co"># plot1(schaef[,"year"],schaef[,"cpue"],ylab="CPUE",xlab="Year",</span></span>
<span id="cb87-73"><a href="#cb87-73" aria-hidden="true" tabindex="-1"></a><span class="co">#       defpar=FALSE,lwd=2)</span></span>
<span id="cb87-74"><a href="#cb87-74" aria-hidden="true" tabindex="-1"></a><span class="co"># plot1(schaef[,"catch"],schaef[,"cpue"],type="p",ylab="CPUE",</span></span>
<span id="cb87-75"><a href="#cb87-75" aria-hidden="true" tabindex="-1"></a><span class="co">#       xlab="Catch",defpar=FALSE,pch=16,cex=1.0)</span></span>
<span id="cb87-76"><a href="#cb87-76" aria-hidden="true" tabindex="-1"></a><span class="co"># model &lt;- lm(schaef[,"cpue"] ~ schaef[,"catch"])</span></span>
<span id="cb87-77"><a href="#cb87-77" aria-hidden="true" tabindex="-1"></a><span class="co"># abline(model,lwd=2,col=2)   # summary(model)</span></span>
<span id="cb87-78"><a href="#cb87-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-79"><a href="#cb87-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-80"><a href="#cb87-80" aria-hidden="true" tabindex="-1"></a>p1<span class="ot">&lt;-</span> <span class="fu">ggplot</span>(<span class="at">data =</span> schaef, <span class="fu">aes</span>(<span class="at">x =</span> year, <span class="at">y =</span> catch)) <span class="sc">+</span></span>
<span id="cb87-81"><a href="#cb87-81" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_line</span>() <span class="sc">+</span></span>
<span id="cb87-82"><a href="#cb87-82" aria-hidden="true" tabindex="-1"></a>    <span class="fu">labs</span>(<span class="at">x =</span> <span class="st">"Year"</span>, <span class="at">y =</span> <span class="st">"Catch"</span>) <span class="sc">+</span></span>
<span id="cb87-83"><a href="#cb87-83" aria-hidden="true" tabindex="-1"></a>    <span class="fu">theme_bw</span>()</span>
<span id="cb87-84"><a href="#cb87-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-85"><a href="#cb87-85" aria-hidden="true" tabindex="-1"></a>p2<span class="ot">&lt;-</span> <span class="fu">ggplot</span>(<span class="at">data =</span> schaef, <span class="fu">aes</span>(<span class="at">x =</span> year, <span class="at">y =</span> cpue)) <span class="sc">+</span></span>
<span id="cb87-86"><a href="#cb87-86" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_line</span>() <span class="sc">+</span></span>
<span id="cb87-87"><a href="#cb87-87" aria-hidden="true" tabindex="-1"></a>    <span class="fu">labs</span>(<span class="at">x =</span> <span class="st">"Year"</span>, <span class="at">y =</span> <span class="st">"CPUE"</span>) <span class="sc">+</span></span>
<span id="cb87-88"><a href="#cb87-88" aria-hidden="true" tabindex="-1"></a>    <span class="fu">theme_bw</span>()</span>
<span id="cb87-89"><a href="#cb87-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-90"><a href="#cb87-90" aria-hidden="true" tabindex="-1"></a>p3<span class="ot">&lt;-</span> <span class="fu">ggplot</span>(<span class="at">data =</span> schaef, <span class="fu">aes</span>(<span class="at">x =</span> catch, <span class="at">y =</span> cpue)) <span class="sc">+</span></span>
<span id="cb87-91"><a href="#cb87-91" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb87-92"><a href="#cb87-92" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_smooth</span>(<span class="at">method =</span> <span class="st">"lm"</span>) <span class="sc">+</span></span>
<span id="cb87-93"><a href="#cb87-93" aria-hidden="true" tabindex="-1"></a>    <span class="fu">labs</span>(<span class="at">x =</span> <span class="st">"Catch"</span>, <span class="at">y =</span> <span class="st">"CPUE"</span>) <span class="sc">+</span></span>
<span id="cb87-94"><a href="#cb87-94" aria-hidden="true" tabindex="-1"></a>    <span class="fu">theme_bw</span>()</span>
<span id="cb87-95"><a href="#cb87-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-96"><a href="#cb87-96" aria-hidden="true" tabindex="-1"></a>  p1<span class="sc">/</span>p2<span class="sc">/</span>p3</span>
<span id="cb87-97"><a href="#cb87-97" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-98"><a href="#cb87-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-99"><a href="#cb87-99" aria-hidden="true" tabindex="-1"></a>如前所述，有迹象表明 $\text{time-lag} = 0$ 只是刚刚显著。然而，在时滞2年时，CPUE与渔获量呈显著负相关（<span class="co">[</span><span class="ot">@fig-spm2</span><span class="co">]</span>），表明黄鳍金枪鱼数据中有足够的对比度来为剩余产量模型提供信息（在 1 年、3 年和 4 年也有显著影响）。如果我们将 CPUE 数据物理滞后两年，这种相关性应该会变得更加明显（ <span class="co">[</span><span class="ot">@fig-spm3</span><span class="co">]</span>）。</span>
<span id="cb87-100"><a href="#cb87-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-103"><a href="#cb87-103" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-104"><a href="#cb87-104" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-spm2</span></span>
<span id="cb87-105"><a href="#cb87-105" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "使用 R 中的 `ccf()` 函数获得的 Schaefer（1957）黄鳍金枪鱼渔业数据 (schaef) 的渔获量与 cpue 之间的交叉相关性。"</span></span>
<span id="cb87-106"><a href="#cb87-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-107"><a href="#cb87-107" aria-hidden="true" tabindex="-1"></a><span class="co"># cross correlation between cpue and catch in schaef Fig 7.2</span></span>
<span id="cb87-108"><a href="#cb87-108" aria-hidden="true" tabindex="-1"></a><span class="fu">parset</span>(<span class="at">cex =</span> <span class="fl">0.85</span>) <span class="co"># sets par parameters for a tidy base graphic</span></span>
<span id="cb87-109"><a href="#cb87-109" aria-hidden="true" tabindex="-1"></a><span class="fu">ccf</span>(</span>
<span id="cb87-110"><a href="#cb87-110" aria-hidden="true" tabindex="-1"></a>    <span class="at">x =</span> schaef[, <span class="st">"catch"</span>], <span class="at">y =</span> schaef[, <span class="st">"cpue"</span>], <span class="at">type =</span> <span class="st">"correlation"</span>,</span>
<span id="cb87-111"><a href="#cb87-111" aria-hidden="true" tabindex="-1"></a>    <span class="at">ylab =</span> <span class="st">"Correlation"</span>, <span class="at">plot =</span> <span class="cn">TRUE</span></span>
<span id="cb87-112"><a href="#cb87-112" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb87-113"><a href="#cb87-113" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-114"><a href="#cb87-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-117"><a href="#cb87-117" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-118"><a href="#cb87-118" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-spm3</span></span>
<span id="cb87-119"><a href="#cb87-119" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Schaefer （1957）黄鳍金枪鱼渔业数据中的渔获量和 cpue 及其关系。当 cpue 时间序列的负滞后期为 2 年时，负相关或反相关关系变得更加明显。"</span></span>
<span id="cb87-120"><a href="#cb87-120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-121"><a href="#cb87-121" aria-hidden="true" tabindex="-1"></a><span class="co"># now plot schaef data with timelag of 2 years on cpue   Fig 7.3</span></span>
<span id="cb87-122"><a href="#cb87-122" aria-hidden="true" tabindex="-1"></a>model2 <span class="ot">&lt;-</span> <span class="fu">lm</span>(schaef[<span class="dv">3</span><span class="sc">:</span><span class="dv">22</span>, <span class="st">"cpue"</span>] <span class="sc">~</span> schaef[<span class="dv">1</span><span class="sc">:</span><span class="dv">20</span>, <span class="st">"catch"</span>])</span>
<span id="cb87-123"><a href="#cb87-123" aria-hidden="true" tabindex="-1"></a><span class="co"># parset(plots=c(3,1),margin=c(0.35,0.4,0.05,0.05))</span></span>
<span id="cb87-124"><a href="#cb87-124" aria-hidden="true" tabindex="-1"></a><span class="co"># plot1(schaef[1:20,"year"],schaef[1:20,"catch"],ylab="Catch",</span></span>
<span id="cb87-125"><a href="#cb87-125" aria-hidden="true" tabindex="-1"></a><span class="co">#       xlab="Year",defpar=FALSE,lwd=2)</span></span>
<span id="cb87-126"><a href="#cb87-126" aria-hidden="true" tabindex="-1"></a><span class="co"># plot1(schaef[3:22,"year"],schaef[3:22,"cpue"],ylab="CPUE",</span></span>
<span id="cb87-127"><a href="#cb87-127" aria-hidden="true" tabindex="-1"></a><span class="co">#       xlab="Year",defpar=FALSE,lwd=2)</span></span>
<span id="cb87-128"><a href="#cb87-128" aria-hidden="true" tabindex="-1"></a><span class="co"># plot(schaef[1:20,"catch"],schaef[3:22,"cpue"],type="p",</span></span>
<span id="cb87-129"><a href="#cb87-129" aria-hidden="true" tabindex="-1"></a><span class="co">#       ylab="CPUE",xlab="Catch",defpar=FALSE,cex=1.0,pch=16)</span></span>
<span id="cb87-130"><a href="#cb87-130" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb87-131"><a href="#cb87-131" aria-hidden="true" tabindex="-1"></a><span class="co"># abline(model2,lwd=2,col=2)</span></span>
<span id="cb87-132"><a href="#cb87-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-133"><a href="#cb87-133" aria-hidden="true" tabindex="-1"></a>p1 <span class="ot">&lt;-</span> schaef <span class="sc">|&gt;</span></span>
<span id="cb87-134"><a href="#cb87-134" aria-hidden="true" tabindex="-1"></a>    <span class="fu">filter</span>(year <span class="sc">&lt;=</span> <span class="dv">1953</span>) <span class="sc">|&gt;</span></span>
<span id="cb87-135"><a href="#cb87-135" aria-hidden="true" tabindex="-1"></a>    <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> year, <span class="at">y =</span> catch)) <span class="sc">+</span></span>
<span id="cb87-136"><a href="#cb87-136" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_line</span>() <span class="sc">+</span></span>
<span id="cb87-137"><a href="#cb87-137" aria-hidden="true" tabindex="-1"></a>    <span class="fu">theme_bw</span>()</span>
<span id="cb87-138"><a href="#cb87-138" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-139"><a href="#cb87-139" aria-hidden="true" tabindex="-1"></a>p2 <span class="ot">&lt;-</span> schaef <span class="sc">|&gt;</span></span>
<span id="cb87-140"><a href="#cb87-140" aria-hidden="true" tabindex="-1"></a>    <span class="fu">filter</span>(year <span class="sc">&gt;</span> <span class="dv">1935</span>) <span class="sc">|&gt;</span></span>
<span id="cb87-141"><a href="#cb87-141" aria-hidden="true" tabindex="-1"></a>    <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> year, <span class="at">y =</span> cpue)) <span class="sc">+</span></span>
<span id="cb87-142"><a href="#cb87-142" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_line</span>() <span class="sc">+</span></span>
<span id="cb87-143"><a href="#cb87-143" aria-hidden="true" tabindex="-1"></a>    <span class="fu">theme_bw</span>()</span>
<span id="cb87-144"><a href="#cb87-144" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-145"><a href="#cb87-145" aria-hidden="true" tabindex="-1"></a>l <span class="ot">&lt;-</span> <span class="fu">nrow</span>(schaef)</span>
<span id="cb87-146"><a href="#cb87-146" aria-hidden="true" tabindex="-1"></a>schaef1 <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb87-147"><a href="#cb87-147" aria-hidden="true" tabindex="-1"></a>    <span class="at">catch =</span> schaef[<span class="dv">1</span><span class="sc">:</span>(l <span class="sc">-</span> <span class="dv">2</span>), <span class="st">"catch"</span>],</span>
<span id="cb87-148"><a href="#cb87-148" aria-hidden="true" tabindex="-1"></a>    <span class="at">cpue =</span> schaef[<span class="dv">3</span><span class="sc">:</span>l, <span class="st">"cpue"</span>]</span>
<span id="cb87-149"><a href="#cb87-149" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb87-150"><a href="#cb87-150" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-151"><a href="#cb87-151" aria-hidden="true" tabindex="-1"></a>p3 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(<span class="at">data =</span> schaef1, <span class="fu">aes</span>(<span class="at">x =</span> catch, <span class="at">y =</span> cpue)) <span class="sc">+</span></span>
<span id="cb87-152"><a href="#cb87-152" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb87-153"><a href="#cb87-153" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_smooth</span>(<span class="at">method =</span> <span class="st">"lm"</span>) <span class="sc">+</span></span>
<span id="cb87-154"><a href="#cb87-154" aria-hidden="true" tabindex="-1"></a>    <span class="fu">theme_bw</span>()</span>
<span id="cb87-155"><a href="#cb87-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-156"><a href="#cb87-156" aria-hidden="true" tabindex="-1"></a>p1<span class="sc">/</span>p2<span class="sc">/</span>p3</span>
<span id="cb87-157"><a href="#cb87-157" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-158"><a href="#cb87-158" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-159"><a href="#cb87-159" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-160"><a href="#cb87-160" aria-hidden="true" tabindex="-1"></a>@schaefer1957 的黄鳍金枪鱼渔业数据中 cpue 与渔获量之间的关系，对 cpue 时间序列施加了2年的负时滞后（第3：22行与第1：20行）。极小的梯度反映了以千磅为单位报告的渔获量。</span>
<span id="cb87-161"><a href="#cb87-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-164"><a href="#cb87-164" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-165"><a href="#cb87-165" aria-hidden="true" tabindex="-1"></a><span class="co"># write out a summary of he regression model2</span></span>
<span id="cb87-166"><a href="#cb87-166" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(model2)</span>
<span id="cb87-167"><a href="#cb87-167" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-168"><a href="#cb87-168" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-169"><a href="#cb87-169" aria-hidden="true" tabindex="-1"></a><span class="fu">## 一些方程</span></span>
<span id="cb87-170"><a href="#cb87-170" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-171"><a href="#cb87-171" aria-hidden="true" tabindex="-1"></a>使用相对丰度指数来描述评估种群的动态。该指数无论如何得到，都假定其反映了用于估算该指数的方法（渔业相关的 cpue 或独立调查）所能获得的生物量，并且假定该生物量受到捕捞渔获量的影响。这意味着，如果我们使用商业单位努力量渔获量（cpue），严格来说，我们处理的是可开发生物量，而不是繁殖生物量（这是种群评估更常见的目标）。不过，一般假设捕捞的选择性接近成熟度曲线，因此所使用的指数仍是繁殖生物量指数，至少是近似指数。即便如此，在得出这样的结论之前，仍应明确考虑究竟指的是什么。</span>
<span id="cb87-172"><a href="#cb87-172" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-173"><a href="#cb87-173" aria-hidden="true" tabindex="-1"></a>一般来讲，动态变化是指年 $t$ 起始时的生物量方程，尽管根据定义，它可以指一年中的不同日期。请记住，一年的结束日期与下一年的起始日期实际上是相同的，但具体使用哪个日期会影响分析的开始和结束（例如，从哪个生物量年去除特定年份的渔获量）：</span>
<span id="cb87-174"><a href="#cb87-174" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-175"><a href="#cb87-175" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb87-176"><a href="#cb87-176" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb87-177"><a href="#cb87-177" aria-hidden="true" tabindex="-1"></a>B_0 &amp;= B_{init} <span class="sc">\\</span></span>
<span id="cb87-178"><a href="#cb87-178" aria-hidden="true" tabindex="-1"></a>B_{t+1} &amp;= B_t + rB_t \left(1-\dfrac{B_t}{K} \right) - C_t</span>
<span id="cb87-179"><a href="#cb87-179" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb87-180"><a href="#cb87-180" aria-hidden="true" tabindex="-1"></a>$$ {#eq-spm1}</span>
<span id="cb87-181"><a href="#cb87-181" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-182"><a href="#cb87-182" aria-hidden="true" tabindex="-1"></a>其中 $B_{init}$ 为数据开始时的初始生物量。如果数据从捕捞开始就有，那么$B_{init} = K$ ， $K$ 是承载能力或未捕捞时的生物量。$B_t$ 表示$t$ 年初的种群生物量，$r$ 表示种群的内禀生长率，以及 $rB_t\left(1-\dfrac{B_t}{K} \right)$ 表示种群生物量的生产函数，该函数考虑了新个体的补充、现存个体生物量的任何增长、自然死亡率，并假设密度对种群增长率的线性影响。最后的项，$C_t$ 是年 $t$ 的渔获量，表示了捕捞死亡率。每一项所指的年份非常重要，因为它决定了方程中的动态建模方式以及随后的 R 代码。</span>
<span id="cb87-183"><a href="#cb87-183" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-184"><a href="#cb87-184" aria-hidden="true" tabindex="-1"></a>为了将这种评估模型的动态与现实世界进行比较和拟合，还利用模型动态生成每年相对丰度指数的预测值：</span>
<span id="cb87-185"><a href="#cb87-185" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-186"><a href="#cb87-186" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb87-187"><a href="#cb87-187" aria-hidden="true" tabindex="-1"></a>\hat {I}_{t}=\frac{{C}_{t}}{{E}_{t}}=q{B}_{t}  </span>
<span id="cb87-188"><a href="#cb87-188" aria-hidden="true" tabindex="-1"></a>$$ {#eq-spm2}</span>
<span id="cb87-189"><a href="#cb87-189" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-190"><a href="#cb87-190" aria-hidden="true" tabindex="-1"></a>式中 $\hat I_t$ 是年 $t$ 相对丰度指数的预测或估计平均值，与观测到的指数进行比较，使模型与数据相匹配。$E_t$ 是年 $t$ 的捕捞努力量，$q$ 是可捕系数（定义为生物量/单位努力量的渔获量）。这种关系还提出了一个强有力的假设，即种群生物量就是所谓的动态库。这意味着，无论地理距离如何，渔业或环境对种群动态的任何影响都会在所用的每个时间段内（通常为一年，但可能更短）对整个种群产生影响。这是一个强有力的假设，特别是如果一个种群中出现任何一致的空间结构，或者渔业的地理规模使得一个区域的鱼需要大量时间才能到达另一个区域。同样，需要了解这些假设，才能理解其局限性并适当地解释任何此类分析。</span>
<span id="cb87-191"><a href="#cb87-191" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-192"><a href="#cb87-192" aria-hidden="true" tabindex="-1"></a><span class="fu">### 产量方程</span></span>
<span id="cb87-193"><a href="#cb87-193" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-194"><a href="#cb87-194" aria-hidden="true" tabindex="-1"></a>已经提出了大量的方程形式来描述种群的生产力以及如何响应资源量。我们将考虑两个形式，即 Schaefer 模型和 Fox （1970） 模型的修改形式，以及包含这两种模型的概括：</span>
<span id="cb87-195"><a href="#cb87-195" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-196"><a href="#cb87-196" aria-hidden="true" tabindex="-1"></a>Schaefer（1954,1957）模型的产量方程为：</span>
<span id="cb87-197"><a href="#cb87-197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-198"><a href="#cb87-198" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb87-199"><a href="#cb87-199" aria-hidden="true" tabindex="-1"></a>f\left( {B}_{t}\right)=r{B}_{t}\left( 1-\frac{{B}_{t}}{K} \right)  </span>
<span id="cb87-200"><a href="#cb87-200" aria-hidden="true" tabindex="-1"></a>$$ {#eq-spm3}</span>
<span id="cb87-201"><a href="#cb87-201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-202"><a href="#cb87-202" aria-hidden="true" tabindex="-1"></a>而 Fox(1970) 模型的修改版本使用：</span>
<span id="cb87-203"><a href="#cb87-203" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-204"><a href="#cb87-204" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb87-205"><a href="#cb87-205" aria-hidden="true" tabindex="-1"></a>f\left( {B_t}\right)=\log({K})r{B}_{t}\left( 1-\frac{\log({B_t})}{\log({K})}\right)  </span>
<span id="cb87-206"><a href="#cb87-206" aria-hidden="true" tabindex="-1"></a>$$ {#eq-spm4}</span>
<span id="cb87-207"><a href="#cb87-207" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-208"><a href="#cb87-208" aria-hidden="true" tabindex="-1"></a>该修改版本将 $\log(K)$ 作为第一项，其作用仅仅是将最大生产率保持在 Schaefer 模型中类似参数大致相当的水平。</span>
<span id="cb87-209"><a href="#cb87-209" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-210"><a href="#cb87-210" aria-hidden="true" tabindex="-1"></a>Pella和Tomlinson（1969）提出了一个广义产量方程，其中包括了 Schaefer 和 Fox 模型作为特例的情况。在此，我们将使用 @polacheck1993 提出的替代公式，它提供了种群动态的一般方程，可用于 Schaefer 和 Fox 模型，以及两者之间的渐变，具体取决于单个参数 $p$ 的值。</span>
<span id="cb87-211"><a href="#cb87-211" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-212"><a href="#cb87-212" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb87-213"><a href="#cb87-213" aria-hidden="true" tabindex="-1"></a>B_{t+1}=B_t + rB_t \frac{1}{p}\left(1-\left(\dfrac{B_t}{K} \right)^p \right)-C_t</span>
<span id="cb87-214"><a href="#cb87-214" aria-hidden="true" tabindex="-1"></a>$$ {#eq-spm5}</span>
<span id="cb87-215"><a href="#cb87-215" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-216"><a href="#cb87-216" aria-hidden="true" tabindex="-1"></a>其中第一项，$B_t$，是时间 $t$ 的种群生物量，最后一项 $C_t$，是时间 $t$ 的渔获量。中间项是比较复杂的部分，定义了产量曲线。它由种群的瞬时增长率 $r$ 、时间 $t$ 的现存生物量 $B_t$、环境容纳量或最大种群数量 $K$，以及控制产量曲线任何不对称性的项 $p$ 组成。如果将 $p$ 设置为 1.0（**MQMF** 中 <span class="in">`discretelogistic()`</span> 函数的默认值），该公式简化为经典的 Schaefer 模型 （Schaefer， 1954， 1957）。@polacheck1993 引入了上述公式，但往往称之为 Pella-Tomlinson（1969）剩余产量模型（尽管他们的公式不同，但具有非常相似的性质）。</span>
<span id="cb87-217"><a href="#cb87-217" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-218"><a href="#cb87-218" aria-hidden="true" tabindex="-1"></a>子项 $rB_t$ 表示不受约束的指数种群增长（因为在该差分方程中，将其加到 $B_t$ 中），只要 $r&gt;0.0$ ，将导致在没有渔获物的情况下种群持续正增长（尽管 14 世纪的瘟疫曾在一段短暂但特别不愉快的时期内扭转了这一趋势，但世界人口的正指数增长仍然是这一趋势的例证）。子项 $(1/p)(1-B_t/K)^p$ 为指数增长项提供了约束条件，因为随着种群数量的增加，指数增长项的值趋于零。这被称为密度依赖（density-dependent）效应。</span>
<span id="cb87-219"><a href="#cb87-219" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-220"><a href="#cb87-220" aria-hidden="true" tabindex="-1"></a>当将 $p$ 设置为 $1.0$ 时，该公式将与 Schaefer 模型相同（线性密度依赖性）。但是当 $p$ 设置为一个很小的数值时，比如 $1e-08$，那么公式就等价于 Fox 模型的动力学公式。$p&gt;1.0$ 的值会导致生产曲线向左倾斜，而模位于中心偏右。当 $p&gt;1$ 或 $&lt;1$ 时，密度依赖性将不再是线性的。一般我们会固定 $p$ 值，而不会尝试使用数据来拟合。仅凭渔获量和相对丰度指数通常不足以估算相对种群数量对产量的详细影响。</span>
<span id="cb87-221"><a href="#cb87-221" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-224"><a href="#cb87-224" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-225"><a href="#cb87-225" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-spm4</span></span>
<span id="cb87-226"><a href="#cb87-226" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "p 参数对 Polacheck 等（1993） 生产函数的影响（上图）和对密度依赖项的影响（下图）。注意生产力的重新缩放，以符合 Schaefer 曲线的结果。种群规模可以是生物量或数量。"</span></span>
<span id="cb87-227"><a href="#cb87-227" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-228"><a href="#cb87-228" aria-hidden="true" tabindex="-1"></a><span class="co"># plot productivity and density-dependence functions Fig7.4</span></span>
<span id="cb87-229"><a href="#cb87-229" aria-hidden="true" tabindex="-1"></a>prodfun <span class="ot">&lt;-</span> <span class="cf">function</span>(r, Bt, K, p) {</span>
<span id="cb87-230"><a href="#cb87-230" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span>((r <span class="sc">*</span> Bt <span class="sc">/</span> p) <span class="sc">*</span> (<span class="dv">1</span> <span class="sc">-</span> (Bt <span class="sc">/</span> K)<span class="sc">^</span>p))</span>
<span id="cb87-231"><a href="#cb87-231" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb87-232"><a href="#cb87-232" aria-hidden="true" tabindex="-1"></a>densdep <span class="ot">&lt;-</span> <span class="cf">function</span>(Bt, K, p) {</span>
<span id="cb87-233"><a href="#cb87-233" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span>((<span class="dv">1</span> <span class="sc">/</span> p) <span class="sc">*</span> (<span class="dv">1</span> <span class="sc">-</span> (Bt <span class="sc">/</span> K)<span class="sc">^</span>p))</span>
<span id="cb87-234"><a href="#cb87-234" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb87-235"><a href="#cb87-235" aria-hidden="true" tabindex="-1"></a>r <span class="ot">&lt;-</span> <span class="fl">0.75</span></span>
<span id="cb87-236"><a href="#cb87-236" aria-hidden="true" tabindex="-1"></a>K <span class="ot">&lt;-</span> <span class="fl">1000.0</span></span>
<span id="cb87-237"><a href="#cb87-237" aria-hidden="true" tabindex="-1"></a>Bt <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">1000</span></span>
<span id="cb87-238"><a href="#cb87-238" aria-hidden="true" tabindex="-1"></a>sp <span class="ot">&lt;-</span> <span class="fu">prodfun</span>(r, Bt, K, <span class="fl">1.0</span>) <span class="co"># Schaefer equivalent</span></span>
<span id="cb87-239"><a href="#cb87-239" aria-hidden="true" tabindex="-1"></a>sp0 <span class="ot">&lt;-</span> <span class="fu">prodfun</span>(r, Bt, K, <span class="at">p =</span> <span class="fl">1e-08</span>) <span class="co"># Fox equivalent</span></span>
<span id="cb87-240"><a href="#cb87-240" aria-hidden="true" tabindex="-1"></a>sp3 <span class="ot">&lt;-</span> <span class="fu">prodfun</span>(r, Bt, K, <span class="dv">3</span>) <span class="co"># left skewed production, marine mammal?</span></span>
<span id="cb87-241"><a href="#cb87-241" aria-hidden="true" tabindex="-1"></a><span class="fu">parset</span>(<span class="at">plots =</span> <span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">1</span>), <span class="at">margin =</span> <span class="fu">c</span>(<span class="fl">0.35</span>, <span class="fl">0.4</span>, <span class="fl">0.1</span>, <span class="fl">0.05</span>))</span>
<span id="cb87-242"><a href="#cb87-242" aria-hidden="true" tabindex="-1"></a><span class="fu">plot1</span>(Bt, sp,</span>
<span id="cb87-243"><a href="#cb87-243" aria-hidden="true" tabindex="-1"></a>    <span class="at">type =</span> <span class="st">"l"</span>, <span class="at">lwd =</span> <span class="dv">2</span>, <span class="at">xlab =</span> <span class="st">"Stock Size"</span>,</span>
<span id="cb87-244"><a href="#cb87-244" aria-hidden="true" tabindex="-1"></a>    <span class="at">ylab =</span> <span class="st">"Surplus Production"</span>, <span class="at">maxy =</span> <span class="dv">200</span>, <span class="at">defpar =</span> <span class="cn">FALSE</span></span>
<span id="cb87-245"><a href="#cb87-245" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb87-246"><a href="#cb87-246" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(Bt, sp0 <span class="sc">*</span> (<span class="fu">max</span>(sp) <span class="sc">/</span> <span class="fu">max</span>(sp0)), <span class="at">lwd =</span> <span class="dv">2</span>, <span class="at">col =</span> <span class="dv">2</span>, <span class="at">lty =</span> <span class="dv">2</span>) <span class="co"># rescale</span></span>
<span id="cb87-247"><a href="#cb87-247" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(Bt, sp3 <span class="sc">*</span> (<span class="fu">max</span>(sp) <span class="sc">/</span> <span class="fu">max</span>(sp3)), <span class="at">lwd =</span> <span class="dv">3</span>, <span class="at">col =</span> <span class="dv">3</span>, <span class="at">lty =</span> <span class="dv">3</span>) <span class="co"># production</span></span>
<span id="cb87-248"><a href="#cb87-248" aria-hidden="true" tabindex="-1"></a><span class="fu">legend</span>(<span class="dv">275</span>, <span class="dv">100</span>, <span class="at">cex =</span> <span class="fl">1.1</span>, <span class="at">lty =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, <span class="fu">c</span>(</span>
<span id="cb87-249"><a href="#cb87-249" aria-hidden="true" tabindex="-1"></a>    <span class="st">"p = 1.0 Schaefer"</span>, <span class="st">"p = 1e-08 Fox"</span>,</span>
<span id="cb87-250"><a href="#cb87-250" aria-hidden="true" tabindex="-1"></a>    <span class="st">"p = 3 LeftSkewed"</span></span>
<span id="cb87-251"><a href="#cb87-251" aria-hidden="true" tabindex="-1"></a>), <span class="at">col =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>), <span class="at">lwd =</span> <span class="dv">3</span>, <span class="at">bty =</span> <span class="st">"n"</span>)</span>
<span id="cb87-252"><a href="#cb87-252" aria-hidden="true" tabindex="-1"></a><span class="fu">plot1</span>(Bt, <span class="fu">densdep</span>(Bt, K, <span class="at">p =</span> <span class="dv">1</span>),</span>
<span id="cb87-253"><a href="#cb87-253" aria-hidden="true" tabindex="-1"></a>    <span class="at">xlab =</span> <span class="st">"Stock Size"</span>, <span class="at">defpar =</span> <span class="cn">FALSE</span>,</span>
<span id="cb87-254"><a href="#cb87-254" aria-hidden="true" tabindex="-1"></a>    <span class="at">ylab =</span> <span class="st">"Density-Dependence"</span>, <span class="at">maxy =</span> <span class="fl">2.5</span>, <span class="at">lwd =</span> <span class="dv">2</span></span>
<span id="cb87-255"><a href="#cb87-255" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb87-256"><a href="#cb87-256" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(Bt, <span class="fu">densdep</span>(Bt, K, <span class="fl">1e-08</span>), <span class="at">lwd =</span> <span class="dv">2</span>, <span class="at">col =</span> <span class="dv">2</span>, <span class="at">lty =</span> <span class="dv">2</span>)</span>
<span id="cb87-257"><a href="#cb87-257" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(Bt, <span class="fu">densdep</span>(Bt, K, <span class="dv">3</span>), <span class="at">lwd =</span> <span class="dv">3</span>, <span class="at">col =</span> <span class="dv">3</span>, <span class="at">lty =</span> <span class="dv">3</span>)</span>
<span id="cb87-258"><a href="#cb87-258" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-259"><a href="#cb87-259" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-260"><a href="#cb87-260" aria-hidden="true" tabindex="-1"></a>Schaefer 模型假设生产曲线对称，在 $0.5K$ 处具有最大剩余生产或最大持续产量（MSY），密度依赖项的线性变化趋势是，当种群数量非常小时密度依赖项为1.0，当 $B_t$ 趋于$K$ 时密度依赖项为0 。当 $p$ 的值很小时，比如说 $p=1e-08$ ，该模型近似为Fox 模型，这会产生一条不对称的生产曲线，在某个较低的消耗水平下（本例中使用 <span class="in">`bt[which.max(sp0)]`</span> 发现为 $0.368K$,），会形成最大产量。密度相关项是非线性的，最大持续产量（MSY）出现在密度相关项 = 1.0 的地方。如果不对<span class="co">[</span><span class="ot">@fig-spm4</span><span class="co">]</span> 中进行重新缩放，Fox模型通常比 Schaefer 模型更有效率，因为当种群数量低于最大持续产量生物量 $B_{MSY}$ 时，密度相关项在大于1.0。$p&gt;1.0$ 时，最大产量出现在较高的种群数量处，当种群数量较低时，种群增长率几乎呈线性增长，而只有在种群数量相当大时，才会出现密度依赖下降的情况。只发生在相当高的种群水平上。与鱼类相比，这种动态在海洋哺乳动物中更为典型。</span>
<span id="cb87-261"><a href="#cb87-261" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-262"><a href="#cb87-262" aria-hidden="true" tabindex="-1"></a>可以认为 Schaefer 模型比 Fox 模型更保守，因为它需要更高的种群数量才能达到最大产量，并且通常会导致较低水平的渔获量，由于 Fox 类型模型的产量通常较高，可能会出现例外情况。</span>
<span id="cb87-263"><a href="#cb87-263" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-264"><a href="#cb87-264" aria-hidden="true" tabindex="-1"></a><span class="fu">### Schaefer 模型</span></span>
<span id="cb87-265"><a href="#cb87-265" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-266"><a href="#cb87-266" aria-hidden="true" tabindex="-1"></a>对于 Schaefer 模型，我们通过设置 $p=1.0$ 得到：</span>
<span id="cb87-267"><a href="#cb87-267" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-268"><a href="#cb87-268" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb87-269"><a href="#cb87-269" aria-hidden="true" tabindex="-1"></a>B_{t+1} = B_t + rB_t \left(1-\dfrac{B_t}{K} \right) -C_t </span>
<span id="cb87-270"><a href="#cb87-270" aria-hidden="true" tabindex="-1"></a>$$ {#eq-spm6}</span>
<span id="cb87-271"><a href="#cb87-271" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-272"><a href="#cb87-272" aria-hidden="true" tabindex="-1"></a>给定渔业数据的时间序列，总会有一个初始生物量，可能是 $B_{init} =K$ 或 $B_{init}$ 是 $K$ 的某个分数，取决于在首次获得渔业数据时是否认为该种群已经枯竭。$B_{init}$ 不可能高于 $K$ ，因为实际种群往往不会表现出稳定的平衡。</span>
<span id="cb87-273"><a href="#cb87-273" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-274"><a href="#cb87-274" aria-hidden="true" tabindex="-1"></a>根据数据拟合模型至少需要3个参数，即 $r$ 、$K$ 、可捕系数 $q$ （可能还需要 $B_{init}$ ）。但是，可以使用所谓的“封闭形式”方法来估计可捕获性系数 $q$:</span>
<span id="cb87-275"><a href="#cb87-275" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-276"><a href="#cb87-276" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb87-277"><a href="#cb87-277" aria-hidden="true" tabindex="-1"></a>\hat q =\exp \left(\frac{1}{n}\sum \log\left(\frac{I_t}{\hat B_t} \right) \right)</span>
<span id="cb87-278"><a href="#cb87-278" aria-hidden="true" tabindex="-1"></a>$$ {#eq-spm7}</span>
<span id="cb87-279"><a href="#cb87-279" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-280"><a href="#cb87-280" aria-hidden="true" tabindex="-1"></a>即观测到的渔获量除以预测的可开发生物量的反演几何平均数 <span class="co">[</span><span class="ot">@polacheck1993</span><span class="co">]</span>。这样就得到了时间序列的平均可捕量。如果渔业发生了重大变化，CPUE 的质量也发生了变化，则有可能对时间序列的不同部分产生不同的可捕量估计值。然而，需要注意为这种建议的模型规格进行有力的辩护，特别是用于估算的时间序列越 短，就越需要注意。 $q$ 的不确定性就越大。</span>
<span id="cb87-281"><a href="#cb87-281" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-282"><a href="#cb87-282" aria-hidden="true" tabindex="-1"></a><span class="fu">### 残差平方和</span></span>
<span id="cb87-283"><a href="#cb87-283" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-284"><a href="#cb87-284" aria-hidden="true" tabindex="-1"></a>该模型可以使用最小二乘法进行拟合，或者更准确地说，可以使用残差误差的平方和进行拟合：</span>
<span id="cb87-285"><a href="#cb87-285" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-286"><a href="#cb87-286" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb87-287"><a href="#cb87-287" aria-hidden="true" tabindex="-1"></a>ssq = \sum \left(\log(I_t)-\log(\hat I_t) \right)^2</span>
<span id="cb87-288"><a href="#cb87-288" aria-hidden="true" tabindex="-1"></a>$$ {#eq-spm8}</span>
<span id="cb87-289"><a href="#cb87-289" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-290"><a href="#cb87-290" aria-hidden="true" tabindex="-1"></a>由于 CPUE 一般呈对数正态分布，而最小二乘法意味着正态随机误差，因此需要进行对数变换。最小二乘法在首先寻找一组参数，使模型与现有数据相匹配时，往往相对稳健。然而，一旦接近解决方案，如果使用最大似然法，就会有更多建模选择。全对数正态对数似然为：</span>
<span id="cb87-291"><a href="#cb87-291" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-292"><a href="#cb87-292" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb87-293"><a href="#cb87-293" aria-hidden="true" tabindex="-1"></a>L(data|B_{init},r,K,q)=\prod_t\dfrac{1}{I_t\sqrt{2\pi \hat \sigma}}e^{\frac{-(\log I_t-\log \hat I_t)^2}{2\hat \sigma^2}}</span>
<span id="cb87-294"><a href="#cb87-294" aria-hidden="true" tabindex="-1"></a>$$ {#eq-spm9}</span>
<span id="cb87-295"><a href="#cb87-295" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-296"><a href="#cb87-296" aria-hidden="true" tabindex="-1"></a>除了对数变换之外，这与插在 $\sqrt{2\pi\hat \sigma}$ 项之前相关变量（此处为 $I_t$ ）的正态 PDF 似然不同。幸运的是，如第 <span class="co">[</span><span class="ot">-@sec-paraestimat</span><span class="co">]</span> 章”模型参数估算“ 所示，可以对负对数似然简化 <span class="co">[</span><span class="ot">@haddon2011</span><span class="co">]</span>，变为：</span>
<span id="cb87-297"><a href="#cb87-297" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-298"><a href="#cb87-298" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb87-299"><a href="#cb87-299" aria-hidden="true" tabindex="-1"></a>-veLL = \frac{n}{2}(\log(2\pi)+2\log(\hat\sigma)+1)</span>
<span id="cb87-300"><a href="#cb87-300" aria-hidden="true" tabindex="-1"></a>$$ {#eq-spm10}</span>
<span id="cb87-301"><a href="#cb87-301" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-302"><a href="#cb87-302" aria-hidden="true" tabindex="-1"></a>其中，标准差（$\hat \sigma$）的最大似然估计，由下式得到：</span>
<span id="cb87-303"><a href="#cb87-303" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-304"><a href="#cb87-304" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb87-305"><a href="#cb87-305" aria-hidden="true" tabindex="-1"></a>\hat \sigma=\sqrt{\dfrac{\sum \left(\log(I_t)-\log(\hat I_t)\right)^2}{n}}</span>
<span id="cb87-306"><a href="#cb87-306" aria-hidden="true" tabindex="-1"></a>$$ {#eq-spm11}</span>
<span id="cb87-307"><a href="#cb87-307" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-308"><a href="#cb87-308" aria-hidden="true" tabindex="-1"></a>注意除以 $n$ 而不是*除以* $n-1$ 。严格来讲，对于对数正态（<span class="co">[</span><span class="ot">@eq-spm10</span><span class="co">]</span> 中），$-veLL$ 后面应该跟着一个附加项：</span>
<span id="cb87-309"><a href="#cb87-309" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-310"><a href="#cb87-310" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb87-311"><a href="#cb87-311" aria-hidden="true" tabindex="-1"></a>-\sum \log(I_t)</span>
<span id="cb87-312"><a href="#cb87-312" aria-hidden="true" tabindex="-1"></a>$$ {#eq-spm12}</span>
<span id="cb87-313"><a href="#cb87-313" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-314"><a href="#cb87-314" aria-hidden="true" tabindex="-1"></a>对数转换后的观测捕获率之和。但是，由于该项是恒量，因此通常会省略。当然，当使用 R 时，我们总是可以使用内置的概率密度函数实现（参见 <span class="in">`negLL()`</span> 和 <span class="in">`negLL1()`</span> ），因此这种简化并不是绝对必要的，但是当人们希望使用 **Rcpp** 加快分析速度时，它们仍然有用，尽管 *Rcpp-syntactic-sugar*，导致 C++ 代码看起来非常像 R 代码，现在包括 <span class="in">`dnorm()`</span> 版本和相关的分布函数。</span>
<span id="cb87-315"><a href="#cb87-315" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-316"><a href="#cb87-316" aria-hidden="true" tabindex="-1"></a><span class="fu">### 估算管理统计</span></span>
<span id="cb87-317"><a href="#cb87-317" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-318"><a href="#cb87-318" aria-hidden="true" tabindex="-1"></a>只需使用以下方法即可计算 Schaefer 模型的最大可持续产量：</span>
<span id="cb87-319"><a href="#cb87-319" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-320"><a href="#cb87-320" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb87-321"><a href="#cb87-321" aria-hidden="true" tabindex="-1"></a>MSY =\dfrac{rK}{4}</span>
<span id="cb87-322"><a href="#cb87-322" aria-hidden="true" tabindex="-1"></a>$$ {#eq-spm13}</span>
<span id="cb87-323"><a href="#cb87-323" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-324"><a href="#cb87-324" aria-hidden="true" tabindex="-1"></a>然而，对于使用 <span class="co">[</span><span class="ot">@polacheck1993</span><span class="co">]</span> 的 *p* 参数的更一般方程，需要使用：</span>
<span id="cb87-325"><a href="#cb87-325" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-326"><a href="#cb87-326" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb87-327"><a href="#cb87-327" aria-hidden="true" tabindex="-1"></a>MSY = \dfrac{rK}{(p+1)^{\frac{(p+1)}{p}}}</span>
<span id="cb87-328"><a href="#cb87-328" aria-hidden="true" tabindex="-1"></a>$$ {#eq-spm14}</span>
<span id="cb87-329"><a href="#cb87-329" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-330"><a href="#cb87-330" aria-hidden="true" tabindex="-1"></a>当$p=1.0$ 时，上式可以简化为<span class="co">[</span><span class="ot">@eq-spm13</span><span class="co">]</span>。我们可以使用 **MQMF** 函数<span class="in">`getMSY()`</span> 来计算 <span class="co">[</span><span class="ot">@eq-spm14</span><span class="co">]</span> ，这也说明了Fox 模型比 Schaefer 模型具有更高的生产力。</span>
<span id="cb87-331"><a href="#cb87-331" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-334"><a href="#cb87-334" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-335"><a href="#cb87-335" aria-hidden="true" tabindex="-1"></a><span class="co"># compare Schaefer and Fox MSY estimates for same parameters</span></span>
<span id="cb87-336"><a href="#cb87-336" aria-hidden="true" tabindex="-1"></a>param <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="at">r =</span> <span class="fl">1.1</span>, <span class="at">K =</span> <span class="fl">1000.0</span>, <span class="at">Binit =</span> <span class="fl">800.0</span>, <span class="at">sigma =</span> <span class="fl">0.075</span>)</span>
<span id="cb87-337"><a href="#cb87-337" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"MSY Schaefer = "</span>, <span class="fu">getMSY</span>(param, <span class="at">p =</span> <span class="fl">1.0</span>), <span class="st">"</span><span class="sc">\n</span><span class="st">"</span>) <span class="co"># p=1 is default</span></span>
<span id="cb87-338"><a href="#cb87-338" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"MSY Fox      = "</span>, <span class="fu">getMSY</span>(param, <span class="at">p =</span> <span class="fl">1e-08</span>), <span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)</span>
<span id="cb87-339"><a href="#cb87-339" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-340"><a href="#cb87-340" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-341"><a href="#cb87-341" aria-hidden="true" tabindex="-1"></a>当然，如果将两个模型与实际数据进行拟合，通常会为每个模型生成不同的参数，因此得到的 MSY 值可能更接近。</span>
<span id="cb87-342"><a href="#cb87-342" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-343"><a href="#cb87-343" aria-hidden="true" tabindex="-1"></a>还可以生成基于努力量的管理统计数据。如果努力量水平一直持续下去，使种群达到平衡时*MSY* 的努力水平称为$E_{MSY}$ :</span>
<span id="cb87-344"><a href="#cb87-344" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-345"><a href="#cb87-345" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb87-346"><a href="#cb87-346" aria-hidden="true" tabindex="-1"></a>E_{MSY} =\dfrac{r}{q(1+p)}</span>
<span id="cb87-347"><a href="#cb87-347" aria-hidden="true" tabindex="-1"></a>$$ {#eq-spm15}</span>
<span id="cb87-348"><a href="#cb87-348" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-349"><a href="#cb87-349" aria-hidden="true" tabindex="-1"></a>其中Schaefer模型中$E_{MSY}=r/2q$ 时种群将衰竭，但对于参数 *p* 的其他值仍具有普遍性。也可以估计平衡渔获率（每年捕获的种群比例），从而得到$B_{MSY}$ ，即MSY*剩余*产量时的生物量：</span>
<span id="cb87-350"><a href="#cb87-350" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-351"><a href="#cb87-351" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb87-352"><a href="#cb87-352" aria-hidden="true" tabindex="-1"></a>H_{MSY}=qE_{MSY}=q\dfrac{r}{q+qp}= \dfrac{r}{1+p}</span>
<span id="cb87-353"><a href="#cb87-353" aria-hidden="true" tabindex="-1"></a>$$ {#eq-spm16}</span>
<span id="cb87-354"><a href="#cb87-354" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-355"><a href="#cb87-355" aria-hidden="true" tabindex="-1"></a>可以经常看到将<span class="co">[</span><span class="ot">@eq-spm16</span><span class="co">]</span> 写为 $F_{MSY}=qE_{MSY}$ ，但这可能会产生误导，因为通常将 $F_{MSY}$ 解释为瞬时捕捞死亡率，而在这种情况下，实际上是成比例的捕捞率。出于这个原因，我明确使用了$H_{MSY}$ 。</span>
<span id="cb87-356"><a href="#cb87-356" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-357"><a href="#cb87-357" aria-hidden="true" tabindex="-1"></a><span class="fu">### 均衡的麻烦</span></span>
<span id="cb87-358"><a href="#cb87-358" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-359"><a href="#cb87-359" aria-hidden="true" tabindex="-1"></a>现实世界中对管理目标的解释并不总是直截了当的。现在，人们认为大多数捕捞种群不可能达到平衡，因此，如果种群以最佳方式捕捞，MSY 的解释更像是平均的、长期的预期潜在产量；动态平衡可能是更好的描述。如果一直应用，$E_{MSY}$ 是到得MSY的努力量，但前提是种群生物量达到 $B_{MSY}$，即产生最大剩余产量的生物量。每种管理统计都源自均衡思想。显然，应当通过将努力量限制在 $E_{MSY}$ 处来管理渔业，但如果种群生物量开始严重枯竭，那么将不会产生平均长期产量。事实上，$E_{MSY}$ 努力量程度可能太高，无法在这个非平衡的世界中重建种群。同样地，但仅当种群生物量为 $B_{MSY}$ 的情况下， $H_{MSY}$ 将按预期运行。可以估计导致种群恢复到 $B_{MSY}$ 的渔获量或努力量水平，可以称之为 $F_{MSY}$ ，但这需要进行种群预测并寻找最终达到预期结果的渔获量水平。我们将在后面的章节中研究如何预测种群。</span>
<span id="cb87-360"><a href="#cb87-360" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-361"><a href="#cb87-361" aria-hidden="true" tabindex="-1"></a>需要强调的是，MSY观点及其相关统计是以平衡思想为基础的，在现实世界中是罕见的。充其量，动态平衡是可以实现的，但无论如何，使用这种平衡统计都存在风险。当首次提出时，大家者认为 𝑀𝑆𝑌 概念是管理渔业的合适目标。现在，尽管这一概念已作为渔业管理的总体目标纳入了一些国家渔业法案和法律，但更安全的做法是将 𝑀𝑆𝑌 作为捕捞死亡率（渔获量）的上限，是一个极限参考点，而不是目标参考点。</span>
<span id="cb87-362"><a href="#cb87-362" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-363"><a href="#cb87-363" aria-hidden="true" tabindex="-1"></a>理想情况下，评估结果需要通过捕捞控制规则（HCR）传递，该规则根据估计的种群状况（捕捞死亡率和种群枯竭水平）就未来渔获量或努力量提供正式的管理建议。然而，如果不对其数值的不确定性有所了解，这些潜在的管理产出中几乎没有价值。正如我们已经指出的那样，能够将这些模型预测到未来，以便对替代管理战略进行风险评估，也将非常有用。但首先，我们需要利用模型拟合数据。</span>
<span id="cb87-364"><a href="#cb87-364" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-365"><a href="#cb87-365" aria-hidden="true" tabindex="-1"></a><span class="fu">## 模型拟合</span></span>
<span id="cb87-366"><a href="#cb87-366" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-367"><a href="#cb87-367" aria-hidden="true" tabindex="-1"></a>模型参数和与模型相关的其他详细信息也可以在每个函数的帮助文件中找到（试着使用 <span class="in">`?spm`</span> 或 <span class="in">`simpspm`</span> ）。简而言之，模型参数 $r$ 为种群净增长率（综合了重量、补充和自然死亡率等方面的个体生长），$K$ 为种群环境容纳量或未捕捞时的生物量，$B_{init}$ 是第一年的生物量。只有当相对丰度数据指数（通常是 cpue）在渔业实施了几年后才可获得，这意味着种群已经在某种程度上枯竭时，才需要此参数。如果假设没有初始损耗，则参数列表中不需要 $B_{init}$ ，并且在函数中设置为等于 $K$ 。最后一个参数是 $\sigma$ ，即用于描述残差的对数正态分布的标准差。为了用最大似然法而编写了 <span class="in">`simpspm()`</span> 和 <span class="in">`spm()`</span> ，因此即使使用 <span class="in">`ssq()`</span> 作为最佳拟合标准，参数向量中也需要 $\sigma$ 值。</span>
<span id="cb87-368"><a href="#cb87-368" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-369"><a href="#cb87-369" aria-hidden="true" tabindex="-1"></a>在澳大利亚，相对种群丰度指数通常是单位努力量渔获量（cpue），但也可以是一些与渔业无关的丰度指数（例如，来自拖网调查、声学调查），或者在某一分析中都使用两者（见 <span class="in">`simspm()`</span>）。通过分析，可以提出持续管理的产量建议以及确定种群状况。</span>
<span id="cb87-370"><a href="#cb87-370" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-371"><a href="#cb87-371" aria-hidden="true" tabindex="-1"></a>在本节中，我们将详细介绍如何进行剩余产量分析、如何从分析中提取结果以及如何绘制这些结果的图解。</span>
<span id="cb87-372"><a href="#cb87-372" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-373"><a href="#cb87-373" aria-hidden="true" tabindex="-1"></a><span class="fu">### 种群评估的可能工作流程</span></span>
<span id="cb87-374"><a href="#cb87-374" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-375"><a href="#cb87-375" aria-hidden="true" tabindex="-1"></a>根据剩余产量模型进行种群评估时，可能的工作流程包括:</span>
<span id="cb87-376"><a href="#cb87-376" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-377"><a href="#cb87-377" aria-hidden="true" tabindex="-1"></a><span class="ss">1.  </span>读取渔获量和相对丰度数据的时间序列。拥有检查数据完整性、缺失值和其他潜在问题的功能会有所帮助，但最好还是了解自己的数据及其局限性。</span>
<span id="cb87-378"><a href="#cb87-378" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-379"><a href="#cb87-379" aria-hidden="true" tabindex="-1"></a><span class="ss">2.  </span>使用<span class="in">`ccf()`</span> 分析以确定 cpue 数据相对于渔获量数据是否具有参考价值。 如果发现明显的负相关关系，这将增强分析的防御力。</span>
<span id="cb87-380"><a href="#cb87-380" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-381"><a href="#cb87-381" aria-hidden="true" tabindex="-1"></a><span class="ss">3.  </span>定义/估计初始参数集，包括了$r$ 和 $K$ ，以及可选 $B_{init}=$ 初始生物量，如果怀疑渔业数据是在种群某种程度上消耗后才开始的，则使用该值。</span>
<span id="cb87-382"><a href="#cb87-382" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-383"><a href="#cb87-383" aria-hidden="true" tabindex="-1"></a><span class="ss">4.  </span>使用函数 <span class="in">`plotspmmod()`</span> 绘制假定的初始参数集对动力学的影响。这在寻找可信的初始参数集时非常有用。</span>
<span id="cb87-384"><a href="#cb87-384" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-385"><a href="#cb87-385" aria-hidden="true" tabindex="-1"></a><span class="ss">5.  </span>使用<span class="in">`nlm()`</span> 或 <span class="in">`fitSPM()`</span> 在输入可能可行的初始参数集后，搜索最佳参数。参见讨论。</span>
<span id="cb87-386"><a href="#cb87-386" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-387"><a href="#cb87-387" aria-hidden="true" tabindex="-1"></a><span class="ss">6.  </span>使用<span class="in">`plotspmmod()`</span> 用最佳参数来说明最佳模型及其相对拟合的影响（尤其是使用残差图）。</span>
<span id="cb87-388"><a href="#cb87-388" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-389"><a href="#cb87-389" aria-hidden="true" tabindex="-1"></a><span class="ss">7.  </span>理想情况下，应通过使用多个不同的初始参数集作为模型拟合过程的起点来检查模型拟合的鲁棒性，见 <span class="in">`robustSPM()`</span></span>
<span id="cb87-390"><a href="#cb87-390" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-391"><a href="#cb87-391" aria-hidden="true" tabindex="-1"></a><span class="ss">8.  </span>一旦对模型拟合的鲁棒性感到满意，就可以使用<span class="in">`spmphaseplot()`</span> 绘制出生物量与渔获率的相图，以便直观地确定和说明种群状况。</span>
<span id="cb87-392"><a href="#cb87-392" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-393"><a href="#cb87-393" aria-hidden="true" tabindex="-1"></a><span class="ss">9.  </span>使用 <span class="in">`spmboot()`</span>，用渐近标准误差或 *On Uncertainty* （第 <span class="co">[</span><span class="ot">-@sec-uncertainty</span><span class="co">]</span> 章）中的贝叶斯方法来描述模型拟合和输出中的不确定性。将此类输出制成表格并绘制成图表。请参阅稍后内容。</span>
<span id="cb87-394"><a href="#cb87-394" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-395"><a href="#cb87-395" aria-hidden="true" tabindex="-1"></a><span class="ss">10. </span>记录并捍卫得出的任何结论。</span>
<span id="cb87-396"><a href="#cb87-396" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-397"><a href="#cb87-397" aria-hidden="true" tabindex="-1"></a>目前 **MQMF** 有两种常见的动力模型：经典的 Schaefer 模型（Schaefer，1954）和近似的 Fox 模型（Fox，1970；Polacheck等，1993），Haddon（2011）对两种模型都有描述。Prager（1994）提供了许多其他形式的分析，这些分析可以使用剩余产量模型进行，Haddon（2011）也提供了实际应用。</span>
<span id="cb87-398"><a href="#cb87-398" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-401"><a href="#cb87-401" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-402"><a href="#cb87-402" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-spm5</span></span>
<span id="cb87-403"><a href="#cb87-403" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "使用初始参数值将剩余产量模型与 schaef 数据集的暂定拟合。CPUE 图中的绿色虚线是简单的loess 拟合，而实线是猜测的输入参数所隐含的拟合。渔获量图中的水平红线是预测的 MSY。残差图中的数字是对数正态残差的均方根误差。"</span></span>
<span id="cb87-404"><a href="#cb87-404" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-405"><a href="#cb87-405" aria-hidden="true" tabindex="-1"></a><span class="co"># Initial model 'fit' to the initial parameter guess  Fig 7.5</span></span>
<span id="cb87-406"><a href="#cb87-406" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(schaef)</span>
<span id="cb87-407"><a href="#cb87-407" aria-hidden="true" tabindex="-1"></a>schaef <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>(schaef)</span>
<span id="cb87-408"><a href="#cb87-408" aria-hidden="true" tabindex="-1"></a>param <span class="ot">&lt;-</span> <span class="fu">log</span>(<span class="fu">c</span>(<span class="at">r =</span> <span class="fl">0.1</span>, <span class="at">K =</span> <span class="dv">2250000</span>, <span class="at">Binit =</span> <span class="dv">2250000</span>, <span class="at">sigma =</span> <span class="fl">0.5</span>))</span>
<span id="cb87-409"><a href="#cb87-409" aria-hidden="true" tabindex="-1"></a>negatL <span class="ot">&lt;-</span> <span class="fu">negLL</span>(param, simpspm, schaef, <span class="at">logobs =</span> <span class="fu">log</span>(schaef[, <span class="st">"cpue"</span>]))</span>
<span id="cb87-410"><a href="#cb87-410" aria-hidden="true" tabindex="-1"></a>ans <span class="ot">&lt;-</span> <span class="fu">plotspmmod</span>(</span>
<span id="cb87-411"><a href="#cb87-411" aria-hidden="true" tabindex="-1"></a>    <span class="at">inp =</span> param, <span class="at">indat =</span> schaef, <span class="at">schaefer =</span> <span class="cn">TRUE</span>,</span>
<span id="cb87-412"><a href="#cb87-412" aria-hidden="true" tabindex="-1"></a>    <span class="at">addrmse =</span> <span class="cn">TRUE</span>, <span class="at">plotprod =</span> <span class="cn">FALSE</span></span>
<span id="cb87-413"><a href="#cb87-413" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb87-414"><a href="#cb87-414" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-415"><a href="#cb87-415" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-416"><a href="#cb87-416" aria-hidden="true" tabindex="-1"></a>$r= 0.1$ 时得到 $negatL= 8.2877$ ，并且在 1950 年之前所有残差都低于1.0，之后有 4 个较大的正残差。将 $K$ 值设置为最大渔获量的10倍左右，这一数量级（10倍到20倍）的生物量通常会得到足够的生物量，使种群生物量和CPUE轨迹偏离x轴，以便进入最小化/优化程序。我们使用了<span class="in">`plotprod = FALSE`</span> 选项（默认值），因为在用模型拟合数据之前，查看预测的产量曲线几乎没有意义。</span>
<span id="cb87-417"><a href="#cb87-417" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-418"><a href="#cb87-418" aria-hidden="true" tabindex="-1"></a>用数值方法拟合数据模型时，通常需要采取措施确保获得稳健的且生物学上合理的拟合模型。稳健性的一个方法是对模型拟合两次，第二次拟合的输入参数来自第一次拟合。我们将使用<span class="in">`optim()`</span> 和 <span class="in">`nlm()`</span>以及<span class="in">`negLL1()`</span> 的组合来估计每次迭代期间的负对数似然（这是<span class="in">`fitSPM()`</span>实现的方式）。在**MQMF**中，我们有一个函数 <span class="in">`spm()`</span> ，根据生物量、CPUE、消耗和渔获率的预测变化来计算所有的动态变化。虽然这样做相对较快，但为了加快迭代模型拟合过程，我们未使用<span class="in">`spm()`</span>，而是使用<span class="in">`simspm()`</span> ，仅输出预测的 CPUE 的对数，以便最小化，而不是每次都计算完整的动态。当我们只有相对丰度指数的单一时间序列时，我们使用<span class="in">`simspm()`</span> 。如果我们有多个指数序列，我们将使用 <span class="in">`simpsmpM()`</span> 、<span class="in">`spmCE()`</span> 以及<span class="in">`negLLM()`</span> ；参阅帮助文件（<span class="in">`?simpsmpM`</span>、<span class="in">`?spmCE`</span>、<span class="in">`?negLLM`</span> ）及其代码，查阅每个示例的运行情况。除了使用 <span class="in">`simpsmpM()`</span> 、<span class="in">`spmCE()`</span> 和 <span class="in">`negLLM()`</span> 外，对于多个时间序列的指数，它还用于说明模型拟合有时会产生生物学上难以置信的解决方案，便在数学上却是最优的解。以及第一个参数$r$ 施加惩罚，以防止其小于0.0，在多指数函数示例中使用了极端渔获量历史记录，根据起始参数，我们还需要对年渔获率进行惩罚，以确保其保持小于 1.0（见 <span class="in">`penalty1()`</span>）。从生物学角度看，渔获量显然不可能超过生物量，但如果我们不对模型进行数学限制，那么渔获率非常大在数学上也没有什么问题。</span>
<span id="cb87-419"><a href="#cb87-419" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-420"><a href="#cb87-420" aria-hidden="true" tabindex="-1"></a>随着我们所使用模型的复杂性增加，或者我们开始使用计算机密集型方法，对速度的考虑就变得更加重要。我们的参数都不应该变为负值，而且它们的大小差别很大，因此我们在这里使用的是自然对数转换的参数。</span>
<span id="cb87-421"><a href="#cb87-421" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-424"><a href="#cb87-424" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-425"><a href="#cb87-425" aria-hidden="true" tabindex="-1"></a><span class="co"># Fit the model first using optim then nlm in sequence</span></span>
<span id="cb87-426"><a href="#cb87-426" aria-hidden="true" tabindex="-1"></a>param <span class="ot">&lt;-</span> <span class="fu">log</span>(<span class="fu">c</span>(<span class="fl">0.1</span>, <span class="dv">2250000</span>, <span class="dv">2250000</span>, <span class="fl">0.5</span>))</span>
<span id="cb87-427"><a href="#cb87-427" aria-hidden="true" tabindex="-1"></a>pnams <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"r"</span>, <span class="st">"K"</span>, <span class="st">"Binit"</span>, <span class="st">"sigma"</span>)</span>
<span id="cb87-428"><a href="#cb87-428" aria-hidden="true" tabindex="-1"></a>best <span class="ot">&lt;-</span> <span class="fu">optim</span>(</span>
<span id="cb87-429"><a href="#cb87-429" aria-hidden="true" tabindex="-1"></a>    <span class="at">par =</span> param, <span class="at">fn =</span> negLL, <span class="at">funk =</span> simpspm, <span class="at">indat =</span> schaef,</span>
<span id="cb87-430"><a href="#cb87-430" aria-hidden="true" tabindex="-1"></a>    <span class="at">logobs =</span> <span class="fu">log</span>(schaef[, <span class="st">"cpue"</span>]), <span class="at">method =</span> <span class="st">"BFGS"</span></span>
<span id="cb87-431"><a href="#cb87-431" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb87-432"><a href="#cb87-432" aria-hidden="true" tabindex="-1"></a><span class="fu">outfit</span>(best, <span class="at">digits =</span> <span class="dv">4</span>, <span class="at">title =</span> <span class="st">"Optim"</span>, <span class="at">parnames =</span> pnams)</span>
<span id="cb87-433"><a href="#cb87-433" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)</span>
<span id="cb87-434"><a href="#cb87-434" aria-hidden="true" tabindex="-1"></a>best2 <span class="ot">&lt;-</span> <span class="fu">nlm</span>(negLL, best<span class="sc">$</span>par,</span>
<span id="cb87-435"><a href="#cb87-435" aria-hidden="true" tabindex="-1"></a>    <span class="at">funk =</span> simpspm, <span class="at">indat =</span> schaef,</span>
<span id="cb87-436"><a href="#cb87-436" aria-hidden="true" tabindex="-1"></a>    <span class="at">logobs =</span> <span class="fu">log</span>(schaef[, <span class="st">"cpue"</span>])</span>
<span id="cb87-437"><a href="#cb87-437" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb87-438"><a href="#cb87-438" aria-hidden="true" tabindex="-1"></a><span class="fu">outfit</span>(best2, <span class="at">digits =</span> <span class="dv">4</span>, <span class="at">title =</span> <span class="st">"nlm"</span>, <span class="at">parnames =</span> pnams)</span>
<span id="cb87-439"><a href="#cb87-439" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-440"><a href="#cb87-440" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-441"><a href="#cb87-441" aria-hidden="true" tabindex="-1"></a>数值优化程序两次应用的输出结果表明，我们不需要进行两次处理，但为了谨慎起见，还是不要太相信数值方法。无论如何都要进行单一模型拟合，但要自担风险（或许我不得不比许多人处理更多质量较差或一般的数据！）。</span>
<span id="cb87-442"><a href="#cb87-442" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-443"><a href="#cb87-443" aria-hidden="true" tabindex="-1"></a>现在，我们可以从 *best2* 拟合中获取最佳参数，并将其输入`plotspmmod()`函数中，可直观显示模型拟合结果。这样我们获得了最佳参数，因此可以通过将 *plotprod* 参数设置为 *TRUE* 来绘制包含生产力曲线。 `plotspmmod()` 的作用不仅仅是图示结果，还隐形返回一个大的列表对象，因此，如果我们想要它，就需要将其赋值给变量或对象（在本例中*为 ans*）。</span>
<span id="cb87-444"><a href="#cb87-444" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-447"><a href="#cb87-447" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-448"><a href="#cb87-448" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-spm6</span></span>
<span id="cb87-449"><a href="#cb87-449" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "根据 nlm() 最终拟合的最优参数，将剩余产量模型与 schaef 数据集进行拟合的摘要。在 CPUE 图中，绿色虚线为简单的黄土曲线拟合，红色实线为最优模型拟合。"</span></span>
<span id="cb87-450"><a href="#cb87-450" aria-hidden="true" tabindex="-1"></a><span class="co"># optimum fit. Defaults used in plotprod and schaefer Fig 7.6</span></span>
<span id="cb87-451"><a href="#cb87-451" aria-hidden="true" tabindex="-1"></a>ans <span class="ot">&lt;-</span> <span class="fu">plotspmmod</span>(</span>
<span id="cb87-452"><a href="#cb87-452" aria-hidden="true" tabindex="-1"></a>    <span class="at">inp =</span> best2<span class="sc">$</span>estimate, <span class="at">indat =</span> schaef, <span class="at">addrmse =</span> <span class="cn">TRUE</span>,</span>
<span id="cb87-453"><a href="#cb87-453" aria-hidden="true" tabindex="-1"></a>    <span class="at">plotprod =</span> <span class="cn">TRUE</span></span>
<span id="cb87-454"><a href="#cb87-454" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb87-455"><a href="#cb87-455" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-456"><a href="#cb87-456" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-457"><a href="#cb87-457" aria-hidden="true" tabindex="-1"></a><span class="in">`plotspmmod()`</span>返回的对象是包含结果集合的对象列表，包括最优参数、包含预测最优动态预测的矩阵 （*ans\$Dynamics\$outmat*）、产量曲线和大量汇总结果。一旦分配给工作环境中的特定对象，就可以快速提取这些对象以用于其他函数。在不使用 *max.level=1* 参数或将其设置为2的情况下尝试运行 <span class="in">`str()`</span> ，以查看更多详细信息。很多函数会生成大量信息丰富的对象，您应该熟悉探索这些对象，以确保了解不同分析中产生的结果。</span>
<span id="cb87-458"><a href="#cb87-458" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-461"><a href="#cb87-461" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-462"><a href="#cb87-462" aria-hidden="true" tabindex="-1"></a><span class="co"># the high-level structure of ans; try str(ans$Dynamics)</span></span>
<span id="cb87-463"><a href="#cb87-463" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(ans, <span class="at">width =</span> <span class="dv">65</span>, <span class="at">strict.width =</span> <span class="st">"cut"</span>, <span class="at">max.level =</span> <span class="dv">1</span>)</span>
<span id="cb87-464"><a href="#cb87-464" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-465"><a href="#cb87-465" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-466"><a href="#cb87-466" aria-hidden="true" tabindex="-1"></a>还有一些 **MQMF** 函数可以帮助提取此类结果或使用 <span class="in">`plotspmmod()`</span> 的结果（参见 <span class="in">`summspm()`</span> 和 <span class="in">`spmphaseplot()`</span> ），这就是为什么该函数包含参数 *plotout = TRUE，*因此不需要生成绘图。但是，在许多情况下，只需在高级对象（在本例中*为 ans*）中指向所需的对象即可。请注意，从生成的生产率曲线获得的 MSY 与从最优参数计算得出的 MSY 相差很小。这是因为生产力曲线是通过计算不同生物量水平向量的生产率数值得出的。因此，其分辨率受到用于生成生物量向量的步骤限制。其估计值将始终略小于参数派生值。</span>
<span id="cb87-467"><a href="#cb87-467" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-470"><a href="#cb87-470" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-471"><a href="#cb87-471" aria-hidden="true" tabindex="-1"></a><span class="co"># compare the parameteric MSY with the numerical MSY</span></span>
<span id="cb87-472"><a href="#cb87-472" aria-hidden="true" tabindex="-1"></a><span class="fu">round</span>(ans<span class="sc">$</span>Dynamics<span class="sc">$</span>sumout, <span class="dv">3</span>)</span>
<span id="cb87-473"><a href="#cb87-473" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"</span><span class="sc">\n</span><span class="st"> Productivity Statistics </span><span class="sc">\n</span><span class="st">"</span>)</span>
<span id="cb87-474"><a href="#cb87-474" aria-hidden="true" tabindex="-1"></a><span class="fu">summspm</span>(ans) <span class="co"># the q parameter needs more significantr digits</span></span>
<span id="cb87-475"><a href="#cb87-475" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-476"><a href="#cb87-476" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-477"><a href="#cb87-477" aria-hidden="true" tabindex="-1"></a>最后，为了简化此双模型拟合过程的未来使用，有一个 **MQMF** 函数 <span class="in">`fitSPM()`</span> 来实现该过程。您可以使用该函数（查看其代码等），也可以重复原始代码的内容，以方便使用。</span>
<span id="cb87-478"><a href="#cb87-478" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-479"><a href="#cb87-479" aria-hidden="true" tabindex="-1"></a><span class="fu">### 分析是否稳健？</span></span>
<span id="cb87-480"><a href="#cb87-480" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-481"><a href="#cb87-481" aria-hidden="true" tabindex="-1"></a>尽管我多次警告，但您可能想知道为什么我们要费力地对模型进行两次拟合，而第二次拟合的起点就是第一次拟合的最优估计值。我们应该始终记住，在拟合这些模型时，我们使用的是数值方法。这种方法并非万无一失，可能会发现错误的最小值。如果模型参数之间存在相互作用或相关性，那么稍有不同的组合就会导致非常相似的负对数似然值。最佳模型拟合在 cpue 时间序列的末尾仍显示出三个相对较大的残差，如 <span class="co">[</span><span class="ot">@fig-spm6</span><span class="co">]</span> 。这些残差没有表现出任何特定的模式，因此我们认为它们只代表不确定性，这应该让人怀疑模型拟合的好坏以及分析输出统计量的可靠性。我们可以通过检查初始模型参数对模型拟合的影响来检查模型拟合的稳健性。</span>
<span id="cb87-482"><a href="#cb87-482" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-483"><a href="#cb87-483" aria-hidden="true" tabindex="-1"></a>稳健性测试的一种实现使用 **MQMF** 函数 <span class="in">`robustSPM()`</span>。 该函数将生成 𝑁 个随机初始值，是通过将最佳对数刻度参数值作为某些正态随机变量的相应平均值，其各自的标准差值通过将这些均值除以*缩放器*参数值获得（有关完整详细信息，请参阅 `robustSPM()`代码和帮助）。`robustSPM()` 输出的对象包括 *N* 随机变化的初始参数值的向量，这允许说明和表征它们的变化。当然，作为除数，*标度值*越小，初始参数向量的可变性就越大，也就越容易导致模型拟合无法找到最小值。</span>
<span id="cb87-484"><a href="#cb87-484" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-487"><a href="#cb87-487" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-488"><a href="#cb87-488" aria-hidden="true" tabindex="-1"></a><span class="co"># conduct a robustness test on the Schaefer model fit</span></span>
<span id="cb87-489"><a href="#cb87-489" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(schaef)</span>
<span id="cb87-490"><a href="#cb87-490" aria-hidden="true" tabindex="-1"></a>schaef <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>(schaef)</span>
<span id="cb87-491"><a href="#cb87-491" aria-hidden="true" tabindex="-1"></a>reps <span class="ot">&lt;-</span> <span class="dv">12</span></span>
<span id="cb87-492"><a href="#cb87-492" aria-hidden="true" tabindex="-1"></a>param <span class="ot">&lt;-</span> <span class="fu">log</span>(<span class="fu">c</span>(<span class="at">r =</span> <span class="fl">0.15</span>, <span class="at">K =</span> <span class="dv">2250000</span>, <span class="at">Binit =</span> <span class="dv">2250000</span>, <span class="at">sigma =</span> <span class="fl">0.5</span>))</span>
<span id="cb87-493"><a href="#cb87-493" aria-hidden="true" tabindex="-1"></a>ansS <span class="ot">&lt;-</span> <span class="fu">fitSPM</span>(</span>
<span id="cb87-494"><a href="#cb87-494" aria-hidden="true" tabindex="-1"></a>    <span class="at">pars =</span> param, <span class="at">fish =</span> schaef, <span class="at">schaefer =</span> <span class="cn">TRUE</span>, <span class="co"># use</span></span>
<span id="cb87-495"><a href="#cb87-495" aria-hidden="true" tabindex="-1"></a>    <span class="at">maxiter =</span> <span class="dv">1000</span>, <span class="at">funk =</span> simpspm, <span class="at">funkone =</span> <span class="cn">FALSE</span></span>
<span id="cb87-496"><a href="#cb87-496" aria-hidden="true" tabindex="-1"></a>) <span class="co"># fitSPM</span></span>
<span id="cb87-497"><a href="#cb87-497" aria-hidden="true" tabindex="-1"></a><span class="co"># getseed() #generates random seed for repeatable results</span></span>
<span id="cb87-498"><a href="#cb87-498" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">777852</span>) <span class="co"># sets random number generator with a known seed</span></span>
<span id="cb87-499"><a href="#cb87-499" aria-hidden="true" tabindex="-1"></a>robout <span class="ot">&lt;-</span> <span class="fu">robustSPM</span>(</span>
<span id="cb87-500"><a href="#cb87-500" aria-hidden="true" tabindex="-1"></a>    <span class="at">inpar =</span> ansS<span class="sc">$</span>estimate, <span class="at">fish =</span> schaef, <span class="at">N =</span> reps,</span>
<span id="cb87-501"><a href="#cb87-501" aria-hidden="true" tabindex="-1"></a>    <span class="at">scaler =</span> <span class="dv">40</span>, <span class="at">verbose =</span> <span class="cn">FALSE</span>, <span class="at">schaefer =</span> <span class="cn">TRUE</span>,</span>
<span id="cb87-502"><a href="#cb87-502" aria-hidden="true" tabindex="-1"></a>    <span class="at">funk =</span> simpspm, <span class="at">funkone =</span> <span class="cn">FALSE</span></span>
<span id="cb87-503"><a href="#cb87-503" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb87-504"><a href="#cb87-504" aria-hidden="true" tabindex="-1"></a><span class="co"># use str(robout) to see the components included in the output</span></span>
<span id="cb87-505"><a href="#cb87-505" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-506"><a href="#cb87-506" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-509"><a href="#cb87-509" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-510"><a href="#cb87-510" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-spm2</span></span>
<span id="cb87-511"><a href="#cb87-511" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: "A robustness test of the fit to the schaef data-set. By examining the results object we can see the individual variation. The top columns relate to the initial parameters and the bottom columns, perhaps of more interest, to the model fits."</span></span>
<span id="cb87-512"><a href="#cb87-512" aria-hidden="true" tabindex="-1"></a><span class="co">#| layout-nrow: 2</span></span>
<span id="cb87-513"><a href="#cb87-513" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb87-514"><a href="#cb87-514" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-515"><a href="#cb87-515" aria-hidden="true" tabindex="-1"></a><span class="co"># robout$results |&gt;</span></span>
<span id="cb87-516"><a href="#cb87-516" aria-hidden="true" tabindex="-1"></a><span class="co">#   as.data.frame() |&gt;</span></span>
<span id="cb87-517"><a href="#cb87-517" aria-hidden="true" tabindex="-1"></a><span class="co">#   select(ir, iK, iBinit, isigma, iLike, r) |&gt;</span></span>
<span id="cb87-518"><a href="#cb87-518" aria-hidden="true" tabindex="-1"></a><span class="co">#   gt() |&gt;</span></span>
<span id="cb87-519"><a href="#cb87-519" aria-hidden="true" tabindex="-1"></a><span class="co">#   fmt_number(columns = c("ir", "isigma", "iLike", "r") , decimals = 3)</span></span>
<span id="cb87-520"><a href="#cb87-520" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-521"><a href="#cb87-521" aria-hidden="true" tabindex="-1"></a>res1 <span class="ot">&lt;-</span> robout<span class="sc">$</span>results <span class="sc">|&gt;</span></span>
<span id="cb87-522"><a href="#cb87-522" aria-hidden="true" tabindex="-1"></a>  <span class="fu">as.data.frame</span>() <span class="sc">|&gt;</span></span>
<span id="cb87-523"><a href="#cb87-523" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(ir, iK, iBinit, isigma, iLike, r) </span>
<span id="cb87-524"><a href="#cb87-524" aria-hidden="true" tabindex="-1"></a>res2 <span class="ot">&lt;-</span> robout<span class="sc">$</span>results <span class="sc">|&gt;</span></span>
<span id="cb87-525"><a href="#cb87-525" aria-hidden="true" tabindex="-1"></a>  <span class="fu">as.data.frame</span>() <span class="sc">|&gt;</span></span>
<span id="cb87-526"><a href="#cb87-526" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(<span class="sc">-</span>ir, <span class="sc">-</span>iK, <span class="sc">-</span>iBinit, <span class="sc">-</span>isigma, <span class="sc">-</span>iLike, <span class="sc">-</span>r)</span>
<span id="cb87-527"><a href="#cb87-527" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-528"><a href="#cb87-528" aria-hidden="true" tabindex="-1"></a><span class="fu">kable</span>(res1, <span class="at">digits =</span> <span class="dv">3</span>)</span>
<span id="cb87-529"><a href="#cb87-529" aria-hidden="true" tabindex="-1"></a><span class="fu">kable</span>(res2, <span class="at">digits =</span> <span class="dv">3</span>)</span>
<span id="cb87-530"><a href="#cb87-530" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-531"><a href="#cb87-531" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-532"><a href="#cb87-532" aria-hidden="true" tabindex="-1"></a>通过使用 *set.seed* 函数，用于生成分散初始参数向量的伪随机数的结果是可重复的。在 @tbl-spm2 中，我们可以看到，在 12 次试验中，我们得到了 12 个相同的最终负对数似然（精确到小数点后 5 位），尽管与实际的 $r$ 、$K$ 和 $B_{init}$ 略有不同，这导致估计的 MSY 值的微小变化。如果我们增加试验的次数，最终会发现一些试验结果与最佳结果略有不同。</span>
<span id="cb87-533"><a href="#cb87-533" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-534"><a href="#cb87-534" aria-hidden="true" tabindex="-1"></a>通常情况下，我们会尝试 12 次以上的试验，并检查标度参数的效果。因此，我们现在将使用相同的最佳拟合和随机种子重复该分析100次。<span class="in">`robustSPM()`</span>输出*结果*表按最终的 -ve 对数似然排序，但即使是相同的小数点后五位，也会发现参数估计值略有不同。这只是使用数值方法的反映。</span>
<span id="cb87-535"><a href="#cb87-535" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-538"><a href="#cb87-538" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-539"><a href="#cb87-539" aria-hidden="true" tabindex="-1"></a><span class="co"># Repeat robustness test on fit to schaef data 100 times</span></span>
<span id="cb87-540"><a href="#cb87-540" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">777854</span>)</span>
<span id="cb87-541"><a href="#cb87-541" aria-hidden="true" tabindex="-1"></a>robout2 <span class="ot">&lt;-</span> <span class="fu">robustSPM</span>(</span>
<span id="cb87-542"><a href="#cb87-542" aria-hidden="true" tabindex="-1"></a>    <span class="at">inpar =</span> ansS<span class="sc">$</span>estimate, <span class="at">fish =</span> schaef, <span class="at">N =</span> <span class="dv">100</span>,</span>
<span id="cb87-543"><a href="#cb87-543" aria-hidden="true" tabindex="-1"></a>    <span class="at">scaler =</span> <span class="dv">25</span>, <span class="at">verbose =</span> <span class="cn">FALSE</span>, <span class="at">schaefer =</span> <span class="cn">TRUE</span>,</span>
<span id="cb87-544"><a href="#cb87-544" aria-hidden="true" tabindex="-1"></a>    <span class="at">funk =</span> simpspm, <span class="at">funkone =</span> <span class="cn">TRUE</span>, <span class="at">steptol =</span> <span class="fl">1e-06</span></span>
<span id="cb87-545"><a href="#cb87-545" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb87-546"><a href="#cb87-546" aria-hidden="true" tabindex="-1"></a>lastbits <span class="ot">&lt;-</span> <span class="fu">tail</span>(robout2<span class="sc">$</span>results[, <span class="dv">6</span><span class="sc">:</span><span class="dv">11</span>], <span class="dv">10</span>)</span>
<span id="cb87-547"><a href="#cb87-547" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-548"><a href="#cb87-548" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-551"><a href="#cb87-551" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-552"><a href="#cb87-552" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-spm3</span></span>
<span id="cb87-553"><a href="#cb87-553" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: "The last 10 trials from the 100 illustrating that the last three trials deviated a little from the optimum negative log-likelihood of -7.93406."</span></span>
<span id="cb87-554"><a href="#cb87-554" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb87-555"><a href="#cb87-555" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-556"><a href="#cb87-556" aria-hidden="true" tabindex="-1"></a>lastbits <span class="sc">|&gt;</span></span>
<span id="cb87-557"><a href="#cb87-557" aria-hidden="true" tabindex="-1"></a>  <span class="fu">as.data.frame</span>() <span class="sc">|&gt;</span></span>
<span id="cb87-558"><a href="#cb87-558" aria-hidden="true" tabindex="-1"></a>  <span class="fu">gt</span>() <span class="sc">|&gt;</span></span>
<span id="cb87-559"><a href="#cb87-559" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmt_number</span>(<span class="at">columns =</span> <span class="fu">c</span>(<span class="st">"r"</span>, <span class="st">"sigma"</span>, <span class="st">"-veLL"</span>), <span class="at">decimals =</span> <span class="dv">3</span>)</span>
<span id="cb87-560"><a href="#cb87-560" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-561"><a href="#cb87-561" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-562"><a href="#cb87-562" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-563"><a href="#cb87-563" aria-hidden="true" tabindex="-1"></a>@tbl-spm3 只列出了排序后 100 个重复样本中的后 10 条记录，这表明所有重复样本的负对数似然值相同（精确到小数点后 5 位）。同样，如果仔细观察 $r$、 $K$、 $Binit$ 和 MSY 的值，就会发现它们之间的差异。如果我们将最终拟合的参数值用图显示，变化的标度就会很明显，如<span class="co">[</span><span class="ot">@fig-spm7</span><span class="co">]</span>。</span>
<span id="cb87-564"><a href="#cb87-564" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-567"><a href="#cb87-567" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-568"><a href="#cb87-568" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-spm7</span></span>
<span id="cb87-569"><a href="#cb87-569" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "对 schaef 数据集模型拟合的稳健性测试中 100 次试验的主要参数和 MSY 的直方图。参数估计值都很接近，但仍存在差异，这反映了估计的不确定性。为了改善这种情况，可以尝试使用较小的 steptol，默认值为 1e-06，但并不总是能得到稳定的解决方案。如果使用 steptol = 1e-07，整个变量的取值范围会变得更小，但仍会有一些微小的变化，这也是使用数值方法时的预期结果。这也是为什么参数估计的特定值在我们也有变化或不确定性估计值时最有意义的另一个原因。"</span></span>
<span id="cb87-570"><a href="#cb87-570" aria-hidden="true" tabindex="-1"></a><span class="co"># replicates from the robustness test        Fig 7.7</span></span>
<span id="cb87-571"><a href="#cb87-571" aria-hidden="true" tabindex="-1"></a>result <span class="ot">&lt;-</span> robout2<span class="sc">$</span>results</span>
<span id="cb87-572"><a href="#cb87-572" aria-hidden="true" tabindex="-1"></a><span class="fu">parset</span>(<span class="at">plots =</span> <span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">2</span>), <span class="at">margin =</span> <span class="fu">c</span>(<span class="fl">0.35</span>, <span class="fl">0.45</span>, <span class="fl">0.05</span>, <span class="fl">0.05</span>))</span>
<span id="cb87-573"><a href="#cb87-573" aria-hidden="true" tabindex="-1"></a><span class="fu">hist</span>(result[, <span class="st">"r"</span>], <span class="at">breaks =</span> <span class="dv">15</span>, <span class="at">col =</span> <span class="dv">2</span>, <span class="at">main =</span> <span class="st">""</span>, <span class="at">xlab =</span> <span class="st">"r"</span>)</span>
<span id="cb87-574"><a href="#cb87-574" aria-hidden="true" tabindex="-1"></a><span class="fu">hist</span>(result[, <span class="st">"K"</span>], <span class="at">breaks =</span> <span class="dv">15</span>, <span class="at">col =</span> <span class="dv">2</span>, <span class="at">main =</span> <span class="st">""</span>, <span class="at">xlab =</span> <span class="st">"K"</span>)</span>
<span id="cb87-575"><a href="#cb87-575" aria-hidden="true" tabindex="-1"></a><span class="fu">hist</span>(result[, <span class="st">"Binit"</span>], <span class="at">breaks =</span> <span class="dv">15</span>, <span class="at">col =</span> <span class="dv">2</span>, <span class="at">main =</span> <span class="st">""</span>, <span class="at">xlab =</span> <span class="st">"Binit"</span>)</span>
<span id="cb87-576"><a href="#cb87-576" aria-hidden="true" tabindex="-1"></a><span class="fu">hist</span>(result[, <span class="st">"MSY"</span>], <span class="at">breaks =</span> <span class="dv">15</span>, <span class="at">col =</span> <span class="dv">2</span>, <span class="at">main =</span> <span class="st">""</span>, <span class="at">xlab =</span> <span class="st">"MSY"</span>)</span>
<span id="cb87-577"><a href="#cb87-577" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-578"><a href="#cb87-578" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-579"><a href="#cb87-579" aria-hidden="true" tabindex="-1"></a>即使负对数似然值非常接近（精确到小数点后五位）（<span class="co">[</span><span class="ot">@fig-spm7</span><span class="co">]</span>），也可能与最常出现的最佳值略有偏差。这强调了仔细检查分析中的不确定性的必要性。鉴于大多数试验得出相同的最佳值，所有试验的中值可以确定最佳值。</span>
<span id="cb87-580"><a href="#cb87-580" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-581"><a href="#cb87-581" aria-hidden="true" tabindex="-1"></a>另一种可视化稳健性检验参数估计值最终变化的方法是使用 R 函数 <span class="in">`pairs()`</span> 绘制各参数与模型输出值的对比图，如 <span class="co">[</span><span class="ot">@fig-spm8</span><span class="co">]</span> 所示，该图说明了参数之间的强相关性。</span>
<span id="cb87-582"><a href="#cb87-582" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-585"><a href="#cb87-585" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-586"><a href="#cb87-586" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-spm8</span></span>
<span id="cb87-587"><a href="#cb87-587" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "100 个最优解决方案中参数之间的关系图，这些解源于将剩余产量模型拟合到 *schaef* 数据集。参数之间的相关性是显而易见的，尽管需要强调的是，估计值之间的比例差异非常小，约为0.2-0.3%。"</span></span>
<span id="cb87-588"><a href="#cb87-588" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-589"><a href="#cb87-589" aria-hidden="true" tabindex="-1"></a><span class="co"># robustSPM parameters against each other  Fig 7.8</span></span>
<span id="cb87-590"><a href="#cb87-590" aria-hidden="true" tabindex="-1"></a><span class="fu">pairs</span>(result[, <span class="fu">c</span>(<span class="st">"r"</span>, <span class="st">"K"</span>, <span class="st">"Binit"</span>, <span class="st">"MSY"</span>)], <span class="at">upper.panel =</span> <span class="cn">NULL</span>, <span class="at">pch =</span> <span class="dv">1</span>)</span>
<span id="cb87-591"><a href="#cb87-591" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-592"><a href="#cb87-592" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-593"><a href="#cb87-593" aria-hidden="true" tabindex="-1"></a><span class="fu">### 使用不同的数据？</span></span>
<span id="cb87-594"><a href="#cb87-594" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-595"><a href="#cb87-595" aria-hidden="true" tabindex="-1"></a>*schaef* 数据集得出的结果相对稳健。在继续分析之前，使用 *dataspm* 数据集进行重复分析会更有启发，因为该数据集的结果更多变。希望这些发现能鼓励今后的建模者阅读本文时，不要相信数值优化程序给出的第一个解决方案。</span>
<span id="cb87-596"><a href="#cb87-596" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-599"><a href="#cb87-599" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-600"><a href="#cb87-600" aria-hidden="true" tabindex="-1"></a><span class="co"># Now use the dataspm data-set, which is noisier</span></span>
<span id="cb87-601"><a href="#cb87-601" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">777854</span>) <span class="co"># other random seeds give different results</span></span>
<span id="cb87-602"><a href="#cb87-602" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(dataspm)</span>
<span id="cb87-603"><a href="#cb87-603" aria-hidden="true" tabindex="-1"></a>fish <span class="ot">&lt;-</span> dataspm <span class="co"># to generalize the code</span></span>
<span id="cb87-604"><a href="#cb87-604" aria-hidden="true" tabindex="-1"></a>param <span class="ot">&lt;-</span> <span class="fu">log</span>(<span class="fu">c</span>(<span class="at">r =</span> <span class="fl">0.24</span>, <span class="at">K =</span> <span class="dv">5174</span>, <span class="at">Binit =</span> <span class="dv">2846</span>, <span class="at">sigma =</span> <span class="fl">0.164</span>))</span>
<span id="cb87-605"><a href="#cb87-605" aria-hidden="true" tabindex="-1"></a>ans <span class="ot">&lt;-</span> <span class="fu">fitSPM</span>(</span>
<span id="cb87-606"><a href="#cb87-606" aria-hidden="true" tabindex="-1"></a>    <span class="at">pars =</span> param, <span class="at">fish =</span> fish, <span class="at">schaefer =</span> <span class="cn">TRUE</span>, <span class="at">maxiter =</span> <span class="dv">1000</span>,</span>
<span id="cb87-607"><a href="#cb87-607" aria-hidden="true" tabindex="-1"></a>    <span class="at">funkone =</span> <span class="cn">TRUE</span></span>
<span id="cb87-608"><a href="#cb87-608" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb87-609"><a href="#cb87-609" aria-hidden="true" tabindex="-1"></a>out <span class="ot">&lt;-</span> <span class="fu">robustSPM</span>(ans<span class="sc">$</span>estimate, fish,</span>
<span id="cb87-610"><a href="#cb87-610" aria-hidden="true" tabindex="-1"></a>    <span class="at">N =</span> <span class="dv">100</span>, <span class="at">scaler =</span> <span class="dv">15</span>, <span class="co"># making</span></span>
<span id="cb87-611"><a href="#cb87-611" aria-hidden="true" tabindex="-1"></a>    <span class="at">verbose =</span> <span class="cn">FALSE</span>, <span class="at">funkone =</span> <span class="cn">TRUE</span></span>
<span id="cb87-612"><a href="#cb87-612" aria-hidden="true" tabindex="-1"></a>) <span class="co"># scaler=10 gives</span></span>
<span id="cb87-613"><a href="#cb87-613" aria-hidden="true" tabindex="-1"></a>result <span class="ot">&lt;-</span> <span class="fu">tail</span>(out<span class="sc">$</span>results[, <span class="dv">6</span><span class="sc">:</span><span class="dv">11</span>], <span class="dv">10</span>) <span class="co"># 16 sub-optimal results</span></span>
<span id="cb87-614"><a href="#cb87-614" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-615"><a href="#cb87-615" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-618"><a href="#cb87-618" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-619"><a href="#cb87-619" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-spm4</span></span>
<span id="cb87-620"><a href="#cb87-620" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: "The last 10 trials from 100 used with dataspm. The last six trials deviate markedly from the optimum negative log-likelihood of -12.1288, and five gave consistent sub-optimal optima. Variation across parameter estimates with the optimum log-likelihood remained minor, but was large for the false optima."</span></span>
<span id="cb87-621"><a href="#cb87-621" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb87-622"><a href="#cb87-622" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-623"><a href="#cb87-623" aria-hidden="true" tabindex="-1"></a>result <span class="sc">|&gt;</span></span>
<span id="cb87-624"><a href="#cb87-624" aria-hidden="true" tabindex="-1"></a>  <span class="fu">as.data.frame</span>() <span class="sc">|&gt;</span> </span>
<span id="cb87-625"><a href="#cb87-625" aria-hidden="true" tabindex="-1"></a>  <span class="fu">gt</span>() <span class="sc">|&gt;</span></span>
<span id="cb87-626"><a href="#cb87-626" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmt_number</span>(<span class="at">decimals =</span> <span class="dv">3</span>)</span>
<span id="cb87-627"><a href="#cb87-627" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-628"><a href="#cb87-628" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-629"><a href="#cb87-629" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-630"><a href="#cb87-630" aria-hidden="true" tabindex="-1"></a>在与 *dataspm* 进行拟合的底部六个模型中，我们可以看到 $r$ 值非常大而 $K$ 值非常小的情况，以及 $K$ 值非常大而 $r$ 值非常小的情况，此外，在最后两行中，$r$ 和 $K$ 的值几乎是合理的，但 *Binit* 值却非常小。</span>
<span id="cb87-631"><a href="#cb87-631" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-632"><a href="#cb87-632" aria-hidden="true" tabindex="-1"></a><span class="fu">## 不确定性</span></span>
<span id="cb87-633"><a href="#cb87-633" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-634"><a href="#cb87-634" aria-hidden="true" tabindex="-1"></a>当我们测试一些模型拟合对初始条件的稳健性时，我们发现当拟合多个参数时，可以从略微不同的参数值中获得基本相同的数值拟合（达到给定的精度）。虽然这些值往往相差不大，但这一观察结果仍然证实，当使用数值方法估计一组参数时，特定参数值并不是唯一重要的结果。我们还需要知道这些估计的精确程度，我们需要知道与它们的估计相关的任何不确定性。有许多方法可以用来探索模型拟合中的不确定性。在这里，我们将使用 R 检查四个的实现：1）似然剖面，2）自举重采样，3） 渐近误差，以及 4）贝叶斯后验分布。</span>
<span id="cb87-635"><a href="#cb87-635" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-636"><a href="#cb87-636" aria-hidden="true" tabindex="-1"></a><span class="fu">### 似然剖面图</span></span>
<span id="cb87-637"><a href="#cb87-637" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-638"><a href="#cb87-638" aria-hidden="true" tabindex="-1"></a>似然剖面顾名思义，就是让人了解如果使用的参数稍有不同，模型拟合的质量会发生怎样的变化。使用最大似然法（最小化对数似然）对模型进行最佳拟合，然后在将一个或多个参数固定为预定值（保持不变）的同时，只对其余未固定的参数进行拟合。这样，在给定一个或多个参数固定值的情况下，就可以获得最佳拟合结果。因此，我们可以确定当所选参数在一系列不同值上保持固定时，模型拟合的总可能性将如何变化。通过一个实例，我们可以更清楚地了解这一过程。我们可以使用 abdat 数据集，该数据集对观测数据进行了合理拟合，但最优拟合的残差模式适中，最优解的最终梯度相对较大（尝试 <span class="in">`outfit(ans)`</span> 查看结果）。</span>
<span id="cb87-639"><a href="#cb87-639" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-642"><a href="#cb87-642" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-643"><a href="#cb87-643" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-spm9</span></span>
<span id="cb87-644"><a href="#cb87-644" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "描述最佳参数与 *abdat* 数据集拟合的汇总图。拟合和 cpue 数据之间的对数正态残差中的剩余模式如右下角所示。"</span></span>
<span id="cb87-645"><a href="#cb87-645" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-646"><a href="#cb87-646" aria-hidden="true" tabindex="-1"></a><span class="co"># Fig 7.9 Fit of optimum to the abdat data-set</span></span>
<span id="cb87-647"><a href="#cb87-647" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(abdat)</span>
<span id="cb87-648"><a href="#cb87-648" aria-hidden="true" tabindex="-1"></a>fish <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>(abdat)</span>
<span id="cb87-649"><a href="#cb87-649" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(fish) <span class="ot">&lt;-</span> <span class="fu">tolower</span>(<span class="fu">colnames</span>(fish)) <span class="co"># just in case</span></span>
<span id="cb87-650"><a href="#cb87-650" aria-hidden="true" tabindex="-1"></a>pars <span class="ot">&lt;-</span> <span class="fu">log</span>(<span class="fu">c</span>(<span class="at">r =</span> <span class="fl">0.4</span>, <span class="at">K =</span> <span class="dv">9400</span>, <span class="at">Binit =</span> <span class="dv">3400</span>, <span class="at">sigma =</span> <span class="fl">0.05</span>))</span>
<span id="cb87-651"><a href="#cb87-651" aria-hidden="true" tabindex="-1"></a>ans <span class="ot">&lt;-</span> <span class="fu">fitSPM</span>(pars, fish, <span class="at">schaefer =</span> <span class="cn">TRUE</span>) <span class="co"># Schaefer</span></span>
<span id="cb87-652"><a href="#cb87-652" aria-hidden="true" tabindex="-1"></a>answer <span class="ot">&lt;-</span> <span class="fu">plotspmmod</span>(ans<span class="sc">$</span>estimate, abdat, <span class="at">schaefer =</span> <span class="cn">TRUE</span>, <span class="at">addrmse =</span> <span class="cn">TRUE</span>)</span>
<span id="cb87-653"><a href="#cb87-653" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-654"><a href="#cb87-654" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-655"><a href="#cb87-655" aria-hidden="true" tabindex="-1"></a>在 *“不确定性”* 一章中，我们研究了围绕单个参数的似然剖面，在这里我们将更深入地探讨与似然剖面的使用相关的一些问题。我们已经有了对 *abdat* 数据集的最佳拟合，可以以此为起点。反过来，如果我们考虑 𝑟 和 𝐾 参数时，编写一个简单的函数拟合每种情形下的剖面会更有效，以避免代码重复。和以前一样，我们使用 `negLLP()` 函数固定某些参数，同时改变其他参数。如 “*不确定性”* 一章所述，对于一个参数，95% 的置信边界的近似值为一个自由度的最小对数似然加上一个自由度 （=1.92） 的卡方值一半的参数范围。</span>
<span id="cb87-656"><a href="#cb87-656" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-657"><a href="#cb87-657" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb87-658"><a href="#cb87-658" aria-hidden="true" tabindex="-1"></a>min(-LL) + \dfrac{\chi_{1,1-\alpha}^2}{2}</span>
<span id="cb87-659"><a href="#cb87-659" aria-hidden="true" tabindex="-1"></a>$$ {#eq-spm17}</span>
<span id="cb87-660"><a href="#cb87-660" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-661"><a href="#cb87-661" aria-hidden="true" tabindex="-1"></a>在绘制每个剖面时，我们可以包括这个阈值，以查看它与似然剖面相交的位置，<span class="co">[</span><span class="ot">@fig-spm10</span><span class="co">]</span>。</span>
<span id="cb87-662"><a href="#cb87-662" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-665"><a href="#cb87-665" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-666"><a href="#cb87-666" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-spm10</span></span>
<span id="cb87-667"><a href="#cb87-667" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Schaefer 模型的 r 和 K 参数的似然分布与 abdat 数据集拟合。水平红线将最小 -veLL 与界定 95% 置信区间的似然值分开。垂直绿线与最小值和 95% CI 相交。这些数字是围绕平均最佳值的 95% 置信区间。"</span></span>
<span id="cb87-668"><a href="#cb87-668" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-669"><a href="#cb87-669" aria-hidden="true" tabindex="-1"></a><span class="co"># likelihood profiles for r and K for fit to abdat  Fig 7.10</span></span>
<span id="cb87-670"><a href="#cb87-670" aria-hidden="true" tabindex="-1"></a><span class="co"># doprofile input terms are vector of values, fixed parameter</span></span>
<span id="cb87-671"><a href="#cb87-671" aria-hidden="true" tabindex="-1"></a><span class="co"># location, starting parameters, and free parameter locations.</span></span>
<span id="cb87-672"><a href="#cb87-672" aria-hidden="true" tabindex="-1"></a><span class="co"># all other input are assumed to be in the calling environment</span></span>
<span id="cb87-673"><a href="#cb87-673" aria-hidden="true" tabindex="-1"></a>doprofile <span class="ot">&lt;-</span> <span class="cf">function</span>(val, loc, startest, indat, <span class="at">notfix =</span> <span class="fu">c</span>(<span class="dv">2</span><span class="sc">:</span><span class="dv">4</span>)) {</span>
<span id="cb87-674"><a href="#cb87-674" aria-hidden="true" tabindex="-1"></a>    pname <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"r"</span>, <span class="st">"K"</span>, <span class="st">"Binit"</span>, <span class="st">"sigma"</span>, <span class="st">"-veLL"</span>)</span>
<span id="cb87-675"><a href="#cb87-675" aria-hidden="true" tabindex="-1"></a>    numv <span class="ot">&lt;-</span> <span class="fu">length</span>(val)</span>
<span id="cb87-676"><a href="#cb87-676" aria-hidden="true" tabindex="-1"></a>    outpar <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="at">nrow =</span> numv, <span class="at">ncol =</span> <span class="dv">5</span>, <span class="at">dimnames =</span> <span class="fu">list</span>(val, pname))</span>
<span id="cb87-677"><a href="#cb87-677" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>numv) { <span class="co">#</span></span>
<span id="cb87-678"><a href="#cb87-678" aria-hidden="true" tabindex="-1"></a>        param <span class="ot">&lt;-</span> <span class="fu">log</span>(startest) <span class="co"># reset the parameters</span></span>
<span id="cb87-679"><a href="#cb87-679" aria-hidden="true" tabindex="-1"></a>        param[loc] <span class="ot">&lt;-</span> <span class="fu">log</span>(val[i]) <span class="co"># insert new fixed value</span></span>
<span id="cb87-680"><a href="#cb87-680" aria-hidden="true" tabindex="-1"></a>        parinit <span class="ot">&lt;-</span> param <span class="co"># copy revised parameter vector</span></span>
<span id="cb87-681"><a href="#cb87-681" aria-hidden="true" tabindex="-1"></a>        bestmod <span class="ot">&lt;-</span> <span class="fu">nlm</span>(</span>
<span id="cb87-682"><a href="#cb87-682" aria-hidden="true" tabindex="-1"></a>            <span class="at">f =</span> negLLP, <span class="at">p =</span> param, <span class="at">funk =</span> simpspm, <span class="at">initpar =</span> parinit,</span>
<span id="cb87-683"><a href="#cb87-683" aria-hidden="true" tabindex="-1"></a>            <span class="at">indat =</span> indat, <span class="at">logobs =</span> <span class="fu">log</span>(indat[, <span class="st">"cpue"</span>]),</span>
<span id="cb87-684"><a href="#cb87-684" aria-hidden="true" tabindex="-1"></a>            <span class="at">notfixed =</span> notfix</span>
<span id="cb87-685"><a href="#cb87-685" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb87-686"><a href="#cb87-686" aria-hidden="true" tabindex="-1"></a>        outpar[i, ] <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">exp</span>(bestmod<span class="sc">$</span>estimate), bestmod<span class="sc">$</span>minimum)</span>
<span id="cb87-687"><a href="#cb87-687" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb87-688"><a href="#cb87-688" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span>(outpar)</span>
<span id="cb87-689"><a href="#cb87-689" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb87-690"><a href="#cb87-690" aria-hidden="true" tabindex="-1"></a>rval <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="fl">0.32</span>, <span class="fl">0.46</span>, <span class="fl">0.001</span>)</span>
<span id="cb87-691"><a href="#cb87-691" aria-hidden="true" tabindex="-1"></a>outr <span class="ot">&lt;-</span> <span class="fu">doprofile</span>(rval,</span>
<span id="cb87-692"><a href="#cb87-692" aria-hidden="true" tabindex="-1"></a>    <span class="at">loc =</span> <span class="dv">1</span>, <span class="at">startest =</span> <span class="fu">c</span>(rval[<span class="dv">1</span>], <span class="dv">11500</span>, <span class="dv">5000</span>, <span class="fl">0.25</span>),</span>
<span id="cb87-693"><a href="#cb87-693" aria-hidden="true" tabindex="-1"></a>    <span class="at">indat =</span> fish, <span class="at">notfix =</span> <span class="fu">c</span>(<span class="dv">2</span><span class="sc">:</span><span class="dv">4</span>)</span>
<span id="cb87-694"><a href="#cb87-694" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb87-695"><a href="#cb87-695" aria-hidden="true" tabindex="-1"></a>Kval <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="dv">7200</span>, <span class="dv">11500</span>, <span class="dv">200</span>)</span>
<span id="cb87-696"><a href="#cb87-696" aria-hidden="true" tabindex="-1"></a>outk <span class="ot">&lt;-</span> <span class="fu">doprofile</span>(Kval,</span>
<span id="cb87-697"><a href="#cb87-697" aria-hidden="true" tabindex="-1"></a>    <span class="at">loc =</span> <span class="dv">2</span>, <span class="fu">c</span>(<span class="fl">0.4</span>, <span class="dv">7200</span>, <span class="dv">6500</span>, <span class="fl">0.3</span>), <span class="at">indat =</span> fish,</span>
<span id="cb87-698"><a href="#cb87-698" aria-hidden="true" tabindex="-1"></a>    <span class="at">notfix =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">4</span>)</span>
<span id="cb87-699"><a href="#cb87-699" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb87-700"><a href="#cb87-700" aria-hidden="true" tabindex="-1"></a><span class="fu">parset</span>(<span class="at">plots =</span> <span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">1</span>), <span class="at">cex =</span> <span class="fl">0.85</span>, <span class="at">outmargin =</span> <span class="fu">c</span>(<span class="fl">0.5</span>, <span class="fl">0.5</span>, <span class="dv">0</span>, <span class="dv">0</span>))</span>
<span id="cb87-701"><a href="#cb87-701" aria-hidden="true" tabindex="-1"></a><span class="fu">plotprofile</span>(outr, <span class="at">var =</span> <span class="st">"r"</span>, <span class="at">defpar =</span> <span class="cn">FALSE</span>, <span class="at">lwd =</span> <span class="dv">2</span>) <span class="co"># MQMF function</span></span>
<span id="cb87-702"><a href="#cb87-702" aria-hidden="true" tabindex="-1"></a><span class="fu">plotprofile</span>(outk, <span class="at">var =</span> <span class="st">"K"</span>, <span class="at">defpar =</span> <span class="cn">FALSE</span>, <span class="at">lwd =</span> <span class="dv">2</span>)</span>
<span id="cb87-703"><a href="#cb87-703" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-704"><a href="#cb87-704" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-705"><a href="#cb87-705" aria-hidden="true" tabindex="-1"></a>估计这种置信度边界的一个问题是，如果只考虑单个参数，就会忽略参数之间的相互关系和相关性，而 Schaefer 模型对此是众所周知的。但是，$r$ 和 $K$ 参数之间的强相关性意味着，通过组合沿 $r$ 和 $K$ 的两个单独的单独搜索而获得的方形网格搜索将导致许多组合甚至超出模型的近似拟合范围。创建二维似然剖面（实际上是曲面）或跨更多参数的剖面并非不可能，但即使是两个参数，通常也需要一次仔细搜索曲面的一小部分，或者以其他方式处理一些极差的模型拟合，这些拟合将通过简单的网格搜索获得。</span>
<span id="cb87-706"><a href="#cb87-706" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-707"><a href="#cb87-707" aria-hidden="true" tabindex="-1"></a>在资源评估具有一个或多个固定值参数的情况下，跨单个参数的似然分布仍然有用。在 Schaefer 剩余产量模型等简单模型中不会发生这种情况，但在处理更复杂的种群评估模型时，这种情况并不少见，因为生物参数，如自然死亡率、种群招募曲线的陡峭程度，甚至生长参数可能未知或假定其值与相关物种相同。在评估中获得最佳模型拟合后，其中某些参数采用固定值，就可以重新运行模型拟合，同时更改其中一个固定参数的假设值，以生成该参数的似然剖面。这样，就可以看出模型拟合与固定参数的假设值的一致性。以这种方式生成似然剖面比仅仅进行敏感性分析更可取，在敏感性分析中，我们可以将这些固定参数更改为高于假设值的水平和低于假设值的水平，以查看效果。似然剖面提供了对建模对各个参数的敏感性的更详细的探索。</span>
<span id="cb87-708"><a href="#cb87-708" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-709"><a href="#cb87-709" aria-hidden="true" tabindex="-1"></a>对于更简单的模型，例如我们在这里处理的模型，还有其他方法可以检查建模中固有的不确定性，这些方法可以尝试考虑参数之间的相关性。</span>
<span id="cb87-710"><a href="#cb87-710" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-711"><a href="#cb87-711" aria-hidden="true" tabindex="-1"></a><span class="fu">### Bootstrap 置信区间</span></span>
<span id="cb87-712"><a href="#cb87-712" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-713"><a href="#cb87-713" aria-hidden="true" tabindex="-1"></a>表征模型拟合不确定性的一种方法是通过对与 cpue 相关的对数正态残差进行自举取样，生成新的 bootstrap cpue 样本来替换原始 cpue 时间序列，从而围绕参数和模型输出（*MSY* 等）生成百分位数置信区间（Haddon，2011）。每次制作这样的自举样本时，都会重新拟合模型并存储解决方案以供进一步分析。要对剩余产量模型进行这样的分析，可以使用 **MQMF** 函数 `spmboot()`。一旦我们找到了合适的起始参数，我们就可以使用函数 `fitSPM()` 来获得最佳拟合，并且引导的是与该最佳拟合相关的对数正态残差。在这里，我们将使用噪声相对较大的 *dataspm* 数据集来说明这些观点</span>
<span id="cb87-714"><a href="#cb87-714" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-717"><a href="#cb87-717" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-718"><a href="#cb87-718" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-spm11</span></span>
<span id="cb87-719"><a href="#cb87-719" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "描述最佳参数与 *dataspm* 数据集拟合的汇总图。拟合和 cpue 数据之间的对数正态残差如右下角所示。这些是自举的，每个自举样本乘以最佳预测的 cpue 时间序列，以获得每个自举 cpue 时间序列。"</span></span>
<span id="cb87-720"><a href="#cb87-720" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-721"><a href="#cb87-721" aria-hidden="true" tabindex="-1"></a> <span class="co">#find optimum Schaefer model fit to dataspm data-set Fig 7.11  </span></span>
<span id="cb87-722"><a href="#cb87-722" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(dataspm)  </span>
<span id="cb87-723"><a href="#cb87-723" aria-hidden="true" tabindex="-1"></a>fish <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>(dataspm)  </span>
<span id="cb87-724"><a href="#cb87-724" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(fish) <span class="ot">&lt;-</span> <span class="fu">tolower</span>(<span class="fu">colnames</span>(fish))  </span>
<span id="cb87-725"><a href="#cb87-725" aria-hidden="true" tabindex="-1"></a>pars <span class="ot">&lt;-</span> <span class="fu">log</span>(<span class="fu">c</span>(<span class="at">r=</span><span class="fl">0.25</span>,<span class="at">K=</span><span class="dv">5500</span>,<span class="at">Binit=</span><span class="dv">3000</span>,<span class="at">sigma=</span><span class="fl">0.25</span>))  </span>
<span id="cb87-726"><a href="#cb87-726" aria-hidden="true" tabindex="-1"></a>ans <span class="ot">&lt;-</span> <span class="fu">fitSPM</span>(pars,fish,<span class="at">schaefer=</span><span class="cn">TRUE</span>,<span class="at">maxiter=</span><span class="dv">1000</span>) <span class="co">#Schaefer  </span></span>
<span id="cb87-727"><a href="#cb87-727" aria-hidden="true" tabindex="-1"></a>answer <span class="ot">&lt;-</span> <span class="fu">plotspmmod</span>(ans<span class="sc">$</span>estimate,fish,<span class="at">schaefer=</span><span class="cn">TRUE</span>,<span class="at">addrmse=</span><span class="cn">TRUE</span>)  </span>
<span id="cb87-728"><a href="#cb87-728" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-729"><a href="#cb87-729" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-730"><a href="#cb87-730" aria-hidden="true" tabindex="-1"></a>一旦我们获得了最佳拟合，我们就可以继续进行 bootstrap 分析。通常会运行至少 1000 次重复，甚至更多，即使这可能需要几分钟才能完成。在这种情况下，即使在最佳拟合状态下，对数正态残差中也存在模式，这表明模型结构缺少一些影响渔业的近似周期性事件。</span>
<span id="cb87-731"><a href="#cb87-731" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-734"><a href="#cb87-734" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-735"><a href="#cb87-735" aria-hidden="true" tabindex="-1"></a><span class="co">#bootstrap the log-normal residuals from optimum model fit  </span></span>
<span id="cb87-736"><a href="#cb87-736" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">210368</span>)  </span>
<span id="cb87-737"><a href="#cb87-737" aria-hidden="true" tabindex="-1"></a>reps <span class="ot">&lt;-</span> <span class="dv">1000</span> <span class="co"># can take 10 sec on a large Desktop. Be patient  </span></span>
<span id="cb87-738"><a href="#cb87-738" aria-hidden="true" tabindex="-1"></a> <span class="co">#startime &lt;- Sys.time()  # schaefer=TRUE is the default  </span></span>
<span id="cb87-739"><a href="#cb87-739" aria-hidden="true" tabindex="-1"></a>boots <span class="ot">&lt;-</span> <span class="fu">spmboot</span>(ans<span class="sc">$</span>estimate,<span class="at">fishery=</span>fish,<span class="at">iter=</span>reps)  </span>
<span id="cb87-740"><a href="#cb87-740" aria-hidden="true" tabindex="-1"></a> <span class="co">#print(Sys.time() - startime) # how long did it take?  </span></span>
<span id="cb87-741"><a href="#cb87-741" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(boots,<span class="at">max.level=</span><span class="dv">1</span>)  </span>
<span id="cb87-742"><a href="#cb87-742" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-743"><a href="#cb87-743" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-744"><a href="#cb87-744" aria-hidden="true" tabindex="-1"></a>输出结果包含每个运行的动态预测模型生物量、每个自举样本的 cpue、每个自举样本的预测 cpue、耗竭时间序列和年收获率时间序列（存储 5 个变量的 31 年运行 $reps=1000$ 次）。每项分析都可用于说明和总结分析结果和不确定性。鉴于 @fig-spm11 中的残差相对较大，可以预计不确定性相对较高，见 @tbl-spm5 。</span>
<span id="cb87-745"><a href="#cb87-745" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-748"><a href="#cb87-748" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-749"><a href="#cb87-749" aria-hidden="true" tabindex="-1"></a>  <span class="co">#Summarize bootstrapped parameter estimates as quantiles  Table 7.6 </span></span>
<span id="cb87-750"><a href="#cb87-750" aria-hidden="true" tabindex="-1"></a>bootpar <span class="ot">&lt;-</span> boots<span class="sc">$</span>bootpar  </span>
<span id="cb87-751"><a href="#cb87-751" aria-hidden="true" tabindex="-1"></a>rows <span class="ot">&lt;-</span> <span class="fu">colnames</span>(bootpar)  </span>
<span id="cb87-752"><a href="#cb87-752" aria-hidden="true" tabindex="-1"></a>columns <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">c</span>(<span class="fl">0.025</span>,<span class="fl">0.05</span>,<span class="fl">0.5</span>,<span class="fl">0.95</span>,<span class="fl">0.975</span>),<span class="st">"Mean"</span>)  </span>
<span id="cb87-753"><a href="#cb87-753" aria-hidden="true" tabindex="-1"></a>bootCI <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>,<span class="at">nrow=</span><span class="fu">length</span>(rows),<span class="at">ncol=</span><span class="fu">length</span>(columns),  </span>
<span id="cb87-754"><a href="#cb87-754" aria-hidden="true" tabindex="-1"></a>                 <span class="at">dimnames=</span><span class="fu">list</span>(rows,columns))  </span>
<span id="cb87-755"><a href="#cb87-755" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(rows)) {  </span>
<span id="cb87-756"><a href="#cb87-756" aria-hidden="true" tabindex="-1"></a>   tmp <span class="ot">&lt;-</span> bootpar[,i]  </span>
<span id="cb87-757"><a href="#cb87-757" aria-hidden="true" tabindex="-1"></a>   qtil <span class="ot">&lt;-</span> <span class="fu">quantile</span>(tmp,<span class="at">probs=</span><span class="fu">c</span>(<span class="fl">0.025</span>,<span class="fl">0.05</span>,<span class="fl">0.5</span>,<span class="fl">0.95</span>,<span class="fl">0.975</span>),<span class="at">na.rm=</span><span class="cn">TRUE</span>)  </span>
<span id="cb87-758"><a href="#cb87-758" aria-hidden="true" tabindex="-1"></a>   bootCI[i,] <span class="ot">&lt;-</span> <span class="fu">c</span>(qtil,<span class="fu">mean</span>(tmp,<span class="at">na.rm=</span><span class="cn">TRUE</span>))  </span>
<span id="cb87-759"><a href="#cb87-759" aria-hidden="true" tabindex="-1"></a>}  </span>
<span id="cb87-760"><a href="#cb87-760" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-761"><a href="#cb87-761" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-764"><a href="#cb87-764" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-765"><a href="#cb87-765" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-spm5</span></span>
<span id="cb87-766"><a href="#cb87-766" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: "The quantiles for the Schaefer model parameters and some model outputs, plus the arithmetic mean. The 0.5 values are the median values."</span></span>
<span id="cb87-767"><a href="#cb87-767" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb87-768"><a href="#cb87-768" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-769"><a href="#cb87-769" aria-hidden="true" tabindex="-1"></a><span class="co"># bootCI |&gt;</span></span>
<span id="cb87-770"><a href="#cb87-770" aria-hidden="true" tabindex="-1"></a><span class="co">#   as_tibble() |&gt;</span></span>
<span id="cb87-771"><a href="#cb87-771" aria-hidden="true" tabindex="-1"></a><span class="co">#   gt() |&gt;</span></span>
<span id="cb87-772"><a href="#cb87-772" aria-hidden="true" tabindex="-1"></a><span class="co">#   fmt_number(decimals = 3)</span></span>
<span id="cb87-773"><a href="#cb87-773" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-774"><a href="#cb87-774" aria-hidden="true" tabindex="-1"></a>knitr<span class="sc">::</span><span class="fu">kable</span>(bootCI, <span class="at">digits =</span> <span class="dv">3</span>)</span>
<span id="cb87-775"><a href="#cb87-775" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-776"><a href="#cb87-776" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-777"><a href="#cb87-777" aria-hidden="true" tabindex="-1"></a>可以使用直方图可视化此类百分位置信区间，并包括相应的选定百分位置信区间。</span>
<span id="cb87-778"><a href="#cb87-778" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-779"><a href="#cb87-779" aria-hidden="true" tabindex="-1"></a>人们期望 1000 次重复将提供平滑的响应和具有代表性的置信范围，但有时，尤其是在嘈杂的数据中，需要更多的重复才能获得不确定性的平滑表示。2000 次重复需要 20 秒可能看起来很长，但考虑到这样的事情过去需要数小时甚至数天，大约 20 秒是了不起的。请注意，置信边界在均值或中位数估计值附近不一定是对称的。另请注意，在最后一年的消耗估计中，第 5 个百分位的置信区间远高于 $0.2B_0$，这意味着即使这种分析是不确定的，目前的消耗水平也高于大多数地方使用的生物量消耗的默认极限参考点，可能性超过 95%。我们需要中央第 80 个百分位数才能找到下限 10%，但它必然高于第 5 个百分位数。$K$ 和 $Binit$ 值所显示的中位数和均值比其他参数和模型输出的差异更大，这表明存在一些偏差证据（@fig-spm12） 。由于某些图仍然存在粗糙度，因此可以通过增加重复次数来改善粗糙度。</span>
<span id="cb87-780"><a href="#cb87-780" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-783"><a href="#cb87-783" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-784"><a href="#cb87-784" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-spm12</span></span>
<span id="cb87-785"><a href="#cb87-785" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "The 1000 bootstrap replicates from the optimum spm fit to the dataspm data-set. The vertical lines, in each case, are the median and 90th percentile confidence intervals and the dashed vertical blue lines are the mean values. The function uphist() is used to expand the x-axis in K, Binit, and MSY."</span></span>
<span id="cb87-786"><a href="#cb87-786" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-787"><a href="#cb87-787" aria-hidden="true" tabindex="-1"></a><span class="co">#boostrap CI. Note use of uphist to expand scale  Fig 7.12 </span></span>
<span id="cb87-788"><a href="#cb87-788" aria-hidden="true" tabindex="-1"></a>{colf <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">4</span>); lwdf <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">3</span>); ltyf <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>)  </span>
<span id="cb87-789"><a href="#cb87-789" aria-hidden="true" tabindex="-1"></a>colsf <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">6</span>)</span>
<span id="cb87-790"><a href="#cb87-790" aria-hidden="true" tabindex="-1"></a><span class="fu">parset</span>(<span class="at">plots=</span><span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">2</span>))  </span>
<span id="cb87-791"><a href="#cb87-791" aria-hidden="true" tabindex="-1"></a><span class="fu">hist</span>(bootpar[,<span class="st">"r"</span>],<span class="at">breaks=</span><span class="dv">25</span>,<span class="at">main=</span><span class="st">""</span>,<span class="at">xlab=</span><span class="st">"r"</span>)  </span>
<span id="cb87-792"><a href="#cb87-792" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span><span class="fu">c</span>(bootCI[<span class="st">"r"</span>,colsf]),<span class="at">col=</span>colf,<span class="at">lwd=</span>lwdf,<span class="at">lty=</span>ltyf)  </span>
<span id="cb87-793"><a href="#cb87-793" aria-hidden="true" tabindex="-1"></a><span class="fu">uphist</span>(bootpar[,<span class="st">"K"</span>],<span class="at">maxval=</span><span class="dv">14000</span>,<span class="at">breaks=</span><span class="dv">25</span>,<span class="at">main=</span><span class="st">""</span>,<span class="at">xlab=</span><span class="st">"K"</span>)  </span>
<span id="cb87-794"><a href="#cb87-794" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span><span class="fu">c</span>(bootCI[<span class="st">"K"</span>,colsf]),<span class="at">col=</span>colf,<span class="at">lwd=</span>lwdf,<span class="at">lty=</span>ltyf)  </span>
<span id="cb87-795"><a href="#cb87-795" aria-hidden="true" tabindex="-1"></a><span class="fu">hist</span>(bootpar[,<span class="st">"Binit"</span>],<span class="at">breaks=</span><span class="dv">25</span>,<span class="at">main=</span><span class="st">""</span>,<span class="at">xlab=</span><span class="st">"Binit"</span>)  </span>
<span id="cb87-796"><a href="#cb87-796" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span><span class="fu">c</span>(bootCI[<span class="st">"Binit"</span>,colsf]),<span class="at">col=</span>colf,<span class="at">lwd=</span>lwdf,<span class="at">lty=</span>ltyf)  </span>
<span id="cb87-797"><a href="#cb87-797" aria-hidden="true" tabindex="-1"></a><span class="fu">uphist</span>(bootpar[,<span class="st">"MSY"</span>],<span class="at">breaks=</span><span class="dv">25</span>,<span class="at">main=</span><span class="st">""</span>,<span class="at">xlab=</span><span class="st">"MSY"</span>,<span class="at">maxval=</span><span class="dv">450</span>)  </span>
<span id="cb87-798"><a href="#cb87-798" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span><span class="fu">c</span>(bootCI[<span class="st">"MSY"</span>,colsf]),<span class="at">col=</span>colf,<span class="at">lwd=</span>lwdf,<span class="at">lty=</span>ltyf)  </span>
<span id="cb87-799"><a href="#cb87-799" aria-hidden="true" tabindex="-1"></a><span class="fu">hist</span>(bootpar[,<span class="st">"Depl"</span>],<span class="at">breaks=</span><span class="dv">25</span>,<span class="at">main=</span><span class="st">""</span>,<span class="at">xlab=</span><span class="st">"Final Depletion"</span>)  </span>
<span id="cb87-800"><a href="#cb87-800" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span><span class="fu">c</span>(bootCI[<span class="st">"Depl"</span>,colsf]),<span class="at">col=</span>colf,<span class="at">lwd=</span>lwdf,<span class="at">lty=</span>ltyf)  </span>
<span id="cb87-801"><a href="#cb87-801" aria-hidden="true" tabindex="-1"></a><span class="fu">hist</span>(bootpar[,<span class="st">"Harv"</span>],<span class="at">breaks=</span><span class="dv">25</span>,<span class="at">main=</span><span class="st">""</span>,<span class="at">xlab=</span><span class="st">"End Harvest Rate"</span>)  </span>
<span id="cb87-802"><a href="#cb87-802" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span><span class="fu">c</span>(bootCI[<span class="st">"Harv"</span>,colsf]),<span class="at">col=</span>colf,<span class="at">lwd=</span>lwdf,<span class="at">lty=</span>ltyf) }</span>
<span id="cb87-803"><a href="#cb87-803" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-804"><a href="#cb87-804" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-805"><a href="#cb87-805" aria-hidden="true" tabindex="-1"></a>存储在 *boots\$dynam* 中的拟合轨迹也可以直观地指示分析的不确定性。</span>
<span id="cb87-806"><a href="#cb87-806" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-809"><a href="#cb87-809" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-810"><a href="#cb87-810" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-spm13</span></span>
<span id="cb87-811"><a href="#cb87-811" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "A plot of the original observed CPUE (black dots), the optimum predicted CPUE (solid line), the 1000 bootstrap predicted CPUE (the grey lines), and the 90th percentile confidence intervals around those predicted values (the vertical bars)."</span></span>
<span id="cb87-812"><a href="#cb87-812" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-813"><a href="#cb87-813" aria-hidden="true" tabindex="-1"></a>  <span class="co">#Fig7.13 1000 bootstrap trajectories for dataspm model fit   </span></span>
<span id="cb87-814"><a href="#cb87-814" aria-hidden="true" tabindex="-1"></a>dynam <span class="ot">&lt;-</span> boots<span class="sc">$</span>dynam  </span>
<span id="cb87-815"><a href="#cb87-815" aria-hidden="true" tabindex="-1"></a>years <span class="ot">&lt;-</span> fish[,<span class="st">"year"</span>]  </span>
<span id="cb87-816"><a href="#cb87-816" aria-hidden="true" tabindex="-1"></a>nyrs <span class="ot">&lt;-</span> <span class="fu">length</span>(years)  </span>
<span id="cb87-817"><a href="#cb87-817" aria-hidden="true" tabindex="-1"></a><span class="fu">parset</span>()  </span>
<span id="cb87-818"><a href="#cb87-818" aria-hidden="true" tabindex="-1"></a>ymax <span class="ot">&lt;-</span> <span class="fu">getmax</span>(<span class="fu">c</span>(dynam[,,<span class="st">"predCE"</span>],fish[,<span class="st">"cpue"</span>]))  </span>
<span id="cb87-819"><a href="#cb87-819" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(fish[,<span class="st">"year"</span>],fish[,<span class="st">"cpue"</span>],<span class="at">type=</span><span class="st">"n"</span>,<span class="at">ylim=</span><span class="fu">c</span>(<span class="dv">0</span>,ymax),  </span>
<span id="cb87-820"><a href="#cb87-820" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlab=</span><span class="st">"Year"</span>,<span class="at">ylab=</span><span class="st">"CPUE"</span>,<span class="at">yaxs=</span><span class="st">"i"</span>,<span class="at">panel.first =</span> <span class="fu">grid</span>())  </span>
<span id="cb87-821"><a href="#cb87-821" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>reps) <span class="fu">lines</span>(years,dynam[i,,<span class="st">"predCE"</span>],<span class="at">lwd=</span><span class="dv">1</span>,<span class="at">col=</span><span class="dv">8</span>)  </span>
<span id="cb87-822"><a href="#cb87-822" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(years,answer<span class="sc">$</span>Dynamics<span class="sc">$</span>outmat[<span class="dv">1</span><span class="sc">:</span>nyrs,<span class="st">"predCE"</span>],<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">0</span>)  </span>
<span id="cb87-823"><a href="#cb87-823" aria-hidden="true" tabindex="-1"></a><span class="fu">points</span>(years,fish[,<span class="st">"cpue"</span>],<span class="at">cex=</span><span class="fl">1.2</span>,<span class="at">pch=</span><span class="dv">16</span>,<span class="at">col=</span><span class="dv">1</span>)  </span>
<span id="cb87-824"><a href="#cb87-824" aria-hidden="true" tabindex="-1"></a>percs <span class="ot">&lt;-</span> <span class="fu">apply</span>(dynam[,,<span class="st">"predCE"</span>],<span class="dv">2</span>,quants)  </span>
<span id="cb87-825"><a href="#cb87-825" aria-hidden="true" tabindex="-1"></a><span class="fu">arrows</span>(<span class="at">x0=</span>years,<span class="at">y0=</span>percs[<span class="st">"5%"</span>,],<span class="at">y1=</span>percs[<span class="st">"95%"</span>,],<span class="at">length=</span><span class="fl">0.03</span>,  </span>
<span id="cb87-826"><a href="#cb87-826" aria-hidden="true" tabindex="-1"></a>       <span class="at">angle=</span><span class="dv">90</span>,<span class="at">code=</span><span class="dv">3</span>,<span class="at">col=</span><span class="dv">0</span>)  </span>
<span id="cb87-827"><a href="#cb87-827" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-828"><a href="#cb87-828" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-829"><a href="#cb87-829" aria-hidden="true" tabindex="-1"></a>预测 CPUE 值与观测 CPUE 值之间存在明显偏差（@fig-spm13）,但估计值的中位数及其周围的置信区间仍然十分明确。</span>
<span id="cb87-830"><a href="#cb87-830" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-831"><a href="#cb87-831" aria-hidden="true" tabindex="-1"></a>请记住，无论何时在时间序列数据上使用自举法，其中时刻 $t + 1$ 的值与时刻 $t$ 的值相关，都有必要自举任何拟合模型的残差值，并将它们与最优拟合值联系起来。对于CPUE 数据，我们通常使用对数正态残差误差，因此一旦找到最优解，这些残差定义为:</span>
<span id="cb87-832"><a href="#cb87-832" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-833"><a href="#cb87-833" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb87-834"><a href="#cb87-834" aria-hidden="true" tabindex="-1"></a>\hat{I}_{t,resid} = \frac{I_t}{\hat{I_t}}  </span>
<span id="cb87-835"><a href="#cb87-835" aria-hidden="true" tabindex="-1"></a>$$ {#eq-spm18}</span>
<span id="cb87-836"><a href="#cb87-836" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-837"><a href="#cb87-837" aria-hidden="true" tabindex="-1"></a>其中$I_t$ 是年$t$中的观测 CPUE，$I_t/\hat I_t$ 是年 $t$ 中观测 CPUE 除以预测 CPUE（对数正态残差 $\hat I_{t, resid}$。这种残差会有一个时间序列，自举法的生成包括从时间序列中随机抽取数值，并进行替换， 从而得到一个对数正态残差的自举样本。然后将这些值乘以原始的最优预测 cpue 值，生成不同时间序列的自举 cpue。</span>
<span id="cb87-838"><a href="#cb87-838" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-839"><a href="#cb87-839" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb87-840"><a href="#cb87-840" aria-hidden="true" tabindex="-1"></a>{I_t}^* = \hat{I_t} * \left <span class="co">[</span><span class="ot"> \frac{I}{\hat{I}} \right </span><span class="co">]</span>^*</span>
<span id="cb87-841"><a href="#cb87-841" aria-hidden="true" tabindex="-1"></a>$$ {#eq-spm19}</span>
<span id="cb87-842"><a href="#cb87-842" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-843"><a href="#cb87-843" aria-hidden="true" tabindex="-1"></a>其中上标 ∗ 表示自举样本，$I_t^*$ 表示年 $t$ 的 Bootstrap CPUE，$\left [ \frac{I}{\hat{I}} \right ]^*$ 表示来自对数正态残差的单个随机样本，然后将其乘以当年的预测 CPUE。这些方程反映了 **MQMF** 函数 <span class="in">`spmboot()`</span> 中的特定代码行。</span>
<span id="cb87-844"><a href="#cb87-844" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-845"><a href="#cb87-845" aria-hidden="true" tabindex="-1"></a>值得一做的是重复上述分析，但将 *schaefer = TRUE* 处改为 *FALSE* ，以便用 Fox 剩余产量模型来拟合模型。这样就可以比较两个模型的不确定性。</span>
<span id="cb87-846"><a href="#cb87-846" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-849"><a href="#cb87-849" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-850"><a href="#cb87-850" aria-hidden="true" tabindex="-1"></a>  <span class="co">#Fit the Fox model to dataspm; note different parameters  </span></span>
<span id="cb87-851"><a href="#cb87-851" aria-hidden="true" tabindex="-1"></a>pars <span class="ot">&lt;-</span> <span class="fu">log</span>(<span class="fu">c</span>(<span class="at">r=</span><span class="fl">0.15</span>,<span class="at">K=</span><span class="dv">6500</span>,<span class="at">Binit=</span><span class="dv">3000</span>,<span class="at">sigma=</span><span class="fl">0.20</span>))  </span>
<span id="cb87-852"><a href="#cb87-852" aria-hidden="true" tabindex="-1"></a>ansF <span class="ot">&lt;-</span> <span class="fu">fitSPM</span>(pars,fish,<span class="at">schaefer=</span><span class="cn">FALSE</span>,<span class="at">maxiter=</span><span class="dv">1000</span>) <span class="co">#Fox version  </span></span>
<span id="cb87-853"><a href="#cb87-853" aria-hidden="true" tabindex="-1"></a>bootsF <span class="ot">&lt;-</span> <span class="fu">spmboot</span>(ansF<span class="sc">$</span>estimate,<span class="at">fishery=</span>fish,<span class="at">iter=</span>reps,<span class="at">schaefer=</span><span class="cn">FALSE</span>)  </span>
<span id="cb87-854"><a href="#cb87-854" aria-hidden="true" tabindex="-1"></a>dynamF <span class="ot">&lt;-</span> bootsF<span class="sc">$</span>dynam   </span>
<span id="cb87-855"><a href="#cb87-855" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-856"><a href="#cb87-856" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-859"><a href="#cb87-859" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-860"><a href="#cb87-860" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-spm14</span></span>
<span id="cb87-861"><a href="#cb87-861" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "A plot of the original observed CPUE (dots), the optimum predicted CPUE (solid white line) with the 90th percentile confidence intervals (the white bars). The black lines are the Fox model bootstrap replicates while the grey lines over the black are those from the Schaefer model."</span></span>
<span id="cb87-862"><a href="#cb87-862" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-863"><a href="#cb87-863" aria-hidden="true" tabindex="-1"></a>  <span class="co"># bootstrap trajectories from both model fits  Fig 7.14  </span></span>
<span id="cb87-864"><a href="#cb87-864" aria-hidden="true" tabindex="-1"></a><span class="fu">parset</span>()  </span>
<span id="cb87-865"><a href="#cb87-865" aria-hidden="true" tabindex="-1"></a>ymax <span class="ot">&lt;-</span> <span class="fu">getmax</span>(<span class="fu">c</span>(dynam[,,<span class="st">"predCE"</span>],fish[,<span class="st">"cpue"</span>]))  </span>
<span id="cb87-866"><a href="#cb87-866" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(fish[,<span class="st">"year"</span>],fish[,<span class="st">"cpue"</span>],<span class="at">type=</span><span class="st">"n"</span>,<span class="at">ylim=</span><span class="fu">c</span>(<span class="dv">0</span>,ymax),  </span>
<span id="cb87-867"><a href="#cb87-867" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlab=</span><span class="st">"Year"</span>,<span class="at">ylab=</span><span class="st">"CPUE"</span>,<span class="at">yaxs=</span><span class="st">"i"</span>,<span class="at">panel.first =</span> <span class="fu">grid</span>())  </span>
<span id="cb87-868"><a href="#cb87-868" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>reps) <span class="fu">lines</span>(years,dynamF[i,,<span class="st">"predCE"</span>],<span class="at">lwd=</span><span class="dv">1</span>,<span class="at">col=</span><span class="dv">1</span>,<span class="at">lty=</span><span class="dv">1</span>)  </span>
<span id="cb87-869"><a href="#cb87-869" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>reps) <span class="fu">lines</span>(years,dynam[i,,<span class="st">"predCE"</span>],<span class="at">lwd=</span><span class="dv">1</span>,<span class="at">col=</span><span class="dv">8</span>)  </span>
<span id="cb87-870"><a href="#cb87-870" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(years,answer<span class="sc">$</span>Dynamics<span class="sc">$</span>outmat[<span class="dv">1</span><span class="sc">:</span>nyrs,<span class="st">"predCE"</span>],<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">0</span>)  </span>
<span id="cb87-871"><a href="#cb87-871" aria-hidden="true" tabindex="-1"></a><span class="fu">points</span>(years,fish[,<span class="st">"cpue"</span>],<span class="at">cex=</span><span class="fl">1.1</span>,<span class="at">pch=</span><span class="dv">16</span>,<span class="at">col=</span><span class="dv">1</span>)  </span>
<span id="cb87-872"><a href="#cb87-872" aria-hidden="true" tabindex="-1"></a>percs <span class="ot">&lt;-</span> <span class="fu">apply</span>(dynam[,,<span class="st">"predCE"</span>],<span class="dv">2</span>,quants)  </span>
<span id="cb87-873"><a href="#cb87-873" aria-hidden="true" tabindex="-1"></a><span class="fu">arrows</span>(<span class="at">x0=</span>years,<span class="at">y0=</span>percs[<span class="st">"5%"</span>,],<span class="at">y1=</span>percs[<span class="st">"95%"</span>,],<span class="at">length=</span><span class="fl">0.03</span>,  </span>
<span id="cb87-874"><a href="#cb87-874" aria-hidden="true" tabindex="-1"></a>       <span class="at">angle=</span><span class="dv">90</span>,<span class="at">code=</span><span class="dv">3</span>,<span class="at">col=</span><span class="dv">0</span>)  </span>
<span id="cb87-875"><a href="#cb87-875" aria-hidden="true" tabindex="-1"></a><span class="fu">legend</span>(<span class="dv">1985</span>,<span class="fl">0.35</span>,<span class="fu">c</span>(<span class="st">"Schaefer"</span>,<span class="st">"Fox"</span>),<span class="at">col=</span><span class="fu">c</span>(<span class="dv">8</span>,<span class="dv">1</span>),<span class="at">bty=</span><span class="st">"n"</span>,<span class="at">lwd=</span><span class="dv">3</span>)    </span>
<span id="cb87-876"><a href="#cb87-876" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-877"><a href="#cb87-877" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-878"><a href="#cb87-878" aria-hidden="true" tabindex="-1"></a>可以说，Fox 模型在捕捉这些数据的变异性方面更成功，因为黑线的扩散范围略大于灰色线（@fig-spm14）。或者，可以说 Fox 模型不太确定。总体而言，Schaefer 和 Fox 模型的输出之间没有太大差异，甚至像他们预测的那样 $MSY$ 值非常相似（313.512 吨与 311.661 吨）。然而，最终，Fox 模型中密度依赖性的非线性似乎赋予了它更大的灵活性，因此它能够比更严格的 Schaefer 模型更好地捕获原始数据的变异性（因此它的 -ve 对数似然性更小，参见 <span class="in">`outfit(ansF)`</span>）。但这两个模型都无法捕获残差中表现出的循环特性，意味着建模动力学中未包含某些过程，即模型错误规范。这两种模型都不完全充分，尽管它们都可以提供足够的近似动态，可以用来产生管理建议（关于周期过程随时间保持不变的警告，等等）。</span>
<span id="cb87-879"><a href="#cb87-879" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-880"><a href="#cb87-880" aria-hidden="true" tabindex="-1"></a><span class="fu">### 参数相关性</span></span>
<span id="cb87-881"><a href="#cb87-881" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-882"><a href="#cb87-882" aria-hidden="true" tabindex="-1"></a>组合的 bootstrap 样本和相关估计值提供了反映数据和拟合模型的参数之间变异性的表征。如果我们将各种参数相互绘制，任何参数相关性都会变得明显。之间强烈的负曲线-线性关系 $r$ 和 $K$ 非常明显，而与其他参数之间的关系也既不是随机的，也不是平滑正态的。在极端值下有一些点，但它们仍然很少见，但是，这些图确实说明了该分析中的变化形式。</span>
<span id="cb87-883"><a href="#cb87-883" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-886"><a href="#cb87-886" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-887"><a href="#cb87-887" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-spm15</span></span>
<span id="cb87-888"><a href="#cb87-888" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "模型参数与 Schaefer 模型（ Fox 模型使用 `bootsF$bootpar`）的一些输出之间的关系。下方面板在数据中具有一条红色的平滑线，用于说明任何趋势，而上方面板具有线性相关系数。少数极值会扭曲绘图。The relationships between the model parameters and some outputs for the Schaefer model (use bootsF$bootpar for the Fox model ). The lower panels have a red smoother line through the data illustrating any trends, while the upper panels have the linear correlation coefficient. The few extreme values distort the plots."</span></span>
<span id="cb87-889"><a href="#cb87-889" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-890"><a href="#cb87-890" aria-hidden="true" tabindex="-1"></a> <span class="co"># plot variables against each other, use MQMF panel.cor  Fig 7.15  </span></span>
<span id="cb87-891"><a href="#cb87-891" aria-hidden="true" tabindex="-1"></a><span class="fu">pairs</span>(boots<span class="sc">$</span>bootpar[,<span class="fu">c</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">7</span>)],<span class="at">lower.panel=</span>panel.smooth,   </span>
<span id="cb87-892"><a href="#cb87-892" aria-hidden="true" tabindex="-1"></a>      <span class="at">upper.panel=</span>panel.cor,<span class="at">gap=</span><span class="dv">0</span>,<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">cex=</span><span class="fl">0.5</span>)  </span>
<span id="cb87-893"><a href="#cb87-893" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-894"><a href="#cb87-894" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-895"><a href="#cb87-895" aria-hidden="true" tabindex="-1"></a><span class="fu">### 渐近误差</span></span>
<span id="cb87-896"><a href="#cb87-896" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-897"><a href="#cb87-897" aria-hidden="true" tabindex="-1"></a>如*“不确定性”*一章所述，在模型拟合过程中，描述与参数估计相关的不确定性的经典方法是使用所谓的渐近误差。渐近误差源自方差-协方差矩阵，可用于描述模型参数之间的变异性和交互作用。在自举法的章节中，可以 `pairs()` 函数直观显示参数之间的关系， 而这些关系显然不是很好的多变量正态关系。尽管如此，仍然可以使用从方差-协方差矩阵 （*vcov*） 得出的多变量正态来描述模型的不确定性。在使用`optim()` 或 `nlm()` 拟合模型时，我们可以将 *vcov* 估计为一个选项来估计。</span>
<span id="cb87-898"><a href="#cb87-898" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-901"><a href="#cb87-901" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-902"><a href="#cb87-902" aria-hidden="true" tabindex="-1"></a>  <span class="co">#Start the SPM analysis using asymptotic errors.  </span></span>
<span id="cb87-903"><a href="#cb87-903" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(dataspm)    <span class="co"># Note the use of hess=TRUE in call to fitSPM   </span></span>
<span id="cb87-904"><a href="#cb87-904" aria-hidden="true" tabindex="-1"></a>fish <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>(dataspm)     <span class="co"># using as.matrix for more speed  </span></span>
<span id="cb87-905"><a href="#cb87-905" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(fish) <span class="ot">&lt;-</span> <span class="fu">tolower</span>(<span class="fu">colnames</span>(fish))  <span class="co"># just in case</span></span>
<span id="cb87-906"><a href="#cb87-906" aria-hidden="true" tabindex="-1"></a>pars <span class="ot">&lt;-</span> <span class="fu">log</span>(<span class="fu">c</span>(<span class="at">r=</span><span class="fl">0.25</span>,<span class="at">K=</span><span class="dv">5200</span>,<span class="at">Binit=</span><span class="dv">2900</span>,<span class="at">sigma=</span><span class="fl">0.20</span>))  </span>
<span id="cb87-907"><a href="#cb87-907" aria-hidden="true" tabindex="-1"></a>ans <span class="ot">&lt;-</span> <span class="fu">fitSPM</span>(pars,fish,<span class="at">schaefer=</span><span class="cn">TRUE</span>,<span class="at">maxiter=</span><span class="dv">1000</span>,<span class="at">hess=</span><span class="cn">TRUE</span>)    </span>
<span id="cb87-908"><a href="#cb87-908" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-909"><a href="#cb87-909" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-910"><a href="#cb87-910" aria-hidden="true" tabindex="-1"></a>通过使用 <span class="in">`outfit()`</span> 函数，我们可以看到在 *hess* 参数设置为 “TRUE”的情况下，Schaefer 剩余产量模型与 *dataspm* 数据集的拟合结果。</span>
<span id="cb87-911"><a href="#cb87-911" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-914"><a href="#cb87-914" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-915"><a href="#cb87-915" aria-hidden="true" tabindex="-1"></a> <span class="co">#The hessian matrix from the Schaefer fit to the dataspm data   </span></span>
<span id="cb87-916"><a href="#cb87-916" aria-hidden="true" tabindex="-1"></a> <span class="fu">outfit</span>(ans)  </span>
<span id="cb87-917"><a href="#cb87-917" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-918"><a href="#cb87-918" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-919"><a href="#cb87-919" aria-hidden="true" tabindex="-1"></a><span class="in">`fitSPM()`</span> 中的最终最小化使用的是最大似然法（实际上是最小负对数似然），因此我们需要反演赫斯方差以获得方差-协方差矩阵。对角线的平方根也给出了每个参数的标准误差估计值（参见 “不确定性 ”一章）。</span>
<span id="cb87-920"><a href="#cb87-920" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-923"><a href="#cb87-923" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-924"><a href="#cb87-924" aria-hidden="true" tabindex="-1"></a> <span class="co">#calculate the var-covar matrix and the st errors  </span></span>
<span id="cb87-925"><a href="#cb87-925" aria-hidden="true" tabindex="-1"></a>vcov <span class="ot">&lt;-</span> <span class="fu">solve</span>(ans<span class="sc">$</span>hessian) <span class="co"># calculate variance-covariance matrix  </span></span>
<span id="cb87-926"><a href="#cb87-926" aria-hidden="true" tabindex="-1"></a>label <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"r"</span>,<span class="st">"K"</span>, <span class="st">"Binit"</span>,<span class="st">"sigma"</span>)  </span>
<span id="cb87-927"><a href="#cb87-927" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(vcov) <span class="ot">&lt;-</span> label; <span class="fu">rownames</span>(vcov) <span class="ot">&lt;-</span> label  </span>
<span id="cb87-928"><a href="#cb87-928" aria-hidden="true" tabindex="-1"></a>outvcov <span class="ot">&lt;-</span> <span class="fu">rbind</span>(vcov,<span class="fu">sqrt</span>(<span class="fu">diag</span>(vcov)))  </span>
<span id="cb87-929"><a href="#cb87-929" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(outvcov) <span class="ot">&lt;-</span> <span class="fu">c</span>(label,<span class="st">"StErr"</span>)  </span>
<span id="cb87-930"><a href="#cb87-930" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-931"><a href="#cb87-931" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-934"><a href="#cb87-934" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-935"><a href="#cb87-935" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-spm6</span></span>
<span id="cb87-936"><a href="#cb87-936" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: "The variance-covariance (vcov) matrix is the inverse of the Hessian and the parameter standard errors are the square-root of the diagonal of the vcov matrix."</span></span>
<span id="cb87-937"><a href="#cb87-937" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb87-938"><a href="#cb87-938" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-939"><a href="#cb87-939" aria-hidden="true" tabindex="-1"></a>knitr<span class="sc">::</span><span class="fu">kable</span>(outvcov, <span class="at">digits =</span> <span class="dv">4</span>)</span>
<span id="cb87-940"><a href="#cb87-940" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-941"><a href="#cb87-941" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-942"><a href="#cb87-942" aria-hidden="true" tabindex="-1"></a>现在我们有了最优解和方差-协方差矩阵，可以使用多变量正态分布来获得多个参数的合理组合，这些参数组合可以用来计算输出，如 $MSY$ ，并描述预期动态。基本 R 不包括从多变量正态分布中采样的方法，但有一些免费提供的软件包可以做到。我们将使用可从 CRAN 下载的 mvtnorm 软件包。在使用这种软件包时，可以通过 <span class="in">`packageDescription()`</span> 函数确定编写者和其他重要信息。另外，在查看软件包中某个函数的帮助文件时，如果滚动到页面底部并点击索引超链接，就可以直接阅读描述文件。</span>
<span id="cb87-943"><a href="#cb87-943" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-946"><a href="#cb87-946" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-947"><a href="#cb87-947" aria-hidden="true" tabindex="-1"></a>  <span class="co">#generate 1000 parameter vectors from multi-variate normal  </span></span>
<span id="cb87-948"><a href="#cb87-948" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(mvtnorm)   <span class="co"># use RStudio, or install.packages("mvtnorm")  </span></span>
<span id="cb87-949"><a href="#cb87-949" aria-hidden="true" tabindex="-1"></a>N <span class="ot">&lt;-</span> <span class="dv">1000</span> <span class="co"># number of parameter vectors, use vcov from above  </span></span>
<span id="cb87-950"><a href="#cb87-950" aria-hidden="true" tabindex="-1"></a>mvn <span class="ot">&lt;-</span> <span class="fu">length</span>(fish[,<span class="st">"year"</span>]) <span class="co">#matrix to store cpue trajectories  </span></span>
<span id="cb87-951"><a href="#cb87-951" aria-hidden="true" tabindex="-1"></a>mvncpue <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="dv">0</span>,<span class="at">nrow=</span>N,<span class="at">ncol=</span>mvn,<span class="at">dimnames=</span><span class="fu">list</span>(<span class="dv">1</span><span class="sc">:</span>N,fish[,<span class="st">"year"</span>]))  </span>
<span id="cb87-952"><a href="#cb87-952" aria-hidden="true" tabindex="-1"></a>columns <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"r"</span>,<span class="st">"K"</span>,<span class="st">"Binit"</span>,<span class="st">"sigma"</span>)  </span>
<span id="cb87-953"><a href="#cb87-953" aria-hidden="true" tabindex="-1"></a>optpar <span class="ot">&lt;-</span> ans<span class="sc">$</span>estimate <span class="co"># Fill matrix with mvn parameter vectors   </span></span>
<span id="cb87-954"><a href="#cb87-954" aria-hidden="true" tabindex="-1"></a>mvnpar <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">exp</span>(<span class="fu">rmvnorm</span>(N,<span class="at">mean=</span>optpar,<span class="at">sigma=</span>vcov)),<span class="at">nrow=</span>N,  </span>
<span id="cb87-955"><a href="#cb87-955" aria-hidden="true" tabindex="-1"></a>                 <span class="at">ncol=</span><span class="dv">4</span>,<span class="at">dimnames=</span><span class="fu">list</span>(<span class="dv">1</span><span class="sc">:</span>N,columns))  </span>
<span id="cb87-956"><a href="#cb87-956" aria-hidden="true" tabindex="-1"></a>msy <span class="ot">&lt;-</span> mvnpar[,<span class="st">"r"</span>]<span class="sc">*</span>mvnpar[,<span class="st">"K"</span>]<span class="sc">/</span><span class="dv">4</span>  </span>
<span id="cb87-957"><a href="#cb87-957" aria-hidden="true" tabindex="-1"></a>nyr <span class="ot">&lt;-</span> <span class="fu">length</span>(fish[,<span class="st">"year"</span>])  </span>
<span id="cb87-958"><a href="#cb87-958" aria-hidden="true" tabindex="-1"></a>depletion <span class="ot">&lt;-</span> <span class="fu">numeric</span>(N) <span class="co">#now calculate N cpue series in linear space  </span></span>
<span id="cb87-959"><a href="#cb87-959" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>N) { <span class="co"># calculate dynamics for each parameter set  </span></span>
<span id="cb87-960"><a href="#cb87-960" aria-hidden="true" tabindex="-1"></a>  dynamA <span class="ot">&lt;-</span> <span class="fu">spm</span>(<span class="fu">log</span>(mvnpar[i,<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>]),fish)  </span>
<span id="cb87-961"><a href="#cb87-961" aria-hidden="true" tabindex="-1"></a>  mvncpue[i,] <span class="ot">&lt;-</span> dynamA<span class="sc">$</span>outmat[<span class="dv">1</span><span class="sc">:</span>nyr,<span class="st">"predCE"</span>]  </span>
<span id="cb87-962"><a href="#cb87-962" aria-hidden="true" tabindex="-1"></a>  depletion[i] <span class="ot">&lt;-</span> dynamA<span class="sc">$</span>outmat[<span class="st">"2016"</span>,<span class="st">"Depletion"</span>]  </span>
<span id="cb87-963"><a href="#cb87-963" aria-hidden="true" tabindex="-1"></a>}  </span>
<span id="cb87-964"><a href="#cb87-964" aria-hidden="true" tabindex="-1"></a>mvnpar <span class="ot">&lt;-</span> <span class="fu">cbind</span>(mvnpar,msy,depletion) <span class="co"># try head(mvnpar,10)  </span></span>
<span id="cb87-965"><a href="#cb87-965" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-966"><a href="#cb87-966" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-967"><a href="#cb87-967" aria-hidden="true" tabindex="-1"></a>@fig-spm13 和 @fig-spm14 通过自举法绘制出隐含的 CPUE 轨迹，结果似乎是可信的。另一方面，利用渐近误差，当我们绘制隐含的动态图时，如 @fig-spm16 ，有一定比例的鱼类在第 90 个百分位数置信区间之外，而置信区间本身是极不对称的，会产生剧烈波动的动态，甚至可能意味着鱼类灭绝。</span>
<span id="cb87-968"><a href="#cb87-968" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-971"><a href="#cb87-971" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-972"><a href="#cb87-972" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-spm16</span></span>
<span id="cb87-973"><a href="#cb87-973" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "从最优参数及其相关方差-协方差矩阵定义的多变量正态分布中采样的随机参数向量得出的 1000 条 cpue 预测轨迹。The 1000 predicted cpue trajectories derived from random parameter vectors sampled from the multi-variate normal distribution defined by the optimum parameters and their related variance-covariance matrix."</span></span>
<span id="cb87-974"><a href="#cb87-974" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-975"><a href="#cb87-975" aria-hidden="true" tabindex="-1"></a>  <span class="co">#data and trajectories from 1000 MVN parameter vectors   Fig 7.16  </span></span>
<span id="cb87-976"><a href="#cb87-976" aria-hidden="true" tabindex="-1"></a><span class="fu">plot1</span>(fish[,<span class="st">"year"</span>],fish[,<span class="st">"cpue"</span>],<span class="at">type=</span><span class="st">"p"</span>,<span class="at">xlab=</span><span class="st">"Year"</span>,<span class="at">ylab=</span><span class="st">"CPUE"</span>,  </span>
<span id="cb87-977"><a href="#cb87-977" aria-hidden="true" tabindex="-1"></a>      <span class="at">maxy=</span><span class="fl">2.0</span>)  </span>
<span id="cb87-978"><a href="#cb87-978" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>N) <span class="fu">lines</span>(fish[,<span class="st">"year"</span>],mvncpue[i,],<span class="at">col=</span><span class="st">"grey"</span>,<span class="at">lwd=</span><span class="dv">1</span>)  </span>
<span id="cb87-979"><a href="#cb87-979" aria-hidden="true" tabindex="-1"></a><span class="fu">points</span>(fish[,<span class="st">"year"</span>],fish[,<span class="st">"cpue"</span>],<span class="at">pch=</span><span class="dv">1</span>,<span class="at">cex=</span><span class="fl">1.3</span>,<span class="at">col=</span><span class="dv">1</span>,<span class="at">lwd=</span><span class="dv">2</span>) <span class="co"># data  </span></span>
<span id="cb87-980"><a href="#cb87-980" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(fish[,<span class="st">"year"</span>],<span class="fu">exp</span>(<span class="fu">simpspm</span>(optpar,fish)),<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">1</span>)<span class="co"># pred   </span></span>
<span id="cb87-981"><a href="#cb87-981" aria-hidden="true" tabindex="-1"></a>percs <span class="ot">&lt;-</span> <span class="fu">apply</span>(mvncpue,<span class="dv">2</span>,quants)  <span class="co"># obtain the quantiles  </span></span>
<span id="cb87-982"><a href="#cb87-982" aria-hidden="true" tabindex="-1"></a><span class="fu">arrows</span>(<span class="at">x0=</span>fish[,<span class="st">"year"</span>],<span class="at">y0=</span>percs[<span class="st">"5%"</span>,],<span class="at">y1=</span>percs[<span class="st">"95%"</span>,],<span class="at">length=</span><span class="fl">0.03</span>,  </span>
<span id="cb87-983"><a href="#cb87-983" aria-hidden="true" tabindex="-1"></a>       <span class="at">angle=</span><span class="dv">90</span>,<span class="at">code=</span><span class="dv">3</span>,<span class="at">col=</span><span class="dv">1</span>) <span class="co">#add 90% quantiles  </span></span>
<span id="cb87-984"><a href="#cb87-984" aria-hidden="true" tabindex="-1"></a>msy <span class="ot">&lt;-</span> mvnpar[,<span class="st">"r"</span>]<span class="sc">*</span>mvnpar[,<span class="st">"K"</span>]<span class="sc">/</span><span class="dv">4</span>  <span class="co"># 1000 MSY estimates  </span></span>
<span id="cb87-985"><a href="#cb87-985" aria-hidden="true" tabindex="-1"></a><span class="fu">text</span>(<span class="dv">2010</span>,<span class="fl">1.75</span>,<span class="fu">paste0</span>(<span class="st">"MSY "</span>,<span class="fu">round</span>(<span class="fu">mean</span>(msy),<span class="dv">3</span>)),<span class="at">cex=</span><span class="fl">1.25</span>,<span class="at">font=</span><span class="dv">7</span>)   </span>
<span id="cb87-986"><a href="#cb87-986" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-987"><a href="#cb87-987" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-988"><a href="#cb87-988" aria-hidden="true" tabindex="-1"></a>使用渐近误差估计的平均 $MSY$ 与自举估计值非常相似（319.546，@tbl-spm5），第90 分位置信区间看起来也很有意义，尽管比自举分析更加偏斜。然而，使用多变量正态分布显然会导致一些难以置信的参数组合，进而导致难以置信的 cpue 轨迹，与观测 cpue 相差甚远。这并不意味着不应该使用渐近误差，而是说如果确实使用了渐近误差，就应该对其影响的合理性进行研究。</span>
<span id="cb87-989"><a href="#cb87-989" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-990"><a href="#cb87-990" aria-hidden="true" tabindex="-1"></a>在这种情况下，我们可以通过查找最终 cpue 值小于 0.4 的记录来搜索导致极端结果的参数组合。</span>
<span id="cb87-991"><a href="#cb87-991" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-994"><a href="#cb87-994" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-995"><a href="#cb87-995" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-spm17</span></span>
<span id="cb87-996"><a href="#cb87-996" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "预测 2016 年 cpue &lt; 0.4 的 34 个渐近误差 cpue 轨迹。圆点为原始数据，虚线为最佳拟合模型。The 34 asymptotic error cpue trajectories that were predicted to have a cpue &lt; 0.4 in 2016. The dots are the original data and the dashed line the optimum model fit."</span></span>
<span id="cb87-997"><a href="#cb87-997" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-998"><a href="#cb87-998" aria-hidden="true" tabindex="-1"></a> <span class="co">#Isolate errant cpue trajectories Fig 7.17  </span></span>
<span id="cb87-999"><a href="#cb87-999" aria-hidden="true" tabindex="-1"></a>pickd <span class="ot">&lt;-</span> <span class="fu">which</span>(mvncpue[,<span class="st">"2016"</span>] <span class="sc">&lt;</span> <span class="fl">0.40</span>)  </span>
<span id="cb87-1000"><a href="#cb87-1000" aria-hidden="true" tabindex="-1"></a><span class="fu">plot1</span>(fish[,<span class="st">"year"</span>],fish[,<span class="st">"cpue"</span>],<span class="at">type=</span><span class="st">"n"</span>,<span class="at">xlab=</span><span class="st">"Year"</span>,<span class="at">ylab=</span><span class="st">"CPUE"</span>,  </span>
<span id="cb87-1001"><a href="#cb87-1001" aria-hidden="true" tabindex="-1"></a>      <span class="at">maxy=</span><span class="fl">6.25</span>)  </span>
<span id="cb87-1002"><a href="#cb87-1002" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(pickd))   </span>
<span id="cb87-1003"><a href="#cb87-1003" aria-hidden="true" tabindex="-1"></a>  <span class="fu">lines</span>(fish[,<span class="st">"year"</span>],mvncpue[pickd[i],],<span class="at">col=</span><span class="dv">1</span>,<span class="at">lwd=</span><span class="dv">1</span>)  </span>
<span id="cb87-1004"><a href="#cb87-1004" aria-hidden="true" tabindex="-1"></a><span class="fu">points</span>(fish[,<span class="st">"year"</span>],fish[,<span class="st">"cpue"</span>],<span class="at">pch=</span><span class="dv">16</span>,<span class="at">cex=</span><span class="fl">1.25</span>,<span class="at">col=</span><span class="dv">4</span>)   </span>
<span id="cb87-1005"><a href="#cb87-1005" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(fish[,<span class="st">"year"</span>],<span class="fu">exp</span>(<span class="fu">simpspm</span>(optpar,fish)),<span class="at">lwd=</span><span class="dv">3</span>,<span class="at">col=</span><span class="dv">2</span>,<span class="at">lty=</span><span class="dv">2</span>)   </span>
<span id="cb87-1006"><a href="#cb87-1006" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-1007"><a href="#cb87-1007" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1008"><a href="#cb87-1008" aria-hidden="true" tabindex="-1"></a>现在，我们已经确定了大多数错误轨迹及其各自的参数矢量，我们可以通过绘图来比较我们认为的非错误轨迹，这样我们就可以确定谁是谁了（@fig-spm18）。</span>
<span id="cb87-1009"><a href="#cb87-1009" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1012"><a href="#cb87-1012" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-1013"><a href="#cb87-1013" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-spm18</span></span>
<span id="cb87-1014"><a href="#cb87-1014" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "渐近误差样本中参数值的分布，黑色部分为预测最终 cpue &lt; 0.4 的参数值。看来，Binit 的低值是造成难以置信轨迹的主要原因。The spread of parameter values from the asymptotic error samples with the values that predicted final cpue &lt; 0.4 highlighted in black. It appears that low values of Binit are mostly behind the implausible trajectories."</span></span>
<span id="cb87-1015"><a href="#cb87-1015" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb87-1016"><a href="#cb87-1016" aria-hidden="true" tabindex="-1"></a> <span class="co">#Use adhoc function to plot errant parameters Fig 7.18  </span></span>
<span id="cb87-1017"><a href="#cb87-1017" aria-hidden="true" tabindex="-1"></a><span class="fu">parset</span>(<span class="at">plots=</span><span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">2</span>),<span class="at">cex=</span><span class="fl">0.85</span>)  </span>
<span id="cb87-1018"><a href="#cb87-1018" aria-hidden="true" tabindex="-1"></a>outplot <span class="ot">&lt;-</span> <span class="cf">function</span>(var1,var2,pickdev) {  </span>
<span id="cb87-1019"><a href="#cb87-1019" aria-hidden="true" tabindex="-1"></a>  <span class="fu">plot1</span>(mvnpar[,var1],mvnpar[,var2],<span class="at">type=</span><span class="st">"p"</span>,<span class="at">pch=</span><span class="dv">16</span>,<span class="at">cex=</span><span class="fl">1.0</span>,  </span>
<span id="cb87-1020"><a href="#cb87-1020" aria-hidden="true" tabindex="-1"></a>        <span class="at">defpar=</span><span class="cn">FALSE</span>,<span class="at">xlab=</span>var1,<span class="at">ylab=</span>var2,<span class="at">col=</span><span class="dv">8</span>)  </span>
<span id="cb87-1021"><a href="#cb87-1021" aria-hidden="true" tabindex="-1"></a>  <span class="fu">points</span>(mvnpar[pickdev,var1],mvnpar[pickdev,var2],<span class="at">pch=</span><span class="dv">16</span>,<span class="at">cex=</span><span class="fl">1.0</span>)  </span>
<span id="cb87-1022"><a href="#cb87-1022" aria-hidden="true" tabindex="-1"></a>}  </span>
<span id="cb87-1023"><a href="#cb87-1023" aria-hidden="true" tabindex="-1"></a><span class="fu">outplot</span>(<span class="st">"r"</span>,<span class="st">"K"</span>,pickd) <span class="co"># assumes mvnpar in working environment  </span></span>
<span id="cb87-1024"><a href="#cb87-1024" aria-hidden="true" tabindex="-1"></a><span class="fu">outplot</span>(<span class="st">"sigma"</span>,<span class="st">"Binit"</span>,pickd)  </span>
<span id="cb87-1025"><a href="#cb87-1025" aria-hidden="true" tabindex="-1"></a><span class="fu">outplot</span>(<span class="st">"r"</span>,<span class="st">"Binit"</span>,pickd)  </span>
<span id="cb87-1026"><a href="#cb87-1026" aria-hidden="true" tabindex="-1"></a><span class="fu">outplot</span>(<span class="st">"K"</span>,<span class="st">"Binit"</span>,pickd)    </span>
<span id="cb87-1027"><a href="#cb87-1027" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-1028"><a href="#cb87-1028" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1029"><a href="#cb87-1029" aria-hidden="true" tabindex="-1"></a>当我们绘制模型变量之间的相互关系时（@fig-spm19），对于正态分布或多变量正态分布变量，预期 *simga* 和其他参数之间缺乏关系。然而，这与从自举法样本中获得的关系明显不同（@fig-spm15）。此外，三个主要参数 $r$、$K$ 和$B_{init}$ 之间的关系远比在自举抽样中看到的平滑得多。在我们看来，这种对称性和界限的清晰度似乎比自举样本中的关系更容易接受（@fig-spm19）。尽管如此，损耗图显示一些轨迹似乎已经消失。</span>
<span id="cb87-1030"><a href="#cb87-1030" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1033"><a href="#cb87-1033" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-1034"><a href="#cb87-1034" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-spm19</span></span>
<span id="cb87-1035"><a href="#cb87-1035" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "使用多变量正态分布生成参数组合时 Schaefer 模型参数之间的关系。r - K 之间的关系比自举样本紧密得多，而 sigma 与其他参数之间几乎没有关系。损耗图显示一些轨迹已经消失。The relationships between the model parameters for the Schaefer model when using the multi-variate normal distribution to generate the parameter combinations. The relationship between r - K is much tighter than in the bootstrap samples and there is almost no relationship between sigma and the other parameters. The depletion plots indicate some trajectories go extinct."</span></span>
<span id="cb87-1036"><a href="#cb87-1036" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1037"><a href="#cb87-1037" aria-hidden="true" tabindex="-1"></a> <span class="co">#asymptotically sampled parameter vectors  Fig 7.19 </span></span>
<span id="cb87-1038"><a href="#cb87-1038" aria-hidden="true" tabindex="-1"></a><span class="fu">pairs</span>(mvnpar,<span class="at">lower.panel=</span>panel.smooth, <span class="at">upper.panel=</span>panel.cor,       </span>
<span id="cb87-1039"><a href="#cb87-1039" aria-hidden="true" tabindex="-1"></a>      <span class="at">gap=</span><span class="dv">0</span>,<span class="at">cex=</span><span class="fl">0.25</span>,<span class="at">lwd=</span><span class="dv">2</span>)  </span>
<span id="cb87-1040"><a href="#cb87-1040" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-1041"><a href="#cb87-1041" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1042"><a href="#cb87-1042" aria-hidden="true" tabindex="-1"></a>我们可以比较自举抽样和渐近误差抽样的参数值范围。来自渐近误差分布的参数样本比来自自举法的样本偏度小，但自举法对于 $B_{init}$ 和 $K$ 的值没有那么低。需要记住的是，使用多元正态分布来描述围绕最优参数集的似然曲面的形状仍然只是一个近似值。</span>
<span id="cb87-1043"><a href="#cb87-1043" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1046"><a href="#cb87-1046" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-1047"><a href="#cb87-1047" aria-hidden="true" tabindex="-1"></a> <span class="co"># Get the ranges of parameters from bootstrap and asymptotic  </span></span>
<span id="cb87-1048"><a href="#cb87-1048" aria-hidden="true" tabindex="-1"></a>bt <span class="ot">&lt;-</span> <span class="fu">apply</span>(bootpar,<span class="dv">2</span>,range)[,<span class="fu">c</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">7</span>)]     </span>
<span id="cb87-1049"><a href="#cb87-1049" aria-hidden="true" tabindex="-1"></a>ay <span class="ot">&lt;-</span> <span class="fu">apply</span>(mvnpar,<span class="dv">2</span>,range)  </span>
<span id="cb87-1050"><a href="#cb87-1050" aria-hidden="true" tabindex="-1"></a>out <span class="ot">&lt;-</span> <span class="fu">rbind</span>(bt,ay)  </span>
<span id="cb87-1051"><a href="#cb87-1051" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(out) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"MinBoot"</span>,<span class="st">"MaxBoot"</span>,<span class="st">"MinAsym"</span>,<span class="st">"MaxAsym"</span>)  </span>
<span id="cb87-1052"><a href="#cb87-1052" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-1053"><a href="#cb87-1053" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1056"><a href="#cb87-1056" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-1057"><a href="#cb87-1057" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-spm7</span></span>
<span id="cb87-1058"><a href="#cb87-1058" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: "自举取样与渐近误差取样的参数值范围对比。The range of parameter values from the bootstrap sampling compared with those from the Asymptotic Error sampling."</span></span>
<span id="cb87-1059"><a href="#cb87-1059" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb87-1060"><a href="#cb87-1060" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1061"><a href="#cb87-1061" aria-hidden="true" tabindex="-1"></a>knitr<span class="sc">::</span><span class="fu">kable</span>(out, <span class="at">digits =</span> <span class="dv">4</span>)</span>
<span id="cb87-1062"><a href="#cb87-1062" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-1063"><a href="#cb87-1063" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1064"><a href="#cb87-1064" aria-hidden="true" tabindex="-1"></a><span class="fu">### 有时渐近误差起作用</span></span>
<span id="cb87-1065"><a href="#cb87-1065" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1066"><a href="#cb87-1066" aria-hidden="true" tabindex="-1"></a>在某些情况下，渐近误差法得到的结果与自举法的结果非常相似。如果我们使用的是 *abdat* 数据而不是 *dataspm* 数据，我们得到的结果与使用自举法得到的结果似乎没有什么区别（比较见 “不确定 性 ”一章中的自举法部分）。生成的轨迹看起来非常相似（@fig-spm20），而且成对图几乎没有区别。与 “关于不确定性 ”的自举示例一样，我们使用了 <span class="in">`rgb()`</span> 着色以方便比较（@fig-spm21）。</span>
<span id="cb87-1067"><a href="#cb87-1067" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1070"><a href="#cb87-1070" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-1071"><a href="#cb87-1071" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-spm20</span></span>
<span id="cb87-1072"><a href="#cb87-1072" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "利用渐近误差为 abdat 数据集生成可信的参数集及其隐含的 cpue 轨迹。最佳拟合模型以白线表示。The use of asymptotic errors to generate plausible parameter sets and their implied cpue trajectories for the abdat data-set. The optimum model fit is shown as a white line."</span></span>
<span id="cb87-1073"><a href="#cb87-1073" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1074"><a href="#cb87-1074" aria-hidden="true" tabindex="-1"></a><span class="co">#repeat asymptotice errors using abdat data-set Figure 7.20  </span></span>
<span id="cb87-1075"><a href="#cb87-1075" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(abdat)  </span>
<span id="cb87-1076"><a href="#cb87-1076" aria-hidden="true" tabindex="-1"></a>fish <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>(abdat)  </span>
<span id="cb87-1077"><a href="#cb87-1077" aria-hidden="true" tabindex="-1"></a>pars <span class="ot">&lt;-</span> <span class="fu">log</span>(<span class="fu">c</span>(<span class="at">r=</span><span class="fl">0.4</span>,<span class="at">K=</span><span class="dv">9400</span>,<span class="at">Binit=</span><span class="dv">3400</span>,<span class="at">sigma=</span><span class="fl">0.05</span>))  </span>
<span id="cb87-1078"><a href="#cb87-1078" aria-hidden="true" tabindex="-1"></a>ansA <span class="ot">&lt;-</span> <span class="fu">fitSPM</span>(pars,fish,<span class="at">schaefer=</span><span class="cn">TRUE</span>,<span class="at">maxiter=</span><span class="dv">1000</span>,<span class="at">hess=</span><span class="cn">TRUE</span>)   </span>
<span id="cb87-1079"><a href="#cb87-1079" aria-hidden="true" tabindex="-1"></a>vcovA <span class="ot">&lt;-</span> <span class="fu">solve</span>(ansA<span class="sc">$</span>hessian) <span class="co"># calculate var-covar matrix  </span></span>
<span id="cb87-1080"><a href="#cb87-1080" aria-hidden="true" tabindex="-1"></a>mvn <span class="ot">&lt;-</span> <span class="fu">length</span>(fish[,<span class="st">"year"</span>])  </span>
<span id="cb87-1081"><a href="#cb87-1081" aria-hidden="true" tabindex="-1"></a>N <span class="ot">&lt;-</span> <span class="dv">1000</span>   <span class="co"># replicates  </span></span>
<span id="cb87-1082"><a href="#cb87-1082" aria-hidden="true" tabindex="-1"></a>mvncpueA <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="dv">0</span>,<span class="at">nrow=</span>N,<span class="at">ncol=</span>mvn,<span class="at">dimnames=</span><span class="fu">list</span>(<span class="dv">1</span><span class="sc">:</span>N,fish[,<span class="st">"year"</span>]))  </span>
<span id="cb87-1083"><a href="#cb87-1083" aria-hidden="true" tabindex="-1"></a>columns <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"r"</span>,<span class="st">"K"</span>,<span class="st">"Binit"</span>,<span class="st">"sigma"</span>)  </span>
<span id="cb87-1084"><a href="#cb87-1084" aria-hidden="true" tabindex="-1"></a>optparA <span class="ot">&lt;-</span> ansA<span class="sc">$</span>estimate  <span class="co"># Fill matrix of parameter vectors   </span></span>
<span id="cb87-1085"><a href="#cb87-1085" aria-hidden="true" tabindex="-1"></a>mvnparA <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">exp</span>(<span class="fu">rmvnorm</span>(N,<span class="at">mean=</span>optparA,<span class="at">sigma=</span>vcovA)),  </span>
<span id="cb87-1086"><a href="#cb87-1086" aria-hidden="true" tabindex="-1"></a>                  <span class="at">nrow=</span>N,<span class="at">ncol=</span><span class="dv">4</span>,<span class="at">dimnames=</span><span class="fu">list</span>(<span class="dv">1</span><span class="sc">:</span>N,columns))  </span>
<span id="cb87-1087"><a href="#cb87-1087" aria-hidden="true" tabindex="-1"></a>msy <span class="ot">&lt;-</span> mvnparA[,<span class="st">"r"</span>]<span class="sc">*</span>mvnparA[,<span class="st">"K"</span>]<span class="sc">/</span><span class="dv">4</span>  </span>
<span id="cb87-1088"><a href="#cb87-1088" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>N) mvncpueA[i,]<span class="ot">&lt;-</span><span class="fu">exp</span>(<span class="fu">simpspm</span>(<span class="fu">log</span>(mvnparA[i,]),fish))  </span>
<span id="cb87-1089"><a href="#cb87-1089" aria-hidden="true" tabindex="-1"></a>mvnparA <span class="ot">&lt;-</span> <span class="fu">cbind</span>(mvnparA,msy)  </span>
<span id="cb87-1090"><a href="#cb87-1090" aria-hidden="true" tabindex="-1"></a><span class="fu">plot1</span>(fish[,<span class="st">"year"</span>],fish[,<span class="st">"cpue"</span>],<span class="at">type=</span><span class="st">"p"</span>,<span class="at">xlab=</span><span class="st">"Year"</span>,<span class="at">ylab=</span><span class="st">"CPUE"</span>,  </span>
<span id="cb87-1091"><a href="#cb87-1091" aria-hidden="true" tabindex="-1"></a>      <span class="at">maxy=</span><span class="fl">2.5</span>)  </span>
<span id="cb87-1092"><a href="#cb87-1092" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>N) <span class="fu">lines</span>(fish[,<span class="st">"year"</span>],mvncpueA[i,],<span class="at">col=</span><span class="dv">8</span>,<span class="at">lwd=</span><span class="dv">1</span>)  </span>
<span id="cb87-1093"><a href="#cb87-1093" aria-hidden="true" tabindex="-1"></a><span class="fu">points</span>(fish[,<span class="st">"year"</span>],fish[,<span class="st">"cpue"</span>],<span class="at">pch=</span><span class="dv">16</span>,<span class="at">cex=</span><span class="fl">1.0</span>) <span class="co">#orig data  </span></span>
<span id="cb87-1094"><a href="#cb87-1094" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(fish[,<span class="st">"year"</span>],<span class="fu">exp</span>(<span class="fu">simpspm</span>(optparA,fish)),<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">0</span>)     </span>
<span id="cb87-1095"><a href="#cb87-1095" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-1096"><a href="#cb87-1096" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1099"><a href="#cb87-1099" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-1100"><a href="#cb87-1100" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-spm21</span></span>
<span id="cb87-1101"><a href="#cb87-1101" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "将 Schaefer 模型拟合到 abdat 数据并使用多变量正态分布生成后续参数组合时的模型参数关系。这与 “不确定性 ”一章中的自举法非常相似。Model parameter relationships when fitting the Schaefer model to the abdat data and using the multi-variate normal distribution to generate subsequent parameter combinations. These are very similar to the bootstrap equivalent in the On Uncertainty chapter."</span></span>
<span id="cb87-1102"><a href="#cb87-1102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1103"><a href="#cb87-1103" aria-hidden="true" tabindex="-1"></a> <span class="co">#plot asymptotically sampled parameter vectors Figure 7.21  </span></span>
<span id="cb87-1104"><a href="#cb87-1104" aria-hidden="true" tabindex="-1"></a><span class="fu">pairs</span>(mvnparA,<span class="at">lower.panel=</span>panel.smooth, <span class="at">upper.panel=</span>panel.cor,  </span>
<span id="cb87-1105"><a href="#cb87-1105" aria-hidden="true" tabindex="-1"></a>      <span class="at">gap=</span><span class="dv">0</span>,<span class="at">pch=</span><span class="dv">16</span>,<span class="at">col=</span><span class="fu">rgb</span>(<span class="at">red=</span><span class="dv">0</span>,<span class="at">green=</span><span class="dv">0</span>,<span class="at">blue=</span><span class="dv">0</span>,<span class="at">alpha =</span> <span class="dv">1</span><span class="sc">/</span><span class="dv">10</span>))  </span>
<span id="cb87-1106"><a href="#cb87-1106" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-1107"><a href="#cb87-1107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1108"><a href="#cb87-1108" aria-hidden="true" tabindex="-1"></a><span class="fu">### 贝叶斯后验</span></span>
<span id="cb87-1109"><a href="#cb87-1109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1110"><a href="#cb87-1110" aria-hidden="true" tabindex="-1"></a>在 *“不确定性 ”* 一章中，我们已经看到可以使用马尔可夫链蒙特卡罗（MCMC）分析来描述给定分析中固有的不确定性。在这里，我们将再次使用 *abdat* 数据集，因为它提供了一个表现良好的数据实例，该数据集导致了一个相对紧密拟合的模型和一个表现良好的 MCMC 分析。关于*“不确定性”*一章中给出了吉布斯-内大都会-哈斯丁（Gibbs-within-Metropolis-Hastings）（或单分量大都会-哈斯丁Metropolis-Hastings）策略背后的方程式。这些都在 <span class="in">`do_MCMC()`</span> 函数中实现。要使用该函数，首先要有一个基于最大似然法的最优拟合模型。这次我们将使用 Fox 模型选项。</span>
<span id="cb87-1111"><a href="#cb87-1111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1114"><a href="#cb87-1114" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-1115"><a href="#cb87-1115" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-spm22</span></span>
<span id="cb87-1116"><a href="#cb87-1116" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "使用 Fox 模型和对数正态误差拟合的 abdat 数据集最佳模型。绿色虚线是较平滑的曲线，红线是最佳预测模型拟合。请注意对数正态残差的模式，这表明该模型在该数据方面存在微小不足。The optimum model fit for the abdat data-set using the Fox model and log-normal errors. The green dashed line is a smoother curve while the red line is the optimum predicted model fit. Note the pattern in the log-normal residuals indicating that the model has small inadequacies with regard to this data."</span></span>
<span id="cb87-1117"><a href="#cb87-1117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1118"><a href="#cb87-1118" aria-hidden="true" tabindex="-1"></a>  <span class="co">#Fit the Fox Model to the abdat data Figure 7.22  </span></span>
<span id="cb87-1119"><a href="#cb87-1119" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(abdat); fish <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>(abdat)  </span>
<span id="cb87-1120"><a href="#cb87-1120" aria-hidden="true" tabindex="-1"></a>param <span class="ot">&lt;-</span> <span class="fu">log</span>(<span class="fu">c</span>(<span class="at">r=</span><span class="fl">0.3</span>,<span class="at">K=</span><span class="dv">11500</span>,<span class="at">Binit=</span><span class="dv">3300</span>,<span class="at">sigma=</span><span class="fl">0.05</span>))  </span>
<span id="cb87-1121"><a href="#cb87-1121" aria-hidden="true" tabindex="-1"></a>foxmod <span class="ot">&lt;-</span> <span class="fu">nlm</span>(<span class="at">f=</span>negLL1,<span class="at">p=</span>param,<span class="at">funk=</span>simpspm,<span class="at">indat=</span>fish,  </span>
<span id="cb87-1122"><a href="#cb87-1122" aria-hidden="true" tabindex="-1"></a>              <span class="at">logobs=</span><span class="fu">log</span>(fish[,<span class="st">"cpue"</span>]),<span class="at">iterlim=</span><span class="dv">1000</span>,<span class="at">schaefer=</span><span class="cn">FALSE</span>)  </span>
<span id="cb87-1123"><a href="#cb87-1123" aria-hidden="true" tabindex="-1"></a>optpar <span class="ot">&lt;-</span> <span class="fu">exp</span>(foxmod<span class="sc">$</span>estimate)  </span>
<span id="cb87-1124"><a href="#cb87-1124" aria-hidden="true" tabindex="-1"></a>ans <span class="ot">&lt;-</span> <span class="fu">plotspmmod</span>(<span class="at">inp=</span>foxmod<span class="sc">$</span>estimate,<span class="at">indat=</span>fish,<span class="at">schaefer=</span><span class="cn">FALSE</span>,  </span>
<span id="cb87-1125"><a href="#cb87-1125" aria-hidden="true" tabindex="-1"></a>                 <span class="at">addrmse=</span><span class="cn">TRUE</span>, <span class="at">plotprod=</span><span class="cn">TRUE</span>)  </span>
<span id="cb87-1126"><a href="#cb87-1126" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-1127"><a href="#cb87-1127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1128"><a href="#cb87-1128" aria-hidden="true" tabindex="-1"></a>由于最优解将接近后验模式，我们不再需要说明预演期的概念，但理想情况下，我们并不希望完全从最大似然解出发。因此，我们可以舍弃最优解，对马尔可夫链进行预烧，使参数集序列进入可信组合的范围。我们知道 $r$ 和 $K$ 参数之间有很强的相关性，因此我们可以使用 128（$4 \times 128 = 512$）的初始步长来减少任何连续接受值之间的自相关性，但这也会受到参数迭代之间跳跃的相对比例的影响。在这里，我们从 1% 到 2%之间的值开始，并尝试使用这些值，直到接受率介于 0.2 和 0.4 之间。最好使用较小的 N 值（使用 512 的稀疏度，即使 1000 也是 50 万次迭代）。只有当刻度设置得当时，才能将重复次数 N 扩大到更大的数目，以获得更清晰的结果。我们将继续使用 **MQMF** 函数 `calcprior()`，对每组可信参数设置同等权重，为了获得可重复的结果，需要在每条链上调用 `set.seed()`，但一般情况下我们不会这样做。在 R 中，所有操作系统都使用相同的随机数生成器，因此这应该可以在不同的计算机上运行，但我还没有在所有版本上都试过。为了提高计算速度，最好能有类似于 *“不确定性 ”*一章中描述的使用 **Rcpp** 的 <span class="in">`simpspmC()`</span> 函数。在运行下面的 MCMC 之前，你需要编译本章的附录，或者在使用 <span class="in">`do_MCMC()`</span> 时调用 <span class="in">`simpspm()`</span>，注意为了使用 Fox 模型，需要加入 *schaefer=FALSE* 参数。</span>
<span id="cb87-1129"><a href="#cb87-1129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1132"><a href="#cb87-1132" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-1133"><a href="#cb87-1133" aria-hidden="true" tabindex="-1"></a><span class="co">#|echo: false</span></span>
<span id="cb87-1134"><a href="#cb87-1134" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1135"><a href="#cb87-1135" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(Rcpp)  </span>
<span id="cb87-1136"><a href="#cb87-1136" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb87-1137"><a href="#cb87-1137" aria-hidden="true" tabindex="-1"></a><span class="fu">cppFunction</span>(<span class="st">'NumericVector simpspmC(NumericVector pars,   </span></span>
<span id="cb87-1138"><a href="#cb87-1138" aria-hidden="true" tabindex="-1"></a><span class="st">             NumericMatrix indat, LogicalVector schaefer) {  </span></span>
<span id="cb87-1139"><a href="#cb87-1139" aria-hidden="true" tabindex="-1"></a><span class="st">   int nyrs = indat.nrow();  </span></span>
<span id="cb87-1140"><a href="#cb87-1140" aria-hidden="true" tabindex="-1"></a><span class="st">   NumericVector predce(nyrs);  </span></span>
<span id="cb87-1141"><a href="#cb87-1141" aria-hidden="true" tabindex="-1"></a><span class="st">   NumericVector biom(nyrs+1);  </span></span>
<span id="cb87-1142"><a href="#cb87-1142" aria-hidden="true" tabindex="-1"></a><span class="st">   double Bt, qval;  </span></span>
<span id="cb87-1143"><a href="#cb87-1143" aria-hidden="true" tabindex="-1"></a><span class="st">   double sumq = 0.0;  </span></span>
<span id="cb87-1144"><a href="#cb87-1144" aria-hidden="true" tabindex="-1"></a><span class="st">   double p = 0.00000001;  </span></span>
<span id="cb87-1145"><a href="#cb87-1145" aria-hidden="true" tabindex="-1"></a><span class="st">   if (schaefer(0) == TRUE) {  </span></span>
<span id="cb87-1146"><a href="#cb87-1146" aria-hidden="true" tabindex="-1"></a><span class="st">     p = 1.0;  </span></span>
<span id="cb87-1147"><a href="#cb87-1147" aria-hidden="true" tabindex="-1"></a><span class="st">   }  </span></span>
<span id="cb87-1148"><a href="#cb87-1148" aria-hidden="true" tabindex="-1"></a><span class="st">   NumericVector ep = exp(pars);  </span></span>
<span id="cb87-1149"><a href="#cb87-1149" aria-hidden="true" tabindex="-1"></a><span class="st">   biom[0] = ep[2];  </span></span>
<span id="cb87-1150"><a href="#cb87-1150" aria-hidden="true" tabindex="-1"></a><span class="st">   for (int i = 0; i &lt; nyrs; i++) {  </span></span>
<span id="cb87-1151"><a href="#cb87-1151" aria-hidden="true" tabindex="-1"></a><span class="st">      Bt = biom[i];  </span></span>
<span id="cb87-1152"><a href="#cb87-1152" aria-hidden="true" tabindex="-1"></a><span class="st">      biom[(i+1)] = Bt + (ep[0]/p)*Bt*(1 - pow((Bt/ep[1]),p)) -   </span></span>
<span id="cb87-1153"><a href="#cb87-1153" aria-hidden="true" tabindex="-1"></a><span class="st">                          indat(i,1);  </span></span>
<span id="cb87-1154"><a href="#cb87-1154" aria-hidden="true" tabindex="-1"></a><span class="st">      if (biom[(i+1)] &lt; 40.0) biom[(i+1)] = 40.0;  </span></span>
<span id="cb87-1155"><a href="#cb87-1155" aria-hidden="true" tabindex="-1"></a><span class="st">      sumq += log(indat(i,2)/biom[i]);  </span></span>
<span id="cb87-1156"><a href="#cb87-1156" aria-hidden="true" tabindex="-1"></a><span class="st">    }  </span></span>
<span id="cb87-1157"><a href="#cb87-1157" aria-hidden="true" tabindex="-1"></a><span class="st">    qval = exp(sumq/nyrs);  </span></span>
<span id="cb87-1158"><a href="#cb87-1158" aria-hidden="true" tabindex="-1"></a><span class="st">    for (int i = 0; i &lt; nyrs; i++) {  </span></span>
<span id="cb87-1159"><a href="#cb87-1159" aria-hidden="true" tabindex="-1"></a><span class="st">      predce[i] = log(biom[i] * qval);  </span></span>
<span id="cb87-1160"><a href="#cb87-1160" aria-hidden="true" tabindex="-1"></a><span class="st">    }  </span></span>
<span id="cb87-1161"><a href="#cb87-1161" aria-hidden="true" tabindex="-1"></a><span class="st">    return predce;  </span></span>
<span id="cb87-1162"><a href="#cb87-1162" aria-hidden="true" tabindex="-1"></a><span class="st">}'</span>)  </span>
<span id="cb87-1163"><a href="#cb87-1163" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-1164"><a href="#cb87-1164" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1167"><a href="#cb87-1167" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-1168"><a href="#cb87-1168" aria-hidden="true" tabindex="-1"></a><span class="co"># eval: false</span></span>
<span id="cb87-1169"><a href="#cb87-1169" aria-hidden="true" tabindex="-1"></a> <span class="co"># Conduct an MCMC using simpspmC on the abdat Fox SPM  </span></span>
<span id="cb87-1170"><a href="#cb87-1170" aria-hidden="true" tabindex="-1"></a> <span class="co"># This means you will need to compile simpspmC from appendix  </span></span>
<span id="cb87-1171"><a href="#cb87-1171" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">698381</span>) <span class="co">#for repeatability, possibly only on Windows10  </span></span>
<span id="cb87-1172"><a href="#cb87-1172" aria-hidden="true" tabindex="-1"></a>begin <span class="ot">&lt;-</span> <span class="fu">gettime</span>()  <span class="co"># to enable the time taken to be calculated  </span></span>
<span id="cb87-1173"><a href="#cb87-1173" aria-hidden="true" tabindex="-1"></a>inscale <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.07</span>,<span class="fl">0.05</span>,<span class="fl">0.09</span>,<span class="fl">0.45</span>) <span class="co">#note large value for sigma  </span></span>
<span id="cb87-1174"><a href="#cb87-1174" aria-hidden="true" tabindex="-1"></a>pars <span class="ot">&lt;-</span> <span class="fu">log</span>(<span class="fu">c</span>(<span class="at">r=</span><span class="fl">0.205</span>,<span class="at">K=</span><span class="dv">11300</span>,<span class="at">Binit=</span><span class="dv">3200</span>,<span class="at">sigma=</span><span class="fl">0.044</span>))  </span>
<span id="cb87-1175"><a href="#cb87-1175" aria-hidden="true" tabindex="-1"></a>result <span class="ot">&lt;-</span> <span class="fu">do_MCMC</span>(<span class="at">chains=</span><span class="dv">1</span>,<span class="at">burnin=</span><span class="dv">50</span>,<span class="at">N=</span><span class="dv">2000</span>,<span class="at">thinstep=</span><span class="dv">512</span>,  </span>
<span id="cb87-1176"><a href="#cb87-1176" aria-hidden="true" tabindex="-1"></a>                  <span class="at">inpar=</span>pars,<span class="at">infunk=</span>negLL,<span class="at">calcpred=</span>simpspm,  </span>
<span id="cb87-1177"><a href="#cb87-1177" aria-hidden="true" tabindex="-1"></a>                  <span class="at">obsdat=</span><span class="fu">log</span>(fish[,<span class="st">"cpue"</span>]),<span class="at">calcdat=</span>fish,  </span>
<span id="cb87-1178"><a href="#cb87-1178" aria-hidden="true" tabindex="-1"></a>                  <span class="at">priorcalc=</span>calcprior,<span class="at">scales=</span>inscale,<span class="at">schaefer=</span><span class="cn">FALSE</span>)  </span>
<span id="cb87-1179"><a href="#cb87-1179" aria-hidden="true" tabindex="-1"></a> <span class="co"># alternatively, use simpspm, but that will take longer.   </span></span>
<span id="cb87-1180"><a href="#cb87-1180" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"acceptance rate = "</span>,result<span class="sc">$</span>arate,<span class="st">" </span><span class="sc">\n</span><span class="st">"</span>)  </span>
<span id="cb87-1181"><a href="#cb87-1181" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"time = "</span>,<span class="fu">gettime</span>() <span class="sc">-</span> begin,<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)  </span>
<span id="cb87-1182"><a href="#cb87-1182" aria-hidden="true" tabindex="-1"></a>post1 <span class="ot">&lt;-</span> result[[<span class="dv">1</span>]][[<span class="dv">1</span>]]  </span>
<span id="cb87-1183"><a href="#cb87-1183" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> <span class="fl">1e-08</span>  </span>
<span id="cb87-1184"><a href="#cb87-1184" aria-hidden="true" tabindex="-1"></a>msy <span class="ot">&lt;-</span> post1[,<span class="st">"r"</span>]<span class="sc">*</span>post1[,<span class="st">"K"</span>]<span class="sc">/</span>((p <span class="sc">+</span> <span class="dv">1</span>)<span class="sc">^</span>((p<span class="sc">+</span><span class="dv">1</span>)<span class="sc">/</span>p))   </span>
<span id="cb87-1185"><a href="#cb87-1185" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-1186"><a href="#cb87-1186" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1187"><a href="#cb87-1187" aria-hidden="true" tabindex="-1"></a>Fox 模型 MCMC 目前设置为 512 的稀释率、2000 次重复和 50 次老化，这意味着将有 $512 \times 2050 = 1049600$ 次迭代用于生成所需的参数跟踪。在用于编写此内容的计算机上，即使使用 ，这大约需要 15 秒;使用 <span class="in">`simpspm()`</span> 可能预计大约需要 75 秒。一旦知道了自己的系统的情况，显然可以计划分析，并对稀释速率和重复做出明确的选择（不要忘记使用最新版本的 R 以获得最快的时间）。</span>
<span id="cb87-1188"><a href="#cb87-1188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1189"><a href="#cb87-1189" aria-hidden="true" tabindex="-1"></a>分析完成后，我们可以使用 <span class="in">`pairs()`</span> 函数绘制每个变量与其他变量的对比图（@fig-spm23）。此外，我们还可以绘制每个主要参数的边际后验分布图和推导出的模型输出（MSY）。由于我们使用了 2000 个重复样本，并采用了 512 的样本链稀疏率（@fig-spm24），因此后验分布相对平滑。</span>
<span id="cb87-1190"><a href="#cb87-1190" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1193"><a href="#cb87-1193" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-1194"><a href="#cb87-1194" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-spm23</span></span>
<span id="cb87-1195"><a href="#cb87-1195" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "MCMC 输出的成对散点图。实线是表示趋势的塬平滑线，上半部分的数字是成对散点图之间的相关系数。r、K 和 Binit 之间，以及 K、Binit 和 MSY 之间都有很强的相关性，而 sigma 与其他参数或 msy 与 r 之间的关系较小或没有关系。MCMC output as paired scattergrams. The solid lines are loess smoothers indicating trends and the numbers in the upper half are the correlation coefficients between the pairs. Strong correlations are indicated between r, K, and Binit, and between K, Binit, and MSY, with only minor or no relationships between sigma the other parameters or between msy and r."</span></span>
<span id="cb87-1196"><a href="#cb87-1196" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1197"><a href="#cb87-1197" aria-hidden="true" tabindex="-1"></a> <span class="co">#pairwise comparison for MCMC of Fox model on abdat  Fig 7.23   </span></span>
<span id="cb87-1198"><a href="#cb87-1198" aria-hidden="true" tabindex="-1"></a><span class="fu">pairs</span>(<span class="fu">cbind</span>(post1[,<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>],msy),<span class="at">upper.panel =</span> panel.cor,<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">cex=</span><span class="fl">0.2</span>,    </span>
<span id="cb87-1199"><a href="#cb87-1199" aria-hidden="true" tabindex="-1"></a>      <span class="at">lower.panel=</span>panel.smooth,<span class="at">col=</span><span class="dv">1</span>,<span class="at">gap=</span><span class="fl">0.1</span>)  </span>
<span id="cb87-1200"><a href="#cb87-1200" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-1201"><a href="#cb87-1201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1204"><a href="#cb87-1204" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-1205"><a href="#cb87-1205" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-spm24</span></span>
<span id="cb87-1206"><a href="#cb87-1206" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "将 Fox 模型应用于鳕鱼数据的 2000 次 MCMC 重复计算得出的三个参数的边际分布和隐含的 MSY。曲线的块状表明需要进行 2000 次以上的迭代。The marginal distributions for three parameters and the implied MSY from 2000 MCMC replicates for the Fox model applied to the abdat data. The lumpiness of the curves suggests more than 2000 iterations are needed."</span></span>
<span id="cb87-1207"><a href="#cb87-1207" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1208"><a href="#cb87-1208" aria-hidden="true" tabindex="-1"></a>  <span class="co"># marginal distributions of 3 parameters and msy  Figure 7.24  </span></span>
<span id="cb87-1209"><a href="#cb87-1209" aria-hidden="true" tabindex="-1"></a><span class="fu">parset</span>(<span class="at">plots=</span><span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">2</span>), <span class="at">cex=</span><span class="fl">0.85</span>)  </span>
<span id="cb87-1210"><a href="#cb87-1210" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">density</span>(post1[,<span class="st">"r"</span>]),<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">main=</span><span class="st">""</span>,<span class="at">xlab=</span><span class="st">"r"</span>) <span class="co">#plot has a method  </span></span>
<span id="cb87-1211"><a href="#cb87-1211" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">density</span>(post1[,<span class="st">"K"</span>]),<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">main=</span><span class="st">""</span>,<span class="at">xlab=</span><span class="st">"K"</span>)   <span class="co">#for output from  </span></span>
<span id="cb87-1212"><a href="#cb87-1212" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">density</span>(post1[,<span class="st">"Binit"</span>]),<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">main=</span><span class="st">""</span>,<span class="at">xlab=</span><span class="st">"Binit"</span>)  <span class="co"># density  </span></span>
<span id="cb87-1213"><a href="#cb87-1213" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">density</span>(msy),<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">main=</span><span class="st">""</span>,<span class="at">xlab=</span><span class="st">"MSY"</span>)   <span class="co">#try str(density(msy))   </span></span>
<span id="cb87-1214"><a href="#cb87-1214" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-1215"><a href="#cb87-1215" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1216"><a href="#cb87-1216" aria-hidden="true" tabindex="-1"></a>需要注意的是，要将 *sigma* 的接受率降到 0.4 以下，需要施加一个相对较大的比例因子。其他参数要求的值在 5% 到 9% 之间。如果使用 500 次重复来寻找合适的比例因子，然后将重复次数重设为 2000 次，那么整个过程所需的时间将是原来的四倍。如果再将步长增加到 1024 倍，那么所需的时间又会增加一倍。需要寻找适当的比例因子，以确保马尔可夫链在合理的时间内充分探索后验空间。如果比例因子太小，接受率就会增加，因为每次试验实际上都会非常接近原始试验，因此只能采取小步试验。静态分布最终仍会被发现，但可能需要大量的重复。在稀疏率为 512 的情况下，如果使用 <span class="in">`acf()`</span> 函数绘制任何迹线的自相关图，如 <span class="in">`acf(post1[, “r”])`</span>，就会发现在步长为 1 和 2 时仍然存在显著的相关性。要减少这种相关性，至少需要将步长增加到 1024 步。</span>
<span id="cb87-1217"><a href="#cb87-1217" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1218"><a href="#cb87-1218" aria-hidden="true" tabindex="-1"></a>随着重复次数的增加，观测到的潜在参数组合的分布范围也在扩大。但是，如果我们检查第 90 分位数等值线的边界，这些边界会保持相对稳定。我们可以使用 **MQMF** 函数 <span class="in">`addcontours()`</span> 在二维范围内进行检查，该函数可以为任意 x-y 数据点云生成等值线（任意但理想的平滑分布）。 2000 个观测点的第 50 和第 90 分位数等值线并不特别平滑，但即使是这样，$K$ 的边界也大约在 9500 - 14000 之间，$r$ 的边界大约在 0.17 - 0.24 之间（@fig-spm25）。随着数值的增加，等值线变得更加平滑，但其边界大致保持不变，即使在两种情况下 x 轴和 y 轴都有所延长。</span>
<span id="cb87-1219"><a href="#cb87-1219" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1222"><a href="#cb87-1222" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-1223"><a href="#cb87-1223" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-spm25</span></span>
<span id="cb87-1224"><a href="#cb87-1224" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "MCMC 边际分布输出为 r 和 K 参数以及 K 和 MSY 值的散点图。灰点是成功的候选参数向量，等值线是近似的第 50 和第 90 分位数。文中给出了全部可接受的参数迹线范围。MCMC marginal distributions output as a scattergram of the r and K parameters, and the K and MSY values. The grey dots are from successful candidate parameter vectors, while the contours are approximate 50th and 90th percentiles. The text give the full range of the accepted parameter traces."</span></span>
<span id="cb87-1225"><a href="#cb87-1225" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1226"><a href="#cb87-1226" aria-hidden="true" tabindex="-1"></a>  <span class="co">#MCMC r and K parameters, approx 50 + 90% contours. Fig7.25  </span></span>
<span id="cb87-1227"><a href="#cb87-1227" aria-hidden="true" tabindex="-1"></a>puttxt <span class="ot">&lt;-</span> <span class="cf">function</span>(xs,xvar,ys,yvar,lvar,<span class="at">lab=</span><span class="st">""</span>,<span class="at">sigd=</span><span class="dv">0</span>) {  </span>
<span id="cb87-1228"><a href="#cb87-1228" aria-hidden="true" tabindex="-1"></a>  <span class="fu">text</span>(xs<span class="sc">*</span>xvar[<span class="dv">2</span>],ys<span class="sc">*</span>yvar[<span class="dv">2</span>],<span class="fu">makelabel</span>(lab,lvar,<span class="at">sep=</span><span class="st">"  "</span>,  </span>
<span id="cb87-1229"><a href="#cb87-1229" aria-hidden="true" tabindex="-1"></a>       <span class="at">sigdig=</span>sigd),<span class="at">cex=</span><span class="fl">1.2</span>,<span class="at">font=</span><span class="dv">7</span>,<span class="at">pos=</span><span class="dv">4</span>)  </span>
<span id="cb87-1230"><a href="#cb87-1230" aria-hidden="true" tabindex="-1"></a>} <span class="co"># end of puttxt - a quick utility function  </span></span>
<span id="cb87-1231"><a href="#cb87-1231" aria-hidden="true" tabindex="-1"></a>kran <span class="ot">&lt;-</span> <span class="fu">range</span>(post1[,<span class="st">"K"</span>]);  rran <span class="ot">&lt;-</span> <span class="fu">range</span>(post1[,<span class="st">"r"</span>])  </span>
<span id="cb87-1232"><a href="#cb87-1232" aria-hidden="true" tabindex="-1"></a>mran <span class="ot">&lt;-</span> <span class="fu">range</span>(msy)         <span class="co">#ranges used in the plots  </span></span>
<span id="cb87-1233"><a href="#cb87-1233" aria-hidden="true" tabindex="-1"></a><span class="fu">parset</span>(<span class="at">plots=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>),<span class="at">margin=</span><span class="fu">c</span>(<span class="fl">0.35</span>,<span class="fl">0.35</span>,<span class="fl">0.05</span>,<span class="fl">0.1</span>)) <span class="co">#plot r vs K  </span></span>
<span id="cb87-1234"><a href="#cb87-1234" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(post1[,<span class="st">"K"</span>],post1[,<span class="st">"r"</span>],<span class="at">type=</span><span class="st">"p"</span>,<span class="at">cex=</span><span class="fl">0.5</span>,<span class="at">xlim=</span>kran,  </span>
<span id="cb87-1235"><a href="#cb87-1235" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylim=</span>rran,<span class="at">col=</span><span class="st">"grey"</span>,<span class="at">xlab=</span><span class="st">"K"</span>,<span class="at">ylab=</span><span class="st">"r"</span>,<span class="at">panel.first=</span><span class="fu">grid</span>())  </span>
<span id="cb87-1236"><a href="#cb87-1236" aria-hidden="true" tabindex="-1"></a><span class="fu">points</span>(optpar[<span class="dv">2</span>],optpar[<span class="dv">1</span>],<span class="at">pch=</span><span class="dv">16</span>,<span class="at">col=</span><span class="dv">1</span>,<span class="at">cex=</span><span class="fl">1.75</span>) <span class="co"># center  </span></span>
<span id="cb87-1237"><a href="#cb87-1237" aria-hidden="true" tabindex="-1"></a><span class="fu">addcontours</span>(post1[,<span class="st">"K"</span>],post1[,<span class="st">"r"</span>],kran,rran,  <span class="co">#if fails make  </span></span>
<span id="cb87-1238"><a href="#cb87-1238" aria-hidden="true" tabindex="-1"></a>            <span class="at">contval=</span><span class="fu">c</span>(<span class="fl">0.5</span>,<span class="fl">0.9</span>),<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">1</span>)   <span class="co">#contval smaller  </span></span>
<span id="cb87-1239"><a href="#cb87-1239" aria-hidden="true" tabindex="-1"></a><span class="fu">puttxt</span>(<span class="fl">0.7</span>,kran,<span class="fl">0.97</span>,rran,kran,<span class="st">"K= "</span>,<span class="at">sigd=</span><span class="dv">0</span>)  </span>
<span id="cb87-1240"><a href="#cb87-1240" aria-hidden="true" tabindex="-1"></a><span class="fu">puttxt</span>(<span class="fl">0.7</span>,kran,<span class="fl">0.94</span>,rran,rran,<span class="st">"r= "</span>,<span class="at">sigd=</span><span class="dv">4</span>)  </span>
<span id="cb87-1241"><a href="#cb87-1241" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(post1[,<span class="st">"K"</span>],msy,<span class="at">type=</span><span class="st">"p"</span>,<span class="at">cex=</span><span class="fl">0.5</span>,<span class="at">xlim=</span>kran,  <span class="co"># K vs msy  </span></span>
<span id="cb87-1242"><a href="#cb87-1242" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylim=</span>mran,<span class="at">col=</span><span class="st">"grey"</span>,<span class="at">xlab=</span><span class="st">"K"</span>,<span class="at">ylab=</span><span class="st">"MSY"</span>,<span class="at">panel.first=</span><span class="fu">grid</span>())  </span>
<span id="cb87-1243"><a href="#cb87-1243" aria-hidden="true" tabindex="-1"></a><span class="fu">points</span>(optpar[<span class="dv">2</span>],<span class="fu">getMSY</span>(optpar,p),<span class="at">pch=</span><span class="dv">16</span>,<span class="at">col=</span><span class="dv">1</span>,<span class="at">cex=</span><span class="fl">1.75</span>)<span class="co">#center  </span></span>
<span id="cb87-1244"><a href="#cb87-1244" aria-hidden="true" tabindex="-1"></a><span class="fu">addcontours</span>(post1[,<span class="st">"K"</span>],msy,kran,mran,<span class="at">contval=</span><span class="fu">c</span>(<span class="fl">0.5</span>,<span class="fl">0.9</span>),<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">1</span>)  </span>
<span id="cb87-1245"><a href="#cb87-1245" aria-hidden="true" tabindex="-1"></a><span class="fu">puttxt</span>(<span class="fl">0.6</span>,kran,<span class="fl">0.99</span>,mran,kran,<span class="st">"K= "</span>,<span class="at">sigd=</span><span class="dv">0</span>)  </span>
<span id="cb87-1246"><a href="#cb87-1246" aria-hidden="true" tabindex="-1"></a><span class="fu">puttxt</span>(<span class="fl">0.6</span>,kran,<span class="fl">0.97</span>,mran,mran,<span class="st">"MSY= "</span>,<span class="at">sigd=</span><span class="dv">3</span>)  </span>
<span id="cb87-1247"><a href="#cb87-1247" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-1248"><a href="#cb87-1248" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1249"><a href="#cb87-1249" aria-hidden="true" tabindex="-1"></a>最后，我们可以绘制 2000 个重复中每个重复的单个迹线。这表明，即使具有平滑的边际分布，偶尔也会出现参数值的峰值，以说明主要参数之间的强负相关。</span>
<span id="cb87-1250"><a href="#cb87-1250" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1253"><a href="#cb87-1253" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-1254"><a href="#cb87-1254" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fit-spm26</span></span>
<span id="cb87-1255"><a href="#cb87-1255" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "三个主要 Schaefer 模型参数和 MSY 估计值的迹线。如果细化步长增加到 1024 步或更长，迹线内剩余的自相关性应得到改善。The traces for the three main Schaefer model parameters and the MSY estimates. The remaining auto-correlation within traces should be improved if the thinning step were increased to 1024 or longer."</span></span>
<span id="cb87-1256"><a href="#cb87-1256" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb87-1257"><a href="#cb87-1257" aria-hidden="true" tabindex="-1"></a>  <span class="co">#Traces for the Fox model parameters from the MCMC  Fig7.26  </span></span>
<span id="cb87-1258"><a href="#cb87-1258" aria-hidden="true" tabindex="-1"></a><span class="fu">parset</span>(<span class="at">plots=</span><span class="fu">c</span>(<span class="dv">4</span>,<span class="dv">1</span>),<span class="at">margin=</span><span class="fu">c</span>(<span class="fl">0.3</span>,<span class="fl">0.45</span>,<span class="fl">0.05</span>,<span class="fl">0.05</span>),  </span>
<span id="cb87-1259"><a href="#cb87-1259" aria-hidden="true" tabindex="-1"></a>       <span class="at">outmargin =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>),<span class="at">cex=</span><span class="fl">0.85</span>)  </span>
<span id="cb87-1260"><a href="#cb87-1260" aria-hidden="true" tabindex="-1"></a>label <span class="ot">&lt;-</span> <span class="fu">colnames</span>(post1)  </span>
<span id="cb87-1261"><a href="#cb87-1261" aria-hidden="true" tabindex="-1"></a>N <span class="ot">&lt;-</span> <span class="fu">dim</span>(post1)[<span class="dv">1</span>]  </span>
<span id="cb87-1262"><a href="#cb87-1262" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>) {  </span>
<span id="cb87-1263"><a href="#cb87-1263" aria-hidden="true" tabindex="-1"></a>  <span class="fu">plot</span>(<span class="dv">1</span><span class="sc">:</span>N,post1[,i],<span class="at">type=</span><span class="st">"l"</span>,<span class="at">lwd=</span><span class="dv">1</span>,<span class="at">ylab=</span>label[i],<span class="at">xlab=</span><span class="st">""</span>)  </span>
<span id="cb87-1264"><a href="#cb87-1264" aria-hidden="true" tabindex="-1"></a>  <span class="fu">abline</span>(<span class="at">h=</span><span class="fu">median</span>(post1[,i]),<span class="at">col=</span><span class="dv">2</span>)  </span>
<span id="cb87-1265"><a href="#cb87-1265" aria-hidden="true" tabindex="-1"></a>}  </span>
<span id="cb87-1266"><a href="#cb87-1266" aria-hidden="true" tabindex="-1"></a>msy <span class="ot">&lt;-</span> post1[,<span class="dv">1</span>]<span class="sc">*</span>post1[,<span class="dv">2</span>]<span class="sc">/</span><span class="dv">4</span>  </span>
<span id="cb87-1267"><a href="#cb87-1267" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="dv">1</span><span class="sc">:</span>N,msy,<span class="at">type=</span><span class="st">"l"</span>,<span class="at">lwd=</span><span class="dv">1</span>,<span class="at">ylab=</span><span class="st">"MSY"</span>,<span class="at">xlab=</span><span class="st">""</span>)  </span>
<span id="cb87-1268"><a href="#cb87-1268" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">h=</span><span class="fu">median</span>(msy),<span class="at">col=</span><span class="dv">2</span>)  </span>
<span id="cb87-1269"><a href="#cb87-1269" aria-hidden="true" tabindex="-1"></a><span class="fu">mtext</span>(<span class="st">"Step"</span>,<span class="at">side=</span><span class="dv">1</span>,<span class="at">outer=</span>T,<span class="at">line=</span><span class="fl">0.0</span>,<span class="at">font=</span><span class="dv">7</span>,<span class="at">cex=</span><span class="fl">1.1</span>)  </span>
<span id="cb87-1270"><a href="#cb87-1270" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-1271"><a href="#cb87-1271" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1272"><a href="#cb87-1272" aria-hidden="true" tabindex="-1"></a>当然，理想情况下，我们会用多条链进行这样的分析，以确保每条链都收敛于相同的后验分布。此外，随着 MCMC 的进展，还有许多诊断性统计数据可以用来检查收敛程度的速率。同样理想的情况是，每条链都从不同的位置开始，但即使从同一位置开始，随机数序列最终也会将链引向截然不同的方向。我们可以使用与 <span class="in">`robustSPM()`</span> 函数相同的方法来选择不同的随机起点。</span>
<span id="cb87-1273"><a href="#cb87-1273" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1276"><a href="#cb87-1276" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-1277"><a href="#cb87-1277" aria-hidden="true" tabindex="-1"></a> <span class="co">#Do five chains of the same length for the Fox model  </span></span>
<span id="cb87-1278"><a href="#cb87-1278" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">6396679</span>)  <span class="co"># Note all chains start from same place, which is   </span></span>
<span id="cb87-1279"><a href="#cb87-1279" aria-hidden="true" tabindex="-1"></a>inscale <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.07</span>,<span class="fl">0.05</span>,<span class="fl">0.09</span>,<span class="fl">0.45</span>)  <span class="co"># suboptimal, but still the chains  </span></span>
<span id="cb87-1280"><a href="#cb87-1280" aria-hidden="true" tabindex="-1"></a>pars <span class="ot">&lt;-</span> <span class="fu">log</span>(<span class="fu">c</span>(<span class="at">r=</span><span class="fl">0.205</span>,<span class="at">K=</span><span class="dv">11300</span>,<span class="at">Binit=</span><span class="dv">3220</span>,<span class="at">sigma=</span><span class="fl">0.044</span>))  <span class="co"># differ  </span></span>
<span id="cb87-1281"><a href="#cb87-1281" aria-hidden="true" tabindex="-1"></a>result <span class="ot">&lt;-</span> <span class="fu">do_MCMC</span>(<span class="at">chains=</span><span class="dv">5</span>,<span class="at">burnin=</span><span class="dv">50</span>,<span class="at">N=</span><span class="dv">2000</span>,<span class="at">thinstep=</span><span class="dv">512</span>,  </span>
<span id="cb87-1282"><a href="#cb87-1282" aria-hidden="true" tabindex="-1"></a>                  <span class="at">inpar=</span>pars,<span class="at">infunk=</span>negLL1,<span class="at">calcpred=</span>simpspmC,  </span>
<span id="cb87-1283"><a href="#cb87-1283" aria-hidden="true" tabindex="-1"></a>                  <span class="at">obsdat=</span><span class="fu">log</span>(fish[,<span class="st">"cpue"</span>]),<span class="at">calcdat=</span>fish,  </span>
<span id="cb87-1284"><a href="#cb87-1284" aria-hidden="true" tabindex="-1"></a>                  <span class="at">priorcalc=</span>calcprior,<span class="at">scales=</span>inscale,  </span>
<span id="cb87-1285"><a href="#cb87-1285" aria-hidden="true" tabindex="-1"></a>                  <span class="at">schaefer=</span><span class="cn">FALSE</span>)  </span>
<span id="cb87-1286"><a href="#cb87-1286" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"acceptance rate = "</span>,result<span class="sc">$</span>arate,<span class="st">" </span><span class="sc">\n</span><span class="st">"</span>) <span class="co"># always check this    </span></span>
<span id="cb87-1287"><a href="#cb87-1287" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-1288"><a href="#cb87-1288" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1291"><a href="#cb87-1291" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-1292"><a href="#cb87-1292" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-spm27</span></span>
<span id="cb87-1293"><a href="#cb87-1293" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "K 参数的边际后验值和 5 链 2000 次重复（512 * 2000 = 1049600 次迭代）得出的隐含 MSY。分布之间仍存在一些差异，尤其是在模式处，这表明更多的重复和更高的稀疏率可能会改善结果。the marginal posterior for the K parameter and the implied MSY from five chains of 2000 replicates (512 * 2000 = 1049600 iterations). Some variation remains between the distributions, especially at the mode, suggesting that more replicates and potentially a higher thinning rate would improve the outcome."</span></span>
<span id="cb87-1294"><a href="#cb87-1294" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1295"><a href="#cb87-1295" aria-hidden="true" tabindex="-1"></a>  <span class="co">#Now plot marginal posteriors from 5 Fox model chains    Fig7.27  </span></span>
<span id="cb87-1296"><a href="#cb87-1296" aria-hidden="true" tabindex="-1"></a><span class="fu">parset</span>(<span class="at">plots=</span><span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">1</span>),<span class="at">cex=</span><span class="fl">0.85</span>,<span class="at">margin=</span><span class="fu">c</span>(<span class="fl">0.4</span>,<span class="fl">0.4</span>,<span class="fl">0.05</span>,<span class="fl">0.05</span>))  </span>
<span id="cb87-1297"><a href="#cb87-1297" aria-hidden="true" tabindex="-1"></a>post <span class="ot">&lt;-</span> result[[<span class="dv">1</span>]][[<span class="dv">1</span>]]  </span>
<span id="cb87-1298"><a href="#cb87-1298" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">density</span>(post[,<span class="st">"K"</span>]),<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">1</span>,<span class="at">main=</span><span class="st">""</span>,<span class="at">xlab=</span><span class="st">"K"</span>,  </span>
<span id="cb87-1299"><a href="#cb87-1299" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylim=</span><span class="fu">c</span>(<span class="dv">0</span>,<span class="fl">4.4e-04</span>),<span class="at">panel.first=</span><span class="fu">grid</span>())  </span>
<span id="cb87-1300"><a href="#cb87-1300" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="sc">:</span><span class="dv">5</span>) <span class="fu">lines</span>(<span class="fu">density</span>(result<span class="sc">$</span>result[[i]][,<span class="st">"K"</span>]),<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span>i)  </span>
<span id="cb87-1301"><a href="#cb87-1301" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> <span class="fl">1e-08</span>  </span>
<span id="cb87-1302"><a href="#cb87-1302" aria-hidden="true" tabindex="-1"></a>post <span class="ot">&lt;-</span> result<span class="sc">$</span>result[[<span class="dv">1</span>]]  </span>
<span id="cb87-1303"><a href="#cb87-1303" aria-hidden="true" tabindex="-1"></a>msy <span class="ot">&lt;-</span>  post[,<span class="st">"r"</span>]<span class="sc">*</span>post[,<span class="st">"K"</span>]<span class="sc">/</span>((p <span class="sc">+</span> <span class="dv">1</span>)<span class="sc">^</span>((p<span class="sc">+</span><span class="dv">1</span>)<span class="sc">/</span>p))  </span>
<span id="cb87-1304"><a href="#cb87-1304" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">density</span>(msy),<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span><span class="dv">1</span>,<span class="at">main=</span><span class="st">""</span>,<span class="at">xlab=</span><span class="st">"MSY"</span>,<span class="at">type=</span><span class="st">"l"</span>,  </span>
<span id="cb87-1305"><a href="#cb87-1305" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylim=</span><span class="fu">c</span>(<span class="dv">0</span>,<span class="fl">0.0175</span>),<span class="at">panel.first=</span><span class="fu">grid</span>())  </span>
<span id="cb87-1306"><a href="#cb87-1306" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="sc">:</span><span class="dv">5</span>) {  </span>
<span id="cb87-1307"><a href="#cb87-1307" aria-hidden="true" tabindex="-1"></a>  post <span class="ot">&lt;-</span> result<span class="sc">$</span>result[[i]]  </span>
<span id="cb87-1308"><a href="#cb87-1308" aria-hidden="true" tabindex="-1"></a>  msy <span class="ot">&lt;-</span>  post[,<span class="st">"r"</span>]<span class="sc">*</span>post[,<span class="st">"K"</span>]<span class="sc">/</span>((p <span class="sc">+</span> <span class="dv">1</span>)<span class="sc">^</span>((p<span class="sc">+</span><span class="dv">1</span>)<span class="sc">/</span>p))  </span>
<span id="cb87-1309"><a href="#cb87-1309" aria-hidden="true" tabindex="-1"></a>  <span class="fu">lines</span>(<span class="fu">density</span>(msy),<span class="at">lwd=</span><span class="dv">2</span>,<span class="at">col=</span>i)  </span>
<span id="cb87-1310"><a href="#cb87-1310" aria-hidden="true" tabindex="-1"></a>}  </span>
<span id="cb87-1311"><a href="#cb87-1311" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-1312"><a href="#cb87-1312" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1313"><a href="#cb87-1313" aria-hidden="true" tabindex="-1"></a>然而，尽管五条链在视觉上存在差异（@fig-spm27），如果我们检查 $K$ 在不同的分位数上，我们发现差异很小（@tbl-spm8）。事实上，中值 $K$ 对于每条链，彼此之间的距离在1.1%左右是令人鼓舞的，最大百分比变化为 2.7%。作为实验，使用相同的 random.seed，但每条链运行 4000 步（总共 $5 \times 512 \times 4050 = 10,368$ 万次迭代，但仍然不到 5 分钟），最大变异下降到 1.48%，同样是 0.975 分位数，其他分位数都低于 1%。在这种情况下，由于模型非常简单，而且每个链只需要很短的时间，因此增加步数是值得的。对于参数更多，更复杂的似然计算，在评估小组的最后期限内，这些分析的时间安排可能变得至关重要。</span>
<span id="cb87-1314"><a href="#cb87-1314" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1317"><a href="#cb87-1317" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-1318"><a href="#cb87-1318" aria-hidden="true" tabindex="-1"></a><span class="co"># get qunatiles of each chain  </span></span>
<span id="cb87-1319"><a href="#cb87-1319" aria-hidden="true" tabindex="-1"></a>probs <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.025</span>,<span class="fl">0.05</span>,<span class="fl">0.5</span>,<span class="fl">0.95</span>,<span class="fl">0.975</span>)  </span>
<span id="cb87-1320"><a href="#cb87-1320" aria-hidden="true" tabindex="-1"></a>storeQ <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="dv">0</span>,<span class="at">nrow=</span><span class="dv">6</span>,<span class="at">ncol=</span><span class="dv">5</span>,<span class="at">dimnames=</span><span class="fu">list</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">6</span>,probs))  </span>
<span id="cb87-1321"><a href="#cb87-1321" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>) storeQ[i,] <span class="ot">&lt;-</span> <span class="fu">quants</span>(result<span class="sc">$</span>result[[i]][,<span class="st">"K"</span>])  </span>
<span id="cb87-1322"><a href="#cb87-1322" aria-hidden="true" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">apply</span>(storeQ[<span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>,],<span class="dv">2</span>,range)  </span>
<span id="cb87-1323"><a href="#cb87-1323" aria-hidden="true" tabindex="-1"></a>storeQ[<span class="dv">6</span>,] <span class="ot">&lt;-</span> <span class="dv">100</span><span class="sc">*</span>(x[<span class="dv">2</span>,] <span class="sc">-</span> x[<span class="dv">1</span>,])<span class="sc">/</span>x[<span class="dv">2</span>,]  </span>
<span id="cb87-1324"><a href="#cb87-1324" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-1325"><a href="#cb87-1325" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1328"><a href="#cb87-1328" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-1329"><a href="#cb87-1329" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-spm8</span></span>
<span id="cb87-1330"><a href="#cb87-1330" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: "针对 abdat 数据的 Fox 模型运行的五条 MCMC 链中 K 参数的五个量化值。最后一行是各链数值范围的百分比差异，显示它们的中位数相差略高于 1%。Five quantiles on the K parameter from the five MCMC chains run on the Fox model applied to the abdat data. The last row is the percent difference in the range of the values across the chains, which shows their medians differ by slightly more than 1%."</span></span>
<span id="cb87-1331"><a href="#cb87-1331" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1332"><a href="#cb87-1332" aria-hidden="true" tabindex="-1"></a>knitr<span class="sc">::</span><span class="fu">kable</span>(storeQ, <span class="at">digits =</span> <span class="dv">3</span>)</span>
<span id="cb87-1333"><a href="#cb87-1333" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-1334"><a href="#cb87-1334" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1335"><a href="#cb87-1335" aria-hidden="true" tabindex="-1"></a><span class="in">```         </span></span>
<span id="cb87-1336"><a href="#cb87-1336" aria-hidden="true" tabindex="-1"></a><span class="in">                                                                                                                                                |</span></span>
<span id="cb87-1337"><a href="#cb87-1337" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-1338"><a href="#cb87-1338" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1339"><a href="#cb87-1339" aria-hidden="true" tabindex="-1"></a><span class="fu">## 管理建议</span></span>
<span id="cb87-1340"><a href="#cb87-1340" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1341"><a href="#cb87-1341" aria-hidden="true" tabindex="-1"></a><span class="fu">### 两种风险观</span></span>
<span id="cb87-1342"><a href="#cb87-1342" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1343"><a href="#cb87-1343" aria-hidden="true" tabindex="-1"></a>正式的资源评估，即使是使用剩余产量模型的简单评估，也可以说明所评估的渔业的种群状况，但问题仍然是如何利用这种评估来提出渔业管理建议。当然，这种建议将取决于有关渔业的管理目标。但是，即使没有正式的渔业政策，也应该能够就未来采用不同渔获量的影响提供咨询意见。我们可以使用最优模型拟合来预测模型动态到未来，这种预测是管理建议的基础，这些建议来自大多数非纯粹经验的资源评估。一旦知道（或假设）了渔业目标，那么，使用模型预测，就可以对未来的努力或捕捞水平进行估计，从而有望引导种群实现选定的目标。</span>
<span id="cb87-1344"><a href="#cb87-1344" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1345"><a href="#cb87-1345" aria-hidden="true" tabindex="-1"></a>一个共同的目标是努力将渔业维持在平均可以产生最大可持续产量的生物量水平，即 $B_{MSY}$ 。这种目标将被称为目标参考点，因为它源自讨论生物学参考点的文献（Garcia，1994；FAO，1995，1997）。可将 $B_{MSY}$ 视为目标，但相关渔获量 （MSY） 实际上应该作为渔获量的上限。除了目标参考点之外，通常还有一个极限参考点，它定义了要避免的资源状态。这通常从被认为对后续补充量构成风险的资源水平的角度进行讨论，尽管这通常只是一个准则。通常，极限参考点 $B_{MSY}/2$，或者将通用代理设置为 $0.2B_0$。 这种限度和目标参考点通常是在正式收获战略的背景下确定的。</span>
<span id="cb87-1346"><a href="#cb87-1346" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1347"><a href="#cb87-1347" aria-hidden="true" tabindex="-1"></a><span class="fu">### 捕捞策略</span></span>
<span id="cb87-1348"><a href="#cb87-1348" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1349"><a href="#cb87-1349" aria-hidden="true" tabindex="-1"></a>在一个管辖区内，捕捞战略确定了决策框架，用于实现不同鱼类种群的既定生物目标，有时还包括经济和社会目标。一般来说，捕捞战略由三部分组成（FAO，1995、1997；Haddon，2007；Smith 等，2008）：</span>
<span id="cb87-1350"><a href="#cb87-1350" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1351"><a href="#cb87-1351" aria-hidden="true" tabindex="-1"></a>1.监测和收集有关每个相关渔业数据的手段。</span>
<span id="cb87-1352"><a href="#cb87-1352" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1353"><a href="#cb87-1353" aria-hidden="true" tabindex="-1"></a>2.评估每种渔业的明确方式，通常相对于预先选择的生物（或其他）参考点，例如捕捞死亡率、生物量水平或其替代物。</span>
<span id="cb87-1354"><a href="#cb87-1354" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1355"><a href="#cb87-1355" aria-hidden="true" tabindex="-1"></a>3.预先确定的捕捞控制规则或决策规则，用于将种群评估或种群状况转化为与未来努力量或捕捞水平相关的管理建议。</span>
<span id="cb87-1356"><a href="#cb87-1356" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1357"><a href="#cb87-1357" aria-hidden="true" tabindex="-1"></a>理想情况下，这种捕捞策略将经过模拟测试，以确定它们有效的条件，并摒弃无法实现预期目标的方案（Smith，1993；Punt 等，2016）</span>
<span id="cb87-1358"><a href="#cb87-1358" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1359"><a href="#cb87-1359" aria-hidden="true" tabindex="-1"></a>有许多众所周知的例子明确说明了辖区内渔业的管理目标（DAFF，2007；Deroba 和 Bence，2008；Magnuson-Stevens，2007）。例如，在澳大利亚联邦海洋管辖区，选定的目标是管理主要经济鱼类种群，使其生物量达到最大经济产量（$B_{MEY}$）（DAFF, 2007; DAWR, 2018）；事实上，由于可用的信息不足，无法可靠地估算 $B_{mEY}$，大多数物种使用 $0.48 B_0$ 的代用值。同样，将 $0.2B_0$ 定义为大多数物种的极限参考点，“其中没有支持选择特定种群的极限参考点<span class="sc">\[</span>$B_{MSY} / 2$<span class="sc">\]</span>的信息……”(DAWR, 2018，第10页)。如果估计种群数量低于极限参考点，则停止有针对性的捕捞，尽管在混合渔业中仍可能出现副渔获物。如果鱼量高于极限参考点，则进行预测，以确定未来的渔获量应能促使鱼量顺利增加到目标生物量水平。</span>
<span id="cb87-1360"><a href="#cb87-1360" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1361"><a href="#cb87-1361" aria-hidden="true" tabindex="-1"></a><span class="fu">## 风险评估预测</span></span>
<span id="cb87-1362"><a href="#cb87-1362" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1363"><a href="#cb87-1363" aria-hidden="true" tabindex="-1"></a>当然，对资源评估模型进行前瞻性预测的想法背后有许多重要的假设。首先，模型能成功捕捉到控制种群生物量的重要动态部分。在剩余产量模型中，这相当于假设对种群生产力的估计在未来将保持不变。请记住，在使用数据集 *dataspm* 时，残差保留了相对较大的振荡模式，这表明该模型在动态变化中遗漏了一些重要内容。尽管有这样的遗漏，模型仍可能保留对近似平均动态的充分估计，以进行有用的预测，但这就假定影响模型拟合的其他因素将继续以过去的方式运行。如果评估具有高度不确定性，那么未来的预测也将具有高度不确定性，这就降低了其在提供建议时的价值。</span>
<span id="cb87-1364"><a href="#cb87-1364" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1365"><a href="#cb87-1365" aria-hidden="true" tabindex="-1"></a>最简单的预测是使用最优参数估计，并采用恒定渔获量或努力量。我们需要当前种群的生物量和可捕量，以使用渔获量方程将指定的努力量水平转换为渔获量水平：</span>
<span id="cb87-1366"><a href="#cb87-1366" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1367"><a href="#cb87-1367" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb87-1368"><a href="#cb87-1368" aria-hidden="true" tabindex="-1"></a>C_t=qE_tB_t  </span>
<span id="cb87-1369"><a href="#cb87-1369" aria-hidden="true" tabindex="-1"></a>$$ {#eq-spm20}</span>
<span id="cb87-1370"><a href="#cb87-1370" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1371"><a href="#cb87-1371" aria-hidden="true" tabindex="-1"></a>然后，就可以使用带有最佳参数的标准动力学方程来预测预测渔获量下的生物量水平。如果使用指定的渔获量，则只需使用动力学方程（此处使用 Polacheck 等（1993）的版本）：</span>
<span id="cb87-1372"><a href="#cb87-1372" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1373"><a href="#cb87-1373" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb87-1374"><a href="#cb87-1374" aria-hidden="true" tabindex="-1"></a>B_{t+1}=B_t+\frac{r}{p}B_t \left(1-\left(\frac{B_t}{K}\right)^p \right)-C_t </span>
<span id="cb87-1375"><a href="#cb87-1375" aria-hidden="true" tabindex="-1"></a>$$ {#eq-spm21}</span>
<span id="cb87-1376"><a href="#cb87-1376" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1377"><a href="#cb87-1377" aria-hidden="true" tabindex="-1"></a><span class="fu">### 确定性预测</span></span>
<span id="cb87-1378"><a href="#cb87-1378" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1379"><a href="#cb87-1379" aria-hidden="true" tabindex="-1"></a>如果我们使用最优的模型参数，那么对于一系列不同的前向预测渔获量，我们会得到不同的生物量和 cpue 轨迹。为了说明这一点，我们可以再次使用 *abdat* 数据集（注意，我们已将 *hessian* 选项设置为 “true”，因为我们将在后面使用）。</span>
<span id="cb87-1380"><a href="#cb87-1380" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1383"><a href="#cb87-1383" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-1384"><a href="#cb87-1384" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-spm28</span></span>
<span id="cb87-1385"><a href="#cb87-1385" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "使用 Fox 模型和对数正态误差拟合的 abdat 数据集最佳模型。绿色虚线为黄土曲线，红色实线为最佳预测拟合模型。请注意对数正态残差的模式，这表明该模型在该数据方面存在一些不足。The optimum model fit for the abdat data-set using the Fox model and log-normal errors. The green dashed line is a loess curve while the solid red line is the optimum predicted model fit. Note the pattern in the log-normal residuals indicating that the model has some inadequacies with regard to this data."</span></span>
<span id="cb87-1386"><a href="#cb87-1386" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1387"><a href="#cb87-1387" aria-hidden="true" tabindex="-1"></a> <span class="co">#Prepare Fox model on abdat data for future projections Fig7.28  </span></span>
<span id="cb87-1388"><a href="#cb87-1388" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(abdat); fish <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>(abdat)  </span>
<span id="cb87-1389"><a href="#cb87-1389" aria-hidden="true" tabindex="-1"></a>param <span class="ot">&lt;-</span> <span class="fu">log</span>(<span class="fu">c</span>(<span class="at">r=</span><span class="fl">0.3</span>,<span class="at">K=</span><span class="dv">11500</span>,<span class="at">Binit=</span><span class="dv">3300</span>,<span class="at">sigma=</span><span class="fl">0.05</span>))  </span>
<span id="cb87-1390"><a href="#cb87-1390" aria-hidden="true" tabindex="-1"></a>bestmod <span class="ot">&lt;-</span> <span class="fu">nlm</span>(<span class="at">f=</span>negLL1,<span class="at">p=</span>param,<span class="at">funk=</span>simpspm,<span class="at">schaefer=</span><span class="cn">FALSE</span>,</span>
<span id="cb87-1391"><a href="#cb87-1391" aria-hidden="true" tabindex="-1"></a>               <span class="at">logobs=</span><span class="fu">log</span>(fish[,<span class="st">"cpue"</span>]),<span class="at">indat=</span>fish,<span class="at">hessian=</span><span class="cn">TRUE</span>)  </span>
<span id="cb87-1392"><a href="#cb87-1392" aria-hidden="true" tabindex="-1"></a>optpar <span class="ot">&lt;-</span> <span class="fu">exp</span>(bestmod<span class="sc">$</span>estimate)  </span>
<span id="cb87-1393"><a href="#cb87-1393" aria-hidden="true" tabindex="-1"></a>ans <span class="ot">&lt;-</span> <span class="fu">plotspmmod</span>(<span class="at">inp=</span>bestmod<span class="sc">$</span>estimate,<span class="at">indat=</span>fish,<span class="at">schaefer=</span><span class="cn">FALSE</span>,  </span>
<span id="cb87-1394"><a href="#cb87-1394" aria-hidden="true" tabindex="-1"></a>                 <span class="at">target=</span><span class="fl">0.4</span>,<span class="at">addrmse=</span><span class="cn">TRUE</span>, <span class="at">plotprod=</span><span class="cn">FALSE</span>)  </span>
<span id="cb87-1395"><a href="#cb87-1395" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1396"><a href="#cb87-1396" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-1397"><a href="#cb87-1397" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1398"><a href="#cb87-1398" aria-hidden="true" tabindex="-1"></a>MSY估计约为 854 吨，资源似乎略高于 $0.4B_0$ 目标水平，通常用作表示 $B_MSY$。从图中，并检查初始 *abdat* 数据框，我们可以看到 2000 年至 2008 年的渔获量每年 都在910 - 1030 吨之间，这导致模型预测 cpue 和生物量将下降。因此，我们可以探索700-1000吨的十年渔获量预测，或许以50吨为步长。鉴于分析中的不确定性以及这些预测是确定性的，因此对未来太多年的预测研究意义不大。长期预测对于说明不同渔获量的影响可能很有价值，但出于实际目的，十年往往绰绰有余，这取决于被评估物种的寿命（预计寿命较长的物种比寿命短的物种表现出较慢的动态变化）。函数 `plotspmmod()` 绘制的动态细节是通过使用具有最佳参数的函数 `spm()` 生成的（查看 `plotspmmod()` 代码，以了解这些详细信息）。当使用最佳参数运行 `spm()` 时，其输出包括 *动态（Dynamics）* 对象中 *outmat* 表中的预测动态。这里我们将使用 Fox 模型而不是 Schaefer 运行模型。</span>
<span id="cb87-1399"><a href="#cb87-1399" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1400"><a href="#cb87-1400" aria-hidden="true" tabindex="-1"></a>函数 <span class="in">`spm()`</span> 输出的对象是一个由五个部分组成的列表。模型参数，包括 q 值；*outmat* 是一个矩阵，包含随时间变化的动态信息；*msy*；*sumout* 包含五个关键统计量的汇总；*schaefer* 用于识别是 Schaefer 模型还是 Fox 模型。</span>
<span id="cb87-1401"><a href="#cb87-1401" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1404"><a href="#cb87-1404" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-1405"><a href="#cb87-1405" aria-hidden="true" tabindex="-1"></a> <span class="co">#   </span></span>
<span id="cb87-1406"><a href="#cb87-1406" aria-hidden="true" tabindex="-1"></a>out <span class="ot">&lt;-</span> <span class="fu">spm</span>(bestmod<span class="sc">$</span>estimate,<span class="at">indat=</span>fish,<span class="at">schaefer=</span><span class="cn">FALSE</span>)   </span>
<span id="cb87-1407"><a href="#cb87-1407" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(out, <span class="at">width=</span><span class="dv">65</span>, <span class="at">strict.width=</span><span class="st">"cut"</span>)  </span>
<span id="cb87-1408"><a href="#cb87-1408" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-1409"><a href="#cb87-1409" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1410"><a href="#cb87-1410" aria-hidden="true" tabindex="-1"></a>*outmat* 中的动态包括年份、生物量、cpue、预测的 cpue 和其他变量的详细信息（@tbl-spm9）。</span>
<span id="cb87-1411"><a href="#cb87-1411" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1414"><a href="#cb87-1414" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-1415"><a href="#cb87-1415" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-spm9</span></span>
<span id="cb87-1416"><a href="#cb87-1416" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: "前十行为 abdat 数据集所代表的种群动态预测值和最佳 Fox 模型拟合值。The first ten rows of the predicted dynamics of the stock represented by the abdat data-set and the optimal Fox model fit."</span></span>
<span id="cb87-1417"><a href="#cb87-1417" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1418"><a href="#cb87-1418" aria-hidden="true" tabindex="-1"></a>knitr<span class="sc">::</span><span class="fu">kable</span>(out<span class="sc">$</span>outmat[<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>,], <span class="at">digits =</span> <span class="dv">3</span>)</span>
<span id="cb87-1419"><a href="#cb87-1419" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-1420"><a href="#cb87-1420" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1421"><a href="#cb87-1421" aria-hidden="true" tabindex="-1"></a>预测是将建模结果的时间序列（@tbl-spm9 ）按顺序加入任何新的固定渔获量，并进行计算以填入所需列，从而继续进行动态计算。我们可以使用 **MQMF** 函数 <span class="in">`spmprojDet()`</span>，它接收来自 <span class="in">`spm()`</span> 函数的列表输出以及与确定性预测相关的一些细节，并为我们生成预测动态。您应该查看 <span class="in">`spmproj()`</span> 代码，了解年份是如何设置的，代码之简短令人惊讶。</span>
<span id="cb87-1422"><a href="#cb87-1422" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1425"><a href="#cb87-1425" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-1426"><a href="#cb87-1426" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-spm29</span></span>
<span id="cb87-1427"><a href="#cb87-1427" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "根据 abdat 数据集拟合的最佳 Fox 模型的确定性恒定渔获量预测。垂直绿线是可用数据的极限，其右侧的红线是主要预测。数字是施加的恒定渔获量。Deterministic constant catch projections of the optimum Fox model fit to the abdat data-set. the vertical green line is the limit of the data available and the red lines to the right of that are the main projections. The numbers are the constant catches imposed."</span></span>
<span id="cb87-1428"><a href="#cb87-1428" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1429"><a href="#cb87-1429" aria-hidden="true" tabindex="-1"></a> <span class="co">#  Fig 7.29  </span></span>
<span id="cb87-1430"><a href="#cb87-1430" aria-hidden="true" tabindex="-1"></a>catches <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="dv">700</span>,<span class="dv">1000</span>,<span class="dv">50</span>)   <span class="co"># projyr=10 is the default  </span></span>
<span id="cb87-1431"><a href="#cb87-1431" aria-hidden="true" tabindex="-1"></a>projans <span class="ot">&lt;-</span> <span class="fu">spmprojDet</span>(<span class="at">spmobj=</span>out,<span class="at">projcatch=</span>catches,<span class="at">plotout=</span><span class="cn">TRUE</span>)  </span>
<span id="cb87-1432"><a href="#cb87-1432" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb87-1433"><a href="#cb87-1433" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-1434"><a href="#cb87-1434" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1435"><a href="#cb87-1435" aria-hidden="true" tabindex="-1"></a>利用确定性恒定渔获量预测（@fig-spm29），可以看出 850 吨的恒定渔获量（接近 $MSY$ 估计值）是预测未来种群状况相对稳定的最接近的渔获量。</span>
<span id="cb87-1436"><a href="#cb87-1436" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1437"><a href="#cb87-1437" aria-hidden="true" tabindex="-1"></a><span class="fu">### 考虑不确定性</span></span>
<span id="cb87-1438"><a href="#cb87-1438" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1439"><a href="#cb87-1439" aria-hidden="true" tabindex="-1"></a>确定性预测的一个明显问题就在于它们是确定性的。它们没有考虑到即使在最佳模型拟合中仍然存在的不确定性。理想情况下，我们在进行模型预测时应考虑到估计的不确定性。我们可以采用渐近误差法、自举法模型拟合或贝叶斯法等三种方法来预测不确定性。在每种情况下，不同分析的输出结果都是可信参数组合列表。这些参数可用于描述模型拟合中包含的可信动态范围，并以与确定性预测相同的方式对每个单独的生物量轨迹进行预测。</span>
<span id="cb87-1440"><a href="#cb87-1440" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1441"><a href="#cb87-1441" aria-hidden="true" tabindex="-1"></a>在拟合最优模型时，我们已经计算了 *Hessian* 矩阵，因此我们将从一个例子开始，利用渐近误差生成一个可信参数集矩阵，然后再向前推算。</span>
<span id="cb87-1442"><a href="#cb87-1442" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1443"><a href="#cb87-1443" aria-hidden="true" tabindex="-1"></a><span class="fu">### 使用渐近误差</span></span>
<span id="cb87-1444"><a href="#cb87-1444" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1445"><a href="#cb87-1445" aria-hidden="true" tabindex="-1"></a>一旦我们有了一个最佳拟合模型，如果我们还计算了 Hessian 矩阵（如前所述），我们就可以利用估计的渐近误差生成一个充满可信参数向量的矩阵。然后就可以利用这些参数来生成复制的生物量轨迹，并绘制和总结这些轨迹。</span>
<span id="cb87-1446"><a href="#cb87-1446" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1447"><a href="#cb87-1447" aria-hidden="true" tabindex="-1"></a>在避免极限参考点方面，渔业管理成功的概率标准并不少见。根据不同的可信参数向量，通过大量重复的生物量轨迹，可以估算出有多大比例的预测会达到预期结果。通过将这些预测结果列表，管理者可以选择他们认为合适的风险水平。例如，澳大利亚联邦渔业政策中对可接受风险的明确定义是：“捕捞策略至少在 90% 的时间内将所有商业种群的生物量维持在极限参考点之上”。对这一点的解释是：“种群应在至少 90% 的时间内保持在极限生物量水平之上（即种群在 10 年中有 1 年的时间会低于极限生物量水平 $B_{LIM}$ 的风险）”（DAWR, 2018a, p10）。</span>
<span id="cb87-1448"><a href="#cb87-1448" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1449"><a href="#cb87-1449" aria-hidden="true" tabindex="-1"></a>在上一节中，我们已经利用 Fox 剩余产量模型（Polacheck 等，1993）对 *abdat* 数据集进行了最佳模型拟合。正如我们在利用渐近误差描述不确定性时能够生成生物量轨迹一样，我们可以在给定恒定渔获量的条件下，将这些轨迹逐一向前推算，并寻找能产生理想结果的渔获量水平。首先要做的是从最优模型拟合生成多个可信参数向量。我们可以使用函数 `parasympt()` 来做到这一点。一旦生成了可信参数向量矩阵，我们就可以使用 `spmproj()` 函数对给定年份数和给定渔获量常数进行动态预测（通过检查代码再次确认其工作原理）。`parasympt()` 函数只是一个方便的包装，用于调用 `rmvnorm()` 函数（**mvtnorm** 软件包的一部分）并将结果返回为一个带标记的矩阵，而 `spmproj()` 函数则稍微复杂一些。为了简化预测，该函数首先扩展了输入鱼类矩阵，以包括预测年份及其恒定渔获量（用 NA 填充未来 cpue）。`spmproj()` 使用 `spm()` 函数计算动态变化，而仅以矩阵形式返回模拟生物量。使用 `spm()` 可能看起来效率不高，但这意味着可以很容易地修改 `spmproj()` 函数，以返回动力学估算的任何变量。这些变量包括模型生物量、耗竭水平、捕获率和预测的 cpue（当然也可以只从生物量、预测 cpue 和原始数据中得出其他变量）。运行以下代码并检查两个输出对象：*matpar* 包含参数向量，*projs* 包含生物量轨迹行。</span>
<span id="cb87-1450"><a href="#cb87-1450" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1453"><a href="#cb87-1453" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-1454"><a href="#cb87-1454" aria-hidden="true" tabindex="-1"></a> <span class="co"># generate parameter vectors from a multivariate normal     </span></span>
<span id="cb87-1455"><a href="#cb87-1455" aria-hidden="true" tabindex="-1"></a><span class="co"># project dynamics under a constant catch of 900t   </span></span>
<span id="cb87-1456"><a href="#cb87-1456" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(mvtnorm)   </span>
<span id="cb87-1457"><a href="#cb87-1457" aria-hidden="true" tabindex="-1"></a>matpar <span class="ot">&lt;-</span> <span class="fu">parasympt</span>(bestmod,<span class="at">N=</span><span class="dv">1000</span>) <span class="co">#generate parameter vectors   </span></span>
<span id="cb87-1458"><a href="#cb87-1458" aria-hidden="true" tabindex="-1"></a>projs <span class="ot">&lt;-</span> <span class="fu">spmproj</span>(matpar,fish,<span class="at">projyr=</span><span class="dv">10</span>,<span class="at">constC=</span><span class="dv">900</span>)<span class="co">#do dynamics  </span></span>
<span id="cb87-1459"><a href="#cb87-1459" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-1460"><a href="#cb87-1460" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1461"><a href="#cb87-1461" aria-hidden="true" tabindex="-1"></a>计算完成后，我们可以总结预测的结果。首先，我们可以使用函数 <span class="in">`plotproj()`</span> 绘制 1000 个预测。</span>
<span id="cb87-1462"><a href="#cb87-1462" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1465"><a href="#cb87-1465" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-1466"><a href="#cb87-1466" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-spm30</span></span>
<span id="cb87-1467"><a href="#cb87-1467" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "1000 个预测值，通过使用反向哈希值和平均参数估计值生成 1000 个可信参数向量，并将每 个向量与 10 年不变的 900 吨渔获量后的渔获量向前推算得出。虚线为极限和目标参考点。蓝色垂直线是渔业数据的极限，黑色粗线是最优拟合，与最优线平行的红色细线是各年的第 10 和第 50 个量值。1000 projections derived from the using the inverse hessian and mean parameter estimates to generate 1000 plausible parameter vectors and projecting each vector forward with the fisheries catches followed by 10 years of a constant catch of 900t. The dashed lines are the limit and target reference points. The blue vertical line is the limit of fisheries data, the thick black line is the optimum fit and the thin red lines parallel to the optimum line are the 10th and 50th quantiles across years."</span></span>
<span id="cb87-1468"><a href="#cb87-1468" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1469"><a href="#cb87-1469" aria-hidden="true" tabindex="-1"></a> <span class="co"># Fig 7.30  1000 replicate projections asymptotic errors   </span></span>
<span id="cb87-1470"><a href="#cb87-1470" aria-hidden="true" tabindex="-1"></a>outp <span class="ot">&lt;-</span> <span class="fu">plotproj</span>(projs,out,<span class="at">qprob=</span><span class="fu">c</span>(<span class="fl">0.1</span>,<span class="fl">0.5</span>),<span class="at">refpts=</span><span class="fu">c</span>(<span class="fl">0.2</span>,<span class="fl">0.4</span>))  </span>
<span id="cb87-1471"><a href="#cb87-1471" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-1472"><a href="#cb87-1472" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1473"><a href="#cb87-1473" aria-hidden="true" tabindex="-1"></a>很明显，10年后，假设动态保持不变，平均900吨的渔获量会导致种群从目前的状态有所下降，但使中值结果接近目标（上虚线），并且10年后不超过10%的轨迹越过极限参考点（LRP）（下细线高于 $0.2B_0$ 限制）。通过探索不同的恒定渔获量，将能够发现，如果渔获量增加到 1000 吨，那么 10 年后，第 10 分位数几乎违反了 LRP。将跨越 LRP 的轨迹比例制成表格以生成风险表，将澄清不同拟议的常数渔获量的影响，并有助于选择更具防御性的管理决策。</span>
<span id="cb87-1474"><a href="#cb87-1474" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1475"><a href="#cb87-1475" aria-hidden="true" tabindex="-1"></a><span class="fu">### 使用 Bootstrap 参数向量</span></span>
<span id="cb87-1476"><a href="#cb87-1476" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1477"><a href="#cb87-1477" aria-hidden="true" tabindex="-1"></a>预测的本质是通过最佳模型拟合，结合分析中固有的不确定性估计，生成一个可信的参数向量矩阵。我们也可以不使用假定为多元正态分布的渐近误差，而使用自举法过程来生成所需的参数向量矩阵。就像在分析中描述不确定性一样，我们可以使用 <span class="in">`spmboot()`</span> 函数来创建所需的参数向量。如果该函数耗时过长，我们可以使用基于 **Rcpp** 的 <span class="in">`simpspmC()`</span> 函数来加快 1000（或更多）次模型拟合的速度。</span>
<span id="cb87-1478"><a href="#cb87-1478" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1481"><a href="#cb87-1481" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-1482"><a href="#cb87-1482" aria-hidden="true" tabindex="-1"></a> <span class="co">#bootstrap generation of plausible parameter vectors for Fox   </span></span>
<span id="cb87-1483"><a href="#cb87-1483" aria-hidden="true" tabindex="-1"></a>reps <span class="ot">&lt;-</span> <span class="dv">1000</span>    </span>
<span id="cb87-1484"><a href="#cb87-1484" aria-hidden="true" tabindex="-1"></a>boots <span class="ot">&lt;-</span> <span class="fu">spmboot</span>(bestmod<span class="sc">$</span>estimate,<span class="at">fishery=</span>fish,<span class="at">iter=</span>reps,   </span>
<span id="cb87-1485"><a href="#cb87-1485" aria-hidden="true" tabindex="-1"></a>                 <span class="at">schaefer=</span><span class="cn">FALSE</span>)   </span>
<span id="cb87-1486"><a href="#cb87-1486" aria-hidden="true" tabindex="-1"></a>matparb <span class="ot">&lt;-</span> boots<span class="sc">$</span>bootpar[,<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>] <span class="co">#examine using head(matparb,20)  </span></span>
<span id="cb87-1487"><a href="#cb87-1487" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-1488"><a href="#cb87-1488" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1489"><a href="#cb87-1489" aria-hidden="true" tabindex="-1"></a>就象以前一样，我们可以使用这些参数向量来预测渔业的未来，并确定不同恒定捕捞水平对可持续性的任何风险（@fig-spm31）。</span>
<span id="cb87-1490"><a href="#cb87-1490" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1493"><a href="#cb87-1493" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-1494"><a href="#cb87-1494" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-spm31</span></span>
<span id="cb87-1495"><a href="#cb87-1495" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "1000 个预测值（灰色）来自使用自举过程生成的 1000 个可信参数向量，并将每个向量与 10 年 900 吨恒定渔获量之后的渔获量进行向前预测。虚线为极限和目标参考点。蓝色垂直线为渔业数据的极限，黑色粗线为最佳拟合，红线为各年的第 10 和第 50 个量值。"</span></span>
<span id="cb87-1496"><a href="#cb87-1496" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1497"><a href="#cb87-1497" aria-hidden="true" tabindex="-1"></a> <span class="co">#bootstrap projections. Lower case b for boostrap  Fig7.31   </span></span>
<span id="cb87-1498"><a href="#cb87-1498" aria-hidden="true" tabindex="-1"></a>projb <span class="ot">&lt;-</span> <span class="fu">spmproj</span>(matparb,fish,<span class="at">projyr=</span><span class="dv">10</span>,<span class="at">constC=</span><span class="dv">900</span>)   </span>
<span id="cb87-1499"><a href="#cb87-1499" aria-hidden="true" tabindex="-1"></a>outb <span class="ot">&lt;-</span> <span class="fu">plotproj</span>(projb,out,<span class="at">qprob=</span><span class="fu">c</span>(<span class="fl">0.1</span>,<span class="fl">0.5</span>),<span class="at">refpts=</span><span class="fu">c</span>(<span class="fl">0.2</span>,<span class="fl">0.4</span>))  </span>
<span id="cb87-1500"><a href="#cb87-1500" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-1501"><a href="#cb87-1501" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1502"><a href="#cb87-1502" aria-hidden="true" tabindex="-1"></a>投影的灰线与使用渐近误差生成的灰线不同（在中位数附近看起来更紧密），但第 10 和第 50 分位数看起来非常相似。当然，汇总结果基本相同，不过在这种情况下，没有一个预测低于极限参考点（试试 *outb*$ltLRP* 并与 *outp$ltLRP 进行比较）。</span>
<span id="cb87-1503"><a href="#cb87-1503" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1504"><a href="#cb87-1504" aria-hidden="true" tabindex="-1"></a><span class="fu">### 使用贝叶斯后验样本</span></span>
<span id="cb87-1505"><a href="#cb87-1505" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1506"><a href="#cb87-1506" aria-hidden="true" tabindex="-1"></a>正如我们利用渐近误差和自举法获取样本一样，我们也可以从贝叶斯后验中获取样本，生成可信的参数向量。在这种情况下，我们可以使用 <span class="in">`do_MCMC()`</span> 函数来进行 MCMC。我们只需要 1000 个可信参数向量，因此我们将从接近最大似然最大值的点开始进行合理的预烧，并使用较大的稀疏率来避免后验分布的连续抽样之间的序列相关性。如前所述，最好使用 **Rcpp** 派生函数 <span class="in">`simpspmC()`</span> 进行 MCMC，因为我们仍在运行 214.5 万次迭代。由于我们使用的是 Fox 运行的剩余产量模型，其比例因子与 Schaefer 版本使用的比例因子有很大不同。如果您尚未编译 <span class="in">`simpspmC()`</span> 函数（见附录），请修改以下代码以使用 <span class="in">`simpspm()`</span>，为提高速度，您可以保留 <span class="in">`as.matrix(fish)`</span>。</span>
<span id="cb87-1507"><a href="#cb87-1507" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1510"><a href="#cb87-1510" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-1511"><a href="#cb87-1511" aria-hidden="true" tabindex="-1"></a>  <span class="co">#Generate 1000 parameter vectors from Bayesian posterior  </span></span>
<span id="cb87-1512"><a href="#cb87-1512" aria-hidden="true" tabindex="-1"></a>param <span class="ot">&lt;-</span> <span class="fu">log</span>(<span class="fu">c</span>(<span class="at">r=</span><span class="fl">0.3</span>,<span class="at">K=</span><span class="dv">11500</span>,<span class="at">Binit=</span><span class="dv">3300</span>,<span class="at">sigma=</span><span class="fl">0.05</span>))  </span>
<span id="cb87-1513"><a href="#cb87-1513" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">444608</span>)  </span>
<span id="cb87-1514"><a href="#cb87-1514" aria-hidden="true" tabindex="-1"></a>N <span class="ot">&lt;-</span> <span class="dv">1000</span>  </span>
<span id="cb87-1515"><a href="#cb87-1515" aria-hidden="true" tabindex="-1"></a>result <span class="ot">&lt;-</span> <span class="fu">do_MCMC</span>(<span class="at">chains=</span><span class="dv">1</span>,<span class="at">burnin=</span><span class="dv">100</span>,<span class="at">N=</span>N,<span class="at">thinstep=</span><span class="dv">2048</span>,  </span>
<span id="cb87-1516"><a href="#cb87-1516" aria-hidden="true" tabindex="-1"></a>                  <span class="at">inpar=</span>param,<span class="at">infunk=</span>negLL,<span class="at">calcpred=</span>simpspmC,  </span>
<span id="cb87-1517"><a href="#cb87-1517" aria-hidden="true" tabindex="-1"></a>                  <span class="at">calcdat=</span>fish,<span class="at">obsdat=</span><span class="fu">log</span>(fish[,<span class="st">"cpue"</span>]),  </span>
<span id="cb87-1518"><a href="#cb87-1518" aria-hidden="true" tabindex="-1"></a>                  <span class="at">priorcalc=</span>calcprior,<span class="at">schaefer=</span><span class="cn">FALSE</span>,  </span>
<span id="cb87-1519"><a href="#cb87-1519" aria-hidden="true" tabindex="-1"></a>                  <span class="at">scales=</span><span class="fu">c</span>(<span class="fl">0.065</span>,<span class="fl">0.055</span>,<span class="fl">0.1</span>,<span class="fl">0.475</span>))  </span>
<span id="cb87-1520"><a href="#cb87-1520" aria-hidden="true" tabindex="-1"></a>parB <span class="ot">&lt;-</span> result[[<span class="dv">1</span>]][[<span class="dv">1</span>]] <span class="co">#capital B for Bayesian  </span></span>
<span id="cb87-1521"><a href="#cb87-1521" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"Acceptance Rate = "</span>,result[[<span class="dv">2</span>]],<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)  </span>
<span id="cb87-1522"><a href="#cb87-1522" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-1523"><a href="#cb87-1523" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1524"><a href="#cb87-1524" aria-hidden="true" tabindex="-1"></a>为了证明生成的 1000 个重复已经失去了它们的序列相关性，并代表了对稳态分布的合理近似，我们可以绘制自相关图和 $K$ 参数 1000 个重复估计值的轨迹（@fig-spm32）。</span>
<span id="cb87-1525"><a href="#cb87-1525" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1528"><a href="#cb87-1528" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-1529"><a href="#cb87-1529" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-spm32</span></span>
<span id="cb87-1530"><a href="#cb87-1530" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "从上图可以明显看出，过剩产量模型福克斯版本的 K 参数后验分布的 1000 次抽样中缺乏自相关性。下图中的迹线显示了典型的分散值，但保留了一些更极端的峰值。"</span></span>
<span id="cb87-1531"><a href="#cb87-1531" aria-hidden="true" tabindex="-1"></a> <span class="co"># auto-correlation, or lack of, and the K trace Fig 7.32   </span></span>
<span id="cb87-1532"><a href="#cb87-1532" aria-hidden="true" tabindex="-1"></a><span class="fu">parset</span>(<span class="at">plots=</span><span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">1</span>),<span class="at">cex=</span><span class="fl">0.85</span>)    </span>
<span id="cb87-1533"><a href="#cb87-1533" aria-hidden="true" tabindex="-1"></a><span class="fu">acf</span>(parB[,<span class="dv">2</span>],<span class="at">lwd=</span><span class="dv">2</span>)   </span>
<span id="cb87-1534"><a href="#cb87-1534" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="dv">1</span><span class="sc">:</span>N,parB[,<span class="dv">2</span>],<span class="at">type=</span><span class="st">"l"</span>,<span class="at">ylab=</span><span class="st">"K"</span>,<span class="at">ylim=</span><span class="fu">c</span>(<span class="dv">8000</span>,<span class="dv">19000</span>),<span class="at">xlab=</span><span class="st">""</span>)  </span>
<span id="cb87-1535"><a href="#cb87-1535" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-1536"><a href="#cb87-1536" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1537"><a href="#cb87-1537" aria-hidden="true" tabindex="-1"></a>可以从 MCMC 输出中提取这 1000 个可信参数向量，并通过与之前相同的 <span class="in">`spmproj()`</span> 和 <span class="in">`plotproj()`</span> 函数进行处理（@fig-spm33）。</span>
<span id="cb87-1538"><a href="#cb87-1538" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1541"><a href="#cb87-1541" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-1542"><a href="#cb87-1542" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-spm33</span></span>
<span id="cb87-1543"><a href="#cb87-1543" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "利用贝叶斯后验的 1000 个样本得出的 900 吨恒定渔获量的 1000 个预测值（灰色）。虚线为极限和目标参考点。蓝色垂直线为渔业数据的极限，黑色粗线为最佳拟合，红线为各年的第 10 和第 50 分位数。"</span></span>
<span id="cb87-1544"><a href="#cb87-1544" aria-hidden="true" tabindex="-1"></a> <span class="co">#  Fig 7.33   </span></span>
<span id="cb87-1545"><a href="#cb87-1545" aria-hidden="true" tabindex="-1"></a>matparB <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>(parB[,<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>]) <span class="co"># B for Bayesian   </span></span>
<span id="cb87-1546"><a href="#cb87-1546" aria-hidden="true" tabindex="-1"></a>projs <span class="ot">&lt;-</span> <span class="fu">spmproj</span>(matparB,fish,<span class="at">constC=</span><span class="dv">900</span>,<span class="at">projyr=</span><span class="dv">10</span>) <span class="co"># project them  </span></span>
<span id="cb87-1547"><a href="#cb87-1547" aria-hidden="true" tabindex="-1"></a><span class="fu">plotproj</span>(projs,out,<span class="at">qprob=</span><span class="fu">c</span>(<span class="fl">0.1</span>,<span class="fl">0.5</span>),<span class="at">refpts=</span><span class="fu">c</span>(<span class="fl">0.2</span>,<span class="fl">0.4</span>)) <span class="co">#projections  </span></span>
<span id="cb87-1548"><a href="#cb87-1548" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb87-1549"><a href="#cb87-1549" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1550"><a href="#cb87-1550" aria-hidden="true" tabindex="-1"></a>请注意，@fig-spm33 中的中值细红线（第 50 分位数）略微偏离最大似然最佳模型拟合线（黑色）。但是，第 10 分位数相对于 LRP 保持在大致相同的位置，就像在使用渐近误差和自举的分析中观察到的那样。在这里，生物量轨迹的分布范围更广，但管理结果与前两种方法非常相似。</span>
<span id="cb87-1551"><a href="#cb87-1551" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1552"><a href="#cb87-1552" aria-hidden="true" tabindex="-1"></a><span class="fu">## 结束语</span></span>
<span id="cb87-1553"><a href="#cb87-1553" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1554"><a href="#cb87-1554" aria-hidden="true" tabindex="-1"></a>我们已经比较详细研究了如何使用剩余产量模型为渔业提供管理建议。输出结果可能是未来三至五年不同渔获量或努力量制度下的预期种群结果列表。假设相关管辖区存在某种管理目标，管理者可以做出决定，渔业评估科学家也可以为其结果辩护。当然，鉴于任何渔业数据固有的不确定性和补充量动态的变幻莫测，不可能有确切的保证，但假设种群动态至少与以前的经验相似，那么对结果进行辩护是可能的。</span>
<span id="cb87-1555"><a href="#cb87-1555" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1556"><a href="#cb87-1556" aria-hidden="true" tabindex="-1"></a>随着气候变化引起的生物生长和成熟过程的改变，我们也可以预料到补充量也会发生变化，因此显然需要更加谨慎。但是，如果大规模的变化是由单一的风暴或其他事件引起的，那将构成一种新的不确定性，而这种不确定性在评估中是没有考虑到的。这就强调了评估科学家必须了解种群所在区域的情况。任何评估，哪怕是简单的评估，都不应仅仅是分析性的，或主要是自动化的。</span>
<span id="cb87-1557"><a href="#cb87-1557" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1558"><a href="#cb87-1558" aria-hidden="true" tabindex="-1"></a>现实情况是，评估的复杂性和先进性往往与其相对价值相关。只有在渔业可用数据大量增加的情况下，才有可能使用更复杂的模型。因此，鱼类种群有一个自然排序，最有价值的种群通常最受关注。然而，目前在世界各地，人们对为数据贫乏的鱼种提供管理建议的兴趣大增，这通常是受法律要求的驱动。因此，尽管我们只回顾了相对简单的评估方法，但这些方法不应被唾弃或忽视。</span>
<span id="cb87-1559"><a href="#cb87-1559" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1560"><a href="#cb87-1560" aria-hidden="true" tabindex="-1"></a><span class="fu">## 附录：使用 Rcpp 代替 simpspm</span></span>
<span id="cb87-1561"><a href="#cb87-1561" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1562"><a href="#cb87-1562" aria-hidden="true" tabindex="-1"></a>在贝叶斯分析中，我们希望使用 Fox 剩余产量模型。这当然可以使用函数 <span class="in">`simpspm()`</span>，通过修改 *schaefer* 参数来实现。但是</span>
<span id="cb87-1563"><a href="#cb87-1563" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-1566"><a href="#cb87-1566" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb87-1567"><a href="#cb87-1567" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(Rcpp)  </span>
<span id="cb87-1568"><a href="#cb87-1568" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb87-1569"><a href="#cb87-1569" aria-hidden="true" tabindex="-1"></a><span class="fu">cppFunction</span>(<span class="st">'NumericVector simpspmC(NumericVector pars,   </span></span>
<span id="cb87-1570"><a href="#cb87-1570" aria-hidden="true" tabindex="-1"></a><span class="st">             NumericMatrix indat, LogicalVector schaefer) {  </span></span>
<span id="cb87-1571"><a href="#cb87-1571" aria-hidden="true" tabindex="-1"></a><span class="st">   int nyrs = indat.nrow();  </span></span>
<span id="cb87-1572"><a href="#cb87-1572" aria-hidden="true" tabindex="-1"></a><span class="st">   NumericVector predce(nyrs);  </span></span>
<span id="cb87-1573"><a href="#cb87-1573" aria-hidden="true" tabindex="-1"></a><span class="st">   NumericVector biom(nyrs+1);  </span></span>
<span id="cb87-1574"><a href="#cb87-1574" aria-hidden="true" tabindex="-1"></a><span class="st">   double Bt, qval;  </span></span>
<span id="cb87-1575"><a href="#cb87-1575" aria-hidden="true" tabindex="-1"></a><span class="st">   double sumq = 0.0;  </span></span>
<span id="cb87-1576"><a href="#cb87-1576" aria-hidden="true" tabindex="-1"></a><span class="st">   double p = 0.00000001;  </span></span>
<span id="cb87-1577"><a href="#cb87-1577" aria-hidden="true" tabindex="-1"></a><span class="st">   if (schaefer(0) == TRUE) {  </span></span>
<span id="cb87-1578"><a href="#cb87-1578" aria-hidden="true" tabindex="-1"></a><span class="st">     p = 1.0;  </span></span>
<span id="cb87-1579"><a href="#cb87-1579" aria-hidden="true" tabindex="-1"></a><span class="st">   }  </span></span>
<span id="cb87-1580"><a href="#cb87-1580" aria-hidden="true" tabindex="-1"></a><span class="st">   NumericVector ep = exp(pars);  </span></span>
<span id="cb87-1581"><a href="#cb87-1581" aria-hidden="true" tabindex="-1"></a><span class="st">   biom[0] = ep[2];  </span></span>
<span id="cb87-1582"><a href="#cb87-1582" aria-hidden="true" tabindex="-1"></a><span class="st">   for (int i = 0; i &lt; nyrs; i++) {  </span></span>
<span id="cb87-1583"><a href="#cb87-1583" aria-hidden="true" tabindex="-1"></a><span class="st">      Bt = biom[i];  </span></span>
<span id="cb87-1584"><a href="#cb87-1584" aria-hidden="true" tabindex="-1"></a><span class="st">      biom[(i+1)] = Bt + (ep[0]/p)*Bt*(1 - pow((Bt/ep[1]),p)) -   </span></span>
<span id="cb87-1585"><a href="#cb87-1585" aria-hidden="true" tabindex="-1"></a><span class="st">                          indat(i,1);  </span></span>
<span id="cb87-1586"><a href="#cb87-1586" aria-hidden="true" tabindex="-1"></a><span class="st">      if (biom[(i+1)] &lt; 40.0) biom[(i+1)] = 40.0;  </span></span>
<span id="cb87-1587"><a href="#cb87-1587" aria-hidden="true" tabindex="-1"></a><span class="st">      sumq += log(indat(i,2)/biom[i]);  </span></span>
<span id="cb87-1588"><a href="#cb87-1588" aria-hidden="true" tabindex="-1"></a><span class="st">    }  </span></span>
<span id="cb87-1589"><a href="#cb87-1589" aria-hidden="true" tabindex="-1"></a><span class="st">    qval = exp(sumq/nyrs);  </span></span>
<span id="cb87-1590"><a href="#cb87-1590" aria-hidden="true" tabindex="-1"></a><span class="st">    for (int i = 0; i &lt; nyrs; i++) {  </span></span>
<span id="cb87-1591"><a href="#cb87-1591" aria-hidden="true" tabindex="-1"></a><span class="st">      predce[i] = log(biom[i] * qval);  </span></span>
<span id="cb87-1592"><a href="#cb87-1592" aria-hidden="true" tabindex="-1"></a><span class="st">    }  </span></span>
<span id="cb87-1593"><a href="#cb87-1593" aria-hidden="true" tabindex="-1"></a><span class="st">    return predce;  </span></span>
<span id="cb87-1594"><a href="#cb87-1594" aria-hidden="true" tabindex="-1"></a><span class="st">}'</span>)  </span>
<span id="cb87-1595"><a href="#cb87-1595" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
</code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->



</body></html>