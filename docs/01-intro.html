<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-Hans" xml:lang="zh-Hans"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>使用 R 语言进行渔业建模和定量方法研究 - 1&nbsp; 关于建模</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./02-NonIntroductiontoR.html" rel="next">
<link href="./preface.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "没有结果",
    "search-matching-documents-text": "匹配的文档",
    "search-copy-link-title": "复制搜索链接",
    "search-hide-matches-text": "隐藏其它匹配结果",
    "search-more-match-text": "更多匹配结果",
    "search-more-matches-text": "更多匹配结果",
    "search-clear-button-title": "清除",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "取消",
    "search-submit-button-title": "提交",
    "search-label": "搜索"
  }
}</script>
<script>
    MathJax ={
  tex: {
    macros: {
      bm: ["{\\boldsymbol #1}",1],
    }
  }
};
</script>


  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="切换侧边栏导航" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./01-intro.html"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">关于建模</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="切换侧边栏导航" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">使用 R 语言进行渔业建模和定量方法研究</a> 
        <div class="sidebar-tools-main">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="切换深色模式"><i class="bi"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="搜索"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">中文版本说明</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./preface.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01-intro.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">关于建模</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-NonIntroductiontoR.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">R 语言的不完全介绍</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03-simpopmodel.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">简单种群模型</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04-application.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">模型参数估算</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05-staticModel.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">静态模型</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06-uncertainty.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">不确定性</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07-spm.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">剩余产量模型</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08-references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">参考文献</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="2">
    <h2 id="toc-title">目录</h2>
   
  <ul>
  <li><a href="#数据模型的特点" id="toc-数据模型的特点" class="nav-link active" data-scroll-target="#数据模型的特点"><span class="header-section-number">1.1</span> 数据模型的特点</a>
  <ul class="collapse">
  <li><a href="#简介" id="toc-简介" class="nav-link" data-scroll-target="#简介"><span class="header-section-number">1.1.1</span> 简介</a></li>
  <li><a href="#模型设计或选择" id="toc-模型设计或选择" class="nav-link" data-scroll-target="#模型设计或选择"><span class="header-section-number">1.1.2</span> 模型设计或选择</a></li>
  <li><a href="#模型类型的局限" id="toc-模型类型的局限" class="nav-link" data-scroll-target="#模型类型的局限"><span class="header-section-number">1.1.3</span> 模型类型的局限</a></li>
  <li><a href="#数学模型" id="toc-数学模型" class="nav-link" data-scroll-target="#数学模型"><span class="header-section-number">1.1.4</span> 数学模型</a></li>
  <li><a href="#参数和变量" id="toc-参数和变量" class="nav-link" data-scroll-target="#参数和变量"><span class="header-section-number">1.1.5</span> 参数和变量</a></li>
  </ul></li>
  <li><a href="#数学模型属性" id="toc-数学模型属性" class="nav-link" data-scroll-target="#数学模型属性"><span class="header-section-number">1.2</span> 数学模型属性</a>
  <ul class="collapse">
  <li><a href="#决定论与随机性" id="toc-决定论与随机性" class="nav-link" data-scroll-target="#决定论与随机性"><span class="header-section-number">1.2.1</span> 决定论与随机性</a></li>
  <li><a href="#连续与离散模型" id="toc-连续与离散模型" class="nav-link" data-scroll-target="#连续与离散模型"><span class="header-section-number">1.2.2</span> 连续与离散模型</a></li>
  <li><a href="#描述性与解释性" id="toc-描述性与解释性" class="nav-link" data-scroll-target="#描述性与解释性"><span class="header-section-number">1.2.3</span> 描述性与解释性</a></li>
  <li><a href="#测试解释模型" id="toc-测试解释模型" class="nav-link" data-scroll-target="#测试解释模型"><span class="header-section-number">1.2.4</span> 测试解释模型</a></li>
  <li><a href="#现实主义与普遍性" id="toc-现实主义与普遍性" class="nav-link" data-scroll-target="#现实主义与普遍性"><span class="header-section-number">1.2.5</span> 现实主义与普遍性</a></li>
  <li><a href="#模型是理论" id="toc-模型是理论" class="nav-link" data-scroll-target="#模型是理论"><span class="header-section-number">1.2.6</span> 模型是理论</a></li>
  </ul></li>
  <li><a href="#结束语" id="toc-结束语" class="nav-link" data-scroll-target="#结束语"><span class="header-section-number">1.3</span> 结束语</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title"><span id="intro" class="quarto-section-identifier"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">关于建模</span></span></h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> 代码</button></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="数据模型的特点" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="数据模型的特点"><span class="header-section-number">1.1</span> 数据模型的特点</h2>
<section id="简介" class="level3" data-number="1.1.1">
<h3 data-number="1.1.1" class="anchored" data-anchor-id="简介"><span class="header-section-number">1.1.1</span> 简介</h3>
<p>常规的渔业种群评估通常基于种群生产过程和捕捞群体种群动态的数学模型。正面的生产过程包括补充动态（增加数量）和个体生长（增加生物量），而负面的生产过程包括自然死亡率和捕捞死亡率（包括选择性），这既减少了数量，也减少了生物量。种群动态包括一些细节，例如建模动态中使用的时间步长、是否对生物量或数量建模（年龄或大小，或两者兼有）、空间结构的细节以及手头案例的其他细节。如此多的潜在细节意味着生物种群和过程的数学模型种类繁多。然而，仍有可能就这些模式发表一些常规性声明。</p>
<p>由建模人员对现在已知过程或现象进行建模得到的所有模型都是抽象和模拟的。数学模型只是所有模型类别的一个子集，模型可能有多种形式，涵盖了构建的物理表示（想想由 Watson 和 Crick，1953年制作的 DNA 球和棒模型），图表模型（如地理地图），以及这里讨论的更抽象的数学表达。我们可以通过关注模型的不同属性和建模人员做出的决定所施加的一些限制，对这种多样性施加某种概念顺序。</p>
</section>
<section id="模型设计或选择" class="level3" data-number="1.1.2">
<h3 data-number="1.1.2" class="anchored" data-anchor-id="模型设计或选择"><span class="header-section-number">1.1.2</span> 模型设计或选择</h3>
<p>作为抽象，模型从来不是模型主题的完美副本，因此必须有一定程度的选择，建模者认为是系统的基本属性或组件。这种”基本属性或组件”的概念假定系统的所有部分并非都同样重要。例如，在人体血液循环系统的模型中，皮肤某处的浅静脉不会像肾动脉那么重要。如果接受这一假设，那么建模背后的一个基本想法是选择要包含的属性，以便模型的行为可能预期显示与建模系统的可观察行为接近。这种选择被认为是系统的重要属性允许，甚至迫使建模者强调系统建模的特定方面。路线图显示道路在真实地理尺度上大大放大，因为这是地图的要点。拓扑图强调不同的东西，因此在确定使用什么结构时，使用模型的目的也很重要。</p>
<p>选择一个系统在模型中包括哪些方面决定模型是否将普遍适用于一类系统，或者如此专业，以至于它试图模拟特定系统的详细行为（对于系统，人们可能会读取鱼群或种群）。然而，通过选择自然系统的特定部分，模型也受到约束，它可以描述。假设尽管没有完成，但它将充分描述利益进程，而且不包括这些方面不会意外地扭曲整个的代表性（Haddon，1980）。</p>
<p>当然，为了进行抽象，首先需要了解整体，但不幸的是，在现实世界中，还有许多仍然未知或被误解的东西。因此，模型很有可能成为所谓的”误用”。这就是模型的动态或行为，未能捕获正在研究的系统的全部动态。在本书稍后说明的一些示例中，我们将看到资源的平均预测生物质轨迹无法解释资源大小的振荡，显示大约 10 年周期（例如，参见第 <a href="07-spm.html" class="quarto-xref"><span>7</span></a> 章”<a href="./07-spm.html">剩余产量模型</a>“的”Bootstrap 置信区间<em>“</em>节中拟合 dataspm 数据集的剩余产量模型）。在这种情况下，存在以未知机制作用于资源量的影响（或多种影响），这种影响以一种看似有规律或可重复的方式发生作用。假设这种规律是有意义的，由于其背后的机制不包含在模型结构中，那么，很明显，模型不能解释它的影响。这是典型的错误表达，虽然不是所有的错误表达都如此清晰或有如此清晰的规律。</p>
<p>模型设计或模型选择是复杂的，因为将模型放在一起时做出的决定将取决于已知的内容和模型的使用。</p>
</section>
<section id="模型类型的局限" class="level3" data-number="1.1.3">
<h3 data-number="1.1.3" class="anchored" data-anchor-id="模型类型的局限"><span class="header-section-number">1.1.3</span> 模型类型的局限</h3>
<p>模型可以是物理、口头、图形或数学，但是，为模型选择的特定形式对其所能描述的内容施加了限制。例如，对动态种群过程的口头描述对任何人都是挑战，因为人们使用文字捕捉或表达种群的动态特性总是有限度的。单词似乎更适合静态对象的描述。这种限制不一定是由于演讲者缺乏语言技能。相反，这是因为口语（至少我知道的语言）似乎不适合描述动态过程，尤其是在系统中的多个变量或方面正在随着时间的推移或相对于其他变量而变化的情况下。令人高兴的是，我们可以认为数学是一种替代语言，它提供了描述动态系统的极好方式。但是，即使以数学作为我们描述的基础，也有许多决定需要做出。</p>
</section>
<section id="数学模型" class="level3" data-number="1.1.4">
<h3 data-number="1.1.4" class="anchored" data-anchor-id="数学模型"><span class="header-section-number">1.1.4</span> 数学模型</h3>
<p>有许多类型的数学模型。它们可被描述为描述性、解释性、现实性、理想主义、一般性或特殊性：它们也可以是决定性的、随机的、连续的和离散的。有时它们可以是其中一部分或所有类型的组合。有了所有这些可能性，对于数学模型究竟在科学研究中能发挥什么作用，就有可能产生混淆。为了更好地了解特定模型的潜在局限性，我们将尝试解释其中一些术语的含义。</p>
<p>可将数学种群模型称为动态的，因为可以通种群/渔业的过去状态表示现在状态，并有可能描述未来的状态。例如，种群生物量动力学的Schaefer模型 <span class="citation" data-cites="schaefer1957">(<a href="08-references.html#ref-schaefer1957" role="doc-biblioref">Schaefer 1957</a>)</span>可以部分地表示为：</p>
<p><span id="eq-1_1"><span class="math display">\[
B_{t+1} = B_t + r{B_t} \left(1 - \frac{B_t}{K} \right) - C_t  
\qquad(1.1)\]</span></span></p>
<p>其中变量<span class="math inline">\(C_t\)</span> 是时间<span class="math inline">\(t\)</span> 段捕获的渔获量，<span class="math inline">\(B_t\)</span> 是时间 <span class="math inline">\(t\)</span> 开始时的群体生物量（<span class="math inline">\(B_t\)</span> 也是模型的输出变量）。模型参数是 <span class="math inline">\(r\)</span>，表示生物量（或数量，具体取决于对<span class="math inline">\(B_t\)</span>的解释， 或许 <span class="math inline">\(=N_t\)</span> ）的种群增长率， <span class="math inline">\(K\)</span> 为系统所能达到的最大生物量（或数量）（这些参数来自早期数学生态学的 logistic 模型；参见第 <a href="03-simpopmodel.html" class="quarto-xref"><span>3</span></a> 章”<a href="./03-simpopmodel.html">简单种群模型</a><em>“</em>）。通过检查这个相对简单的模型，人们可以看到，在时间 <span class="math inline">\((t+1)\)</span> 的期望生物量水平 与渔获量和前期生物量直接相关 （时间 <span class="math inline">\(= t\)</span>; 该值是连续相关的） 。前期生物量对种群增长的影响由 <span class="math inline">\(r\)</span> 和 <span class="math inline">\(K\)</span> 这两个参数的共同调控。通过计算不同时间段的变量之间的序列相关性，这种动态状态模型与传统的统计分析有显著差异。序列相关性意味着，如果我们每年对一个种群进行抽样，那么严格地说，样本将不独立，这是更经典的统计分析的要求。例如，在封闭的种群中，一年内两龄鱼的数量不能超过上一年的一龄鱼的数量：他们不独立。</p>
</section>
<section id="参数和变量" class="level3" data-number="1.1.5">
<h3 data-number="1.1.5" class="anchored" data-anchor-id="参数和变量"><span class="header-section-number">1.1.5</span> 参数和变量</h3>
<p>在最原始的层面上，数学模型由变量和参数组成的。模型的变量必须表示可定义或可测量的性质（至少在原则上是这样）。参数会修改变量对模型输出的影响或贡献，或与模型内变量之间的关系有关。参数是定量决定变量如何相互作用的因素。它们与模型的变量不同，因为参数是模型安装到观测数据时估计的参数。在 <a href="#eq-1_1" class="quarto-xref">公式&nbsp;<span>1.1</span></a> 中， <span class="math inline">\(B_t\)</span> 和 <span class="math inline">\(C_t\)</span> 是变量，<span class="math inline">\(r\)</span> 和 <span class="math inline">\(K\)</span> 是参数。可以有重叠，例如，人们可能会估计 <span class="math inline">\(B_t\)</span> 系列中非常初始的值，也许 <span class="math inline">\(B_{init}\)</span> 因此，该系列将由一个参数组成，其余的为 <span class="math inline">\(B_{init}\)</span> 的直接函数， <span class="math inline">\(r\)</span> 和 <span class="math inline">\(K\)</span> 为参数和 <span class="math inline">\(C_t\)</span> 为变量。</p>
<p>在任何模型中，如 <a href="#eq-1_1" class="quarto-xref">公式&nbsp;<span>1.1</span></a> 中，我们必须估计或提供参数的恒定值。对于这些变量，任一提供观察到的值（例如，时间系列渔获量， <span class="math inline">\(C_t\)</span> ）或它们是模型的输出（ 如上所述 <span class="math inline">\(B_{init}\)</span> ）。因此，在 <a href="#eq-1_1" class="quarto-xref">公式&nbsp;<span>1.1</span></a> 中，给出时间系列的观测渔获量以及 <span class="math inline">\(B_{init}\)</span> 、<span class="math inline">\(r\)</span> 和 <span class="math inline">\(K\)</span> 的参数估计值，然后是一系列生物量值，<span class="math inline">\(B_t\)</span>，由模型作为输出。只要人们意识到在观测值、估计、变量、参数和模型输出等术语中可能出现混淆的可能性，就可以更清楚地了解在建模特定现象时究竟在做什么。理论与模型结构的关系不一定简单。背景知识和理论可能是模型结构选择背后的驱动力。一组变量之间提议的关系可能构成关于自然组织的一个新假设或理论，或者仅仅是对目前已知内容的总结，准备随着学习的更多而修改。</p>
<p>模型误用的另一个方面源于这样一个事实，即控制种群动态的参数往往被认为是随着时间而保持不变的，这通常应被承认为近似值。如果种群增长率 <span class="math inline">\(r\)</span> 或承载能力<span class="math inline">\(K\)</span> 随时间而随机变化，但假设是恒定的，这将是所谓的过程错误的一个例子。这种过程错误将增加从人群中采集的样本的可观察到的变化，即使可以毫无差错地收集（没有测量错误）。如果参数因人口外部的某些因素（环境因素或生物因素（如捕食者或竞争对手）而变化，那么这种非随机反应就有可能增进对自然世界的了解。因此，构建模型时所作决策的一个重要方面是明确对所选结构的假设。</p>
</section>
</section>
<section id="数学模型属性" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="数学模型属性"><span class="header-section-number">1.2</span> 数学模型属性</h2>
<section id="决定论与随机性" class="level3" data-number="1.2.1">
<h3 data-number="1.2.1" class="anchored" data-anchor-id="决定论与随机性"><span class="header-section-number">1.2.1</span> 决定论与随机性</h3>
<p>我们可以将模型参数定义为<em>定量属性（系统建模），假定该属性要么在可用数据的期间保持不变，要么由环境变化调节</em>。大致而言，参数在模型应用的时间尺度上保持不变的模型称为确定性模型。对于给定的一组输入，由于其恒定的参数，确定性模型始终会为相同的输入提供相同的输出。由于模型变量之间的关系是固定的（恒定参数），因此给定输入的输出由模型的结构”决定”。人们不应被以下情况所混淆：确定模型中的参数通过采取一组预先确定值（例如，招聘指数或可捕获性指数可能每年更改和更改）而发生顺序变化。在这种情况下，虽然估计参数预计会随着时间而变化，但它们以可重复的、确定性的方式（在较长的时间尺度上保持不变）进行，给定输入始终提供相同输出的主要属性仍然有效。</p>
<p>确定性模型与随机模型形成对比，在模型所涵盖的时间段内，至少有一个参数以随机或不可预知的方式变化。因此，如果给出一组输入值，相关的输出值将不确定。不同的参数将从预定的概率分布（无论是从经典概率密度函数 （PDF） 之一）或自定义分布中随机值。因此，例如，在模拟鱼群时，每年的补充量水平可能达到平均值正负随机量，由随机变种 <a href="#eq-1_2" class="quarto-xref">公式&nbsp;<span>1.2</span></a> 的性质决定。</p>
<p><span id="eq-1_2"><span class="math display">\[
R_{y} = \bar{R} e^{N(0,\sigma^{2}_{R})-\sigma^{2}_{R}/2}
\qquad(1.2)\]</span></span></p>
<p>其中<span class="math inline">\(R_y\)</span> 是年<span class="math inline">\(y\)</span> 的补充量，<span class="math inline">\(\bar R\)</span> 是年间的平均补充量（这本身可能是资源规模的函数），<span class="math inline">\(N(0, \sigma_R^2)\)</span> 是用于随机变量的符号，其值在本示例中是均值为0 和方差为<span class="math inline">\(\sigma^2_R\)</span> 的正态分布（即具有正值和负值）。通过将正态分布以指数项表示，这将指定为对数正态变异，<span class="math inline">\(-\sigma_R^2/2\)</span> 为补充量时间系列中 Log-Normal 变异的偏差更正项（Haltuch等，2008）。</p>
<p>模拟模型与具有估计参数的模型不同。这两种模型的目标也不同，前者可能被用来探讨不同管理方案的影响，而后者可能被用来估计资源的当前衰竭状态。</p>
<p>鉴于一组输入数据（假定是完整和准确的;注意这些假设），一个确定性模型表示其所有可能的反应。然而，随机模型构成了所谓的蒙特卡洛模拟的基础，其中模型是反复运行相同的输入数据，但每次运行新的随机值产生为随机参数，如 <a href="#eq-1_2" class="quarto-xref">公式&nbsp;<span>1.2</span></a> 。 对于每个运行，都会产生不同的输出，并绘制这些输出表或图表，以查看从此类系统中可以预期到哪些结果范围。即使模型固有的变化通常是分布的，但这并不意味着可以预期特定输出通常分布在某些平均值上。如果模型中有非线性方面，可能会出现偏斜和其他更改。</p>
<p>未来的种群预测、风险评估和确定数据中不确定性的影响都需要使用蒙特卡洛建模。模型结构的模拟测试是一个非常强大的工具。在 第 <a href="06-uncertainty.html" class="quarto-xref"><span>6</span></a> 章 “<a href="./06-uncertainty.html">不确定性</a>”（<em>On Uncertainty</em>）和第 <a href="07-spm.html" class="quarto-xref"><span>7</span></a> 章“<a href="./07-spm.html">剩余产量模型</a>”（<em>Surplus Production Models</em>）中，详细介绍了这些预测的运行情况。</p>
</section>
<section id="连续与离散模型" class="level3" data-number="1.2.2">
<h3 data-number="1.2.2" class="anchored" data-anchor-id="连续与离散模型"><span class="header-section-number">1.2.2</span> 连续与离散模型</h3>
<p>早期的渔业建模专家使用连续的微分方程来设计他们的模型，所以模型中的时间步长都是无限小的 （Beverton 和 Holt，1957）。当时，计算机还处于起步阶段，分析解决方案是当今的文化。因此，早期渔业模型是利用微积分形成的，其结构的某些部分更多地取决于可以分析解决的问题，而不是因为它们以特定准确的方式反映了自然。同时，这些模型的应用反映了或假定了平衡条件。幸运的是，我们现在可以使用易于访问的计算机和软件模拟资源状况，我们可以使用更现实或更详细的公式。虽然可能无法通过分析来求解此类模型（即，如果模型配方具有该结构，那么它的解就必须是这样的），但通常可以通过数值方式求解（了解情况并改进试验和错误）。尽管这两种方法仍在使用，但渔业科学的一大变化是从连续的微分方程向差异方程的转变，差分方程试图通过离散间隔（从无穷小到每年的时间步长）变化时对系统进行建模。</p>
<p>模型构建的其他方面可以限制模型可以捕获或描述的行为。模型的实际结构或形式施加了限制。例如，如果数学建模人员使用差分方程来描述系统，那么事件的分辨率不能比模型构建的时间间隔更精确。这种明显的效果发生在许多地方。例如，在包含季节性成分的模型中，分辨率明显有限，具体取决于可用数据是持几周、几月还是其他间隔。例如，在第 <a href="05-staticModel.html" class="quarto-xref"><span>5</span></a>章 “<a href="./05-staticModel.html">静态模型</a>”（<em>Static Models</em>）中，我们使用每周收集的数据来拟合季节性增长曲线，很明显，如果数据是每年收集的，那么描述季节性增长将是不可能的。</p>
</section>
<section id="描述性与解释性" class="level3" data-number="1.2.3">
<h3 data-number="1.2.3" class="anchored" data-anchor-id="描述性与解释性"><span class="header-section-number">1.2.3</span> 描述性与解释性</h3>
<p>一个模型是离散的还是连续的，是确定性的还是随机的，这是模型结构的问题，它会明显影响着可以建模的内容。使用模型的目的也很重要。为了使模型具有描述性，它只需要模拟观察数据的经验行为。例如，对个体生长数据的精确拟合通常可以通过使用多项式方程获得:</p>
<p><span id="eq-1_3"><span class="math display">\[
y = a +bx +cx^2 + dx^3 + \cdots + mx^n
\qquad(1.3)\]</span></span></p>
<p>其中未试图解释使用的多个参数(通常人们不会使用大于6阶的多项式，2阶或3阶更为常见)。这样的描述模型可以被视为黑盒，它为给定的输入提供确定性的输出。不需要知道这些模型的工作原理；甚至可以使用简单的查询表，通过从值的交叉列表中逐字查找输出，从给定的输入值生成特定的输出值。这样的黑盒模型只能是描述性的，除此之外别无其他。即使经验描述性模型可以做出假设，但如果特定的情况不能满足这些假设，这并不意味着需要完全拒绝模型，而只是必须限制该模型应用于哪些系统。除了所描述的变量外，这种纯描述性模型不需要具有现实主义元素，尽管它们的参数通常可以给出解释(如可实现的最大规模)。但同样重要的是，这些模型描述现有数据的程度，而不是它们的参数值是否具有生物学意义。在第 <a href="04-application.html" class="quarto-xref"><span>4</span></a> 章“<a href="04-application.qdm">模型参数估计</a>”（<em>Model Parameter Estimation</em>）中，我们将考察三条增长曲线，包括著名的 von Bertalanffy 曲线。该部分将对这种描述性模型的使用进行更深入的讨论。</p>
<p>解释性模型还提供了对感兴趣的实证观察的描述，但除此之外，它们试图提供一些理由或解释，一种机制，说明为什么所注意到的特定观察发生而不是不同的数据。对于解释性模型，有必要考虑假设和参数，以及构成模型的变量。通过尝试使参数和变量，以及变量如何相互作用，反映自然，解释模型试图模拟自然界中的真实事件。如果模型包含理论构造（假设、变量或参数），则模型具有解释性，这些结构声称与自然过程有关，而不仅仅是与自然的行为方式相关。</p>
</section>
<section id="测试解释模型" class="level3" data-number="1.2.4">
<h3 data-number="1.2.4" class="anchored" data-anchor-id="测试解释模型"><span class="header-section-number">1.2.4</span> 测试解释模型</h3>
<p>解释性模型至少部分地是关于自然的机制和结构以及自然如何运作的假设或理论。因此，它们应该根据自然界的观测结果进行测试。但是，我们如何测试解释模型呢？数据拟合模型可以提供模型测试吗？如果模型预测的观测数据的预期值占观测数据内变异性的很大比例，那么我们对模型充分描述观测结果的信心可能很大。但初始模型拟合并不构成对模型结构的直接测试。拟合模型并不测试模型是否解释观测到的数据；它只测试模型描述的程度和与数据一致性（Haddon，1980）。解释和描述之间的区别非常重要。一个纯粹的描述性或经验模型可以提供同样适合的数据，这有望表明，我们需要进一步的，独立的观察，以真正测试模型的结构。需要测试的不仅是模型是否适合一组观察到的数据（即不仅适合的质量），而且模型假设是否有效，以及模型变量之间的相互作用（如模型中的编码）是否密切反映自然。</p>
<p>将目前拟合的模型与新的观测结果进行比较确实构成了某种测试。理想情况下，考虑到特定的输入，该模型将提供预测的观测以及围绕预期结果的置信间隔。如果模型预测，鉴于输入，其价值极不可能，则观察结果将与模型不一致。但是，有了这个测试，如果有反驳，没有迹象表明模型的哪个方面有问题。这是因为这不是对模型结构的测试，而只是对特定参数值（ 给定模型结构）是否足以预测未来结果的测试！我们不知道拟合过程是否有限，因为现有数据没有充分说明所研究资源固有的变化潜力。是假设还是建模者使变量相互作用的特殊方式？模型是否过于简单，这意味着重要的相互作用或变量被排除在结构外？如果没有对假设或特定变量重要性的独立测试，我们就无法判断。</p>
<p>如果新的观测结果与模型一致，那么人们就没有什么收获了。实际上，新数据很可能会被包括在原始数据和重新估计的参数中。但这同样适用于纯粹的经验模型。所需要的是独立测试，确保所选择的结构不遗漏重要的变异来源；要验证这一点，需要的不仅仅是将预期输出与实际观测结果进行简单比较。</p>
<p>虽然我们可以满足于观测数据和模型预测数据之间的拟合质量，但我们永远无法确定我们确定的模型是最好的。当然，有些模型可能看起来不太可接受，因为其它模型可能更有效地拟合数据。</p>
<p>然而，任何关于哪条曲线或模型最能代表一组数据的讨论，不仅取决于拟合的质量，而且还取决于有关变量之间关系形式的其他信息。带有每个数据点参数的经验模型可以精确地拟合数据集，但不能提供任何有用的信息。显然，在这种情况下，除了数值拟合的质量之外，还必须使用其他标准来决定应该选择哪个模型。在第 <a href="05-staticModel.html" class="quarto-xref"><span>5</span></a> 章”<a href="./05-staticModel.html">静态模型</a>“（<em>Static Models</em>）中，我们考虑了第 <a href="05-staticModel.html#sec-label" class="quarto-xref"><span>5.4</span></a> 节 <em>目标模型选择</em> 的方法，试图评估增加模型中的参数数量在统计上是否合理。任何解释模型都必须具有生物学上的合理性。甚至可以给一个完全任意的模型结构的参数赋予意义。然而，这种解释将是临时的，而且仅在表面上可信。模型除了描述一组特定的数据外，不可能做更多的事情。解释性模型应该适用于新的数据集，尽管可能需要一组新的特定参数来适应新的情况。</p>
<p>即使在现实的模型中，精度也不可能实现，因为我们对拟合变量的估计(观测误差)或系统响应(可能是环境变化(模型参数的过程误差))的内在不确定性。换句话说，在我们预测的系统结果的精度方面，可能无法超越某些限制(拟合质量可能有内在限制)。</p>
</section>
<section id="现实主义与普遍性" class="level3" data-number="1.2.5">
<h3 data-number="1.2.5" class="anchored" data-anchor-id="现实主义与普遍性"><span class="header-section-number">1.2.5</span> 现实主义与普遍性</h3>
<p>与我们是否应该使用解释性模型相关的问题是模型中的现实主义问题。纯粹的描述性模型不需要任何现实的东西。但这只是一个假设，即如果某个科研人同正在开发一个解释模型，那么至少解释模型的一部分必须是现实的。例如，在年龄或体长可以区分的种群中，年龄或体长结构模型会被认为比将所有年龄或体长组集中在一起的模型更现实。但是一个模型可以是真实的和经验的结合。</p>
<p>一般模型将具有非常广泛的适用性领域，即在许多情况下可以有效应用。在渔业科学的发展中，将许多描述特定过程的模型（例如，个体生长）纳入一个更普遍的数学模型，这些模型是特殊情况（见第<a href="05-staticModel.html" class="quarto-xref"><span>5</span></a> 章“<a href="05-statiicModel.qmd">静态模型</a>”（<em>Static Models</em>））。通常这涉及增加所涉及的参数数量，但尽管如此，这些新模型显然在数学上更为通用。很难就这种更笼统的方程/模型是否不太现实得出结论。这将是一个问题，是否额外的参数可以现实地解释，或者它们是否只是临时解决方案，将不同的方程组合成一个更数学通用的方程。随着更复杂的现象，如年龄结构模型，一般模型通常不会给出准确的预测，因为更专业的模型调整到特定的情况。正因如此，建模人员在处理特定情况时，往往认为数学上一般模型不太现实（Maynard-Smith, 1974）。</p>
</section>
<section id="模型是理论" class="level3" data-number="1.2.6">
<h3 data-number="1.2.6" class="anchored" data-anchor-id="模型是理论"><span class="header-section-number">1.2.6</span> 模型是理论</h3>
<p>所有模型都可能被认为具有理论成分，甚至被认为是经验模型。它成为一个感知问题，而不是模型结构。例如，通过简单的模型，基本假设可以开始承担假设断言的重担。因此，如果使用 logistic 方程来描述种群的增长，它就导入了种群增长率的密度依赖补偿与种群密度线性相关的假设。换言之，种群规模增长对种群增长的负面影响与种群规模呈线性关系（见第 <a href="03-simpopmodel.html" class="quarto-xref"><span>3</span></a> 章“<a href="./03-simpopmodel.html">简单种群模型</a><em>”</em>（<em>Simple Population Models</em>））。这可以被视为一个领域假设（即模型只能有效地应用于密度依赖效应与种群密度线性相关的情况）或理论（非线性密度依赖效应在建模的系统中不重要）。这显然是一个感知或建模目标的问题，即这两种可能性中哪一种是获得的。这是一个很好的理由，人们应该明确解释一个人的模型的假设。</p>
<p>如果将自己局限于纯粹的经验关系，那么他的模型唯一可以改进的方法就是增加模型所解释的观测结果的方差。没有有效的期望，经验模型将提供洞察一个系统的未来行为。解释/理论模型的一个优点是，它应该能够检验假设、变量之间的关系和误差结构，独立于与观测结果的拟合质量。</p>
<p>因此，应该有可能提出证据来支持一个模型，这超出了拟合的质量。那些建议的结构没有以这种方式得到支持的模型，也可能是经验性的。</p>
</section>
</section>
<section id="结束语" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="结束语"><span class="header-section-number">1.3</span> 结束语</h2>
<p>编写和讨论模型，它们的使用和构建有时是有价值的，因为它提醒我们在其中工作的框架。如果你想成为一名建模人员，对数学模型的优缺点的理论理解总是有价值的。然而，通常理解模型及其属性的最佳方法是实际使用它们，并通过操作它们的参数和检查它们在实践中如何操作来探索它们的属性。希望您会发现，使用 <code>R</code> 作为编程语言使这些探索相对容易实现。</p>
<p>下面的材料包括非常一般的方法和其他更具体的方法。这本书的目的是鼓励你，也许是为你提供一个开始，发展你自己的分析功能，也许是通过修改本书中的一些内容。您可以这样做，以便您自己的分析变得更快、更容易，并且在某种程度上是自动化的，从而让您有更多的时间来思考和解释您的发现。如果您使用的是其他更少的程序性分析的话，您需要机械地进行分析的时间越少，就有越多的时间来思考科学问题并进行更深入的探索。使用<code>R</code>来实现您的建模的一个主要优势是，您所做的任何工作都应该变得更容易重复，因此，大概也更容易防御。当然，这里所涉及的主题范围只是触及了可用内容的表面，但试图探索一些基本方法，如最大似然估计。请记住，有大量的 R 包可用，这些可以帮助您实现自己的模型，无论是统计或动态。</p>


<!-- -->

<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-schaefer1957" class="csl-entry" role="listitem">
Schaefer, M. B. 1957. <span>《A study of the dynamics of the fishery for yellowfin tuna in the eastern tropical pacific ocean》</span>. 收入. <a href="https://www.semanticscholar.org/paper/A-study-of-the-dynamics-of-the-fishery-for-tuna-in-Schaefer/29677d4a85d251d68d645584b2505c51c1ef1728">https://www.semanticscholar.org/paper/A-study-of-the-dynamics-of-the-fishery-for-tuna-in-Schaefer/29677d4a85d251d68d645584b2505c51c1ef1728</a>.
</div>
</div>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "已复制");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "已复制");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./preface.html" class="pagination-link  aria-label=" preface"="">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Preface</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./02-NonIntroductiontoR.html" class="pagination-link" aria-label="<span class='chapter-number'>2</span>&nbsp; <span class='chapter-title'>R 语言的不完全介绍</span>">
        <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">R 语言的不完全介绍</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">源代码</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb1" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu"># 关于建模 {#intro}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">## 数据模型的特点</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="fu">### 简介</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>常规的渔业种群评估通常基于种群生产过程和捕捞群体种群动态的数学模型。正面的生产过程包括补充动态（增加数量）和个体生长（增加生物量），而负面的生产过程包括自然死亡率和捕捞死亡率（包括选择性），这既减少了数量，也减少了生物量。种群动态包括一些细节，例如建模动态中使用的时间步长、是否对生物量或数量建模（年龄或大小，或两者兼有）、空间结构的细节以及手头案例的其他细节。如此多的潜在细节意味着生物种群和过程的数学模型种类繁多。然而，仍有可能就这些模式发表一些常规性声明。</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>由建模人员对现在已知过程或现象进行建模得到的所有模型都是抽象和模拟的。数学模型只是所有模型类别的一个子集，模型可能有多种形式，涵盖了构建的物理表示（想想由 Watson 和 Crick，1953年制作的 DNA 球和棒模型），图表模型（如地理地图），以及这里讨论的更抽象的数学表达。我们可以通过关注模型的不同属性和建模人员做出的决定所施加的一些限制，对这种多样性施加某种概念顺序。</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="fu">### 模型设计或选择</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>作为抽象，模型从来不是模型主题的完美副本，因此必须有一定程度的选择，建模者认为是系统的基本属性或组件。这种"基本属性或组件"的概念假定系统的所有部分并非都同样重要。例如，在人体血液循环系统的模型中，皮肤某处的浅静脉不会像肾动脉那么重要。如果接受这一假设，那么建模背后的一个基本想法是选择要包含的属性，以便模型的行为可能预期显示与建模系统的可观察行为接近。这种选择被认为是系统的重要属性允许，甚至迫使建模者强调系统建模的特定方面。路线图显示道路在真实地理尺度上大大放大，因为这是地图的要点。拓扑图强调不同的东西，因此在确定使用什么结构时，使用模型的目的也很重要。</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>选择一个系统在模型中包括哪些方面决定模型是否将普遍适用于一类系统，或者如此专业，以至于它试图模拟特定系统的详细行为（对于系统，人们可能会读取鱼群或种群）。然而，通过选择自然系统的特定部分，模型也受到约束，它可以描述。假设尽管没有完成，但它将充分描述利益进程，而且不包括这些方面不会意外地扭曲整个的代表性（Haddon，1980）。</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>当然，为了进行抽象，首先需要了解整体，但不幸的是，在现实世界中，还有许多仍然未知或被误解的东西。因此，模型很有可能成为所谓的"误用"。这就是模型的动态或行为，未能捕获正在研究的系统的全部动态。在本书稍后说明的一些示例中，我们将看到资源的平均预测生物质轨迹无法解释资源大小的振荡，显示大约 10 年周期（例如，参见第 <span class="co">[</span><span class="ot">-@sec-surplusproduction</span><span class="co">]</span> 章”<span class="co">[</span><span class="ot">剩余产量模型</span><span class="co">](07-spm.qmd)</span>“的”Bootstrap 置信区间*“*节中拟合 dataspm 数据集的剩余产量模型）。在这种情况下，存在以未知机制作用于资源量的影响（或多种影响），这种影响以一种看似有规律或可重复的方式发生作用。假设这种规律是有意义的，由于其背后的机制不包含在模型结构中，那么，很明显，模型不能解释它的影响。这是典型的错误表达，虽然不是所有的错误表达都如此清晰或有如此清晰的规律。</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>模型设计或模型选择是复杂的，因为将模型放在一起时做出的决定将取决于已知的内容和模型的使用。</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="fu">### 模型类型的局限</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>模型可以是物理、口头、图形或数学，但是，为模型选择的特定形式对其所能描述的内容施加了限制。例如，对动态种群过程的口头描述对任何人都是挑战，因为人们使用文字捕捉或表达种群的动态特性总是有限度的。单词似乎更适合静态对象的描述。这种限制不一定是由于演讲者缺乏语言技能。相反，这是因为口语（至少我知道的语言）似乎不适合描述动态过程，尤其是在系统中的多个变量或方面正在随着时间的推移或相对于其他变量而变化的情况下。令人高兴的是，我们可以认为数学是一种替代语言，它提供了描述动态系统的极好方式。但是，即使以数学作为我们描述的基础，也有许多决定需要做出。</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="fu">### 数学模型</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>有许多类型的数学模型。它们可被描述为描述性、解释性、现实性、理想主义、一般性或特殊性：它们也可以是决定性的、随机的、连续的和离散的。有时它们可以是其中一部分或所有类型的组合。有了所有这些可能性，对于数学模型究竟在科学研究中能发挥什么作用，就有可能产生混淆。为了更好地了解特定模型的潜在局限性，我们将尝试解释其中一些术语的含义。</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>可将数学种群模型称为动态的，因为可以通种群/渔业的过去状态表示现在状态，并有可能描述未来的状态。例如，种群生物量动力学的Schaefer模型 <span class="co">[</span><span class="ot">@schaefer1957</span><span class="co">]</span>可以部分地表示为：</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>B_{t+1} = B_t + r{B_t} \left(1 - \frac{B_t}{K} \right) - C_t  </span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>$$ {#eq-1_1}</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>其中变量$C_t$ 是时间$t$ 段捕获的渔获量，$B_t$ 是时间 $t$ 开始时的群体生物量（$B_t$ 也是模型的输出变量）。模型参数是 $r$，表示生物量（或数量，具体取决于对$B_t$的解释， 或许 $=N_t$ ）的种群增长率， $K$ 为系统所能达到的最大生物量（或数量）（这些参数来自早期数学生态学的 logistic 模型；参见第 <span class="co">[</span><span class="ot">-@sec-simplemodel</span><span class="co">]</span> 章”<span class="co">[</span><span class="ot">简单种群模型</span><span class="co">](03-simpopmodel.qmd)</span>*“*）。通过检查这个相对简单的模型，人们可以看到，在时间 $(t+1)$ 的期望生物量水平 与渔获量和前期生物量直接相关 （时间 $= t$; 该值是连续相关的） 。前期生物量对种群增长的影响由 $r$ 和 $K$ 这两个参数的共同调控。通过计算不同时间段的变量之间的序列相关性，这种动态状态模型与传统的统计分析有显著差异。序列相关性意味着，如果我们每年对一个种群进行抽样，那么严格地说，样本将不独立，这是更经典的统计分析的要求。例如，在封闭的种群中，一年内两龄鱼的数量不能超过上一年的一龄鱼的数量：他们不独立。</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a><span class="fu">### 参数和变量</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>在最原始的层面上，数学模型由变量和参数组成的。模型的变量必须表示可定义或可测量的性质（至少在原则上是这样）。参数会修改变量对模型输出的影响或贡献，或与模型内变量之间的关系有关。参数是定量决定变量如何相互作用的因素。它们与模型的变量不同，因为参数是模型安装到观测数据时估计的参数。在 @eq-1_1 中， $B_t$ 和 $C_t$ 是变量，$r$ 和 $K$ 是参数。可以有重叠，例如，人们可能会估计 $B_t$ 系列中非常初始的值，也许 $B_{init}$ 因此，该系列将由一个参数组成，其余的为 $B_{init}$ 的直接函数， $r$ 和 $K$ 为参数和 $C_t$ 为变量。</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>在任何模型中，如 @eq-1_1 中，我们必须估计或提供参数的恒定值。对于这些变量，任一提供观察到的值（例如，时间系列渔获量， $C_t$ ）或它们是模型的输出（ 如上所述 $B_{init}$ ）。因此，在 @eq-1_1 中，给出时间系列的观测渔获量以及 $B_{init}$ 、$r$ 和 $K$ 的参数估计值，然后是一系列生物量值，$B_t$，由模型作为输出。只要人们意识到在观测值、估计、变量、参数和模型输出等术语中可能出现混淆的可能性，就可以更清楚地了解在建模特定现象时究竟在做什么。理论与模型结构的关系不一定简单。背景知识和理论可能是模型结构选择背后的驱动力。一组变量之间提议的关系可能构成关于自然组织的一个新假设或理论，或者仅仅是对目前已知内容的总结，准备随着学习的更多而修改。</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>模型误用的另一个方面源于这样一个事实，即控制种群动态的参数往往被认为是随着时间而保持不变的，这通常应被承认为近似值。如果种群增长率 $r$ 或承载能力$K$ 随时间而随机变化，但假设是恒定的，这将是所谓的过程错误的一个例子。这种过程错误将增加从人群中采集的样本的可观察到的变化，即使可以毫无差错地收集（没有测量错误）。如果参数因人口外部的某些因素（环境因素或生物因素（如捕食者或竞争对手）而变化，那么这种非随机反应就有可能增进对自然世界的了解。因此，构建模型时所作决策的一个重要方面是明确对所选结构的假设。</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a><span class="fu">## 数学模型属性</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a><span class="fu">### 决定论与随机性</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>我们可以将模型参数定义为*定量属性（系统建模），假定该属性要么在可用数据的期间保持不变，要么由环境变化调节*。大致而言，参数在模型应用的时间尺度上保持不变的模型称为确定性模型。对于给定的一组输入，由于其恒定的参数，确定性模型始终会为相同的输入提供相同的输出。由于模型变量之间的关系是固定的（恒定参数），因此给定输入的输出由模型的结构"决定"。人们不应被以下情况所混淆：确定模型中的参数通过采取一组预先确定值（例如，招聘指数或可捕获性指数可能每年更改和更改）而发生顺序变化。在这种情况下，虽然估计参数预计会随着时间而变化，但它们以可重复的、确定性的方式（在较长的时间尺度上保持不变）进行，给定输入始终提供相同输出的主要属性仍然有效。</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>确定性模型与随机模型形成对比，在模型所涵盖的时间段内，至少有一个参数以随机或不可预知的方式变化。因此，如果给出一组输入值，相关的输出值将不确定。不同的参数将从预定的概率分布（无论是从经典概率密度函数 （PDF） 之一）或自定义分布中随机值。因此，例如，在模拟鱼群时，每年的补充量水平可能达到平均值正负随机量，由随机变种 @eq-1_2 的性质决定。</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>R_{y} = \bar{R} e^{N(0,\sigma^{2}_{R})-\sigma^{2}_{R}/2}</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>$$ {#eq-1_2}</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>其中$R_y$ 是年$y$ 的补充量，$\bar R$ 是年间的平均补充量（这本身可能是资源规模的函数），$N(0, \sigma_R^2)$ 是用于随机变量的符号，其值在本示例中是均值为0 和方差为$\sigma^2_R$ 的正态分布（即具有正值和负值）。通过将正态分布以指数项表示，这将指定为对数正态变异，$-\sigma_R^2/2$ 为补充量时间系列中 Log-Normal 变异的偏差更正项（Haltuch等，2008）。</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>模拟模型与具有估计参数的模型不同。这两种模型的目标也不同，前者可能被用来探讨不同管理方案的影响，而后者可能被用来估计资源的当前衰竭状态。</span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>鉴于一组输入数据（假定是完整和准确的;注意这些假设），一个确定性模型表示其所有可能的反应。然而，随机模型构成了所谓的蒙特卡洛模拟的基础，其中模型是反复运行相同的输入数据，但每次运行新的随机值产生为随机参数，如 @eq-1_2 。 对于每个运行，都会产生不同的输出，并绘制这些输出表或图表，以查看从此类系统中可以预期到哪些结果范围。即使模型固有的变化通常是分布的，但这并不意味着可以预期特定输出通常分布在某些平均值上。如果模型中有非线性方面，可能会出现偏斜和其他更改。</span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>未来的种群预测、风险评估和确定数据中不确定性的影响都需要使用蒙特卡洛建模。模型结构的模拟测试是一个非常强大的工具。在 第 <span class="co">[</span><span class="ot">-@sec-uncertainty</span><span class="co">]</span> 章 "<span class="co">[</span><span class="ot">不确定性</span><span class="co">](06-uncertainty.qmd)</span>"（*On Uncertainty*）和第 [-@sec-surplusproduction] 章“[剩余产量模型](07-spm.qmd)”（*Surplus Production Models*）中，详细介绍了这些预测的运行情况。</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a><span class="fu">### 连续与离散模型</span></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>早期的渔业建模专家使用连续的微分方程来设计他们的模型，所以模型中的时间步长都是无限小的 （Beverton 和 Holt，1957）。当时，计算机还处于起步阶段，分析解决方案是当今的文化。因此，早期渔业模型是利用微积分形成的，其结构的某些部分更多地取决于可以分析解决的问题，而不是因为它们以特定准确的方式反映了自然。同时，这些模型的应用反映了或假定了平衡条件。幸运的是，我们现在可以使用易于访问的计算机和软件模拟资源状况，我们可以使用更现实或更详细的公式。虽然可能无法通过分析来求解此类模型（即，如果模型配方具有该结构，那么它的解就必须是这样的），但通常可以通过数值方式求解（了解情况并改进试验和错误）。尽管这两种方法仍在使用，但渔业科学的一大变化是从连续的微分方程向差异方程的转变，差分方程试图通过离散间隔（从无穷小到每年的时间步长）变化时对系统进行建模。</span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>模型构建的其他方面可以限制模型可以捕获或描述的行为。模型的实际结构或形式施加了限制。例如，如果数学建模人员使用差分方程来描述系统，那么事件的分辨率不能比模型构建的时间间隔更精确。这种明显的效果发生在许多地方。例如，在包含季节性成分的模型中，分辨率明显有限，具体取决于可用数据是持几周、几月还是其他间隔。例如，在第 <span class="co">[</span><span class="ot">-@sec-staticmodel</span><span class="co">]</span>章 "<span class="co">[</span><span class="ot">静态模型</span><span class="co">](05-staticModel.qmd)</span>"（*Static Models*）中，我们使用每周收集的数据来拟合季节性增长曲线，很明显，如果数据是每年收集的，那么描述季节性增长将是不可能的。</span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a><span class="fu">### 描述性与解释性</span></span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>一个模型是离散的还是连续的，是确定性的还是随机的，这是模型结构的问题，它会明显影响着可以建模的内容。使用模型的目的也很重要。为了使模型具有描述性，它只需要模拟观察数据的经验行为。例如，对个体生长数据的精确拟合通常可以通过使用多项式方程获得:</span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>y = a +bx +cx^2 + dx^3 + \cdots + mx^n</span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>$$ {#eq-1_3}</span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a>其中未试图解释使用的多个参数(通常人们不会使用大于6阶的多项式，2阶或3阶更为常见)。这样的描述模型可以被视为黑盒，它为给定的输入提供确定性的输出。不需要知道这些模型的工作原理；甚至可以使用简单的查询表，通过从值的交叉列表中逐字查找输出，从给定的输入值生成特定的输出值。这样的黑盒模型只能是描述性的，除此之外别无其他。即使经验描述性模型可以做出假设，但如果特定的情况不能满足这些假设，这并不意味着需要完全拒绝模型，而只是必须限制该模型应用于哪些系统。除了所描述的变量外，这种纯描述性模型不需要具有现实主义元素，尽管它们的参数通常可以给出解释(如可实现的最大规模)。但同样重要的是，这些模型描述现有数据的程度，而不是它们的参数值是否具有生物学意义。在第 <span class="co">[</span><span class="ot">-@sec-paraestimat</span><span class="co">]</span> 章“<span class="co">[</span><span class="ot">模型参数估计</span><span class="co">](04-application.qdm)</span>”（*Model Parameter Estimation*）中，我们将考察三条增长曲线，包括著名的 von Bertalanffy 曲线。该部分将对这种描述性模型的使用进行更深入的讨论。</span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a>解释性模型还提供了对感兴趣的实证观察的描述，但除此之外，它们试图提供一些理由或解释，一种机制，说明为什么所注意到的特定观察发生而不是不同的数据。对于解释性模型，有必要考虑假设和参数，以及构成模型的变量。通过尝试使参数和变量，以及变量如何相互作用，反映自然，解释模型试图模拟自然界中的真实事件。如果模型包含理论构造（假设、变量或参数），则模型具有解释性，这些结构声称与自然过程有关，而不仅仅是与自然的行为方式相关。</span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a><span class="fu">### 测试解释模型</span></span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a>解释性模型至少部分地是关于自然的机制和结构以及自然如何运作的假设或理论。因此，它们应该根据自然界的观测结果进行测试。但是，我们如何测试解释模型呢？数据拟合模型可以提供模型测试吗？如果模型预测的观测数据的预期值占观测数据内变异性的很大比例，那么我们对模型充分描述观测结果的信心可能很大。但初始模型拟合并不构成对模型结构的直接测试。拟合模型并不测试模型是否解释观测到的数据；它只测试模型描述的程度和与数据一致性（Haddon，1980）。解释和描述之间的区别非常重要。一个纯粹的描述性或经验模型可以提供同样适合的数据，这有望表明，我们需要进一步的，独立的观察，以真正测试模型的结构。需要测试的不仅是模型是否适合一组观察到的数据（即不仅适合的质量），而且模型假设是否有效，以及模型变量之间的相互作用（如模型中的编码）是否密切反映自然。</span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a>将目前拟合的模型与新的观测结果进行比较确实构成了某种测试。理想情况下，考虑到特定的输入，该模型将提供预测的观测以及围绕预期结果的置信间隔。如果模型预测，鉴于输入，其价值极不可能，则观察结果将与模型不一致。但是，有了这个测试，如果有反驳，没有迹象表明模型的哪个方面有问题。这是因为这不是对模型结构的测试，而只是对特定参数值（ 给定模型结构）是否足以预测未来结果的测试！我们不知道拟合过程是否有限，因为现有数据没有充分说明所研究资源固有的变化潜力。是假设还是建模者使变量相互作用的特殊方式？模型是否过于简单，这意味着重要的相互作用或变量被排除在结构外？如果没有对假设或特定变量重要性的独立测试，我们就无法判断。</span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>如果新的观测结果与模型一致，那么人们就没有什么收获了。实际上，新数据很可能会被包括在原始数据和重新估计的参数中。但这同样适用于纯粹的经验模型。所需要的是独立测试，确保所选择的结构不遗漏重要的变异来源；要验证这一点，需要的不仅仅是将预期输出与实际观测结果进行简单比较。</span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a>虽然我们可以满足于观测数据和模型预测数据之间的拟合质量，但我们永远无法确定我们确定的模型是最好的。当然，有些模型可能看起来不太可接受，因为其它模型可能更有效地拟合数据。</span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a>然而，任何关于哪条曲线或模型最能代表一组数据的讨论，不仅取决于拟合的质量，而且还取决于有关变量之间关系形式的其他信息。带有每个数据点参数的经验模型可以精确地拟合数据集，但不能提供任何有用的信息。显然，在这种情况下，除了数值拟合的质量之外，还必须使用其他标准来决定应该选择哪个模型。在第 <span class="co">[</span><span class="ot">-@sec-staticmodel</span><span class="co">]</span> 章”<span class="co">[</span><span class="ot">静态模型</span><span class="co">](05-staticModel.qmd)</span>“（*Static Models*）中，我们考虑了第 [-@sec-label] 节 *目标模型选择* 的方法，试图评估增加模型中的参数数量在统计上是否合理。任何解释模型都必须具有生物学上的合理性。甚至可以给一个完全任意的模型结构的参数赋予意义。然而，这种解释将是临时的，而且仅在表面上可信。模型除了描述一组特定的数据外，不可能做更多的事情。解释性模型应该适用于新的数据集，尽管可能需要一组新的特定参数来适应新的情况。</span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a>即使在现实的模型中，精度也不可能实现，因为我们对拟合变量的估计(观测误差)或系统响应(可能是环境变化(模型参数的过程误差))的内在不确定性。换句话说，在我们预测的系统结果的精度方面，可能无法超越某些限制(拟合质量可能有内在限制)。</span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a><span class="fu">### 现实主义与普遍性</span></span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a>与我们是否应该使用解释性模型相关的问题是模型中的现实主义问题。纯粹的描述性模型不需要任何现实的东西。但这只是一个假设，即如果某个科研人同正在开发一个解释模型，那么至少解释模型的一部分必须是现实的。例如，在年龄或体长可以区分的种群中，年龄或体长结构模型会被认为比将所有年龄或体长组集中在一起的模型更现实。但是一个模型可以是真实的和经验的结合。</span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a>一般模型将具有非常广泛的适用性领域，即在许多情况下可以有效应用。在渔业科学的发展中，将许多描述特定过程的模型（例如，个体生长）纳入一个更普遍的数学模型，这些模型是特殊情况（见第<span class="co">[</span><span class="ot">-@sec-staticmodel</span><span class="co">]</span> 章“<span class="co">[</span><span class="ot">静态模型</span><span class="co">](05-statiicModel.qmd)</span>”（*Static Models*））。通常这涉及增加所涉及的参数数量，但尽管如此，这些新模型显然在数学上更为通用。很难就这种更笼统的方程/模型是否不太现实得出结论。这将是一个问题，是否额外的参数可以现实地解释，或者它们是否只是临时解决方案，将不同的方程组合成一个更数学通用的方程。随着更复杂的现象，如年龄结构模型，一般模型通常不会给出准确的预测，因为更专业的模型调整到特定的情况。正因如此，建模人员在处理特定情况时，往往认为数学上一般模型不太现实（Maynard-Smith, 1974）。</span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true" tabindex="-1"></a><span class="fu">### 模型是理论</span></span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true" tabindex="-1"></a>所有模型都可能被认为具有理论成分，甚至被认为是经验模型。它成为一个感知问题，而不是模型结构。例如，通过简单的模型，基本假设可以开始承担假设断言的重担。因此，如果使用 logistic 方程来描述种群的增长，它就导入了种群增长率的密度依赖补偿与种群密度线性相关的假设。换言之，种群规模增长对种群增长的负面影响与种群规模呈线性关系（见第 <span class="co">[</span><span class="ot">-@sec-simplemodel</span><span class="co">]</span> 章“<span class="co">[</span><span class="ot">简单种群模型</span><span class="co">](03-simpopmodel.qmd)</span>*”*（*Simple Population Models*））。这可以被视为一个领域假设（即模型只能有效地应用于密度依赖效应与种群密度线性相关的情况）或理论（非线性密度依赖效应在建模的系统中不重要）。这显然是一个感知或建模目标的问题，即这两种可能性中哪一种是获得的。这是一个很好的理由，人们应该明确解释一个人的模型的假设。</span>
<span id="cb1-106"><a href="#cb1-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-107"><a href="#cb1-107" aria-hidden="true" tabindex="-1"></a>如果将自己局限于纯粹的经验关系，那么他的模型唯一可以改进的方法就是增加模型所解释的观测结果的方差。没有有效的期望，经验模型将提供洞察一个系统的未来行为。解释/理论模型的一个优点是，它应该能够检验假设、变量之间的关系和误差结构，独立于与观测结果的拟合质量。</span>
<span id="cb1-108"><a href="#cb1-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-109"><a href="#cb1-109" aria-hidden="true" tabindex="-1"></a>因此，应该有可能提出证据来支持一个模型，这超出了拟合的质量。那些建议的结构没有以这种方式得到支持的模型，也可能是经验性的。</span>
<span id="cb1-110"><a href="#cb1-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-111"><a href="#cb1-111" aria-hidden="true" tabindex="-1"></a><span class="fu">## 结束语</span></span>
<span id="cb1-112"><a href="#cb1-112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-113"><a href="#cb1-113" aria-hidden="true" tabindex="-1"></a>编写和讨论模型，它们的使用和构建有时是有价值的，因为它提醒我们在其中工作的框架。如果你想成为一名建模人员，对数学模型的优缺点的理论理解总是有价值的。然而，通常理解模型及其属性的最佳方法是实际使用它们，并通过操作它们的参数和检查它们在实践中如何操作来探索它们的属性。希望您会发现，使用 <span class="in">`R`</span> 作为编程语言使这些探索相对容易实现。</span>
<span id="cb1-114"><a href="#cb1-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-115"><a href="#cb1-115" aria-hidden="true" tabindex="-1"></a>下面的材料包括非常一般的方法和其他更具体的方法。这本书的目的是鼓励你，也许是为你提供一个开始，发展你自己的分析功能，也许是通过修改本书中的一些内容。您可以这样做，以便您自己的分析变得更快、更容易，并且在某种程度上是自动化的，从而让您有更多的时间来思考和解释您的发现。如果您使用的是其他更少的程序性分析的话，您需要机械地进行分析的时间越少，就有越多的时间来思考科学问题并进行更深入的探索。使用<span class="in">`R`</span>来实现您的建模的一个主要优势是，您所做的任何工作都应该变得更容易重复，因此，大概也更容易防御。当然，这里所涉及的主题范围只是触及了可用内容的表面，但试图探索一些基本方法，如最大似然估计。请记住，有大量的 R 包可用，这些可以帮助您实现自己的模型，无论是统计或动态。</span></code><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>